declare module "dan200.computercraft.api.turtle.TurtleVerb" {
import {$Enum} from "java.lang.Enum"

export class $TurtleVerb extends $Enum<($TurtleVerb)> {
static readonly "DIG": $TurtleVerb
static readonly "ATTACK": $TurtleVerb

public static "values"(): ($TurtleVerb)[]
public static "valueOf"(arg0: StringJS): $TurtleVerb
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleVerb$$Type = (("dig") | ("attack"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleVerb$$Original = $TurtleVerb;}
declare module "dan200.computercraft.api.turtle.ITurtleUpgrade" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$TurtleUpgradeType} from "dan200.computercraft.api.turtle.TurtleUpgradeType"
import {$ITurtleAccess$$Type} from "dan200.computercraft.api.turtle.ITurtleAccess"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$TurtleVerb$$Type} from "dan200.computercraft.api.turtle.TurtleVerb"
import {$Component} from "net.minecraft.network.chat.Component"
import {$TurtleCommandResult} from "dan200.computercraft.api.turtle.TurtleCommandResult"
import {$UpgradeType} from "dan200.computercraft.api.upgrades.UpgradeType"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TurtleSide$$Type} from "dan200.computercraft.api.turtle.TurtleSide"
import {$UpgradeBase$$Interface} from "dan200.computercraft.api.upgrades.UpgradeBase"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$IPeripheral} from "dan200.computercraft.api.peripheral.IPeripheral"

export interface $ITurtleUpgrade$$Interface extends $UpgradeBase$$Interface {
get "upgradeType"(): $TurtleUpgradeType
get "type"(): $UpgradeType<($ITurtleUpgrade)>
get "adjective"(): $Component
get "craftingItem"(): $ItemStack
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.ComputercraftTurtleUpgrade
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.ComputercraftTurtleUpgradeTag
}

export class $ITurtleUpgrade implements $ITurtleUpgrade$$Interface {
static readonly "REGISTRY": $ResourceKey<($Registry<($ITurtleUpgrade)>)>

static "createKey"(arg0: $ResourceLocation$$Type): $ResourceKey<($ITurtleUpgrade)>
 "getUpgradeType"(): $TurtleUpgradeType
 "createPeripheral"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type): $IPeripheral
 "useTool"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type, arg2: $TurtleVerb$$Type, arg3: $Direction$$Type): $TurtleCommandResult
 "getPersistedData"(arg0: $DataComponentPatch$$Type): $DataComponentPatch
 "update"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type): void
 "getType"(): $UpgradeType<($ITurtleUpgrade)>
static "typeRegistry"(): $ResourceKey<($Registry<($UpgradeType<($ITurtleUpgrade)>)>)>
 "getUpgradeData"(arg0: $ItemStack$$Type): $DataComponentPatch
 "getAdjective"(): $Component
 "getUpgradeItem"(arg0: $DataComponentPatch$$Type): $ItemStack
 "getCraftingItem"(): $ItemStack
 "isItemSuitable"(arg0: $ItemStack$$Type): boolean
static "getDefaultAdjective"(arg0: $ResourceLocation$$Type): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITurtleUpgrade$$Type = (Special.ComputercraftTurtleUpgrade);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ITurtleUpgrade$$Original = $ITurtleUpgrade;}
declare module "dan200.computercraft.api.turtle.TurtleCommand" {
import {$ITurtleAccess, $ITurtleAccess$$Type} from "dan200.computercraft.api.turtle.ITurtleAccess"
import {$TurtleCommandResult, $TurtleCommandResult$$Type} from "dan200.computercraft.api.turtle.TurtleCommandResult"

export interface $TurtleCommand$$Interface {

(arg0: $ITurtleAccess): $TurtleCommandResult$$Type
}

export class $TurtleCommand implements $TurtleCommand$$Interface {
 "execute"(arg0: $ITurtleAccess$$Type): $TurtleCommandResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleCommand$$Type = ((arg0: $ITurtleAccess) => $TurtleCommandResult$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleCommand$$Original = $TurtleCommand;}
declare module "dan200.computercraft.api.turtle.TurtleToolDurability" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $TurtleToolDurability extends $Enum<($TurtleToolDurability)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $StringRepresentable$EnumCodec<($TurtleToolDurability)>
static readonly "NEVER": $TurtleToolDurability
static readonly "WHEN_ENCHANTED": $TurtleToolDurability
static readonly "ALWAYS": $TurtleToolDurability

public static "values"(): ($TurtleToolDurability)[]
public static "valueOf"(arg0: StringJS): $TurtleToolDurability
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleToolDurability$$Type = (("always") | ("when_enchanted") | ("never"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleToolDurability$$Original = $TurtleToolDurability;}
declare module "dan200.computercraft.api.turtle.TurtleAnimation" {
import {$Enum} from "java.lang.Enum"

export class $TurtleAnimation extends $Enum<($TurtleAnimation)> {
static readonly "TURN_RIGHT": $TurtleAnimation
static readonly "SWING_LEFT_TOOL": $TurtleAnimation
static readonly "MOVE_UP": $TurtleAnimation
static readonly "MOVE_DOWN": $TurtleAnimation
static readonly "TURN_LEFT": $TurtleAnimation
static readonly "MOVE_BACK": $TurtleAnimation
static readonly "MOVE_FORWARD": $TurtleAnimation
static readonly "NONE": $TurtleAnimation
static readonly "SWING_RIGHT_TOOL": $TurtleAnimation
static readonly "WAIT": $TurtleAnimation
static readonly "SHORT_WAIT": $TurtleAnimation

public static "values"(): ($TurtleAnimation)[]
public static "valueOf"(arg0: StringJS): $TurtleAnimation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleAnimation$$Type = (("none") | ("move_forward") | ("move_back") | ("move_up") | ("move_down") | ("turn_left") | ("turn_right") | ("swing_left_tool") | ("swing_right_tool") | ("wait") | ("short_wait"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleAnimation$$Original = $TurtleAnimation;}
declare module "dan200.computercraft.api.turtle.AbstractTurtleUpgrade" {
import {$ITurtleUpgrade, $ITurtleUpgrade$$Interface} from "dan200.computercraft.api.turtle.ITurtleUpgrade"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$TurtleUpgradeType} from "dan200.computercraft.api.turtle.TurtleUpgradeType"
import {$ITurtleAccess$$Type} from "dan200.computercraft.api.turtle.ITurtleAccess"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$TurtleVerb$$Type} from "dan200.computercraft.api.turtle.TurtleVerb"
import {$Component} from "net.minecraft.network.chat.Component"
import {$TurtleCommandResult} from "dan200.computercraft.api.turtle.TurtleCommandResult"
import {$UpgradeType} from "dan200.computercraft.api.upgrades.UpgradeType"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TurtleSide$$Type} from "dan200.computercraft.api.turtle.TurtleSide"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$IPeripheral} from "dan200.computercraft.api.peripheral.IPeripheral"

export class $AbstractTurtleUpgrade implements $ITurtleUpgrade$$Interface {
public "getUpgradeType"(): $TurtleUpgradeType
public "getAdjective"(): $Component
public "getCraftingItem"(): $ItemStack
public static "createKey"(arg0: $ResourceLocation$$Type): $ResourceKey<($ITurtleUpgrade)>
public "createPeripheral"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type): $IPeripheral
public "useTool"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type, arg2: $TurtleVerb$$Type, arg3: $Direction$$Type): $TurtleCommandResult
public "getPersistedData"(arg0: $DataComponentPatch$$Type): $DataComponentPatch
public "update"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type): void
public "getType"(): $UpgradeType<($ITurtleUpgrade)>
public static "typeRegistry"(): $ResourceKey<($Registry<($UpgradeType<($ITurtleUpgrade)>)>)>
public "getUpgradeData"(arg0: $ItemStack$$Type): $DataComponentPatch
public "getUpgradeItem"(arg0: $DataComponentPatch$$Type): $ItemStack
public "isItemSuitable"(arg0: $ItemStack$$Type): boolean
public static "getDefaultAdjective"(arg0: $ResourceLocation$$Type): StringJS
get "upgradeType"(): $TurtleUpgradeType
get "adjective"(): $Component
get "craftingItem"(): $ItemStack
get "type"(): $UpgradeType<($ITurtleUpgrade)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractTurtleUpgrade$$Type = ($AbstractTurtleUpgrade);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractTurtleUpgrade$$Original = $AbstractTurtleUpgrade;}
declare module "dan200.computercraft.api.turtle.TurtleCommandResult" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TurtleCommandResult {
public static "success"(): $TurtleCommandResult
public static "success"(arg0: (any)[]): $TurtleCommandResult
public "getErrorMessage"(): StringJS
public static "failure"(arg0: StringJS): $TurtleCommandResult
public static "failure"(): $TurtleCommandResult
public "isSuccess"(): boolean
public "getResults"(): (any)[]
get "errorMessage"(): StringJS
get "results"(): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleCommandResult$$Type = ($TurtleCommandResult);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleCommandResult$$Original = $TurtleCommandResult;}
declare module "dan200.computercraft.api.turtle.TurtleSide" {
import {$Enum} from "java.lang.Enum"

export class $TurtleSide extends $Enum<($TurtleSide)> {
static readonly "LEFT": $TurtleSide
static readonly "RIGHT": $TurtleSide

public static "values"(): ($TurtleSide)[]
public static "valueOf"(arg0: StringJS): $TurtleSide
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleSide$$Type = (("left") | ("right"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleSide$$Original = $TurtleSide;}
declare module "dan200.computercraft.api.turtle.TurtleUpgradeType" {
import {$Enum} from "java.lang.Enum"

export class $TurtleUpgradeType extends $Enum<($TurtleUpgradeType)> {
static readonly "PERIPHERAL": $TurtleUpgradeType
static readonly "BOTH": $TurtleUpgradeType
static readonly "TOOL": $TurtleUpgradeType

public "isTool"(): boolean
public "isPeripheral"(): boolean
public static "values"(): ($TurtleUpgradeType)[]
public static "valueOf"(arg0: StringJS): $TurtleUpgradeType
get "tool"(): boolean
get "peripheral"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleUpgradeType$$Type = (("tool") | ("peripheral") | ("both"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleUpgradeType$$Original = $TurtleUpgradeType;}
declare module "dan200.computercraft.api.turtle.ITurtleAccess" {
import {$ITurtleUpgrade, $ITurtleUpgrade$$Type} from "dan200.computercraft.api.turtle.ITurtleUpgrade"
import {$MethodResult} from "dan200.computercraft.api.lua.MethodResult"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$TurtleAnimation$$Type} from "dan200.computercraft.api.turtle.TurtleAnimation"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TurtleCommand$$Type} from "dan200.computercraft.api.turtle.TurtleCommand"
import {$UpgradeData, $UpgradeData$$Type} from "dan200.computercraft.api.upgrades.UpgradeData"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Container} from "net.minecraft.world.Container"
import {$TurtleSide$$Type} from "dan200.computercraft.api.turtle.TurtleSide"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IPeripheral} from "dan200.computercraft.api.peripheral.IPeripheral"

export interface $ITurtleAccess$$Interface {
set "direction"(value: $Direction$$Type)
set "colour"(value: integer)
set "fuelLevel"(value: integer)
get "colour"(): integer
get "fuelLevel"(): integer
get "fuelLimit"(): integer
set "selectedSlot"(value: integer)
get "selectedSlot"(): integer
get "owningPlayer"(): $GameProfile
get "fuelNeeded"(): boolean
get "level"(): $Level
get "position"(): $BlockPos
get "removed"(): boolean
get "direction"(): $Direction
get "inventory"(): $Container
}

export class $ITurtleAccess implements $ITurtleAccess$$Interface {
 "getUpgrade"(arg0: $TurtleSide$$Type): $ITurtleUpgrade
 "setUpgrade"(arg0: $TurtleSide$$Type, arg1: $UpgradeData$$Type<($ITurtleUpgrade$$Type)>): void
 "consumeFuel"(arg0: integer): boolean
 "playAnimation"(arg0: $TurtleAnimation$$Type): void
 "getUpgradeData"(arg0: $TurtleSide$$Type): $DataComponentPatch
 "setDirection"(arg0: $Direction$$Type): void
 "setColour"(arg0: integer): void
 "setFuelLevel"(arg0: integer): void
 "getColour"(): integer
 "getFuelLevel"(): integer
 "getUpgradeWithData"(arg0: $TurtleSide$$Type): $UpgradeData<($ITurtleUpgrade)>
 "getFuelLimit"(): integer
 "setSelectedSlot"(arg0: integer): void
 "getSelectedSlot"(): integer
 "getPeripheral"(arg0: $TurtleSide$$Type): $IPeripheral
 "getOwningPlayer"(): $GameProfile
 "isFuelNeeded"(): boolean
 "addFuel"(arg0: integer): void
 "executeCommand"(arg0: $TurtleCommand$$Type): $MethodResult
 "setUpgradeData"(arg0: $TurtleSide$$Type, arg1: $DataComponentPatch$$Type): void
 "getLevel"(): $Level
 "getPosition"(): $BlockPos
 "isRemoved"(): boolean
 "getDirection"(): $Direction
 "getInventory"(): $Container
 "teleportTo"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITurtleAccess$$Type = ($ITurtleAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ITurtleAccess$$Original = $ITurtleAccess;}
