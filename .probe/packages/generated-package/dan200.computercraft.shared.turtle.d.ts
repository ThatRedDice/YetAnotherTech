declare module "dan200.computercraft.shared.turtle.items.TurtleItem" {
import {$ITurtleUpgrade} from "dan200.computercraft.api.turtle.ITurtleUpgrade"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$TurtleBlock$$Type} from "dan200.computercraft.shared.turtle.blocks.TurtleBlock"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$Component} from "net.minecraft.network.chat.Component"
import {$CauldronInteraction} from "net.minecraft.core.cauldron.CauldronInteraction"
import {$UpgradeData} from "dan200.computercraft.api.upgrades.UpgradeData"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$TurtleSide$$Type} from "dan200.computercraft.api.turtle.TurtleSide"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$TurtleOverlay} from "dan200.computercraft.shared.turtle.TurtleOverlay"
import {$Item} from "net.minecraft.world.item.Item"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $TurtleItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "CAULDRON_INTERACTION": $CauldronInteraction
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $TurtleBlock$$Type, arg1: $Item$Properties$$Type)

public static "getUpgrade"(arg0: $ItemStack$$Type, arg1: $TurtleSide$$Type): $ITurtleUpgrade
public "getCreatorModId"(arg0: $ItemStack$$Type): StringJS
public static "getUpgradeWithData"(arg0: $ItemStack$$Type, arg1: $TurtleSide$$Type): $UpgradeData<($ITurtleUpgrade)>
public "getName"(arg0: $ItemStack$$Type): $Component
public static "getOverlay"(arg0: $ItemStack$$Type): $TurtleOverlay
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleItem$$Type = ($TurtleItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleItem$$Original = $TurtleItem;}
declare module "dan200.computercraft.shared.turtle.TurtleOverlay" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $TurtleOverlay extends $Record {
static readonly "CODEC": $Codec<($Holder<($TurtleOverlay)>)>
static readonly "ELF_MODEL": $ResourceLocation
static readonly "DIRECT_CODEC": $Codec<($TurtleOverlay)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Holder<($TurtleOverlay)>)>
static readonly "REGISTRY": $ResourceKey<($Registry<($TurtleOverlay)>)>

constructor(model: $ResourceLocation$$Type, showElfOverlay: boolean)

public static "showElfOverlay"(arg0: $TurtleOverlay$$Type, arg1: boolean): boolean
public "showElfOverlay"(): boolean
public "model"(): $ResourceLocation
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.ComputercraftTurtleOverlay
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.ComputercraftTurtleOverlayTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleOverlay$$Type = (Special.ComputercraftTurtleOverlay) | ({"model"?: $ResourceLocation$$Type, "showElfOverlay"?: boolean}) | ([model?: $ResourceLocation$$Type, showElfOverlay?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleOverlay$$Original = $TurtleOverlay;}
declare module "dan200.computercraft.shared.turtle.upgrades.TurtleTool" {
import {$TurtleToolSpec$$Type} from "dan200.computercraft.impl.upgrades.TurtleToolSpec"
import {$ITurtleUpgrade} from "dan200.computercraft.api.turtle.ITurtleUpgrade"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ITurtleAccess$$Type} from "dan200.computercraft.api.turtle.ITurtleAccess"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$TurtleVerb$$Type} from "dan200.computercraft.api.turtle.TurtleVerb"
import {$TurtleCommandResult} from "dan200.computercraft.api.turtle.TurtleCommandResult"
import {$UpgradeType} from "dan200.computercraft.api.upgrades.UpgradeType"
import {$AbstractTurtleUpgrade} from "dan200.computercraft.api.turtle.AbstractTurtleUpgrade"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TurtleSide$$Type} from "dan200.computercraft.api.turtle.TurtleSide"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $TurtleTool extends $AbstractTurtleUpgrade {
static readonly "CODEC": $MapCodec<($TurtleTool)>

constructor(arg0: $TurtleToolSpec$$Type)

public "getUpgradeData"(arg0: $ItemStack$$Type): $DataComponentPatch
public "useTool"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type, arg2: $TurtleVerb$$Type, arg3: $Direction$$Type): $TurtleCommandResult
public "getUpgradeItem"(arg0: $DataComponentPatch$$Type): $ItemStack
public "isItemSuitable"(arg0: $ItemStack$$Type): boolean
public "getType"(): $UpgradeType<($TurtleTool)>
public static "createKey"(arg0: $ResourceLocation$$Type): $ResourceKey<($ITurtleUpgrade)>
public static "typeRegistry"(): $ResourceKey<($Registry<($UpgradeType<($ITurtleUpgrade)>)>)>
public static "getDefaultAdjective"(arg0: $ResourceLocation$$Type): StringJS
get "type"(): $UpgradeType<($TurtleTool)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleTool$$Type = ($TurtleTool);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleTool$$Original = $TurtleTool;}
declare module "dan200.computercraft.shared.turtle.blocks.TurtleBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$TurtleBlockEntity, $TurtleBlockEntity$$Type} from "dan200.computercraft.shared.turtle.blocks.TurtleBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$AbstractComputerBlock} from "dan200.computercraft.shared.computer.blocks.AbstractComputerBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$RegistryEntry$$Type} from "dan200.computercraft.shared.platform.RegistryEntry"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $TurtleBlock extends $AbstractComputerBlock<($TurtleBlockEntity)> implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "IMMUNE_EXPLOSION_RESISTANCE": float
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $RegistryEntry$$Type<($BlockEntityType$$Type<($TurtleBlockEntity$$Type)>)>)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getExplosionResistance"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type): float
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getTicker"<U extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(U)>): $BlockEntityTicker<(U)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleBlock$$Type = ($TurtleBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleBlock$$Original = $TurtleBlock;}
declare module "dan200.computercraft.shared.turtle.upgrades.TurtleCraftingTable" {
import {$AbstractTurtleUpgrade} from "dan200.computercraft.api.turtle.AbstractTurtleUpgrade"
import {$ITurtleUpgrade} from "dan200.computercraft.api.turtle.ITurtleUpgrade"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Registry} from "net.minecraft.core.Registry"
import {$ITurtleAccess$$Type} from "dan200.computercraft.api.turtle.ITurtleAccess"
import {$TurtleSide$$Type} from "dan200.computercraft.api.turtle.TurtleSide"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$IPeripheral} from "dan200.computercraft.api.peripheral.IPeripheral"
import {$UpgradeType} from "dan200.computercraft.api.upgrades.UpgradeType"

export class $TurtleCraftingTable extends $AbstractTurtleUpgrade {
constructor(arg0: $ItemStack$$Type)

public "createPeripheral"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type): $IPeripheral
public "getType"(): $UpgradeType<($TurtleCraftingTable)>
public static "createKey"(arg0: $ResourceLocation$$Type): $ResourceKey<($ITurtleUpgrade)>
public static "typeRegistry"(): $ResourceKey<($Registry<($UpgradeType<($ITurtleUpgrade)>)>)>
public static "getDefaultAdjective"(arg0: $ResourceLocation$$Type): StringJS
get "type"(): $UpgradeType<($TurtleCraftingTable)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleCraftingTable$$Type = ($TurtleCraftingTable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleCraftingTable$$Original = $TurtleCraftingTable;}
declare module "dan200.computercraft.shared.turtle.upgrades.TurtleModem" {
import {$ITurtleUpgrade} from "dan200.computercraft.api.turtle.ITurtleUpgrade"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ITurtleAccess$$Type} from "dan200.computercraft.api.turtle.ITurtleAccess"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$TurtleVerb$$Type} from "dan200.computercraft.api.turtle.TurtleVerb"
import {$TurtleCommandResult} from "dan200.computercraft.api.turtle.TurtleCommandResult"
import {$UpgradeType} from "dan200.computercraft.api.upgrades.UpgradeType"
import {$AbstractTurtleUpgrade} from "dan200.computercraft.api.turtle.AbstractTurtleUpgrade"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TurtleSide$$Type} from "dan200.computercraft.api.turtle.TurtleSide"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$IPeripheral} from "dan200.computercraft.api.peripheral.IPeripheral"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $TurtleModem extends $AbstractTurtleUpgrade {
static readonly "CODEC": $MapCodec<($TurtleModem)>

constructor(arg0: $ItemStack$$Type, arg1: boolean)

public "createPeripheral"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type): $IPeripheral
public "useTool"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type, arg2: $TurtleVerb$$Type, arg3: $Direction$$Type): $TurtleCommandResult
public "getPersistedData"(arg0: $DataComponentPatch$$Type): $DataComponentPatch
public "update"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type): void
public "getType"(): $UpgradeType<($TurtleModem)>
public "advanced"(): boolean
public static "createKey"(arg0: $ResourceLocation$$Type): $ResourceKey<($ITurtleUpgrade)>
public static "typeRegistry"(): $ResourceKey<($Registry<($UpgradeType<($ITurtleUpgrade)>)>)>
public static "getDefaultAdjective"(arg0: $ResourceLocation$$Type): StringJS
get "type"(): $UpgradeType<($TurtleModem)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleModem$$Type = ($TurtleModem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleModem$$Original = $TurtleModem;}
declare module "dan200.computercraft.shared.turtle.blocks.TurtleBlockEntity" {
import {$AbstractComputerBlockEntity} from "dan200.computercraft.shared.computer.blocks.AbstractComputerBlockEntity"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ITurtleAccess} from "dan200.computercraft.api.turtle.ITurtleAccess"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BasicContainer$$Interface} from "dan200.computercraft.shared.container.BasicContainer"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$TurtleSide$$Type} from "dan200.computercraft.api.turtle.TurtleSide"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ITurtleUpgrade} from "dan200.computercraft.api.turtle.ITurtleUpgrade"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IntSupplier$$Type} from "java.util.function.IntSupplier"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$TurtleOverlay} from "dan200.computercraft.shared.turtle.TurtleOverlay"
import {$IPeripheral} from "dan200.computercraft.api.peripheral.IPeripheral"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$ComputerFamily$$Type} from "dan200.computercraft.shared.computer.core.ComputerFamily"

export class $TurtleBlockEntity extends $AbstractComputerBlockEntity implements $BasicContainer$$Interface {
static readonly "INVENTORY_WIDTH": integer
static readonly "INVENTORY_HEIGHT": integer
static readonly "INVENTORY_SIZE": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<($TurtleBlockEntity$$Type)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $IntSupplier$$Type, arg4: $ComputerFamily$$Type)

public "getUpgrade"(arg0: $TurtleSide$$Type): $ITurtleUpgrade
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "getItems"(): $List
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "setDirection"(arg0: $Direction$$Type): void
public "peripheral"(): $IPeripheral
public "getColour"(): integer
public "onTileEntityChange"(): void
public "getToolRenderAngle"(arg0: $TurtleSide$$Type, arg1: float): float
public "notifyMoveStart"(): void
public "notifyMoveEnd"(): void
public "getRenderYaw"(arg0: float): float
public "getItemSnapshot"(arg0: integer): $ItemStack
public "getFuelLimit"(): integer
public "loadServer"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "loadClient"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "transferStateFrom"(arg0: $TurtleBlockEntity$$Type): void
public "getAccess"(): $ITurtleAccess
public "getDirection"(): $Direction
/**
 * 
 * @deprecated
 */
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "getOverlay"(): $TurtleOverlay
public "getRenderOffset"(arg0: float): $Vec3
public "setChanged"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public "neighborChanged"(arg0: $BlockPos$$Type): void
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "clearContent"(): void
public static "defaultSetItems"(arg0: $List$$Type<($ItemStack$$Type)>, arg1: $List$$Type<($ItemStack$$Type)>): void
public "getItem"(arg0: integer): $ItemStack
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "isEmpty"(): boolean
public "getContainerSize"(): integer
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "startOpen"(arg0: $Player$$Type): void
public "stopOpen"(arg0: $Player$$Type): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "countItem"(arg0: $Item$$Type): integer
public "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
public "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "getMaxStackSize"(): integer
public "getMaxStackSize"(arg0: $ItemStack$$Type): integer
public "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
public static "tryClear"(arg0: any): void
public "self"(): $Container
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "getSlotLimit"(slot: integer): integer
public "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
public "clear"(): void
public "getWidth"(): integer
public "getHeight"(): integer
public "getBlock"(level: $Level$$Type): $LevelBlock
public "setChanged"(): void
public "asContainer"(): $Container
public "setTransferCooldown"(arg0: long): void
public "canReceiveTransferCooldown"(): boolean
public "lithium$itemInsertionTestRequiresStackSize1"(): boolean
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "clear"(match: $ItemPredicate$$Type): void
public "find"(match: $ItemPredicate$$Type): integer
public "find"(): integer
public "count"(match: $ItemPredicate$$Type): integer
public "count"(): integer
public "countNonEmpty"(): integer
public "countNonEmpty"(match: $ItemPredicate$$Type): integer
public "getAllItems"(): $List<($ItemStack)>
get "items"(): $List
set "direction"(value: $Direction$$Type)
get "colour"(): integer
get "fuelLimit"(): integer
get "access"(): $ITurtleAccess
get "direction"(): $Direction
get "overlay"(): $TurtleOverlay
get "changed"(): void
get "empty"(): boolean
get "containerSize"(): integer
get "maxStackSize"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "width"(): integer
get "height"(): integer
get "changed"(): void
set "transferCooldown"(value: long)
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleBlockEntity$$Type = ($TurtleBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleBlockEntity$$Original = $TurtleBlockEntity;}
declare module "dan200.computercraft.shared.turtle.upgrades.TurtleSpeaker" {
import {$AbstractTurtleUpgrade} from "dan200.computercraft.api.turtle.AbstractTurtleUpgrade"
import {$ITurtleUpgrade} from "dan200.computercraft.api.turtle.ITurtleUpgrade"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Registry} from "net.minecraft.core.Registry"
import {$ITurtleAccess$$Type} from "dan200.computercraft.api.turtle.ITurtleAccess"
import {$TurtleSide$$Type} from "dan200.computercraft.api.turtle.TurtleSide"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$IPeripheral} from "dan200.computercraft.api.peripheral.IPeripheral"
import {$UpgradeType} from "dan200.computercraft.api.upgrades.UpgradeType"

export class $TurtleSpeaker extends $AbstractTurtleUpgrade {
constructor(arg0: $ItemStack$$Type)

public "createPeripheral"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type): $IPeripheral
public "update"(arg0: $ITurtleAccess$$Type, arg1: $TurtleSide$$Type): void
public "getType"(): $UpgradeType<($TurtleSpeaker)>
public static "createKey"(arg0: $ResourceLocation$$Type): $ResourceKey<($ITurtleUpgrade)>
public static "typeRegistry"(): $ResourceKey<($Registry<($UpgradeType<($ITurtleUpgrade)>)>)>
public static "getDefaultAdjective"(arg0: $ResourceLocation$$Type): StringJS
get "type"(): $UpgradeType<($TurtleSpeaker)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleSpeaker$$Type = ($TurtleSpeaker);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleSpeaker$$Original = $TurtleSpeaker;}
