declare module "dan200.computercraft.api.upgrades.UpgradeData" {
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$UpgradeBase} from "dan200.computercraft.api.upgrades.UpgradeBase"
import {$Holder$Reference, $Holder$Reference$$Type} from "net.minecraft.core.Holder$Reference"
import {$Record} from "java.lang.Record"

export class $UpgradeData<T extends $UpgradeBase> extends $Record {
constructor(holder: $Holder$Reference$$Type<(T)>, data: $DataComponentPatch$$Type)

public "getUpgradeItem"(): $ItemStack
public static "ofDefault"<T extends $UpgradeBase>(arg0: $Holder$Reference$$Type<(T)>): $UpgradeData<(T)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"<T extends $UpgradeBase>(arg0: $Holder$Reference$$Type<(T)>, arg1: $DataComponentPatch$$Type): $UpgradeData<(T)>
public "data"(): $DataComponentPatch
public "holder"(): $Holder$Reference<(T)>
public "upgrade"(): T
get "upgradeItem"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeData$$Type<T> = ({"holder"?: $Holder$Reference$$Type<(T)>, "data"?: $DataComponentPatch$$Type}) | ([holder?: $Holder$Reference$$Type<(T)>, data?: $DataComponentPatch$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UpgradeData$$Original<T> = $UpgradeData<(T)>;}
declare module "dan200.computercraft.api.upgrades.UpgradeTypeImpl" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Function$$Type} from "java.util.function.Function"
import {$UpgradeBase, $UpgradeBase$$Type} from "dan200.computercraft.api.upgrades.UpgradeBase"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"
import {$UpgradeType, $UpgradeType$$Interface} from "dan200.computercraft.api.upgrades.UpgradeType"

export class $UpgradeTypeImpl<T extends $UpgradeBase> extends $Record implements $UpgradeType$$Interface<(T)> {
public static "simpleWithCustomItem"<T extends $UpgradeBase>(arg0: $Function$$Type<($ItemStack), (T)>): $UpgradeType<(T)>
public static "create"<T extends $UpgradeBase>(arg0: $MapCodec$$Type<(T)>): $UpgradeType<(T)>
public static "simple"<T extends $UpgradeBase>(arg0: T): $UpgradeType<(T)>
public "codec"(): $MapCodec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeTypeImpl$$Type<T> = ({"codec"?: $MapCodec$$Type<(T)>}) | ([codec?: $MapCodec$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UpgradeTypeImpl$$Original<T> = $UpgradeTypeImpl<(T)>;}
declare module "dan200.computercraft.api.upgrades.UpgradeType" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Function$$Type} from "java.util.function.Function"
import {$UpgradeBase, $UpgradeBase$$Type} from "dan200.computercraft.api.upgrades.UpgradeBase"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export interface $UpgradeType$$Interface<T extends $UpgradeBase> {

(): $MapCodec$$Type<(T)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.ComputercraftTurtleUpgradeType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.ComputercraftTurtleUpgradeTypeTag
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.ComputercraftPocketUpgradeType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.ComputercraftPocketUpgradeTypeTag
}

export class $UpgradeType<T extends $UpgradeBase> implements $UpgradeType$$Interface {
static "simpleWithCustomItem"<T extends $UpgradeBase>(arg0: $Function$$Type<($ItemStack), (T)>): $UpgradeType<(T)>
static "create"<T extends $UpgradeBase>(arg0: $MapCodec$$Type<(T)>): $UpgradeType<(T)>
static "simple"<T extends $UpgradeBase>(arg0: T): $UpgradeType<(T)>
 "codec"(): $MapCodec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeType$$Type<T> = (Special.ComputercraftTurtleUpgradeType) | (Special.ComputercraftPocketUpgradeType) | (() => $MapCodec$$Type<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UpgradeType$$Original<T> = $UpgradeType<(T)>;}
declare module "dan200.computercraft.api.upgrades.UpgradeBase" {
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Component} from "net.minecraft.network.chat.Component"
import {$UpgradeType} from "dan200.computercraft.api.upgrades.UpgradeType"

export interface $UpgradeBase$$Interface {
get "adjective"(): $Component
get "craftingItem"(): $ItemStack
get "type"(): $UpgradeType<(never)>
}

export class $UpgradeBase implements $UpgradeBase$$Interface {
 "getUpgradeData"(arg0: $ItemStack$$Type): $DataComponentPatch
 "getAdjective"(): $Component
 "getUpgradeItem"(arg0: $DataComponentPatch$$Type): $ItemStack
 "getCraftingItem"(): $ItemStack
 "isItemSuitable"(arg0: $ItemStack$$Type): boolean
static "getDefaultAdjective"(arg0: $ResourceLocation$$Type): StringJS
 "getType"(): $UpgradeType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeBase$$Type = ($UpgradeBase);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UpgradeBase$$Original = $UpgradeBase;}
