declare module "com.simibubi.create.content.kinetics.deployer.DeployerFakePlayer" {
import {$HumanoidArm} from "net.minecraft.world.entity.HumanoidArm"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$ServerGamePacketListenerImpl} from "net.minecraft.server.network.ServerGamePacketListenerImpl"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$LivingChangeTargetEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingChangeTargetEvent"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"
import {$InteractionHand} from "net.minecraft.world.InteractionHand"
import {$LivingDropsEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDropsEvent"
import {$LivingExperienceDropEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingExperienceDropEvent"
import {$Entity$RemovalReason, $Entity$RemovalReason$$Type} from "net.minecraft.world.entity.Entity$RemovalReason"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$OptionalInt} from "java.util.OptionalInt"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$InventoryMenu} from "net.minecraft.world.inventory.InventoryMenu"
import {$MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ServerPlayerGameMode} from "net.minecraft.server.level.ServerPlayerGameMode"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Trackable} from "dev.uncandango.alltheleaks.mixin.Trackable"
import {$FakePlayer} from "net.neoforged.neoforge.common.util.FakePlayer"
import {$Component} from "net.minecraft.network.chat.Component"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Pose$$Type} from "net.minecraft.world.entity.Pose"
import {$MenuProvider$$Type} from "net.minecraft.world.MenuProvider"
import {$Abilities} from "net.minecraft.world.entity.player.Abilities"
import {$FishingHook} from "net.minecraft.world.entity.projectile.FishingHook"
import {$WalkAnimationState} from "net.minecraft.world.entity.WalkAnimationState"
import {$ScoreHolder} from "net.minecraft.world.scores.ScoreHolder"
import {$Class} from "java.lang.Class"
import {$PortalProcessor} from "net.minecraft.world.entity.PortalProcessor"
import {$ObjectOpenCustomHashSet} from "it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$EntityEvent$Size$$Type} from "net.neoforged.neoforge.event.entity.EntityEvent$Size"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$PlayerData} from "com.minecraftserverzone.weaponmaster.setup.playerdata.PlayerData"
import {$Map} from "java.util.Map"
import {$EntityDimensions} from "net.minecraft.world.entity.EntityDimensions"
import {$ChangeSubscriber, $ChangeSubscriber$$Type} from "net.caffeinemc.mods.lithium.common.util.change_tracking.ChangeSubscriber"
import {$EntityInLevelCallback} from "net.minecraft.world.level.entity.EntityInLevelCallback"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

export class $DeployerFakePlayer extends $FakePlayer {
 "lastHurtByPlayerTime": integer
static readonly "DEFAULT_BASE_GRAVITY": double
 "hasImpulse": boolean
static readonly "USE_ITEM_INTERVAL": integer
 "yHeadRot": float
 "yCloakO": double
 "noPhysics": boolean
 "yo": double
 "connection": $ServerGamePacketListenerImpl
 "yBodyRotO": float
 "removalReason": $Entity$RemovalReason
 "zza": float
 "swingingArm": $InteractionHand
static readonly "CRAFTING_SLOT_OFFSET": integer
static readonly "INTERACTION_DISTANCE_VERIFICATION_BUFFER": double
 "placedTracks": boolean
static readonly "ID_TAG": StringJS
static readonly "WAKE_UP_DURATION": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
 "xRotO": float
 "zo": double
 "onMinecartContraption": boolean
 "wonGame": boolean
 "walkDist": float
 "lastHurt": float
 "noCulling": boolean
 "walkAnimation": $WalkAnimationState
readonly "gameMode": $ServerPlayerGameMode
readonly "object": any
static readonly "STANDING_DIMENSIONS": $EntityDimensions
 "yya": float
readonly "server": $MinecraftServer
 "oAttackAnim": float
 "yHeadRotO": float
static readonly "UUID_TAG": StringJS
static readonly "DEFAULT_MODEL_CUSTOMIZATION": integer
 "hurtDuration": integer
static readonly "DEATH_DURATION": integer
 "portalProcess": $PortalProcessor
static readonly "SWIMMING_BB_HEIGHT": float
static readonly "DEFAULT_ENTITY_INTERACTION_RANGE": float
 "dead": boolean
 "verticalCollision": boolean
 "verticalCollisionBelow": boolean
 "experienceLevel": integer
static readonly "DEFAULT_BABY_SCALE": float
static readonly "ATTRIBUTES_FIELD": StringJS
static readonly "PERSISTED_NBT_TAG": StringJS
static readonly "DEFAULT_BB_HEIGHT": float
 "seenCredits": boolean
 "xxa": float
 "zCloak": double
 "flyDist": float
static readonly "fallbackID": $UUID
 "currentImpulseImpactPos": $Vec3
static readonly "PASSENGERS_TAG": StringJS
 "xCloakO": double
 "wasOnFire": boolean
 "attackAnim": float
 "zOld": double
readonly "timeOffs": float
 "wasTouchingWater": boolean
readonly "rotA": float
 "horizontalCollision": boolean
static readonly "ENDER_SLOT_OFFSET": integer
static readonly "ARMOR_SLOT_OFFSET": integer
static readonly "SLEEP_DURATION": integer
static readonly "HELD_ITEM_SLOT": integer
 "yCloak": double
 "swingTime": integer
static readonly "BODY_ARMOR_OFFSET": integer
 "xCloak": double
readonly "abilities": $Abilities
 "tickCount": integer
 "lastHurtByPlayer": $Player
static readonly "BOARDING_COOLDOWN": integer
static readonly "MAX_HEALTH": integer
static readonly "SWING_DURATION": integer
 "yRotO": float
static readonly "MIN_MOVEMENT_DISTANCE": double
static readonly "CONTENTS_SLOT_INDEX": integer
static readonly "BASE_JUMP_POWER": float
static readonly "DEFAULT_EYE_HEIGHT": float
 "level": $Level
static readonly "CROUCH_BB_HEIGHT": float
 "moveDist": float
 "zCloakO": double
 "mainSupportingBlockPos": $Optional<($BlockPos)>
 "bob": float
 "experienceProgress": float
 "totalExperience": integer
 "xOld": double
 "wasInPowderSnow": boolean
 "containerMenu": $AbstractContainerMenu
 "hurtTime": integer
 "swinging": boolean
 "hurtMarked": boolean
 "attackStrengthTicker": integer
static readonly "DEFAULT_MAIN_HAND": $HumanoidArm
 "deathTime": integer
static readonly "EQUIPMENT_SLOT_OFFSET": integer
 "invulnerableTime": integer
 "jumping": boolean
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
 "fallDistance": float
static readonly "DEFAULT_VEHICLE_ATTACHMENT": $Vec3
readonly "inventoryMenu": $InventoryMenu
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "MAX_ENTITY_TAG_COUNT": integer
 "playerData": $PlayerData
static readonly "ARMOR_SLOTS": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
static readonly "PLAYER_HURT_EXPERIENCE_TIME": integer
 "yOld": double
static readonly "HAND_SLOTS": integer
static readonly "DEFAULT_BB_WIDTH": float
 "minorHorizontalCollision": boolean
 "levelCallback": $EntityInLevelCallback
 "enteredNetherPosition": $Vec3
static readonly "EXTRA_RENDER_CULLING_SIZE_WITH_BIG_HAT": float
 "fishing": $FishingHook
 "removeArrowTime": integer
 "walkDistO": float
static readonly "SWIMMING_BB_WIDTH": float
static readonly "FREEZE_HURT_FREQUENCY": integer
 "isInPowderSnow": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "yBodyRot": float
 "blocksBuilding": boolean
 "takeXpDelay": integer
static readonly "DEFAULT_BLOCK_INTERACTION_RANGE": float
 "oBob": float
static readonly "TOTAL_AIR_SUPPLY": integer
 "xo": double
readonly "invulnerableDuration": integer
 "removeStingerTime": integer
static readonly "BASE_SAFE_FALL_DISTANCE": integer
 "currentExplosionCause": $Entity

constructor(arg0: $ServerLevel$$Type, arg1: $UUID$$Type)

public static "deployerHasEyesOnHisFeet"(arg0: $EntityEvent$Size$$Type): void
public static "deployerCollectsDropsFromKilledEntities"(arg0: $LivingDropsEvent$$Type): void
public static "deployerKillsDoNotSpawnXP"(arg0: $LivingExperienceDropEvent$$Type): void
public static "entitiesDontRetaliate"(arg0: $LivingChangeTargetEvent$$Type): void
public "getDisplayName"(): $Component
public "remove"(arg0: $Entity$RemovalReason$$Type): void
public "position"(): $Vec3
public "getUuid"(): $UUID
public "canBeAffected"(arg0: $MobEffectInstance$$Type): boolean
public "getDefaultDimensions"(arg0: $Pose$$Type): $EntityDimensions
public "eat"(arg0: $Level$$Type, arg1: $ItemStack$$Type, arg2: $FoodProperties$$Type): $ItemStack
public "openMenu"(arg0: $MenuProvider$$Type): $OptionalInt
public "canEat"(arg0: boolean): boolean
public "getCurrentItemAttackStrengthDelay"(): float
public "self"(): $Player
public static "startTracking"(arg0: any): void
public static "createWeakRefBasedSet"(): $ObjectOpenCustomHashSet<($WeakReference<($Trackable)>)>
public static "clearNullReferences"(): void
public static "getSummary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
public static "getAlternativeStack"(livingEntity: $LivingEntity$$Type, equipmentSlot: $EquipmentSlot$$Type, consumer: $Consumer$$Type<($ItemStack)>): void
public "lithium$getCachedFeetBlockState"(): $BlockState
/**
 * 
 * @deprecated
 */
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
public static "without"<T>(arg0: $ChangeSubscriber$$Type<(T)>, arg1: $ChangeSubscriber$$Type<(T)>, arg2: integer, arg3: boolean): $ChangeSubscriber<(T)>
public static "without"<T>(arg0: $ChangeSubscriber$$Type<(T)>, arg1: $ChangeSubscriber$$Type<(T)>): $ChangeSubscriber<(T)>
public static "combine"<T>(arg0: $ChangeSubscriber$$Type<(T)>, arg1: integer, arg2: $ChangeSubscriber$$Type<(T)>, arg3: integer): $ChangeSubscriber<(T)>
public static "dataWithout"<T>(arg0: $ChangeSubscriber$$Type<(T)>, arg1: $ChangeSubscriber$$Type<(T)>, arg2: integer, arg3: integer, arg4: boolean): integer
public static "dataWithout"<T>(arg0: $ChangeSubscriber$$Type<(T)>, arg1: $ChangeSubscriber$$Type<(T)>, arg2: integer): integer
public static "dataOf"(arg0: $ChangeSubscriber$$Type<(never)>, arg1: $ChangeSubscriber$$Type<(never)>, arg2: integer): integer
public static "containsSubscriber"(arg0: $ChangeSubscriber$$Type<($ItemStack$$Type)>, arg1: integer, arg2: $ChangeSubscriber$$Type<($ItemStack$$Type)>, arg3: integer): boolean
public static "forNameOnly"(arg0: StringJS): $ScoreHolder
public static "fromGameProfile"(arg0: $GameProfile$$Type): $ScoreHolder
get "displayName"(): $Component
get "uuid"(): $UUID
get "currentItemAttackStrengthDelay"(): float
public static get "summary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeployerFakePlayer$$Type = ($DeployerFakePlayer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeployerFakePlayer$$Original = $DeployerFakePlayer;}
declare module "com.simibubi.create.content.fluids.tank.storage.creative.CreativeFluidTankMountedStorage" {
import {$CreativeFluidTankBlockEntity$$Type} from "com.simibubi.create.content.fluids.tank.CreativeFluidTankBlockEntity"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$MountedFluidStorageType} from "com.simibubi.create.api.contraption.storage.fluid.MountedFluidStorageType"
import {$MountedFluidStorage} from "com.simibubi.create.api.contraption.storage.fluid.MountedFluidStorage"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$WrapperMountedFluidStorage} from "com.simibubi.create.api.contraption.storage.fluid.WrapperMountedFluidStorage"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$CreativeFluidTankBlockEntity$CreativeSmartFluidTank} from "com.simibubi.create.content.fluids.tank.CreativeFluidTankBlockEntity$CreativeSmartFluidTank"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CreativeFluidTankMountedStorage extends $WrapperMountedFluidStorage<($CreativeFluidTankBlockEntity$CreativeSmartFluidTank)> {
static readonly "CODEC": $MapCodec<($CreativeFluidTankMountedStorage)>
readonly "type": $MountedFluidStorageType<($MountedFluidStorage)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MountedFluidStorage)>

public static "fromLegacy"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): $CreativeFluidTankMountedStorage
public static "fromTank"(arg0: $CreativeFluidTankBlockEntity$$Type): $CreativeFluidTankMountedStorage
public "unmount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeFluidTankMountedStorage$$Type = ($CreativeFluidTankMountedStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeFluidTankMountedStorage$$Original = $CreativeFluidTankMountedStorage;}
declare module "com.simibubi.create.content.kinetics.simpleRelays.SimpleKineticBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List, $List$$Type} from "java.util.List"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$IRotate$$Type} from "com.simibubi.create.content.kinetics.base.IRotate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $SimpleKineticBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addPropagationLocations"(arg0: $IRotate$$Type, arg1: $BlockState$$Type, arg2: $List$$Type<($BlockPos$$Type)>): $List<($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleKineticBlockEntity$$Type = ($SimpleKineticBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleKineticBlockEntity$$Original = $SimpleKineticBlockEntity;}
declare module "com.simibubi.create.content.processing.burner.BlazeBurnerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$BlazeBurnerBlockEntity, $BlazeBurnerBlockEntity$$Type} from "com.simibubi.create.content.processing.burner.BlazeBurnerBlockEntity"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LootTable$Builder} from "net.minecraft.world.level.storage.loot.LootTable$Builder"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$BlazeBurnerBlock$HeatLevel} from "com.simibubi.create.content.processing.burner.BlazeBurnerBlock$HeatLevel"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $BlazeBurnerBlock extends $HorizontalDirectionalBlock implements $IBE$$Interface<($BlazeBurnerBlockEntity)>, $IWrenchable$$Interface, $SpecialBlockItemRequirement$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BlazeBurnerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "HEAT_LEVEL": $EnumProperty<($BlazeBurnerBlock$HeatLevel)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "tryInsert"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: boolean, arg5: boolean, arg6: boolean): $InteractionResultHolder<($ItemStack)>
public static "getLight"(arg0: $BlockState$$Type): integer
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($BlazeBurnerBlockEntity)>
public "getBlockEntityClass"(): $Class<($BlazeBurnerBlockEntity)>
public static "getHeatLevelOf"(arg0: $BlockState$$Type): $BlazeBurnerBlock$HeatLevel
public static "buildLootTable"(): $LootTable$Builder
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($BlazeBurnerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($BlazeBurnerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BlazeBurnerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BlazeBurnerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $BlazeBurnerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($BlazeBurnerBlockEntity)>
get "blockEntityClass"(): $Class<($BlazeBurnerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlazeBurnerBlock$$Type = ($BlazeBurnerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlazeBurnerBlock$$Original = $BlazeBurnerBlock;}
declare module "com.simibubi.create.content.logistics.packagePort.frogport.FrogportBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$SmartInventory} from "com.simibubi.create.foundation.item.SmartInventory"
import {$PackagePortBlockEntity} from "com.simibubi.create.content.logistics.packagePort.PackagePortBlockEntity"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$PackagePortTarget} from "com.simibubi.create.content.logistics.packagePort.PackagePortTarget"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveHoveringInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveHoveringInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB} from "net.minecraft.world.phys.AABB"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FrogportBlockEntity extends $PackagePortBlockEntity implements $IHaveHoveringInformation$$Interface {
 "acceptsPackages": boolean
 "anticipationProgress": $LerpedFloat
 "animationProgress": $LerpedFloat
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "computerBehaviour": $AbstractComputerBehaviour
 "inventory": $SmartInventory
 "manualOpenAnimationProgress": $LerpedFloat
 "currentlyDepositing": boolean
 "target": $PackagePortTarget
 "animatedPackage": $ItemStack
 "goggles": boolean
 "passiveYaw": float
 "addressFilter": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "startAnimation"(arg0: $ItemStack$$Type, arg1: boolean): void
public "isAnimationInProgress"(): boolean
public "sendAnticipate"(): void
public "tryPullingFromOwnAndAdjacentInventories"(): void
public "tryPullingFrom"(arg0: $IItemHandler$$Type): boolean
public "anticipate"(): void
public "getYaw"(): float
public "addToTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "getRenderBoundingBox"(): $AABB
public "tick"(): void
public "use"(arg0: $Player$$Type): $ItemInteractionResult
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public "getIcon"(arg0: boolean): $ItemStack
public static "tryClear"(arg0: any): void
get "animationInProgress"(): boolean
get "yaw"(): float
get "renderBoundingBox"(): $AABB
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrogportBlockEntity$$Type = ($FrogportBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FrogportBlockEntity$$Original = $FrogportBlockEntity;}
declare module "com.simibubi.create.content.kinetics.deployer.ItemApplicationRecipe$Serializer" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ProcessingRecipe$Factory$$Type} from "com.simibubi.create.content.processing.recipe.ProcessingRecipe$Factory"
import {$ItemApplicationRecipe} from "com.simibubi.create.content.kinetics.deployer.ItemApplicationRecipe"
import {$ItemApplicationRecipeParams$$Type} from "com.simibubi.create.content.kinetics.deployer.ItemApplicationRecipeParams"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$RecipeSerializer, $RecipeSerializer$$Type, $RecipeSerializer$$Interface} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $ItemApplicationRecipe$Serializer<R extends $ItemApplicationRecipe> implements $RecipeSerializer$$Interface<(R)> {
constructor(arg0: $ProcessingRecipe$Factory$$Type<($ItemApplicationRecipeParams), (R)>)

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (R)>
public "codec"(): $MapCodec<(R)>
public static "register"<S extends $RecipeSerializer<(object)>, T extends $Recipe<(object)>>(arg0: StringJS, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemApplicationRecipe$Serializer$$Type<R> = ($ItemApplicationRecipe$Serializer<(R)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemApplicationRecipe$Serializer$$Original<R> = $ItemApplicationRecipe$Serializer<(R)>;}
declare module "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorBlockEntity" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$ChainConveyorBlockEntity$ConnectionStats} from "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorBlockEntity$ConnectionStats"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$ChainConveyorBlockEntity$ConnectedPort} from "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorBlockEntity$ConnectedPort"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Set} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ChainConveyorRoutingTable} from "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorRoutingTable"
import {$IRotate$$Type} from "com.simibubi.create.content.kinetics.base.IRotate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$KineticBlockEntity, $KineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$ChainConveyorPackage, $ChainConveyorPackage$$Type} from "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorPackage"

export class $ChainConveyorBlockEntity extends $KineticBlockEntity implements $TransformableBlockEntity$$Interface, $Clearable$$Interface {
 "loopPorts": $Map<($BlockPos), ($ChainConveyorBlockEntity$ConnectedPort)>
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "network": long
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "travelPorts": $Map<($BlockPos), ($ChainConveyorBlockEntity$ConnectedPort)>
 "connectionStats": $Map<($BlockPos), ($ChainConveyorBlockEntity$ConnectionStats)>
 "updateSpeed": boolean
 "routingTable": $ChainConveyorRoutingTable
 "checkInvalid": boolean
 "preventSpeedUpdate": integer
 "connections": $Set<($BlockPos)>
 "reversed": boolean
 "cancelDrops": boolean

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "notifyConnectedToValidate"(): void
public "wrapAngle"(arg0: float): float
public "canAcceptMorePackages"(): boolean
public "removeInvalidConnections"(): void
public "prepareStats"(): void
public "tickBoxVisuals"(): void
public "updateBoxWorldPositions"(): void
public "addTravellingPackage"(arg0: $ChainConveyorPackage$$Type, arg1: $BlockPos$$Type): boolean
public "addLoopingPackage"(arg0: $ChainConveyorPackage$$Type): boolean
public "loopThresholdCrossed"(arg0: float, arg1: float, arg2: float): boolean
public "canAcceptMorePackagesFromOtherConveyor"(): boolean
public "getPackagePosition"(arg0: float, arg1: $BlockPos$$Type): $Vec3
public "forPointsAlongChains"(arg0: $BlockPos$$Type, arg1: integer, arg2: $Consumer$$Type<($Vec3)>): boolean
public "chainDestroyed"(arg0: $BlockPos$$Type, arg1: boolean, arg2: boolean): void
public "removeConnectionTo"(arg0: $BlockPos$$Type): boolean
public "canAcceptPackagesFor"(arg0: $BlockPos$$Type): boolean
public "addConnectionTo"(arg0: $BlockPos$$Type): boolean
public static "getChainsFromInventory"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: integer, arg3: boolean): boolean
public "getTravellingPackages"(): $Map<($BlockPos), ($List<($ChainConveyorPackage)>)>
public "propagateRotationTo"(arg0: $KineticBlockEntity$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: boolean, arg5: boolean): float
public "addPropagationLocations"(arg0: $IRotate$$Type, arg1: $BlockState$$Type, arg2: $List$$Type<($BlockPos$$Type)>): $List<($BlockPos)>
public "clearContent"(): void
public "addToTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "notifyUpdate"(): void
public "getRequiredItems"(arg0: $BlockState$$Type): $ItemRequirement
public "lazyTick"(): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getLoopingPackages"(): $List<($ChainConveyorPackage)>
public static "getChainCost"(arg0: $BlockPos$$Type): integer
public "tick"(): void
public "remove"(): void
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "destroy"(): void
public "invalidate"(): void
public static "tryClear"(arg0: any): void
get "travellingPackages"(): $Map<($BlockPos), ($List<($ChainConveyorPackage)>)>
get "loopingPackages"(): $List<($ChainConveyorPackage)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainConveyorBlockEntity$$Type = ($ChainConveyorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainConveyorBlockEntity$$Original = $ChainConveyorBlockEntity;}
declare module "com.simibubi.create.content.trains.track.BezierConnection" {
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Iterator} from "java.util.Iterator"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IMonorailBezier$MonorailAngles} from "com.railwayteam.railways.mixin_interfaces.IMonorailBezier$MonorailAngles"
import {$SlabBlock, $SlabBlock$$Type} from "net.minecraft.world.level.block.SlabBlock"
import {$Map} from "java.util.Map"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$BezierConnection$SegmentAngles} from "com.simibubi.create.content.trains.track.BezierConnection$SegmentAngles"
import {$BezierConnection$Segment, $BezierConnection$Segment$$Type} from "com.simibubi.create.content.trains.track.BezierConnection$Segment"
import {$Spliterator} from "java.util.Spliterator"
import {$BezierConnection$GirderAngles} from "com.simibubi.create.content.trains.track.BezierConnection$GirderAngles"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$IHasTrackCasing$$Interface} from "com.railwayteam.railways.mixin_interfaces.IHasTrackCasing"
import {$TrackMaterial, $TrackMaterial$$Type} from "com.simibubi.create.content.trains.track.TrackMaterial"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Couple, $Couple$$Type} from "net.createmod.catnip.data.Couple"
import {$IMonorailBezier$$Interface} from "com.railwayteam.railways.mixin_interfaces.IMonorailBezier"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $BezierConnection implements $Iterable$$Interface<($BezierConnection$Segment)>, $IHasTrackCasing$$Interface, $IMonorailBezier$$Interface {
readonly "axes": $Couple<($Vec3)>
 "smoothing": $Couple<(integer)>
readonly "hasGirder": boolean
readonly "starts": $Couple<($Vec3)>
readonly "normals": $Couple<($Vec3)>
readonly "bePositions": $Couple<($BlockPos)>
readonly "primary": boolean

constructor(arg0: $CompoundTag$$Type, arg1: $BlockPos$$Type)
constructor(arg0: $Couple$$Type<($BlockPos$$Type)>, arg1: $Couple$$Type<($Vec3$$Type)>, arg2: $Couple$$Type<($Vec3$$Type)>, arg3: $Couple$$Type<($Vec3$$Type)>, arg4: boolean, arg5: boolean, arg6: $TrackMaterial$$Type)
constructor(arg0: $FriendlyByteBuf$$Type)

public "equalsSansMaterial"(arg0: $BezierConnection$$Type): boolean
public "spawnItems"(arg0: $Level$$Type): void
public "rasterise"(): $Map<($Pair<(integer), (integer)>), (double)>
public "getSegmentT"(arg0: integer): float
public "getBakedSegments"(): $BezierConnection$SegmentAngles
public "getBakedGirders"(): $BezierConnection$GirderAngles
public "getBakedMonorails"(): ($IMonorailBezier$MonorailAngles)[]
public "getStepLUT"(): (float)[]
public "spawnDestroyParticles"(arg0: $Level$$Type): void
public "getTrackCasing"(): $SlabBlock
public "secondary"(): $BezierConnection
public "getRadius"(): double
public "getSegmentCount"(): integer
public "getHandleLength"(): double
public "setMaterial"(arg0: $TrackMaterial$$Type): void
public "isPrimary"(): boolean
public "getTrackItemCost"(): integer
public "getGirderItemCost"(): integer
public "addItemsToPlayer"(arg0: $Player$$Type): void
public "yOffsetAt"(arg0: $Vec3$$Type): integer
public "isAlternate"(): boolean
public "incrementT"(arg0: double, arg1: double): double
public "setAlternate"(arg0: boolean): void
public "setTrackCasing"(arg0: $SlabBlock$$Type): void
public "clone"(): any
public "getLength"(): double
public "iterator"(): $Iterator<($BezierConnection$Segment)>
public "getBounds"(): $AABB
public "getKey"(): $BlockPos
public "write"(arg0: $BlockPos$$Type): $CompoundTag
public "write"(arg0: $FriendlyByteBuf$$Type): void
public "getPosition"(arg0: double): $Vec3
public "getNormal"(arg0: double): $Vec3
public "getMaterial"(): $TrackMaterial
public "spliterator"(): $Spliterator<($BezierConnection$Segment)>
public "forEach"(arg0: $Consumer$$Type<($BezierConnection$Segment)>): void
public static "setAlternateModel"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: boolean): boolean
public static "getTrackCasing"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $SlabBlock
public static "isAlternate"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public static "setTrackCasing"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $SlabBlock$$Type): void
[Symbol.iterator](): IterableIterator<$BezierConnection$Segment>;
get "bakedSegments"(): $BezierConnection$SegmentAngles
get "bakedGirders"(): $BezierConnection$GirderAngles
get "bakedMonorails"(): ($IMonorailBezier$MonorailAngles)[]
get "stepLUT"(): (float)[]
get "trackCasing"(): $SlabBlock
get "radius"(): double
get "segmentCount"(): integer
get "handleLength"(): double
set "material"(value: $TrackMaterial$$Type)
get "trackItemCost"(): integer
get "girderItemCost"(): integer
get "alternate"(): boolean
set "alternate"(value: boolean)
set "trackCasing"(value: $SlabBlock$$Type)
get "length"(): double
get "bounds"(): $AABB
get "key"(): $BlockPos
get "material"(): $TrackMaterial
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BezierConnection$$Type = ($BezierConnection);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BezierConnection$$Original = $BezierConnection;}
declare module "com.simibubi.create.content.fluids.pipes.SmartFluidPipeBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SmartFluidPipeBlockEntity extends $SmartBlockEntity implements $Clearable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public static "tryClear"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmartFluidPipeBlockEntity$$Type = ($SmartFluidPipeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmartFluidPipeBlockEntity$$Original = $SmartFluidPipeBlockEntity;}
declare module "com.simibubi.create.content.kinetics.transmission.sequencer.Instruction" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$SequencerInstructions, $SequencerInstructions$$Type} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencerInstructions"
import {$InstructionAccessor$$Interface} from "com.hlysine.create_connected.mixin.sequencedgearshift.InstructionAccessor"
import {$List$$Type} from "java.util.List"
import {$Vector} from "java.util.Vector"
import {$ListTag, $ListTag$$Type} from "net.minecraft.nbt.ListTag"
import {$InstructionSpeedModifiers$$Type} from "com.simibubi.create.content.kinetics.transmission.sequencer.InstructionSpeedModifiers"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $Instruction implements $InstructionAccessor$$Interface {
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($Instruction)>

constructor(arg0: $SequencerInstructions$$Type, arg1: $InstructionSpeedModifiers$$Type, arg2: integer)
constructor(arg0: $SequencerInstructions$$Type, arg1: integer)
constructor(arg0: $SequencerInstructions$$Type)

public static "serializeAll"(arg0: $List$$Type<($Instruction$$Type)>): $ListTag
public static "deserializeAll"(arg0: $ListTag$$Type): $Vector<($Instruction)>
public "getInstruction"(): $SequencerInstructions
public static "createDefault"(): $Vector<($Instruction)>
get "instruction"(): $SequencerInstructions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Instruction$$Type = ($Instruction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Instruction$$Original = $Instruction;}
declare module "com.simibubi.create.content.logistics.tableCloth.TableClothBlockEntity" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$UUID} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$FilteringBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.filtering.FilteringBehaviour"
import {$AutoRequestData} from "com.simibubi.create.content.logistics.redstoneRequester.AutoRequestData"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$ShoppingListItem$ShoppingList$$Type} from "com.simibubi.create.content.logistics.tableCloth.ShoppingListItem$ShoppingList"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TableClothBlockEntity extends $SmartBlockEntity implements $TransformableBlockEntity$$Interface {
 "owner": $UUID
 "manuallyAddedItems": $List<($ItemStack)>
 "priceTag": $FilteringBehaviour
 "facing": $Direction
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "sideOccluded": boolean
 "computerBehaviour": $AbstractComputerBehaviour
 "requestData": $AutoRequestData

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "useShop"(arg0: $Player$$Type): $ItemInteractionResult
public "getStockLevelForTrade"(arg0: $ShoppingListItem$ShoppingList$$Type): integer
public "getItemsForRender"(): $List<($ItemStack)>
public "invalidateItemsForRender"(): void
public "notifyShopUpdate"(): void
public "targetsPriceTag"(arg0: $Player$$Type, arg1: $BlockHitResult$$Type): boolean
public "getPaymentItem"(): $ItemStack
public "getPaymentAmount"(): integer
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "isShop"(): boolean
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "destroy"(): void
public "use"(arg0: $Player$$Type, arg1: $BlockHitResult$$Type): $ItemInteractionResult
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
get "itemsForRender"(): $List<($ItemStack)>
get "paymentItem"(): $ItemStack
get "paymentAmount"(): integer
get "shop"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TableClothBlockEntity$$Type = ($TableClothBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TableClothBlockEntity$$Original = $TableClothBlockEntity;}
declare module "com.simibubi.create.content.redstone.displayLink.source.ScoreboardDisplaySource" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ValueListDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.ValueListDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $ScoreboardDisplaySource extends $ValueListDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScoreboardDisplaySource$$Type = ($ScoreboardDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScoreboardDisplaySource$$Original = $ScoreboardDisplaySource;}
declare module "com.simibubi.create.content.contraptions.elevator.ElevatorContactBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$DoorControlBehaviour} from "com.simibubi.create.content.decoration.slidingDoor.DoorControlBehaviour"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ElevatorColumn$ColumnCoords} from "com.simibubi.create.content.contraptions.elevator.ElevatorColumn$ColumnCoords"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ElevatorContactBlockEntity extends $SmartBlockEntity {
 "columnCoords": $ElevatorColumn$ColumnCoords
 "lastReportedCurrentFloor": StringJS
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "doorControls": $DoorControlBehaviour
 "shortName": StringJS
 "activateBlock": boolean
 "longName": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "updateDisplayedFloor"(arg0: StringJS): void
public "updateName"(arg0: StringJS, arg1: StringJS): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "tick"(): void
public "getNames"(): $Couple<(StringJS)>
public "initialize"(): void
public "invalidate"(): void
get "names"(): $Couple<(StringJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElevatorContactBlockEntity$$Type = ($ElevatorContactBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ElevatorContactBlockEntity$$Original = $ElevatorContactBlockEntity;}
declare module "com.simibubi.create.content.schematics.table.SchematicTableBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$SchematicTableBlockEntity, $SchematicTableBlockEntity$$Type} from "com.simibubi.create.content.schematics.table.SchematicTableBlockEntity"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $SchematicTableBlock extends $HorizontalDirectionalBlock implements $IBE$$Interface<($SchematicTableBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SchematicTableBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($SchematicTableBlockEntity)>
public "getBlockEntityClass"(): $Class<($SchematicTableBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SchematicTableBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SchematicTableBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SchematicTableBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SchematicTableBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SchematicTableBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SchematicTableBlockEntity)>
get "blockEntityClass"(): $Class<($SchematicTableBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicTableBlock$$Type = ($SchematicTableBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicTableBlock$$Original = $SchematicTableBlock;}
declare module "com.simibubi.create.content.contraptions.elevator.ElevatorColumn" {
import {$Collection} from "java.util.Collection"
import {$Map} from "java.util.Map"
import {$List} from "java.util.List"
import {$IntAttached} from "net.createmod.catnip.data.IntAttached"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WorldAttached} from "net.createmod.catnip.data.WorldAttached"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$ElevatorColumn$ColumnCoords, $ElevatorColumn$ColumnCoords$$Type} from "com.simibubi.create.content.contraptions.elevator.ElevatorColumn$ColumnCoords"

export class $ElevatorColumn {
static "LOADED_COLUMNS": $WorldAttached<($Map<($ElevatorColumn$ColumnCoords), ($ElevatorColumn)>)>
 "namesListVersion": integer

constructor(arg0: $LevelAccessor$$Type, arg1: $ElevatorColumn$ColumnCoords$$Type)

public "gatherAll"(): void
public "getTargetedYLevel"(): integer
public "compileNamesList"(): $List<($IntAttached<($Couple<(StringJS)>)>)>
public "namesChanged"(): void
public "isTargetAvailable"(): boolean
public "floorReached"(arg0: $LevelAccessor$$Type, arg1: StringJS): void
public "markDirty"(): void
public "getContacts"(): $Collection<($BlockPos)>
public "contactAt"(arg0: integer): $BlockPos
public "initNames"(arg0: $Level$$Type): void
public static "getOrCreate"(arg0: $LevelAccessor$$Type, arg1: $ElevatorColumn$ColumnCoords$$Type): $ElevatorColumn
public "remove"(arg0: $BlockPos$$Type): void
public static "get"(arg0: $LevelAccessor$$Type, arg1: $ElevatorColumn$ColumnCoords$$Type): $ElevatorColumn
public "target"(arg0: integer): void
public "add"(arg0: $BlockPos$$Type): void
public "isActive"(): boolean
public "setActive"(arg0: boolean): void
get "targetedYLevel"(): integer
get "targetAvailable"(): boolean
get "contacts"(): $Collection<($BlockPos)>
get "active"(): boolean
set "active"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElevatorColumn$$Type = ($ElevatorColumn);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ElevatorColumn$$Original = $ElevatorColumn;}
declare module "com.simibubi.create.content.redstone.displayLink.source.FillLevelDisplaySource" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$PercentOrProgressBarDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.PercentOrProgressBarDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $FillLevelDisplaySource extends $PercentOrProgressBarDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FillLevelDisplaySource$$Type = ($FillLevelDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FillLevelDisplaySource$$Original = $FillLevelDisplaySource;}
declare module "com.simibubi.create.content.equipment.armor.BaseArmorItem" {
import {$ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$ArmorMaterial$Layer$$Type} from "net.minecraft.world.item.ArmorMaterial$Layer"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Supplier} from "java.util.function.Supplier"
import {$ArmorItem} from "net.minecraft.world.item.ArmorItem"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $BaseArmorItem extends $ArmorItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Holder$$Type<($ArmorMaterial)>, arg1: $ArmorItem$Type$$Type, arg2: $Item$Properties$$Type, arg3: $ResourceLocation$$Type)

public "getArmorTexture"(arg0: $ItemStack$$Type, arg1: $Entity$$Type, arg2: $EquipmentSlot$$Type, arg3: $ArmorMaterial$Layer$$Type, arg4: boolean): $ResourceLocation
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseArmorItem$$Type = ($BaseArmorItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseArmorItem$$Original = $BaseArmorItem;}
declare module "com.simibubi.create.content.redstone.deskBell.DeskBellBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$DeskBellBlockEntity, $DeskBellBlockEntity$$Type} from "com.simibubi.create.content.redstone.deskBell.DeskBellBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $DeskBellBlock extends $WrenchableDirectionalBlock implements $ProperWaterloggedBlock$$Interface, $IBE$$Interface<($DeskBellBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($DeskBellBlockEntity)>
public "getBlockEntityClass"(): $Class<($DeskBellBlockEntity)>
public "unPress"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "playSound"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getDirectSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($DeskBellBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($DeskBellBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($DeskBellBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($DeskBellBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $DeskBellBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($DeskBellBlockEntity)>
get "blockEntityClass"(): $Class<($DeskBellBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeskBellBlock$$Type = ($DeskBellBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeskBellBlock$$Original = $DeskBellBlock;}
declare module "com.simibubi.create.content.contraptions.piston.MechanicalPistonBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$MechanicalPistonBlockEntity, $MechanicalPistonBlockEntity$$Type} from "com.simibubi.create.content.contraptions.piston.MechanicalPistonBlockEntity"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$MechanicalPistonBlock$PistonState} from "com.simibubi.create.content.contraptions.piston.MechanicalPistonBlock$PistonState"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$DirectionalAxisKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalAxisKineticBlock"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $MechanicalPistonBlock extends $DirectionalAxisKineticBlock implements $IBE$$Interface<($MechanicalPistonBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "STATE": $EnumProperty<($MechanicalPistonBlock$PistonState)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "AXIS_ALONG_FIRST_COORDINATE": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($MechanicalPistonBlockEntity)>
public "getBlockEntityClass"(): $Class<($MechanicalPistonBlockEntity)>
public static "isExtensionPole"(arg0: $BlockState$$Type): boolean
public static "maxAllowedPistonPoles"(): integer
public static "isPistonHead"(arg0: $BlockState$$Type): boolean
public static "isStickyPiston"(arg0: $BlockState$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public static "normal"(arg0: $BlockBehaviour$Properties$$Type): $MechanicalPistonBlock
public static "isPiston"(arg0: $BlockState$$Type): boolean
public static "sticky"(arg0: $BlockBehaviour$Properties$$Type): $MechanicalPistonBlock
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($MechanicalPistonBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($MechanicalPistonBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MechanicalPistonBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MechanicalPistonBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $MechanicalPistonBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($MechanicalPistonBlockEntity)>
get "blockEntityClass"(): $Class<($MechanicalPistonBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPistonBlock$$Type = ($MechanicalPistonBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalPistonBlock$$Original = $MechanicalPistonBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.target.SignDisplayTarget" {
import {$DisplayTargetStats} from "com.simibubi.create.content.redstone.displayLink.target.DisplayTargetStats"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List$$Type} from "java.util.List"
import {$MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$DisplayTarget} from "com.simibubi.create.api.behaviour.display.DisplayTarget"

export class $SignDisplayTarget extends $DisplayTarget {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry<($BlockEntityType<(never)>), ($DisplayTarget)>
static readonly "BY_BLOCK": $SimpleRegistry<($Block), ($DisplayTarget)>

constructor()

public "provideStats"(arg0: $DisplayLinkContext$$Type): $DisplayTargetStats
public "requiresComponentSanitization"(): boolean
public "acceptText"(arg0: integer, arg1: $List$$Type<($MutableComponent$$Type)>, arg2: $DisplayLinkContext$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignDisplayTarget$$Type = ($SignDisplayTarget);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignDisplayTarget$$Original = $SignDisplayTarget;}
declare module "com.simibubi.create.content.trains.entity.Carriage" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Carriage$DimensionalCarriageEntity} from "com.simibubi.create.content.trains.entity.Carriage$DimensionalCarriageEntity"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$TravellingPoint, $TravellingPoint$$Type} from "com.simibubi.create.content.trains.entity.TravellingPoint"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$CarriageBogey, $CarriageBogey$$Type} from "com.simibubi.create.content.trains.entity.CarriageBogey"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$CarriageContraptionEntity, $CarriageContraptionEntity$$Type} from "com.simibubi.create.content.trains.entity.CarriageContraptionEntity"
import {$Map} from "java.util.Map"
import {$CarriageContraption$$Type} from "com.simibubi.create.content.trains.entity.CarriageContraption"
import {$Train, $Train$$Type} from "com.simibubi.create.content.trains.entity.Train"
import {$TrainCargoManager} from "com.simibubi.create.content.contraptions.minecart.TrainCargoManager"
import {$AccessorCarriage$$Interface} from "com.railwayteam.railways.mixin.AccessorCarriage"
import {$ICarriageConductors$$Interface} from "com.railwayteam.railways.mixin_interfaces.ICarriageConductors"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$AtomicInteger} from "java.util.concurrent.atomic.AtomicInteger"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$ICarriageBufferDistanceTracker$$Interface} from "com.railwayteam.railways.mixin_interfaces.ICarriageBufferDistanceTracker"

export class $Carriage implements $AccessorCarriage$$Interface, $ICarriageConductors$$Interface, $ICarriageBufferDistanceTracker$$Interface {
 "presentConductors": $Couple<(boolean)>
 "bogeys": $Couple<($CarriageBogey)>
 "blocked": boolean
 "stalled": boolean
static readonly "netIdGenerator": $AtomicInteger
 "id": integer
 "bogeySpacing": integer
 "storage": $TrainCargoManager
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Carriage)>
 "train": $Train

constructor(arg0: $CarriageBogey$$Type, arg1: $CarriageBogey$$Type, arg2: integer)

public "getDimensionalIfPresent"(arg0: $ResourceKey$$Type<($Level)>): $Carriage$DimensionalCarriageEntity
public "getAnchorDiff"(): double
public "anyAvailableDimensionalCarriage"(): $Pair<($ResourceKey<($Level)>), ($Carriage$DimensionalCarriageEntity)>
public "presentInMultipleDimensions"(): boolean
public "getPresentDimensions"(): $List<($ResourceKey<($Level)>)>
public "getPositionInDimension"(arg0: $ResourceKey$$Type<($Level)>): $Optional<($BlockPos)>
public "manageEntities"(arg0: $Level$$Type): void
public "isOnIncompatibleTrack"(): boolean
public "getLeadingPoint"(): $TravellingPoint
public "getTrailingPoint"(): $TravellingPoint
public "leadingBogey"(): $CarriageBogey
public "trailingBogey"(): $CarriageBogey
public "anyAvailableEntity"(): $CarriageContraptionEntity
public "forEachPresentEntity"(arg0: $Consumer$$Type<($CarriageContraptionEntity)>): void
public "getDimensional"(arg0: $Level$$Type): $Carriage$DimensionalCarriageEntity
public "getDimensional"(arg0: $ResourceKey$$Type<($Level)>): $Carriage$DimensionalCarriageEntity
public "updateContraptionAnchors"(): void
public "alignEntity"(arg0: $Level$$Type): void
public "isOnTwoBogeys"(): boolean
public "railways$getLeadingDistance"(): integer
public "railways$getTrailingDistance"(): integer
public "railways$setLeadingDistance"(arg0: integer): void
public "railways$setTrailingDistance"(arg0: integer): void
public "railways$getControllingConductors"(): $List
public "updateConductors"(): void
public "getSerialisedPassengers"(): $Map
public "setTrain"(arg0: $Train$$Type): void
public "setContraption"(arg0: $Level$$Type, arg1: $CarriageContraption$$Type): void
public "write"(arg0: $DimensionPalette$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public static "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $TrackGraph$$Type, arg3: $DimensionPalette$$Type): $Carriage
public "travel"(arg0: $Level$$Type, arg1: $TrackGraph$$Type, arg2: double, arg3: $TravellingPoint$$Type, arg4: $TravellingPoint$$Type, arg5: integer): double
get "anchorDiff"(): double
get "presentDimensions"(): $List<($ResourceKey<($Level)>)>
get "onIncompatibleTrack"(): boolean
get "leadingPoint"(): $TravellingPoint
get "trailingPoint"(): $TravellingPoint
get "onTwoBogeys"(): boolean
get "serialisedPassengers"(): $Map
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Carriage$$Type = ($Carriage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Carriage$$Original = $Carriage;}
declare module "com.simibubi.create.content.kinetics.fan.EncasedFanBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DirectionalKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalKineticBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$EncasedFanBlockEntity, $EncasedFanBlockEntity$$Type} from "com.simibubi.create.content.kinetics.fan.EncasedFanBlockEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $EncasedFanBlock extends $DirectionalKineticBlock implements $IBE$$Interface<($EncasedFanBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($EncasedFanBlockEntity)>
public "getBlockEntityClass"(): $Class<($EncasedFanBlockEntity)>
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "updateIndirectNeighbourShapes"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: integer, arg4: integer): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($EncasedFanBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($EncasedFanBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($EncasedFanBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($EncasedFanBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $EncasedFanBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($EncasedFanBlockEntity)>
get "blockEntityClass"(): $Class<($EncasedFanBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EncasedFanBlock$$Type = ($EncasedFanBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EncasedFanBlock$$Original = $EncasedFanBlock;}
declare module "com.simibubi.create.content.kinetics.deployer.ItemApplicationRecipe" {
import {$ProcessingRecipe} from "com.simibubi.create.content.processing.recipe.ProcessingRecipe"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$AllRecipeTypes$$Type} from "com.simibubi.create.AllRecipeTypes"
import {$RecipeWrapper, $RecipeWrapper$$Type} from "net.neoforged.neoforge.items.wrapper.RecipeWrapper"
import {$ItemApplicationRecipeParams, $ItemApplicationRecipeParams$$Type} from "com.simibubi.create.content.kinetics.deployer.ItemApplicationRecipeParams"

export class $ItemApplicationRecipe extends $ProcessingRecipe<($RecipeWrapper), ($ItemApplicationRecipeParams)> {
constructor(arg0: $AllRecipeTypes$$Type, arg1: $ItemApplicationRecipeParams$$Type)

public "getProcessedItem"(): $Ingredient
public "getRequiredHeldItem"(): $Ingredient
public "shouldKeepHeldItem"(): boolean
public "matches"(arg0: $RecipeWrapper$$Type, arg1: $Level$$Type): boolean
public "matches"(arg0: $RecipeInput$$Type, arg1: $Level$$Type): boolean
get "processedItem"(): $Ingredient
get "requiredHeldItem"(): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemApplicationRecipe$$Type = ($ItemApplicationRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemApplicationRecipe$$Original = $ItemApplicationRecipe;}
declare module "com.simibubi.create.content.redstone.thresholdSwitch.ThresholdSwitchObservable" {
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"

export interface $ThresholdSwitchObservable$$Interface {
get "currentValue"(): integer
get "minValue"(): integer
get "maxValue"(): integer
}

export class $ThresholdSwitchObservable implements $ThresholdSwitchObservable$$Interface {
 "getCurrentValue"(): integer
 "getMinValue"(): integer
 "getMaxValue"(): integer
 "format"(arg0: integer): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThresholdSwitchObservable$$Type = ($ThresholdSwitchObservable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThresholdSwitchObservable$$Original = $ThresholdSwitchObservable;}
declare module "com.simibubi.create.content.equipment.armor.DivingBootsItem" {
import {$ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$EntityTickEvent$Pre$$Type} from "net.neoforged.neoforge.event.tick.EntityTickEvent$Pre"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot} from "net.minecraft.world.entity.EquipmentSlot"
import {$Supplier} from "java.util.function.Supplier"
import {$BaseArmorItem} from "com.simibubi.create.content.equipment.armor.BaseArmorItem"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$DispenseItemBehavior} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $DivingBootsItem extends $BaseArmorItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "SLOT": $EquipmentSlot
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
static readonly "TYPE": $ArmorItem$Type
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Holder$$Type<($ArmorMaterial)>, arg1: $Item$Properties$$Type, arg2: $ResourceLocation$$Type)

public static "accelerateDescentUnderwater"(arg0: $EntityTickEvent$Pre$$Type): void
public static "isWornBy"(arg0: $Entity$$Type): boolean
public static "getWornItem"(arg0: $Entity$$Type): $ItemStack
public static "getMovementMultiplier"(arg0: $LivingEntity$$Type): $Vec3
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DivingBootsItem$$Type = ($DivingBootsItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DivingBootsItem$$Original = $DivingBootsItem;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.SingletonItemAttribute" {
import {$BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute, $ItemAttribute$$Type, $ItemAttribute$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$SingletonItemAttribute$Type$$Type} from "com.simibubi.create.content.logistics.item.filter.attribute.SingletonItemAttribute$Type"
import {$ItemAttributeType} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $SingletonItemAttribute implements $ItemAttribute$$Interface {
constructor(arg0: $SingletonItemAttribute$Type$$Type, arg1: $BiPredicate$$Type<($ItemStack), ($Level)>, arg2: StringJS)

public "appliesTo"(arg0: $ItemStack$$Type, arg1: $Level$$Type): boolean
public "getTranslationKey"(): StringJS
public "getType"(): $ItemAttributeType
public static "loadStatic"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $ItemAttribute
public static "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "getTranslationParameters"(): (any)[]
public static "saveStatic"(arg0: $ItemAttribute$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "format"(arg0: boolean): $MutableComponent
get "translationKey"(): StringJS
get "type"(): $ItemAttributeType
get "translationParameters"(): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingletonItemAttribute$$Type = ($SingletonItemAttribute);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SingletonItemAttribute$$Original = $SingletonItemAttribute;}
declare module "com.simibubi.create.content.processing.AssemblyOperatorBlockItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $AssemblyOperatorBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "place"(arg0: $BlockPlaceContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AssemblyOperatorBlockItem$$Type = ($AssemblyOperatorBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AssemblyOperatorBlockItem$$Original = $AssemblyOperatorBlockItem;}
declare module "com.simibubi.create.content.kinetics.belt.item.BeltConnectorItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $BeltConnectorItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public static "canConnect"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type): boolean
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public static "validateAxis"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public static "createBelts"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type): void
public static "maxLength"(): integer
public "getDescriptionId"(): StringJS
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltConnectorItem$$Type = ($BeltConnectorItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltConnectorItem$$Original = $BeltConnectorItem;}
declare module "com.simibubi.create.content.trains.display.FlapDisplayBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List, $List$$Type} from "java.util.List"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Direction} from "net.minecraft.core.Direction"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$FlapDisplayLayout} from "com.simibubi.create.content.trains.display.FlapDisplayLayout"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FlapDisplayBlockEntity extends $KineticBlockEntity {
 "glowingLines": (boolean)[]
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "ySize": integer
 "source": $BlockPos
 "isController": boolean
 "network": long
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "colour": ($DyeColor)[]
 "manualLines": (boolean)[]
 "isRunning": boolean
 "updateSpeed": boolean
 "xSize": integer
 "lines": $List<($FlapDisplayLayout)>
 "preventSpeedUpdate": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isSpeedRequirementFulfilled"(): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "setColour"(arg0: integer, arg1: $DyeColor$$Type): void
public "getController"(): $FlapDisplayBlockEntity
public "getMaxCharCount"(arg0: integer): integer
public "getMaxCharCount"(): integer
public "getLineIndexAt"(arg0: double): integer
public "applyTextManually"(arg0: integer, arg1: $Component$$Type): void
public "updateControllerStatus"(): void
public "initDefaultSections"(): void
public "getLineColor"(arg0: integer): integer
public "isLineGlowing"(arg0: integer): boolean
public "tick"(): void
public "initialize"(): void
public "getLines"(): $List<($FlapDisplayLayout)>
public "getDirection"(): $Direction
public "setGlowing"(arg0: integer): void
get "speedRequirementFulfilled"(): boolean
get "controller"(): $FlapDisplayBlockEntity
get "maxCharCount"(): integer
get "direction"(): $Direction
set "glowing"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlapDisplayBlockEntity$$Type = ($FlapDisplayBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlapDisplayBlockEntity$$Original = $FlapDisplayBlockEntity;}
declare module "com.simibubi.create.content.decoration.slidingDoor.DoorControl" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Enum} from "java.lang.Enum"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ScrollInput} from "com.simibubi.create.foundation.gui.widget.ScrollInput"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Label} from "com.simibubi.create.foundation.gui.widget.Label"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $DoorControl extends $Enum<($DoorControl)> {
static readonly "ALL": $DoorControl
static readonly "NORTH": $DoorControl
static readonly "WEST": $DoorControl
static readonly "SOUTH": $DoorControl
static readonly "NONE": $DoorControl
static readonly "EAST": $DoorControl
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($DoorControl)>

public static "createWidget"(arg0: integer, arg1: integer, arg2: $Consumer$$Type<($DoorControl)>, arg3: $DoorControl$$Type): $Pair<($ScrollInput), ($Label)>
public static "values"(): ($DoorControl)[]
public static "valueOf"(arg0: StringJS): $DoorControl
public "matches"(arg0: $Direction$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoorControl$$Type = (("all") | ("north") | ("east") | ("south") | ("west") | ("none"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoorControl$$Original = $DoorControl;}
declare module "com.simibubi.create.content.kinetics.press.MechanicalPressBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$HorizontalKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalKineticBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$MechanicalPressBlockEntity, $MechanicalPressBlockEntity$$Type} from "com.simibubi.create.content.kinetics.press.MechanicalPressBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $MechanicalPressBlock extends $HorizontalKineticBlock implements $IBE$$Interface<($MechanicalPressBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "HORIZONTAL_FACING": $Property<($Direction)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($MechanicalPressBlockEntity)>
public "getBlockEntityClass"(): $Class<($MechanicalPressBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($MechanicalPressBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($MechanicalPressBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MechanicalPressBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MechanicalPressBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $MechanicalPressBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($MechanicalPressBlockEntity)>
get "blockEntityClass"(): $Class<($MechanicalPressBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPressBlock$$Type = ($MechanicalPressBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalPressBlock$$Original = $MechanicalPressBlock;}
declare module "com.simibubi.create.content.kinetics.gauge.StressGaugeBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GaugeBlockEntity} from "com.simibubi.create.content.kinetics.gauge.GaugeBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $StressGaugeBlockEntity extends $GaugeBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "color": integer
 "prevDialState": float
 "dialState": float
 "updateSpeed": boolean
 "dialTarget": float
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "computerBehaviour": $AbstractComputerBehaviour
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "onObserved"(): void
public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "updateFromNetwork"(arg0: float, arg1: float, arg2: integer): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onSpeedChanged"(arg0: float): void
public "getNetworkCapacity"(): float
public "getNetworkStress"(): float
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
get "networkCapacity"(): float
get "networkStress"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StressGaugeBlockEntity$$Type = ($StressGaugeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StressGaugeBlockEntity$$Original = $StressGaugeBlockEntity;}
declare module "com.simibubi.create.content.schematics.cannon.SchematicannonBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$SchematicannonBlockEntity, $SchematicannonBlockEntity$$Type} from "com.simibubi.create.content.schematics.cannon.SchematicannonBlockEntity"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SchematicannonBlock extends $Block implements $IBE$$Interface<($SchematicannonBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($SchematicannonBlockEntity)>
public "getBlockEntityClass"(): $Class<($SchematicannonBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SchematicannonBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SchematicannonBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SchematicannonBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SchematicannonBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SchematicannonBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SchematicannonBlockEntity)>
get "blockEntityClass"(): $Class<($SchematicannonBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicannonBlock$$Type = ($SchematicannonBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicannonBlock$$Original = $SchematicannonBlock;}
declare module "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorRoutingTable" {
import {$ChainConveyorRoutingTable$RoutingTableEntry} from "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorRoutingTable$RoutingTableEntry"
import {$Collection} from "java.util.Collection"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Component} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $ChainConveyorRoutingTable {
static readonly "ENTRY_TIMEOUT": integer
 "lastUpdate": integer
static readonly "PORT_ENTRY_TIMEOUT": integer
 "entriesByDistance": $List<($ChainConveyorRoutingTable$RoutingTableEntry)>
 "changed": boolean

constructor()

public "shouldAdvertise"(): boolean
public "advertiseTo"(arg0: $BlockPos$$Type, arg1: $ChainConveyorRoutingTable$$Type): void
public "getExitFor"(arg0: $ItemStack$$Type): $BlockPos
public "receivePortInfo"(arg0: StringJS, arg1: $BlockPos$$Type): void
public "createSummary"(): $Collection<($Component)>
public "tick"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainConveyorRoutingTable$$Type = ($ChainConveyorRoutingTable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainConveyorRoutingTable$$Original = $ChainConveyorRoutingTable;}
declare module "com.simibubi.create.content.trains.entity.CarriageSyncData" {
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$CarriageContraptionEntity$$Type} from "com.simibubi.create.content.trains.entity.CarriageContraptionEntity"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Carriage$$Type} from "com.simibubi.create.content.trains.entity.Carriage"
import {$List} from "java.util.List"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$TravellingPoint$$Type} from "com.simibubi.create.content.trains.entity.TravellingPoint"

export class $CarriageSyncData {
 "distanceToDestination": float
 "leadingCarriage": boolean
 "wheelLocations": $List<($Pair<($Couple<(integer)>), (float)>)>
 "fallbackLocations": $Pair<($Vec3), ($Couple<($Vec3)>)>

constructor()
constructor(arg0: $FriendlyByteBuf$$Type)

public "getDistanceTo"(arg0: $TrackGraph$$Type, arg1: $TravellingPoint$$Type, arg2: $TravellingPoint$$Type, arg3: float, arg4: boolean): float
public "setDirty"(arg0: boolean): void
public "isDirty"(): boolean
public "update"(arg0: $CarriageContraptionEntity$$Type, arg1: $Carriage$$Type): void
public "apply"(arg0: $CarriageContraptionEntity$$Type, arg1: $Carriage$$Type): void
public "write"(arg0: $FriendlyByteBuf$$Type): void
public "read"(arg0: $FriendlyByteBuf$$Type): void
public "copy"(): $CarriageSyncData
public "approach"(arg0: $CarriageContraptionEntity$$Type, arg1: $Carriage$$Type, arg2: float): void
set "dirty"(value: boolean)
get "dirty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarriageSyncData$$Type = ($CarriageSyncData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarriageSyncData$$Original = $CarriageSyncData;}
declare module "com.simibubi.create.content.redstone.displayLink.source.ComputerDisplaySource" {
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$DisplayTargetStats$$Type} from "com.simibubi.create.content.redstone.displayLink.target.DisplayTargetStats"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $ComputerDisplaySource extends $DisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "provideText"(arg0: $DisplayLinkContext$$Type, arg1: $DisplayTargetStats$$Type): $List<($MutableComponent)>
public "shouldPassiveReset"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComputerDisplaySource$$Type = ($ComputerDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComputerDisplaySource$$Original = $ComputerDisplaySource;}
declare module "com.simibubi.create.content.logistics.tableCloth.ShoppingListItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$List$$Type} from "java.util.List"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$ShoppingListItem$ShoppingList, $ShoppingListItem$ShoppingList$$Type} from "com.simibubi.create.content.logistics.tableCloth.ShoppingListItem$ShoppingList"

export class $ShoppingListItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public static "saveList"(arg0: $ItemStack$$Type, arg1: $ShoppingListItem$ShoppingList$$Type, arg2: StringJS): $ItemStack
public static "getAddress"(arg0: $ItemStack$$Type): StringJS
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "getList"(arg0: $ItemStack$$Type): $ShoppingListItem$ShoppingList
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShoppingListItem$$Type = ($ShoppingListItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShoppingListItem$$Original = $ShoppingListItem;}
declare module "com.simibubi.create.content.logistics.packagePort.frogport.FrogportBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$FrogportBlockEntity, $FrogportBlockEntity$$Type} from "com.simibubi.create.content.logistics.packagePort.frogport.FrogportBlockEntity"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"

export class $FrogportBlock extends $Block implements $IBE$$Interface<($FrogportBlockEntity)>, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($FrogportBlockEntity)>
public "getBlockEntityClass"(): $Class<($FrogportBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($FrogportBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($FrogportBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FrogportBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FrogportBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $FrogportBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($FrogportBlockEntity)>
get "blockEntityClass"(): $Class<($FrogportBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrogportBlock$$Type = ($FrogportBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FrogportBlock$$Original = $FrogportBlock;}
declare module "com.simibubi.create.content.trains.entity.Navigation$StationTest" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$TrackNode, $TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$Pair, $Pair$$Type} from "net.createmod.catnip.data.Pair"
import {$Couple, $Couple$$Type} from "net.createmod.catnip.data.Couple"
import {$TrackEdge, $TrackEdge$$Type} from "com.simibubi.create.content.trains.graph.TrackEdge"
import {$GlobalStation, $GlobalStation$$Type} from "com.simibubi.create.content.trains.station.GlobalStation"

export interface $Navigation$StationTest$$Interface {

(arg0: double, arg1: double, arg2: $Map<($TrackEdge), ($Pair<(boolean), ($Couple<($TrackNode)>)>)>, arg3: $Pair<($Couple<($TrackNode)>), ($TrackEdge)>, arg4: $GlobalStation): boolean
}

export class $Navigation$StationTest implements $Navigation$StationTest$$Interface {
 "test"(arg0: double, arg1: double, arg2: $Map$$Type<($TrackEdge$$Type), ($Pair$$Type<(boolean), ($Couple$$Type<($TrackNode$$Type)>)>)>, arg3: $Pair$$Type<($Couple$$Type<($TrackNode$$Type)>), ($TrackEdge$$Type)>, arg4: $GlobalStation$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Navigation$StationTest$$Type = ((arg0: double, arg1: double, arg2: $Map<($TrackEdge), ($Pair<(boolean), ($Couple<($TrackNode)>)>)>, arg3: $Pair<($Couple<($TrackNode)>), ($TrackEdge)>, arg4: $GlobalStation) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Navigation$StationTest$$Original = $Navigation$StationTest;}
declare module "com.simibubi.create.content.trains.station.StationMapData" {
import {$StationMarker$$Type} from "com.simibubi.create.content.trains.station.StationMarker"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$StationBlockEntity$$Type} from "com.simibubi.create.content.trains.station.StationBlockEntity"

export interface $StationMapData$$Interface {
}

export class $StationMapData implements $StationMapData$$Interface {
 "addStationMarker"(arg0: $StationMarker$$Type): void
 "toggleStation"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $StationBlockEntity$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StationMapData$$Type = ($StationMapData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StationMapData$$Original = $StationMapData;}
declare module "com.simibubi.create.content.trains.track.TrackBlockOutline$BezierPointSelection" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BezierTrackPointLocation, $BezierTrackPointLocation$$Type} from "com.simibubi.create.content.trains.track.BezierTrackPointLocation"
import {$TrackBlockEntity, $TrackBlockEntity$$Type} from "com.simibubi.create.content.trains.track.TrackBlockEntity"
import {$Record} from "java.lang.Record"

export class $TrackBlockOutline$BezierPointSelection extends $Record {
constructor(blockEntity: $TrackBlockEntity$$Type, loc: $BezierTrackPointLocation$$Type, vec: $Vec3$$Type, angles: $Vec3$$Type, direction: $Vec3$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "loc"(): $BezierTrackPointLocation
public "direction"(): $Vec3
public "vec"(): $Vec3
public "angles"(): $Vec3
public "blockEntity"(): $TrackBlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackBlockOutline$BezierPointSelection$$Type = ({"loc"?: $BezierTrackPointLocation$$Type, "angles"?: $Vec3$$Type, "vec"?: $Vec3$$Type, "direction"?: $Vec3$$Type, "blockEntity"?: $TrackBlockEntity$$Type}) | ([loc?: $BezierTrackPointLocation$$Type, angles?: $Vec3$$Type, vec?: $Vec3$$Type, direction?: $Vec3$$Type, blockEntity?: $TrackBlockEntity$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackBlockOutline$BezierPointSelection$$Original = $TrackBlockOutline$BezierPointSelection;}
declare module "com.simibubi.create.content.schematics.requirement.ItemRequirement$StackRequirement" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemRequirement$ItemUseType, $ItemRequirement$ItemUseType$$Type} from "com.simibubi.create.content.schematics.requirement.ItemRequirement$ItemUseType"

export class $ItemRequirement$StackRequirement {
readonly "stack": $ItemStack
readonly "usage": $ItemRequirement$ItemUseType

constructor(arg0: $ItemStack$$Type, arg1: $ItemRequirement$ItemUseType$$Type)

public "matches"(arg0: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRequirement$StackRequirement$$Type = ($ItemRequirement$StackRequirement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemRequirement$StackRequirement$$Original = $ItemRequirement$StackRequirement;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.attributes.InItemGroupAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $InItemGroupAttribute$Type implements $ItemAttributeType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InItemGroupAttribute$Type$$Type = ($InItemGroupAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InItemGroupAttribute$Type$$Original = $InItemGroupAttribute$Type;}
declare module "com.simibubi.create.content.processing.basin.BasinBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BasinBlockEntity, $BasinBlockEntity$$Type} from "com.simibubi.create.content.processing.basin.BasinBlockEntity"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $BasinBlock extends $Block implements $IBE$$Interface<($BasinBlockEntity)>, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "isBasin"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "getBlockEntityType"(): $BlockEntityType<($BasinBlockEntity)>
public "getBlockEntityClass"(): $Class<($BasinBlockEntity)>
public static "canOutputTo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getInteractionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($BasinBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($BasinBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BasinBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BasinBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $BasinBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($BasinBlockEntity)>
get "blockEntityClass"(): $Class<($BasinBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasinBlock$$Type = ($BasinBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasinBlock$$Original = $BasinBlock;}
declare module "com.simibubi.create.content.kinetics.mixer.MechanicalMixerBlockEntity" {
import {$DeferralBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.simple.DeferralBehaviour"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BasinOperatingBlockEntity} from "com.simibubi.create.content.processing.basin.BasinOperatingBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $MechanicalMixerBlockEntity extends $BasinOperatingBlockEntity {
 "running": boolean
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "basinRemoved": boolean
 "networkDirty": boolean
 "runningTicks": integer
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "processingTicks": integer
 "source": $BlockPos
 "basinChecker": $DeferralBehaviour
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "startProcessingBasin"(): void
public "renderParticles"(): void
public "getRenderedHeadOffset"(arg0: float): float
public "continueWithPreviousRecipe"(): boolean
public "getRenderedHeadRotationSpeed"(arg0: float): float
public "tickAudio"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "tick"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalMixerBlockEntity$$Type = ($MechanicalMixerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalMixerBlockEntity$$Original = $MechanicalMixerBlockEntity;}
declare module "com.simibubi.create.content.processing.sequenced.SequencedAssemblyItem" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"

export class $SequencedAssemblyItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "isBarVisible"(arg0: $ItemStack$$Type): boolean
public "getBarWidth"(arg0: $ItemStack$$Type): integer
public "getBarColor"(arg0: $ItemStack$$Type): integer
public "getProgress"(arg0: $ItemStack$$Type): float
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencedAssemblyItem$$Type = ($SequencedAssemblyItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SequencedAssemblyItem$$Original = $SequencedAssemblyItem;}
declare module "com.simibubi.create.content.trains.entity.TravellingPoint$SteerDirection" {
import {$Enum} from "java.lang.Enum"

export class $TravellingPoint$SteerDirection extends $Enum<($TravellingPoint$SteerDirection)> {
static readonly "LEFT": $TravellingPoint$SteerDirection
static readonly "RIGHT": $TravellingPoint$SteerDirection
static readonly "NONE": $TravellingPoint$SteerDirection

public static "values"(): ($TravellingPoint$SteerDirection)[]
public static "valueOf"(arg0: StringJS): $TravellingPoint$SteerDirection
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TravellingPoint$SteerDirection$$Type = (("none") | ("left") | ("right"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TravellingPoint$SteerDirection$$Original = $TravellingPoint$SteerDirection;}
declare module "com.simibubi.create.content.redstone.displayLink.source.BoilerDisplaySource" {
import {$FlapDisplayBlockEntity$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayBlockEntity"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$DisplayTargetStats$$Type} from "com.simibubi.create.content.redstone.displayLink.target.DisplayTargetStats"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$FlapDisplayLayout$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayLayout"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $BoilerDisplaySource extends $DisplaySource {
static readonly "notEnoughSpaceSingle": $List<($MutableComponent)>
static readonly "notEnoughSpaceFlap": $List<($List<($MutableComponent)>)>
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "notEnoughSpaceDouble": $List<($MutableComponent)>
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "provideText"(arg0: $DisplayLinkContext$$Type, arg1: $DisplayTargetStats$$Type): $List<($MutableComponent)>
public "provideFlapDisplayText"(arg0: $DisplayLinkContext$$Type, arg1: $DisplayTargetStats$$Type): $List<($List<($MutableComponent)>)>
public "loadFlapDisplayLayout"(arg0: $DisplayLinkContext$$Type, arg1: $FlapDisplayBlockEntity$$Type, arg2: $FlapDisplayLayout$$Type, arg3: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilerDisplaySource$$Type = ($BoilerDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BoilerDisplaySource$$Original = $BoilerDisplaySource;}
declare module "com.simibubi.create.content.fluids.tank.BoilerData$BoilerFluidHandler" {
import {$BoilerData$$Type} from "com.simibubi.create.content.fluids.tank.BoilerData"
import {$IFluidHandler$FluidAction$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler$FluidAction"
import {$IFluidHandler$$Interface} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"

export class $BoilerData$BoilerFluidHandler implements $IFluidHandler$$Interface {
constructor(arg0: $BoilerData$$Type)

public "getTanks"(): integer
public "getFluidInTank"(arg0: integer): $FluidStack
public "getTankCapacity"(arg0: integer): integer
public "isFluidValid"(arg0: integer, arg1: $FluidStack$$Type): boolean
public "fill"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): integer
public "drain"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
get "tanks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilerData$BoilerFluidHandler$$Type = ($BoilerData$BoilerFluidHandler);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BoilerData$BoilerFluidHandler$$Original = $BoilerData$BoilerFluidHandler;}
declare module "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$DisplayLinkBlockEntity, $DisplayLinkBlockEntity$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkBlockEntity"

export class $DisplayLinkContext {
 "flapDisplayContext": any

constructor(arg0: $Level$$Type, arg1: $DisplayLinkBlockEntity$$Type)

public "getTargetPos"(): $BlockPos
public "sourceConfig"(): $CompoundTag
public "getTargetBlockEntity"(): $BlockEntity
public "getSourceBlockEntity"(): $BlockEntity
public "getSourcePos"(): $BlockPos
public "level"(): $Level
public "blockEntity"(): $DisplayLinkBlockEntity
get "targetPos"(): $BlockPos
get "targetBlockEntity"(): $BlockEntity
get "sourceBlockEntity"(): $BlockEntity
get "sourcePos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayLinkContext$$Type = ($DisplayLinkContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DisplayLinkContext$$Original = $DisplayLinkContext;}
declare module "com.simibubi.create.content.decoration.palettes.WindowBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ConnectedGlassBlock} from "com.simibubi.create.content.decoration.palettes.ConnectedGlassBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Item} from "net.minecraft.world.item.Item"
import {$TransparentBlock} from "net.minecraft.world.level.block.TransparentBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WindowBlock extends $ConnectedGlassBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TransparentBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: boolean)

public "skipRendering"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "isTranslucent"(): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "translucent"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowBlock$$Type = ($WindowBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WindowBlock$$Original = $WindowBlock;}
declare module "com.simibubi.create.content.fluids.tank.BoilerData" {
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List$$Type} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BoilerData$BoilerFluidHandler} from "com.simibubi.create.content.fluids.tank.BoilerData$BoilerFluidHandler"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidTankBlockEntity$$Type} from "com.simibubi.create.content.fluids.tank.FluidTankBlockEntity"
import {$ChatFormatting$$Type} from "net.minecraft.ChatFormatting"

export class $BoilerData {
 "attachedEngines": integer
 "gauge": $LerpedFloat
 "needsHeatLevelUpdate": boolean
 "passiveHeat": boolean
 "activeHeat": integer
 "attachedWhistles": integer
 "occludedDirections": (boolean)[]
 "waterSupply": float

constructor()

public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean, arg2: integer): boolean
public "checkPipeOrganAdvancement"(arg0: $FluidTankBlockEntity$$Type): void
public "updateOcclusion"(arg0: $FluidTankBlockEntity$$Type): void
public "updateTemperature"(arg0: $FluidTankBlockEntity$$Type): boolean
public "isPassive"(arg0: integer): boolean
public "isPassive"(): boolean
public "getEngineEfficiency"(arg0: integer): float
public "queueSoundOnSide"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): void
public "getTheoreticalHeatLevel"(): integer
public "getMaxHeatLevelForBoilerSize"(arg0: integer): integer
public "getMaxHeatLevelForWaterSupply"(): integer
public "calcMinMaxForSize"(arg0: integer): void
public "getHeatLevelTextComponent"(): $MutableComponent
public "getSizeComponent"(arg0: boolean, arg1: boolean, ...arg2: ($ChatFormatting$$Type)[]): $MutableComponent
public "getWaterComponent"(arg0: boolean, arg1: boolean, ...arg2: ($ChatFormatting$$Type)[]): $MutableComponent
public "getHeatComponent"(arg0: boolean, arg1: boolean, ...arg2: ($ChatFormatting$$Type)[]): $MutableComponent
public "tick"(arg0: $FluidTankBlockEntity$$Type): void
public "createHandler"(): $BoilerData$BoilerFluidHandler
public "evaluate"(arg0: $FluidTankBlockEntity$$Type): boolean
public "clear"(): void
public "write"(): $CompoundTag
public "read"(arg0: $CompoundTag$$Type, arg1: integer): void
public "isActive"(): boolean
get "passive"(): boolean
get "theoreticalHeatLevel"(): integer
get "maxHeatLevelForWaterSupply"(): integer
get "heatLevelTextComponent"(): $MutableComponent
get "active"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilerData$$Type = ($BoilerData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BoilerData$$Original = $BoilerData;}
declare module "com.simibubi.create.content.equipment.armor.BacktankItem$BacktankBlockItem" {
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $BacktankItem$BacktankBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Supplier$$Type<($Item$$Type)>, arg2: $Item$Properties$$Type)

public "getActualItem"(): $Item
public "getDescriptionId"(): StringJS
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "actualItem"(): $Item
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BacktankItem$BacktankBlockItem$$Type = ($BacktankItem$BacktankBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BacktankItem$BacktankBlockItem$$Original = $BacktankItem$BacktankBlockItem;}
declare module "com.simibubi.create.content.contraptions.IDisplayAssemblyExceptions" {
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$AssemblyException, $AssemblyException$$Type} from "com.simibubi.create.content.contraptions.AssemblyException"

export interface $IDisplayAssemblyExceptions$$Interface {

(): $AssemblyException$$Type
get "lastAssemblyException"(): $AssemblyException
}

export class $IDisplayAssemblyExceptions implements $IDisplayAssemblyExceptions$$Interface {
 "getLastAssemblyException"(): $AssemblyException
 "addExceptionToTooltip"(arg0: $List$$Type<($Component$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDisplayAssemblyExceptions$$Type = (() => $AssemblyException$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IDisplayAssemblyExceptions$$Original = $IDisplayAssemblyExceptions;}
declare module "com.simibubi.create.content.equipment.BuildersTeaItem" {
import {$UseAnim} from "net.minecraft.world.item.UseAnim"
import {$Map} from "java.util.Map"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $BuildersTeaItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "getUseDuration"(arg0: $ItemStack$$Type, arg1: $LivingEntity$$Type): integer
public "getUseAnimation"(arg0: $ItemStack$$Type): $UseAnim
public "finishUsingItem"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $LivingEntity$$Type): $ItemStack
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuildersTeaItem$$Type = ($BuildersTeaItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuildersTeaItem$$Original = $BuildersTeaItem;}
declare module "com.simibubi.create.content.trains.track.BezierTrackPointLocation" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Record} from "java.lang.Record"

export class $BezierTrackPointLocation extends $Record {
static readonly "CODEC": $Codec<($BezierTrackPointLocation)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($BezierTrackPointLocation)>

constructor(curveTarget: $BlockPos$$Type, segment: integer)

public "curveTarget"(): $BlockPos
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "segment"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BezierTrackPointLocation$$Type = ({"curveTarget"?: $BlockPos$$Type, "segment"?: integer}) | ([curveTarget?: $BlockPos$$Type, segment?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BezierTrackPointLocation$$Original = $BezierTrackPointLocation;}
declare module "com.simibubi.create.content.contraptions.actors.contraptionControls.ContraptionControlsBlockEntity" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$FilteringBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.filtering.FilteringBehaviour"
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ContraptionControlsBlockEntity extends $SmartBlockEntity implements $Clearable$$Interface {
 "indicator": $LerpedFloat
 "button": $LerpedFloat
 "powered": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "disabled": boolean
 "filtering": $FilteringBehaviour

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public static "sendStatus"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: boolean): void
public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "pressButton"(): void
public "updatePoweredState"(): void
public "tickAnimations"(): void
public "tick"(): void
public "initialize"(): void
public static "tryClear"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContraptionControlsBlockEntity$$Type = ($ContraptionControlsBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ContraptionControlsBlockEntity$$Original = $ContraptionControlsBlockEntity;}
declare module "com.simibubi.create.content.logistics.packagePort.PackagePortTarget" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$PackagePortBlockEntity$$Type} from "com.simibubi.create.content.logistics.packagePort.PackagePortBlockEntity"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $PackagePortTarget {
static readonly "CODEC": $Codec<($PackagePortTarget)>
 "relativePos": $BlockPos
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($PackagePortTarget)>

constructor(arg0: $BlockPos$$Type)

public "getExactTargetLocation"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): $Vec3
public "depositImmediately"(): boolean
public "deregister"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): void
public "register"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): void
public "setup"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): void
public "be"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): $BlockEntity
public "getIcon"(): $ItemStack
public "export"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type, arg3: boolean): boolean
public "canSupport"(arg0: $BlockEntity$$Type): boolean
get "icon"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagePortTarget$$Type = ($PackagePortTarget);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagePortTarget$$Original = $PackagePortTarget;}
declare module "com.simibubi.create.content.kinetics.simpleRelays.BracketedKineticBlockEntity" {
import {$SimpleKineticBlockEntity} from "com.simibubi.create.content.kinetics.simpleRelays.SimpleKineticBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $BracketedKineticBlockEntity extends $SimpleKineticBlockEntity implements $TransformableBlockEntity$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BracketedKineticBlockEntity$$Type = ($BracketedKineticBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BracketedKineticBlockEntity$$Original = $BracketedKineticBlockEntity;}
declare module "com.simibubi.create.content.trains.display.GlobalTrainDisplayData$TrainDeparturePrediction" {
import {$Comparable$$Interface} from "java.lang.Comparable"
import {$Train, $Train$$Type} from "com.simibubi.create.content.trains.entity.Train"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"

export class $GlobalTrainDisplayData$TrainDeparturePrediction implements $Comparable$$Interface<($GlobalTrainDisplayData$TrainDeparturePrediction)> {
 "scheduleTitle": $MutableComponent
 "ticks": integer
 "destination": StringJS
 "train": $Train

constructor(arg0: $Train$$Type, arg1: integer, arg2: $MutableComponent$$Type, arg3: StringJS)

public "compareTo"(arg0: any): integer
public "compareTo"(arg0: $GlobalTrainDisplayData$TrainDeparturePrediction$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlobalTrainDisplayData$TrainDeparturePrediction$$Type = ($GlobalTrainDisplayData$TrainDeparturePrediction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GlobalTrainDisplayData$TrainDeparturePrediction$$Original = $GlobalTrainDisplayData$TrainDeparturePrediction;}
declare module "com.simibubi.create.content.logistics.tableCloth.TableClothBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$LootParams$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootParams$Builder"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$TableClothBlockEntity, $TableClothBlockEntity$$Type} from "com.simibubi.create.content.logistics.tableCloth.TableClothBlockEntity"
import {$IHaveBigOutline$$Interface} from "com.simibubi.create.foundation.block.IHaveBigOutline"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $TableClothBlock extends $Block implements $IHaveBigOutline$$Interface, $IWrenchable$$Interface, $IBE$$Interface<($TableClothBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "HAS_BE": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: StringJS)
constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $DyeColor$$Type)

public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getDrops"(arg0: $BlockState$$Type, arg1: $LootParams$Builder$$Type): $List<($ItemStack)>
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityType"(): $BlockEntityType<($TableClothBlockEntity)>
public "getBlockEntityClass"(): $Class<($TableClothBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getColor"(): $DyeColor
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getInteractionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($TableClothBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($TableClothBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($TableClothBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($TableClothBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $TableClothBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($TableClothBlockEntity)>
get "blockEntityClass"(): $Class<($TableClothBlockEntity)>
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TableClothBlock$$Type = ($TableClothBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TableClothBlock$$Original = $TableClothBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.DisplayLinkBlockItem" {
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$ClickToLinkBlockItem} from "com.simibubi.create.content.redstone.displayLink.ClickToLinkBlockItem"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $DisplayLinkBlockItem extends $ClickToLinkBlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "getMaxDistanceFromSelection"(): integer
public "getMessageTranslationKey"(): StringJS
public "getSelectionBounds"(arg0: $BlockPos$$Type): $AABB
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "maxDistanceFromSelection"(): integer
get "messageTranslationKey"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayLinkBlockItem$$Type = ($DisplayLinkBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DisplayLinkBlockItem$$Original = $DisplayLinkBlockItem;}
declare module "com.simibubi.create.content.redstone.displayLink.source.ItemCountDisplaySource" {
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$NumericSingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.NumericSingleLineDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $ItemCountDisplaySource extends $NumericSingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemCountDisplaySource$$Type = ($ItemCountDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemCountDisplaySource$$Original = $ItemCountDisplaySource;}
declare module "com.simibubi.create.content.logistics.itemHatch.ItemHatchBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$ItemHatchBlockEntity, $ItemHatchBlockEntity$$Type} from "com.simibubi.create.content.logistics.itemHatch.ItemHatchBlockEntity"

export class $ItemHatchBlock extends $HorizontalDirectionalBlock implements $IBE$$Interface<($ItemHatchBlockEntity)>, $IWrenchable$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ItemHatchBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($ItemHatchBlockEntity)>
public "getBlockEntityClass"(): $Class<($ItemHatchBlockEntity)>
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ItemHatchBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ItemHatchBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ItemHatchBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ItemHatchBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ItemHatchBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ItemHatchBlockEntity)>
get "blockEntityClass"(): $Class<($ItemHatchBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemHatchBlock$$Type = ($ItemHatchBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemHatchBlock$$Original = $ItemHatchBlock;}
declare module "com.simibubi.create.content.redstone.diodes.BrassDiodeBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$AbstractDiodeBlock} from "com.simibubi.create.content.redstone.diodes.AbstractDiodeBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BrassDiodeBlockEntity, $BrassDiodeBlockEntity$$Type} from "com.simibubi.create.content.redstone.diodes.BrassDiodeBlockEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $BrassDiodeBlock extends $AbstractDiodeBlock implements $IBE$$Interface<($BrassDiodeBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BrassDiodeBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERING": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "INVERTED": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "toggle"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type, arg4: $InteractionHand$$Type): $ItemInteractionResult
public "getBlockEntityType"(): $BlockEntityType<($BrassDiodeBlockEntity)>
public "getBlockEntityClass"(): $Class<($BrassDiodeBlockEntity)>
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($BrassDiodeBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($BrassDiodeBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BrassDiodeBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BrassDiodeBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $BrassDiodeBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($BrassDiodeBlockEntity)>
get "blockEntityClass"(): $Class<($BrassDiodeBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrassDiodeBlock$$Type = ($BrassDiodeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BrassDiodeBlock$$Original = $BrassDiodeBlock;}
declare module "com.simibubi.create.content.logistics.depot.EjectorBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$EjectorBlockEntity, $EjectorBlockEntity$$Type} from "com.simibubi.create.content.logistics.depot.EjectorBlockEntity"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$HorizontalKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalKineticBlock"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $EjectorBlock extends $HorizontalKineticBlock implements $IBE$$Interface<($EjectorBlockEntity)>, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "HORIZONTAL_FACING": $Property<($Direction)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($EjectorBlockEntity)>
public "getBlockEntityClass"(): $Class<($EjectorBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getFriction"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): float
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($EjectorBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($EjectorBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($EjectorBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($EjectorBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $EjectorBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($EjectorBlockEntity)>
get "blockEntityClass"(): $Class<($EjectorBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EjectorBlock$$Type = ($EjectorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EjectorBlock$$Original = $EjectorBlock;}
declare module "com.simibubi.create.content.decoration.encasing.EncasableBlock" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $EncasableBlock$$Interface {
}

export class $EncasableBlock implements $EncasableBlock$$Interface {
 "playEncaseSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
 "tryEncase"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): $ItemInteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EncasableBlock$$Type = ($EncasableBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EncasableBlock$$Original = $EncasableBlock;}
declare module "com.simibubi.create.content.kinetics.fan.processing.AllFanProcessingTypes$SmokingType" {
import {$FanProcessingType$AirFlowParticleAccess$$Type} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType$AirFlowParticleAccess"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$FanProcessingType, $FanProcessingType$$Interface} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $AllFanProcessingTypes$SmokingType implements $FanProcessingType$$Interface {
constructor()

public "spawnProcessingParticles"(arg0: $Level$$Type, arg1: $Vec3$$Type): void
public "morphAirFlow"(arg0: $FanProcessingType$AirFlowParticleAccess$$Type, arg1: $RandomSource$$Type): void
public "affectEntity"(arg0: $Entity$$Type, arg1: $Level$$Type): void
public "isValidAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public "canProcess"(arg0: $ItemStack$$Type, arg1: $Level$$Type): boolean
public "process"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemStack)>
public "getPriority"(): integer
public static "parse"(arg0: StringJS): $FanProcessingType
public static "getAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $FanProcessingType
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllFanProcessingTypes$SmokingType$$Type = ($AllFanProcessingTypes$SmokingType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllFanProcessingTypes$SmokingType$$Original = $AllFanProcessingTypes$SmokingType;}
declare module "com.simibubi.create.content.fluids.pipes.AxisPipeBlock" {
import {$RotatedPillarBlock} from "net.minecraft.world.level.block.RotatedPillarBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IWrenchableWithBracket$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchableWithBracket"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IAxisPipe$$Interface} from "com.simibubi.create.content.fluids.pipes.IAxisPipe"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AxisPipeBlock extends $RotatedPillarBlock implements $IWrenchableWithBracket$$Interface, $IAxisPipe$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RotatedPillarBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "toRegularPipe"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
public "removeBracket"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: boolean): $Optional<($ItemStack)>
public static "isOpenAt"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "tryRemoveBracket"(arg0: $UseOnContext$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "getAxisOf"(arg0: $BlockState$$Type): $Direction$Axis
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AxisPipeBlock$$Type = ($AxisPipeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AxisPipeBlock$$Original = $AxisPipeBlock;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$BlazeBurnerType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$BlazeBurnerType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$BlazeBurnerType$$Type = ($AllArmInteractionPointTypes$BlazeBurnerType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$BlazeBurnerType$$Original = $AllArmInteractionPointTypes$BlazeBurnerType;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.DirectBeltInputBehaviour$InsertionCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$TransportedItemStack, $TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"

export interface $DirectBeltInputBehaviour$InsertionCallback$$Interface {

(arg0: $TransportedItemStack, arg1: $Direction, arg2: boolean): $ItemStack$$Type
}

export class $DirectBeltInputBehaviour$InsertionCallback implements $DirectBeltInputBehaviour$InsertionCallback$$Interface {
 "apply"(arg0: $TransportedItemStack$$Type, arg1: $Direction$$Type, arg2: boolean): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectBeltInputBehaviour$InsertionCallback$$Type = ((arg0: $TransportedItemStack, arg1: $Direction, arg2: boolean) => $ItemStack$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectBeltInputBehaviour$InsertionCallback$$Original = $DirectBeltInputBehaviour$InsertionCallback;}
declare module "com.simibubi.create.content.contraptions.Contraption" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ContraptionWorld} from "com.simibubi.create.content.contraptions.ContraptionWorld"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$MountedFluidStorageWrapper} from "com.simibubi.create.api.contraption.storage.fluid.MountedFluidStorageWrapper"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$IContraptionFuel$$Interface} from "com.railwayteam.railways.mixin_interfaces.IContraptionFuel"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$CollisionList} from "com.simibubi.create.foundation.collision.CollisionList"
import {$Object2BooleanMap} from "it.unimi.dsi.fastutil.objects.Object2BooleanMap"
import {$MountedStorageManager} from "com.simibubi.create.content.contraptions.MountedStorageManager"
import {$StructureTemplate$StructureBlockInfo} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClientContraption} from "com.simibubi.create.content.contraptions.render.ClientContraption"
import {$MovementBehaviour$$Type} from "com.simibubi.create.api.behaviour.movement.MovementBehaviour"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$AccessorContraption$$Interface} from "com.railwayteam.railways.mixin.AccessorContraption"
import {$Map, $Map$$Type} from "java.util.Map"
import {$MovingInteractionBehaviour} from "com.simibubi.create.api.behaviour.interaction.MovingInteractionBehaviour"
import {$MutablePair} from "org.apache.commons.lang3.tuple.MutablePair"
import {$MovementContext, $MovementContext$$Type} from "com.simibubi.create.content.contraptions.behaviour.MovementContext"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AbstractContraptionEntity, $AbstractContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$ContraptionMixin$$Interface} from "com.starfish_studios.another_furniture.mixin.neoforge.create.ContraptionMixin"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB} from "net.minecraft.world.phys.AABB"
import {$ContraptionType} from "com.simibubi.create.api.contraption.ContraptionType"

export class $Contraption implements $AccessorContraption$$Interface, $IContraptionFuel$$Interface, $ContraptionMixin$$Interface {
 "hasUniversalCreativeCrate": boolean
 "isLegacy": $Object2BooleanMap<($BlockPos)>
 "anchor": $BlockPos
 "stalled": boolean
 "bounds": $AABB
readonly "simplifiedEntityColliders": $CollisionList
 "disassembled": boolean
 "entity": $AbstractContraptionEntity

constructor()

public "searchMovedStructure"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "removeBlocksFromWorld"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "writeStorage"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "forEachActor"(arg0: $Level$$Type, arg1: $BiConsumer$$Type<($MovementBehaviour), ($MovementContext)>): void
public "expandBoundsAroundAxis"(arg0: $Direction$Axis$$Type): void
public "setSeatMapping"(arg0: $Map$$Type<($UUID$$Type), (integer)>): void
public "getIsLegacy"(): $Object2BooleanMap<($BlockPos)>
public "getInteractors"(): $Map<($BlockPos), ($MovingInteractionBehaviour)>
public "isHiddenInPortal"(arg0: $BlockPos$$Type): boolean
public "getSimplifiedEntityColliders"(): $CollisionList
public "containsBlockBreakers"(): boolean
public "invalidateClientContraptionStructure"(): void
public "getStorage"(): $MountedStorageManager
public "assemble"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public static "getRadius"(arg0: $Iterable$$Type<($Vec3i$$Type)>, arg1: $Direction$Axis$$Type): double
public "writeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: boolean): $CompoundTag
public "readNBT"(arg0: $Level$$Type, arg1: $CompoundTag$$Type, arg2: boolean): void
public static "fromNBT"(arg0: $Level$$Type, arg1: $CompoundTag$$Type, arg2: boolean): $Contraption
public "getActors"(): $List<($MutablePair<($StructureTemplate$StructureBlockInfo), ($MovementContext)>)>
public "startMoving"(arg0: $Level$$Type): void
public "invalidateClientContraptionChildren"(): void
public "getSeats"(): $List<($BlockPos)>
public "getActorAt"(arg0: $BlockPos$$Type): $MutablePair<($StructureTemplate$StructureBlockInfo), ($MovementContext)>
public "getBlockEntityClientSide"(arg0: $BlockPos$$Type): $BlockEntity
public "getDisabledActors"(): $List<($ItemStack)>
public "isActorTypeDisabled"(arg0: $ItemStack$$Type): boolean
public "setActorsActive"(arg0: $ItemStack$$Type, arg1: boolean): void
public "canBeStabilized"(arg0: $Direction$$Type, arg1: $BlockPos$$Type): boolean
public "getContraptionWorld"(): $ContraptionWorld
public "getOrCreateClientContraptionLazy"(): $ClientContraption
public "railways$getEntity"(): $AbstractContraptionEntity
public "railways$getFluidFuels"(): $MountedFluidStorageWrapper
public "getInitialPassengers"(): $Map
public "setInitialPassengers"(arg0: $Map$$Type): void
public "onEntityCreated"(arg0: $AbstractContraptionEntity$$Type): void
public "onEntityInitialize"(arg0: $Level$$Type, arg1: $AbstractContraptionEntity$$Type): void
public "getSeatOf"(arg0: $UUID$$Type): $BlockPos
public "getSeatMapping"(): $Map<($UUID), (integer)>
public "getBearingPosOf"(arg0: $UUID$$Type): $BlockPos
public "tickStorage"(arg0: $AbstractContraptionEntity$$Type): void
public "addBlocksToWorld"(arg0: $Level$$Type, arg1: $StructureTransform$$Type): void
public "addPassengersToWorld"(arg0: $Level$$Type, arg1: $StructureTransform$$Type, arg2: $List$$Type<($Entity$$Type)>): void
public "resetClientContraption"(): void
public "invalidateColliders"(): void
public "stop"(arg0: $Level$$Type): void
public "getType"(): $ContraptionType
public "getBlocks"(): $Map<($BlockPos), ($StructureTemplate$StructureBlockInfo)>
set "seatMapping"(value: $Map$$Type<($UUID$$Type), (integer)>)
get "interactors"(): $Map<($BlockPos), ($MovingInteractionBehaviour)>
get "storage"(): $MountedStorageManager
get "actors"(): $List<($MutablePair<($StructureTemplate$StructureBlockInfo), ($MovementContext)>)>
get "seats"(): $List<($BlockPos)>
get "disabledActors"(): $List<($ItemStack)>
get "contraptionWorld"(): $ContraptionWorld
get "orCreateClientContraptionLazy"(): $ClientContraption
get "initialPassengers"(): $Map
set "initialPassengers"(value: $Map$$Type)
get "seatMapping"(): $Map<($UUID), (integer)>
get "type"(): $ContraptionType
get "blocks"(): $Map<($BlockPos), ($StructureTemplate$StructureBlockInfo)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Contraption$$Type = ($Contraption);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Contraption$$Original = $Contraption;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.attributes.EnchantAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $EnchantAttribute$Type implements $ItemAttributeType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantAttribute$Type$$Type = ($EnchantAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnchantAttribute$Type$$Original = $EnchantAttribute$Type;}
declare module "com.simibubi.create.content.decoration.palettes.ConnectedGlassPaneBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$GlassPaneBlock} from "com.simibubi.create.content.decoration.palettes.GlassPaneBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Map} from "java.util.Map"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IronBarsBlock} from "net.minecraft.world.level.block.IronBarsBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ConnectedGlassPaneBlock extends $GlassPaneBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($IronBarsBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($BooleanProperty)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "SOUTH": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "EAST": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "skipRendering"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectedGlassPaneBlock$$Type = ($ConnectedGlassPaneBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConnectedGlassPaneBlock$$Original = $ConnectedGlassPaneBlock;}
declare module "com.simibubi.create.content.contraptions.actors.plough.PloughBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$AttachedActorBlock} from "com.simibubi.create.content.contraptions.actors.AttachedActorBlock"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PloughBlock extends $AttachedActorBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PloughBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PloughBlock$$Type = ($PloughBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PloughBlock$$Original = $PloughBlock;}
declare module "com.simibubi.create.content.trains.station.StationMarker" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Optional$$Type} from "java.util.Optional"
import {$MapDecoration} from "net.minecraft.world.level.saveddata.maps.MapDecoration"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $StationMarker {
constructor(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type, arg2: $Component$$Type)

public static "fromWorld"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $StationMarker
public static "createStationDecoration"(arg0: byte, arg1: byte, arg2: ($Component$$Type)?): $MapDecoration
public "getSource"(): $BlockPos
public "getName"(): $Component
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "load"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $StationMarker
public "getId"(): StringJS
public "save"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getTarget"(): $BlockPos
get "source"(): $BlockPos
get "name"(): $Component
get "id"(): StringJS
get "target"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StationMarker$$Type = ($StationMarker);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StationMarker$$Original = $StationMarker;}
declare module "com.simibubi.create.content.equipment.zapper.terrainzapper.PlacementOptions" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$AllIcons} from "com.simibubi.create.foundation.gui.AllIcons"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $PlacementOptions extends $Enum<($PlacementOptions)> implements $StringRepresentable$$Interface {
static readonly "Attached": $PlacementOptions
static readonly "CODEC": $Codec<($PlacementOptions)>
readonly "translationKey": StringJS
static readonly "Merged": $PlacementOptions
readonly "icon": $AllIcons
static readonly "Inserted": $PlacementOptions
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($PlacementOptions)>

public static "values"(): ($PlacementOptions)[]
public static "valueOf"(arg0: StringJS): $PlacementOptions
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacementOptions$$Type = (("merged") | ("attached") | ("inserted"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacementOptions$$Original = $PlacementOptions;}
declare module "com.simibubi.create.content.processing.recipe.ProcessingRecipe" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeType} from "net.minecraft.world.item.crafting.RecipeType"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ProcessingRecipe$Factory$$Type} from "com.simibubi.create.content.processing.recipe.ProcessingRecipe$Factory"
import {$ProcessingOutput, $ProcessingOutput$$Type} from "com.simibubi.create.content.processing.recipe.ProcessingOutput"
import {$SizedFluidIngredient} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack} from "net.neoforged.neoforge.fluids.FluidStack"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IRecipeTypeInfo, $IRecipeTypeInfo$$Type} from "com.simibubi.create.foundation.recipe.IRecipeTypeInfo"
import {$HeatCondition} from "com.simibubi.create.content.processing.recipe.HeatCondition"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Recipe$$Interface} from "net.minecraft.world.item.crafting.Recipe"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ProcessingRecipeParams, $ProcessingRecipeParams$$Type} from "com.simibubi.create.content.processing.recipe.ProcessingRecipeParams"

export class $ProcessingRecipe<I extends $RecipeInput, P extends $ProcessingRecipeParams> implements $Recipe$$Interface<(I)> {
constructor(arg0: $IRecipeTypeInfo$$Type, arg1: P)

public "getRollableResults"(): $List<($ProcessingOutput)>
public "rollResults"(arg0: $RandomSource$$Type): $List<($ItemStack)>
public "rollResults"(arg0: $List$$Type<($ProcessingOutput$$Type)>, arg1: $RandomSource$$Type): $List<($ItemStack)>
public "getFluidIngredients"(): $NonNullList<($SizedFluidIngredient)>
public "getFluidResults"(): $NonNullList<($FluidStack)>
public "getProcessingDuration"(): integer
public "getRequiredHeat"(): $HeatCondition
public "getRollableResultsAsItemStacks"(): $List<($ItemStack)>
public static "streamCodec"<P extends $ProcessingRecipeParams, R extends $ProcessingRecipe<(object), (object)>>(arg0: $ProcessingRecipe$Factory$$Type<(P), (R)>, arg1: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (P)>): $StreamCodec<($RegistryFriendlyByteBuf), (R)>
public "assemble"(arg0: I, arg1: $HolderLookup$Provider$$Type): $ItemStack
public "getSerializer"(): $RecipeSerializer<(never)>
public "enforceNextResult"(arg0: $Supplier$$Type<($ItemStack$$Type)>): void
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
public "getResultItem"(arg0: $HolderLookup$Provider$$Type): $ItemStack
public "getIngredients"(): $NonNullList<($Ingredient)>
public "getTypeInfo"(): $IRecipeTypeInfo
public "validate"(): $List<(StringJS)>
public "getType"(): $RecipeType<(never)>
public static "codec"<P extends $ProcessingRecipeParams, R extends $ProcessingRecipe<(object), (object)>>(arg0: $ProcessingRecipe$Factory$$Type<(P), (R)>, arg1: $MapCodec$$Type<(P)>): $MapCodec<(R)>
public "getParams"(): P
public "getGroup"(): StringJS
public "isSpecial"(): boolean
public "getRemainingItems"(arg0: I): $NonNullList<($ItemStack)>
public "showNotification"(): boolean
public "getToastSymbol"(): $ItemStack
public "isIncomplete"(): boolean
public "matches"(arg0: I, arg1: $Level$$Type): boolean
get "rollableResults"(): $List<($ProcessingOutput)>
get "fluidIngredients"(): $NonNullList<($SizedFluidIngredient)>
get "fluidResults"(): $NonNullList<($FluidStack)>
get "processingDuration"(): integer
get "requiredHeat"(): $HeatCondition
get "rollableResultsAsItemStacks"(): $List<($ItemStack)>
get "serializer"(): $RecipeSerializer<(never)>
get "ingredients"(): $NonNullList<($Ingredient)>
get "typeInfo"(): $IRecipeTypeInfo
get "type"(): $RecipeType<(never)>
get "params"(): P
get "group"(): StringJS
get "special"(): boolean
get "toastSymbol"(): $ItemStack
get "incomplete"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProcessingRecipe$$Type<I, P> = ($ProcessingRecipe<(I), (P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProcessingRecipe$$Original<I, P> = $ProcessingRecipe<(I), (P)>;}
declare module "com.simibubi.create.content.decoration.placard.PlacardBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PlacardBlockEntity extends $SmartBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "setHeldItem"(arg0: $ItemStack$$Type): void
public "getHeldItem"(): $ItemStack
public "tick"(): void
set "heldItem"(value: $ItemStack$$Type)
get "heldItem"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacardBlockEntity$$Type = ($PlacardBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacardBlockEntity$$Original = $PlacardBlockEntity;}
declare module "com.simibubi.create.content.trains.bogey.StandardBogeyBlock" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$AbstractBogeyBlock} from "com.simibubi.create.content.trains.bogey.AbstractBogeyBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$BogeySizes$BogeySize, $BogeySizes$BogeySize$$Type} from "com.simibubi.create.content.trains.bogey.BogeySizes$BogeySize"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$TrackMaterial$TrackType} from "com.simibubi.create.content.trains.track.TrackMaterial$TrackType"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$StandardBogeyBlockEntity} from "com.simibubi.create.content.trains.bogey.StandardBogeyBlockEntity"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BogeyStyle, $BogeyStyle$$Type} from "com.simibubi.create.content.trains.bogey.BogeyStyle"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $StandardBogeyBlock extends $AbstractBogeyBlock<($StandardBogeyBlockEntity)> implements $IBE$$Interface<($StandardBogeyBlockEntity)>, $ProperWaterloggedBlock$$Interface, $SpecialBlockItemRequirement$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($AbstractBogeyBlock<(never)>)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
 "size": $BogeySizes$BogeySize
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $BogeySizes$BogeySize$$Type)

public "getBlockEntityType"(): $BlockEntityType<($StandardBogeyBlockEntity)>
public "getBlockEntityClass"(): $Class<($StandardBogeyBlockEntity)>
public "getTrackType"(arg0: $BogeyStyle$$Type): $TrackMaterial$TrackType
public "getWheelPointSpacing"(): double
public "getWheelRadius"(): double
public "getConnectorAnchorOffset"(): $Vec3
public "getDefaultStyle"(): $BogeyStyle
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($StandardBogeyBlockEntity)>
get "blockEntityClass"(): $Class<($StandardBogeyBlockEntity)>
get "wheelPointSpacing"(): double
get "wheelRadius"(): double
get "connectorAnchorOffset"(): $Vec3
get "defaultStyle"(): $BogeyStyle
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StandardBogeyBlock$$Type = ($StandardBogeyBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StandardBogeyBlock$$Original = $StandardBogeyBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.CurrentFloorDisplaySource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $CurrentFloorDisplaySource extends $SingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CurrentFloorDisplaySource$$Type = ($CurrentFloorDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CurrentFloorDisplaySource$$Original = $CurrentFloorDisplaySource;}
declare module "com.simibubi.create.content.logistics.packager.PackagerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$PackagerBlockEntity, $PackagerBlockEntity$$Type} from "com.simibubi.create.content.logistics.packager.PackagerBlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $PackagerBlock extends $WrenchableDirectionalBlock implements $IBE$$Interface<($PackagerBlockEntity)>, $IWrenchable$$Interface {
static readonly "LINKED": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($PackagerBlockEntity)>
public "getBlockEntityClass"(): $Class<($PackagerBlockEntity)>
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "onNeighborChange"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type): void
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($PackagerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($PackagerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PackagerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PackagerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $PackagerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($PackagerBlockEntity)>
get "blockEntityClass"(): $Class<($PackagerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagerBlock$$Type = ($PackagerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagerBlock$$Original = $PackagerBlock;}
declare module "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType$AirFlowParticleAccess" {
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export interface $FanProcessingType$AirFlowParticleAccess$$Interface {
set "color"(value: integer)
set "alpha"(value: float)
}

export class $FanProcessingType$AirFlowParticleAccess implements $FanProcessingType$AirFlowParticleAccess$$Interface {
 "spawnExtraParticle"(arg0: $ParticleOptions$$Type, arg1: float): void
 "setColor"(arg0: integer): void
 "setAlpha"(arg0: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FanProcessingType$AirFlowParticleAccess$$Type = ($FanProcessingType$AirFlowParticleAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FanProcessingType$AirFlowParticleAccess$$Original = $FanProcessingType$AirFlowParticleAccess;}
declare module "com.simibubi.create.content.equipment.bell.HauntedBellBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$HauntedBellBlockEntity} from "com.simibubi.create.content.equipment.bell.HauntedBellBlockEntity"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BellBlock} from "net.minecraft.world.level.block.BellBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BellAttachType} from "net.minecraft.world.level.block.state.properties.BellAttachType"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$AbstractBellBlock} from "com.simibubi.create.content.equipment.bell.AbstractBellBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Class} from "java.lang.Class"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HauntedBellBlock extends $AbstractBellBlock<($HauntedBellBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "ATTACHMENT": $EnumProperty<($BellAttachType)>
 "item": $Item
static readonly "CODEC": $MapCodec<($BellBlock)>
static readonly "EVENT_BELL_RING": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getBlockEntityType"(): $BlockEntityType<($HauntedBellBlockEntity)>
public "getBlockEntityClass"(): $Class<($HauntedBellBlockEntity)>
public "playSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($HauntedBellBlockEntity)>
get "blockEntityClass"(): $Class<($HauntedBellBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HauntedBellBlock$$Type = ($HauntedBellBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HauntedBellBlock$$Original = $HauntedBellBlock;}
declare module "com.simibubi.create.content.trains.schedule.IScheduleInput" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$GuiGraphics$$Type} from "net.minecraft.client.gui.GuiGraphics"
import {$List} from "java.util.List"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$Component} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export interface $IScheduleInput$$Interface {
get "secondLineIcon"(): $ItemStack
get "data"(): $CompoundTag
get "id"(): $ResourceLocation
get "summary"(): $Pair<($ItemStack), ($Component)>
}

export class $IScheduleInput implements $IScheduleInput$$Interface {
 "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
 "initConfigurationWidgets"(arg0: $ModularGuiLineBuilder$$Type): void
 "slotsTargeted"(): integer
 "getTitleAs"(arg0: StringJS): $List<($Component)>
 "getSecondLineIcon"(): $ItemStack
 "getSecondLineTooltip"(arg0: integer): $List<($Component)>
 "renderSpecialIcon"(arg0: $GuiGraphics$$Type, arg1: integer, arg2: integer): boolean
 "setData"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
 "getItem"(arg0: integer): $ItemStack
 "getData"(): $CompoundTag
 "getId"(): $ResourceLocation
 "getSummary"(): $Pair<($ItemStack), ($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IScheduleInput$$Type = ($IScheduleInput);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IScheduleInput$$Original = $IScheduleInput;}
declare module "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelSupportBehaviour" {
import {$SmartBlockEntity, $SmartBlockEntity$$Type} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$FactoryPanelBehaviour$$Type} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBehaviour"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$List} from "java.util.List"
import {$BlockEntityBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BehaviourType} from "com.simibubi.create.foundation.blockEntity.behaviour.BehaviourType"
import {$Runnable$$Type} from "java.lang.Runnable"
import {$FactoryPanelPosition} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelPosition"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $FactoryPanelSupportBehaviour extends $BlockEntityBehaviour {
 "blockEntity": $SmartBlockEntity
static readonly "TYPE": $BehaviourType<($FactoryPanelSupportBehaviour)>

constructor(arg0: $SmartBlockEntity$$Type, arg1: $Supplier$$Type<(boolean)>, arg2: $Supplier$$Type<(boolean)>, arg3: $Runnable$$Type)

public "notifyPanels"(): void
public "isOutput"(): boolean
public "getLinkedPanels"(): $List<($FactoryPanelPosition)>
public "shouldBePoweredTristate"(): boolean
public "notifyLink"(): void
public "shouldPanelBePowered"(): boolean
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "connect"(arg0: $FactoryPanelBehaviour$$Type): void
public "destroy"(): void
public "getType"(): $BehaviourType<(never)>
public "disconnect"(arg0: $FactoryPanelBehaviour$$Type): void
get "output"(): boolean
get "linkedPanels"(): $List<($FactoryPanelPosition)>
get "type"(): $BehaviourType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryPanelSupportBehaviour$$Type = ($FactoryPanelSupportBehaviour);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FactoryPanelSupportBehaviour$$Original = $FactoryPanelSupportBehaviour;}
declare module "com.simibubi.create.content.trains.graph.TrackGraphLocation" {
import {$TrackNodeLocation} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$TrackGraph} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$Couple} from "net.createmod.catnip.data.Couple"

export class $TrackGraphLocation {
 "edge": $Couple<($TrackNodeLocation)>
 "position": double
 "graph": $TrackGraph

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackGraphLocation$$Type = ($TrackGraphLocation);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackGraphLocation$$Original = $TrackGraphLocation;}
declare module "com.simibubi.create.content.logistics.crate.CreativeCrateMountedStorageType" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CreativeCrateMountedStorage} from "com.simibubi.create.content.logistics.crate.CreativeCrateMountedStorage"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MountedItemStorageType} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageType"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CreativeCrateMountedStorageType extends $MountedItemStorageType<($CreativeCrateMountedStorage)> {
readonly "codec": $MapCodec<(T)>
static readonly "CODEC": $Codec<($MountedItemStorageType<(never)>)>
readonly "holder": $Holder$Reference<($MountedItemStorageType<(never)>)>
static readonly "REGISTRY": $SimpleRegistry<($Block), ($MountedItemStorageType<(never)>)>

constructor()

public "mount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): $CreativeCrateMountedStorage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeCrateMountedStorageType$$Type = ($CreativeCrateMountedStorageType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeCrateMountedStorageType$$Original = $CreativeCrateMountedStorageType;}
declare module "com.simibubi.create.content.trains.observer.TrackObserver" {
import {$FilterItemStack} from "com.simibubi.create.content.logistics.filter.FilterItemStack"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$UUID} from "java.util.UUID"
import {$Train$$Type} from "com.simibubi.create.content.trains.entity.Train"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$TrackNodeLocation} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$SingleBlockEntityEdgePoint} from "com.simibubi.create.content.trains.signal.SingleBlockEntityEdgePoint"
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $TrackObserver extends $SingleBlockEntityEdgePoint {
 "edgeLocation": $Couple<($TrackNodeLocation)>
 "blockEntityPos": $BlockPos
 "blockEntityDimension": $ResourceKey<($Level)>
 "id": $UUID
 "position": double

constructor()

public "getCurrentTrain"(): $UUID
public "blockEntityAdded"(arg0: $BlockEntity$$Type, arg1: boolean): void
public "setFilterAndNotify"(arg0: $Level$$Type, arg1: $ItemStack$$Type): void
public "isActivated"(): boolean
public "tick"(arg0: $TrackGraph$$Type, arg1: boolean): void
public "keepAlive"(arg0: $Train$$Type): void
public "getFilter"(): $FilterItemStack
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $DimensionPalette$$Type): void
public "write"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): void
public "read"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean, arg3: $DimensionPalette$$Type): void
get "currentTrain"(): $UUID
get "activated"(): boolean
get "filter"(): $FilterItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackObserver$$Type = ($TrackObserver);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackObserver$$Original = $TrackObserver;}
declare module "com.simibubi.create.content.logistics.packagePort.PackagePortTarget$ChainConveyorFrogportTarget" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$PackagePortBlockEntity$$Type} from "com.simibubi.create.content.logistics.packagePort.PackagePortBlockEntity"
import {$Optional$$Type} from "java.util.Optional"
import {$PackagePortTarget} from "com.simibubi.create.content.logistics.packagePort.PackagePortTarget"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $PackagePortTarget$ChainConveyorFrogportTarget extends $PackagePortTarget {
 "flipped": boolean
static readonly "CODEC": $MapCodec<($PackagePortTarget$ChainConveyorFrogportTarget)>
 "relativePos": $BlockPos
 "connection": $BlockPos
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($PackagePortTarget$ChainConveyorFrogportTarget)>
 "chainPos": float

constructor(arg0: $BlockPos$$Type, arg1: float, arg2: ($BlockPos$$Type)?, arg3: boolean)
constructor(arg0: $BlockPos$$Type, arg1: float, arg2: $BlockPos$$Type, arg3: boolean)

public "getExactTargetLocation"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): $Vec3
public "deregister"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): void
public "register"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): void
public "setup"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): void
public "getIcon"(): $ItemStack
public "export"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type, arg3: boolean): boolean
public "canSupport"(arg0: $BlockEntity$$Type): boolean
get "icon"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagePortTarget$ChainConveyorFrogportTarget$$Type = ($PackagePortTarget$ChainConveyorFrogportTarget);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagePortTarget$ChainConveyorFrogportTarget$$Original = $PackagePortTarget$ChainConveyorFrogportTarget;}
declare module "com.simibubi.create.content.logistics.vault.ItemVaultBlockEntity" {
import {$IMultiBlockEntityContainer$Inventory$$Interface} from "com.simibubi.create.foundation.blockEntity.IMultiBlockEntityContainer$Inventory"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$InventoryIdentifier} from "com.simibubi.create.api.packager.InventoryIdentifier"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$Direction$Axis, $Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$ItemStackHandler, $ItemStackHandler$$Type} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $ItemVaultBlockEntity extends $SmartBlockEntity implements $IMultiBlockEntityContainer$Inventory$$Interface, $Clearable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getMaxWidth"(): integer
public "getController"(): $BlockPos
public "setController"(arg0: $BlockPos$$Type): void
public "getControllerBE"(): $ItemVaultBlockEntity
public "isController"(): boolean
public "removeController"(arg0: boolean): void
public "applyInventoryToBlock"(arg0: $ItemStackHandler$$Type): void
public "getInventoryOfBlock"(): $ItemStackHandler
public "notifyMultiUpdated"(): void
public "getInvId"(): $InventoryIdentifier
public "getMainConnectionAxis"(): $Direction$Axis
public "getLastKnownPos"(): $BlockPos
public "preventConnectivityUpdate"(): void
public "hasInventory"(): boolean
public "tick"(): void
public "getWidth"(): integer
public "getHeight"(): integer
public "getMaxLength"(arg0: $Direction$Axis$$Type, arg1: integer): integer
public static "getMaxLength"(arg0: integer): integer
public "setWidth"(arg0: integer): void
public "setHeight"(arg0: integer): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
public "getMainAxisOf"(arg0: $BlockEntity$$Type): $Direction$Axis
public "setExtraData"(arg0: any): void
public "modifyExtraData"(arg0: any): any
public "getExtraData"(): any
get "maxWidth"(): integer
get "controller"(): $BlockPos
set "controller"(value: $BlockPos$$Type)
get "controllerBE"(): $ItemVaultBlockEntity
get "controller"(): boolean
get "inventoryOfBlock"(): $ItemStackHandler
get "invId"(): $InventoryIdentifier
get "mainConnectionAxis"(): $Direction$Axis
get "lastKnownPos"(): $BlockPos
get "width"(): integer
get "height"(): integer
set "width"(value: integer)
set "height"(value: integer)
set "extraData"(value: any)
get "extraData"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemVaultBlockEntity$$Type = ($ItemVaultBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemVaultBlockEntity$$Original = $ItemVaultBlockEntity;}
declare module "com.simibubi.create.content.contraptions.actors.roller.RollerBlockItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $RollerBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "place"(arg0: $BlockPlaceContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RollerBlockItem$$Type = ($RollerBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RollerBlockItem$$Original = $RollerBlockItem;}
declare module "com.simibubi.create.content.equipment.symmetryWand.mirror.SymmetryMirror" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Map, $Map$$Type} from "java.util.Map"
import {$PartialModel} from "dev.engine_room.flywheel.lib.model.baked.PartialModel"
import {$List} from "java.util.List"
import {$PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$StringRepresentable} from "net.minecraft.util.StringRepresentable"
import {$Component} from "net.minecraft.network.chat.Component"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SymmetryMirror {
static readonly "CROSS_PLANE": StringJS
static readonly "CODEC": $Codec<($SymmetryMirror)>
static readonly "TRIPLE_PLANE": StringJS
static readonly "PLANE": StringJS
 "enable": boolean
static readonly "EMPTY": StringJS
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($SymmetryMirror)>

constructor(arg0: $Vec3$$Type)

public static "getMirrors"(): $List<($Component)>
public "getAlignToolTips"(): $List<($Component)>
public "setOrientation"(arg0: integer): void
public "getOrientationIndex"(): integer
public "getOrientation"(): $StringRepresentable
public "applyModelTransform"(arg0: $PoseStack$$Type): void
public "process"(arg0: $Map$$Type<($BlockPos$$Type), ($BlockState$$Type)>): void
public "process"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $Map<($BlockPos), ($BlockState)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "typeName"(): StringJS
public "rotate"(arg0: boolean): void
public "getPosition"(): $Vec3
public "getModel"(): $PartialModel
public "setPosition"(arg0: $Vec3$$Type): void
public static get "mirrors"(): $List<($Component)>
get "alignToolTips"(): $List<($Component)>
set "orientation"(value: integer)
get "orientationIndex"(): integer
get "orientation"(): $StringRepresentable
get "position"(): $Vec3
get "model"(): $PartialModel
set "position"(value: $Vec3$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SymmetryMirror$$Type = ($SymmetryMirror);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SymmetryMirror$$Original = $SymmetryMirror;}
declare module "com.simibubi.create.content.processing.basin.BasinInventory" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$SmartInventory} from "com.simibubi.create.foundation.item.SmartInventory"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container} from "net.minecraft.world.Container"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$BasinBlockEntity$$Type} from "com.simibubi.create.content.processing.basin.BasinBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$IItemHandler} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $BasinInventory extends $SmartInventory {
 "packagerMode": boolean

constructor(arg0: integer, arg1: $BasinBlockEntity$$Type)

public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
public "self"(): $IItemHandler
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getBlock"(level: $Level$$Type): $LevelBlock
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "clear"(): void
public "getWidth"(): integer
public "getHeight"(): integer
public "setChanged"(): void
public "asContainer"(): $Container
public static "tryClear"(arg0: any): void
get "mutable"(): boolean
get "slots"(): integer
get "width"(): integer
get "height"(): integer
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasinInventory$$Type = ($BasinInventory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasinInventory$$Original = $BasinInventory;}
declare module "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBlockItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $LogisticallyLinkedBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "isFoil"(arg0: $ItemStack$$Type): boolean
public static "isTuned"(arg0: $ItemStack$$Type): boolean
public static "assignFrequency"(arg0: $ItemStack$$Type, arg1: $Player$$Type, arg2: $UUID$$Type): void
public static "networkFromStack"(arg0: $ItemStack$$Type): $UUID
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogisticallyLinkedBlockItem$$Type = ($LogisticallyLinkedBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LogisticallyLinkedBlockItem$$Original = $LogisticallyLinkedBlockItem;}
declare module "com.simibubi.create.content.redstone.nixieTube.NixieTubeBlockEntity$ComputerSignal$TubeDisplay" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $NixieTubeBlockEntity$ComputerSignal$TubeDisplay {
 "blinkOffTime": byte
 "r": byte
 "b": byte
 "blinkPeriod": byte
 "glowHeight": byte
 "g": byte
static readonly "ENCODED_SIZE": integer
 "glowWidth": byte

constructor()

public "decode"(arg0: (byte)[], arg1: integer): void
public "encode"(arg0: (byte)[], arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NixieTubeBlockEntity$ComputerSignal$TubeDisplay$$Type = ($NixieTubeBlockEntity$ComputerSignal$TubeDisplay);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NixieTubeBlockEntity$ComputerSignal$TubeDisplay$$Original = $NixieTubeBlockEntity$ComputerSignal$TubeDisplay;}
declare module "com.simibubi.create.content.kinetics.motor.CreativeMotorBlockEntity" {
import {$GeneratingKineticBlockEntity} from "com.simibubi.create.content.kinetics.base.GeneratingKineticBlockEntity"
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ScrollValueBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.scrollValue.ScrollValueBehaviour"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $CreativeMotorBlockEntity extends $GeneratingKineticBlockEntity {
 "generatedSpeed": $ScrollValueBehaviour
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
static readonly "MAX_SPEED": integer
static readonly "DEFAULT_SPEED": integer
 "updateSpeed": boolean
 "reActivateSource": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "computerBehaviour": $AbstractComputerBehaviour
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getGeneratedSpeed"(): float
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "initialize"(): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeMotorBlockEntity$$Type = ($CreativeMotorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeMotorBlockEntity$$Original = $CreativeMotorBlockEntity;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.attributes.FluidContentsAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $FluidContentsAttribute$Type implements $ItemAttributeType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidContentsAttribute$Type$$Type = ($FluidContentsAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidContentsAttribute$Type$$Original = $FluidContentsAttribute$Type;}
declare module "com.simibubi.create.content.trains.signal.TrackEdgePoint" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$EdgePointType, $EdgePointType$$Type} from "com.simibubi.create.content.trains.graph.EdgePointType"
import {$TrackEdge$$Type} from "com.simibubi.create.content.trains.graph.TrackEdge"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$TrackNodeLocation, $TrackNodeLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$Couple, $Couple$$Type} from "net.createmod.catnip.data.Couple"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $TrackEdgePoint {
 "edgeLocation": $Couple<($TrackNodeLocation)>
 "id": $UUID
 "position": double

constructor()

public "canMerge"(): boolean
public "onRemoved"(arg0: $TrackGraph$$Type): void
public "isPrimary"(arg0: $TrackNode$$Type): boolean
public "getLocationOn"(arg0: $TrackEdge$$Type): double
public "canCoexistWith"(arg0: $EdgePointType$$Type<(never)>, arg1: boolean): boolean
public "blockEntityAdded"(arg0: $BlockEntity$$Type, arg1: boolean): void
public "blockEntityRemoved"(arg0: $BlockPos$$Type, arg1: boolean): void
public "canNavigateVia"(arg0: $TrackNode$$Type): boolean
public "handler$fbi000$create_power_loader$cpl$tick"(arg0: $TrackGraph$$Type, arg1: boolean, arg2: $CallbackInfo$$Type): void
public "handler$fbi000$create_power_loader$cpl$remove"(arg0: $CallbackInfo$$Type): void
public "tick"(arg0: $TrackGraph$$Type, arg1: boolean): void
public "setType"(arg0: $EdgePointType$$Type<(never)>): void
public "write"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $DimensionPalette$$Type): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean, arg3: $DimensionPalette$$Type): void
public "read"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): void
public "getId"(): $UUID
public "getType"(): $EdgePointType<(never)>
public "invalidate"(arg0: $LevelAccessor$$Type): void
public "setLocation"(arg0: $Couple$$Type<($TrackNodeLocation$$Type)>, arg1: double): void
public "setId"(arg0: $UUID$$Type): void
set "type"(value: $EdgePointType$$Type<(never)>)
get "type"(): $EdgePointType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackEdgePoint$$Type = ($TrackEdgePoint);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackEdgePoint$$Original = $TrackEdgePoint;}
declare module "com.simibubi.create.content.trains.entity.TrainStatus$StatusMessage" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Record} from "java.lang.Record"

export class $TrainStatus$StatusMessage extends $Record {
constructor(...messages: ($Component$$Type)[])

public "displayToPlayer"(arg0: $Player$$Type): void
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "messages"(): ($Component)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrainStatus$StatusMessage$$Type = ({"messages"?: ($Component$$Type)[]}) | ([messages?: ($Component$$Type)[]]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrainStatus$StatusMessage$$Original = $TrainStatus$StatusMessage;}
declare module "com.simibubi.create.content.contraptions.render.ClientContraption$RenderedBlocks" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ClientContraption$RenderedBlocks extends $Record {
constructor(lookup: $Function$$Type<($BlockPos), ($BlockState$$Type)>, positions: $Iterable$$Type<($BlockPos$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "lookup"(): $Function<($BlockPos), ($BlockState)>
public "positions"(): $Iterable<($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientContraption$RenderedBlocks$$Type = ({"lookup"?: $Function$$Type<($BlockPos$$Type), ($BlockState$$Type)>, "positions"?: $Iterable$$Type<($BlockPos$$Type)>}) | ([lookup?: $Function$$Type<($BlockPos$$Type), ($BlockState$$Type)>, positions?: $Iterable$$Type<($BlockPos$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientContraption$RenderedBlocks$$Original = $ClientContraption$RenderedBlocks;}
declare module "com.simibubi.create.content.trains.graph.TrackGraphBounds" {
import {$BezierConnection} from "com.simibubi.create.content.trains.track.BezierConnection"
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $TrackGraphBounds {
 "beziers": $List<($BezierConnection)>
 "box": $AABB

constructor(arg0: $TrackGraph$$Type, arg1: $ResourceKey$$Type<($Level)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackGraphBounds$$Type = ($TrackGraphBounds);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackGraphBounds$$Original = $TrackGraphBounds;}
declare module "com.simibubi.create.content.trains.track.TrackBlockItem" {
import {$PlayerInteractEvent$RightClickBlock$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$RightClickBlock"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $TrackBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "isFoil"(arg0: $ItemStack$$Type): boolean
public "getPlacementState"(arg0: $UseOnContext$$Type): $BlockState
public static "clearSelection"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $Player$$Type): $InteractionResultHolder<($ItemStack)>
public static "sendExtenderPacket"(arg0: $PlayerInteractEvent$RightClickBlock$$Type): void
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "select"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Vec3$$Type, arg3: $ItemStack$$Type): boolean
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackBlockItem$$Type = ($TrackBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackBlockItem$$Original = $TrackBlockItem;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$CrushingWheelsType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$CrushingWheelsType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$CrushingWheelsType$$Type = ($AllArmInteractionPointTypes$CrushingWheelsType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$CrushingWheelsType$$Original = $AllArmInteractionPointTypes$CrushingWheelsType;}
declare module "com.simibubi.create.content.fluids.tank.CreativeFluidTankBlockEntity$CreativeSmartFluidTank" {
import {$IFluidHandler$FluidAction$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler$FluidAction"
import {$Codec} from "com.mojang.serialization.Codec"
import {$SmartFluidTank} from "com.simibubi.create.foundation.fluid.SmartFluidTank"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $CreativeFluidTankBlockEntity$CreativeSmartFluidTank extends $SmartFluidTank {
static readonly "CODEC": $Codec<($CreativeFluidTankBlockEntity$CreativeSmartFluidTank)>

constructor(arg0: integer, arg1: $Consumer$$Type<($FluidStack)>)

public "getFluidAmount"(): integer
public "setContainedFluid"(arg0: $FluidStack$$Type): void
public "fill"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): integer
public "drain"(arg0: integer, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
public "drain"(arg0: $FluidStack$$Type, arg1: $IFluidHandler$FluidAction$$Type): $FluidStack
get "fluidAmount"(): integer
set "containedFluid"(value: $FluidStack$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeFluidTankBlockEntity$CreativeSmartFluidTank$$Type = ($CreativeFluidTankBlockEntity$CreativeSmartFluidTank);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeFluidTankBlockEntity$CreativeSmartFluidTank$$Original = $CreativeFluidTankBlockEntity$CreativeSmartFluidTank;}
declare module "com.simibubi.create.content.kinetics.fan.IAirCurrentSource" {
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$AirCurrent} from "com.simibubi.create.content.kinetics.fan.AirCurrent"

export interface $IAirCurrentSource$$Interface {
get "airCurrent"(): $AirCurrent
get "airCurrentWorld"(): $Level
get "airCurrentPos"(): $BlockPos
get "airFlowDirection"(): $Direction
get "sourceRemoved"(): boolean
get "maxDistance"(): float
get "airflowOriginSide"(): $Direction
get "speed"(): float
}

export class $IAirCurrentSource implements $IAirCurrentSource$$Interface {
 "getAirCurrent"(): $AirCurrent
 "getAirCurrentWorld"(): $Level
 "getAirCurrentPos"(): $BlockPos
 "getAirFlowDirection"(): $Direction
 "isSourceRemoved"(): boolean
 "getMaxDistance"(): float
 "getAirflowOriginSide"(): $Direction
 "getSpeed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAirCurrentSource$$Type = ($IAirCurrentSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IAirCurrentSource$$Original = $IAirCurrentSource;}
declare module "com.simibubi.create.content.logistics.funnel.BrassFunnelBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$FunnelBlock} from "com.simibubi.create.content.logistics.funnel.FunnelBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BrassFunnelBlock extends $FunnelBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "EXTRACTING": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getEquivalentBeltFunnel"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrassFunnelBlock$$Type = ($BrassFunnelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BrassFunnelBlock$$Original = $BrassFunnelBlock;}
declare module "com.simibubi.create.content.trains.track.TrackMaterial$TrackType$TrackBlockFactory" {
import {$TrackBlock, $TrackBlock$$Type} from "com.simibubi.create.content.trains.track.TrackBlock"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$TrackMaterial, $TrackMaterial$$Type} from "com.simibubi.create.content.trains.track.TrackMaterial"

export interface $TrackMaterial$TrackType$TrackBlockFactory$$Interface {

(arg0: $BlockBehaviour$Properties, arg1: $TrackMaterial): $TrackBlock$$Type
}

export class $TrackMaterial$TrackType$TrackBlockFactory implements $TrackMaterial$TrackType$TrackBlockFactory$$Interface {
 "create"(arg0: $BlockBehaviour$Properties$$Type, arg1: $TrackMaterial$$Type): $TrackBlock
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackMaterial$TrackType$TrackBlockFactory$$Type = ((arg0: $BlockBehaviour$Properties, arg1: $TrackMaterial) => $TrackBlock$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackMaterial$TrackType$TrackBlockFactory$$Original = $TrackMaterial$TrackType$TrackBlockFactory;}
declare module "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$SequencedGearshiftBlockEntity, $SequencedGearshiftBlockEntity$$Type} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$TransformableBlock$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$HorizontalAxisKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalAxisKineticBlock"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $SequencedGearshiftBlock extends $HorizontalAxisKineticBlock implements $IBE$$Interface<($SequencedGearshiftBlockEntity)>, $TransformableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "STATE": $IntegerProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "HORIZONTAL_AXIS": $Property<($Direction$Axis)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "VERTICAL": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($SequencedGearshiftBlockEntity)>
public "getBlockEntityClass"(): $Class<($SequencedGearshiftBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "transform"(arg0: $BlockState$$Type, arg1: $StructureTransform$$Type): $BlockState
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SequencedGearshiftBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SequencedGearshiftBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SequencedGearshiftBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SequencedGearshiftBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SequencedGearshiftBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SequencedGearshiftBlockEntity)>
get "blockEntityClass"(): $Class<($SequencedGearshiftBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencedGearshiftBlock$$Type = ($SequencedGearshiftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SequencedGearshiftBlock$$Original = $SequencedGearshiftBlock;}
declare module "com.simibubi.create.content.decoration.palettes.ConnectedGlassBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$Item} from "net.minecraft.world.item.Item"
import {$TransparentBlock} from "net.minecraft.world.level.block.TransparentBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ConnectedGlassBlock extends $TransparentBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TransparentBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "skipRendering"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "shouldDisplayFluidOverlay"(arg0: $BlockState$$Type, arg1: $BlockAndTintGetter$$Type, arg2: $BlockPos$$Type, arg3: $FluidState$$Type): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectedGlassBlock$$Type = ($ConnectedGlassBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConnectedGlassBlock$$Original = $ConnectedGlassBlock;}
declare module "com.simibubi.create.content.logistics.chute.ChuteBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveGoggleInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveGoggleInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ChuteBlockEntity extends $SmartBlockEntity implements $IHaveGoggleInformation$$Interface, $Clearable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "updatePull"(): void
public "updatePush"(arg0: integer): void
public "canDirectlyInsertCached"(): boolean
public "getItemMotion"(): float
public "propagatePush"(): void
public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "setItem"(arg0: $ItemStack$$Type): void
public "setItem"(arg0: $ItemStack$$Type, arg1: float): void
public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onAdded"(): void
public "blockBelowChanged"(): void
public "tick"(): void
public "getItem"(): $ItemStack
public "initialize"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "destroy"(): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public "containedFluidTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean, arg2: $IFluidHandler$$Type): boolean
public static "tryClear"(arg0: any): void
public "getIcon"(arg0: boolean): $ItemStack
get "itemMotion"(): float
set "item"(value: $ItemStack$$Type)
get "item"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChuteBlockEntity$$Type = ($ChuteBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChuteBlockEntity$$Original = $ChuteBlockEntity;}
declare module "com.simibubi.create.content.logistics.packagePort.PackagePortBlockEntity" {
import {$SmartInventory} from "com.simibubi.create.foundation.item.SmartInventory"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$PackagePortTarget} from "com.simibubi.create.content.logistics.packagePort.PackagePortTarget"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PackagePortBlockEntity extends $SmartBlockEntity implements $MenuProvider$$Interface, $Clearable$$Interface {
 "acceptsPackages": boolean
 "addressFilter": StringJS
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventory": $SmartInventory
 "target": $PackagePortTarget

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isBackedUp"(): boolean
public "filterChanged"(): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "clearContent"(): void
public "getComparatorOutput"(): integer
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "getFilterString"(): StringJS
public "getDisplayName"(): $Component
public "destroy"(): void
public "use"(arg0: $Player$$Type): $ItemInteractionResult
public "drop"(arg0: $ItemStack$$Type): void
public "invalidate"(): void
public static "tryClear"(arg0: any): void
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
get "backedUp"(): boolean
get "comparatorOutput"(): integer
get "filterString"(): StringJS
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagePortBlockEntity$$Type = ($PackagePortBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagePortBlockEntity$$Original = $PackagePortBlockEntity;}
declare module "com.simibubi.create.content.kinetics.gauge.GaugeBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveGoggleInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveGoggleInformation"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $GaugeBlockEntity extends $KineticBlockEntity implements $IHaveGoggleInformation$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "color": integer
 "prevDialState": float
 "dialState": float
 "updateSpeed": boolean
 "dialTarget": float
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GaugeBlockEntity$$Type = ($GaugeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GaugeBlockEntity$$Original = $GaugeBlockEntity;}
declare module "com.simibubi.create.content.kinetics.fan.processing.AllFanProcessingTypes$HauntingType" {
import {$FanProcessingType$AirFlowParticleAccess$$Type} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType$AirFlowParticleAccess"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$FanProcessingType, $FanProcessingType$$Interface} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $AllFanProcessingTypes$HauntingType implements $FanProcessingType$$Interface {
constructor()

public "spawnProcessingParticles"(arg0: $Level$$Type, arg1: $Vec3$$Type): void
public "morphAirFlow"(arg0: $FanProcessingType$AirFlowParticleAccess$$Type, arg1: $RandomSource$$Type): void
public "affectEntity"(arg0: $Entity$$Type, arg1: $Level$$Type): void
public "isValidAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public "canProcess"(arg0: $ItemStack$$Type, arg1: $Level$$Type): boolean
public "process"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemStack)>
public "getPriority"(): integer
public static "parse"(arg0: StringJS): $FanProcessingType
public static "getAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $FanProcessingType
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllFanProcessingTypes$HauntingType$$Type = ($AllFanProcessingTypes$HauntingType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllFanProcessingTypes$HauntingType$$Original = $AllFanProcessingTypes$HauntingType;}
declare module "com.simibubi.create.content.contraptions.chassis.AbstractChassisBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$RotatedPillarBlock} from "net.minecraft.world.level.block.RotatedPillarBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ChassisBlockEntity, $ChassisBlockEntity$$Type} from "com.simibubi.create.content.contraptions.chassis.ChassisBlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$TransformableBlock$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AbstractChassisBlock extends $RotatedPillarBlock implements $IWrenchable$$Interface, $IBE$$Interface<($ChassisBlockEntity)>, $TransformableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RotatedPillarBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($ChassisBlockEntity)>
public "getBlockEntityClass"(): $Class<($ChassisBlockEntity)>
public "getGlueableSide"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BooleanProperty
public "transform"(arg0: $BlockState$$Type, arg1: $StructureTransform$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ChassisBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ChassisBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ChassisBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ChassisBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ChassisBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ChassisBlockEntity)>
get "blockEntityClass"(): $Class<($ChassisBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractChassisBlock$$Type = ($AbstractChassisBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractChassisBlock$$Original = $AbstractChassisBlock;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.attributes.ItemNameAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $ItemNameAttribute$Type implements $ItemAttributeType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemNameAttribute$Type$$Type = ($ItemNameAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemNameAttribute$Type$$Original = $ItemNameAttribute$Type;}
declare module "com.simibubi.create.content.kinetics.KineticNetwork" {
import {$Map} from "java.util.Map"
import {$KineticBlockEntity, $KineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"

export class $KineticNetwork {
 "sources": $Map<($KineticBlockEntity), (float)>
 "members": $Map<($KineticBlockEntity), (float)>
 "initialized": boolean
 "id": long

constructor()

public "updateCapacity"(): void
public "calculateStress"(): float
public "getActualCapacityOf"(arg0: $KineticBlockEntity$$Type): float
public "getActualStressOf"(arg0: $KineticBlockEntity$$Type): float
public "initFromTE"(arg0: float, arg1: float, arg2: integer): void
public "addSilently"(arg0: $KineticBlockEntity$$Type, arg1: float, arg2: float): void
public "updateNetwork"(): void
public "updateStressFor"(arg0: $KineticBlockEntity$$Type, arg1: float): void
public "updateStress"(): void
public "updateCapacityFor"(arg0: $KineticBlockEntity$$Type, arg1: float): void
public "calculateCapacity"(): float
public "remove"(arg0: $KineticBlockEntity$$Type): void
public "add"(arg0: $KineticBlockEntity$$Type): void
public "getSize"(): integer
public "sync"(): void
get "size"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KineticNetwork$$Type = ($KineticNetwork);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KineticNetwork$$Original = $KineticNetwork;}
declare module "com.simibubi.create.content.fluids.pump.PumpBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DirectionalKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalKineticBlock"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ICogWheel$$Interface} from "com.simibubi.create.content.kinetics.simpleRelays.ICogWheel"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$PumpBlockEntity, $PumpBlockEntity$$Type} from "com.simibubi.create.content.fluids.pump.PumpBlockEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $PumpBlock extends $DirectionalKineticBlock implements $SimpleWaterloggedBlock$$Interface, $ICogWheel$$Interface, $IBE$$Interface<($PumpBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($PumpBlockEntity)>
public "getBlockEntityClass"(): $Class<($PumpBlockEntity)>
public static "isOpenAt"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public static "isPump"(arg0: $BlockState$$Type): boolean
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "isSmallCog"(): boolean
public static "isSmallCog"(arg0: $Block$$Type): boolean
public static "isSmallCog"(arg0: $BlockState$$Type): boolean
public "isLargeCog"(): boolean
public static "isLargeCog"(arg0: $Block$$Type): boolean
public static "isLargeCog"(arg0: $BlockState$$Type): boolean
public "isDedicatedCogWheel"(): boolean
public static "isDedicatedCogWheel"(arg0: $Block$$Type): boolean
public static "isDedicatedCogItem"(arg0: $ItemStack$$Type): boolean
public static "isSmallCogItem"(arg0: $ItemStack$$Type): boolean
public static "isLargeCogItem"(arg0: $ItemStack$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($PumpBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($PumpBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PumpBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PumpBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $PumpBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($PumpBlockEntity)>
get "blockEntityClass"(): $Class<($PumpBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
get "smallCog"(): boolean
get "largeCog"(): boolean
get "dedicatedCogWheel"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PumpBlock$$Type = ($PumpBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PumpBlock$$Original = $PumpBlock;}
declare module "com.simibubi.create.content.trains.track.TrackMaterial" {
import {$TrackMaterial$TrackModelHolder, $TrackMaterial$TrackModelHolder$$Type} from "com.simibubi.create.content.trains.track.TrackMaterial$TrackModelHolder"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$TrackMaterial$TrackType, $TrackMaterial$TrackType$$Type} from "com.simibubi.create.content.trains.track.TrackMaterial$TrackType"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$TrackMaterial$TrackType$TrackBlockFactory$$Type} from "com.simibubi.create.content.trains.track.TrackMaterial$TrackType$TrackBlockFactory"
import {$NonNullSupplier, $NonNullSupplier$$Type} from "com.tterrag.registrate.util.nullness.NonNullSupplier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$TrackBlock, $TrackBlock$$Type} from "com.simibubi.create.content.trains.track.TrackBlock"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Item$$Type} from "net.minecraft.world.item.Item"

export class $TrackMaterial {
static readonly "ALL": $Map<($ResourceLocation), ($TrackMaterial)>
readonly "trackBlock": $NonNullSupplier<($NonNullSupplier<($TrackBlock)>)>
readonly "trackType": $TrackMaterial$TrackType
readonly "langName": StringJS
static readonly "ANDESITE": $TrackMaterial
readonly "particle": $ResourceLocation
readonly "id": $ResourceLocation
readonly "sleeperIngredient": $Ingredient
readonly "railsIngredient": $Ingredient

constructor(arg0: $ResourceLocation$$Type, arg1: StringJS, arg2: $NonNullSupplier$$Type<($NonNullSupplier$$Type<($TrackBlock$$Type)>)>, arg3: $ResourceLocation$$Type, arg4: $Ingredient$$Type, arg5: $Ingredient$$Type, arg6: $TrackMaterial$TrackType$$Type, arg7: $Supplier$$Type<($Supplier$$Type<($TrackMaterial$TrackModelHolder$$Type)>)>)
constructor(arg0: $ResourceLocation$$Type, arg1: StringJS, arg2: $NonNullSupplier$$Type<($NonNullSupplier$$Type<($TrackBlock$$Type)>)>, arg3: $ResourceLocation$$Type, arg4: $Ingredient$$Type, arg5: $Ingredient$$Type, arg6: $TrackMaterial$TrackType$$Type, arg7: $Supplier$$Type<($Supplier$$Type<($TrackMaterial$TrackModelHolder$$Type)>)>, arg8: $TrackMaterial$TrackType$TrackBlockFactory$$Type)

public "asStack"(): $ItemStack
public "asStack"(arg0: integer): $ItemStack
public static "fromItem"(arg0: $Item$$Type): $TrackMaterial
public "createBlock"(arg0: $BlockBehaviour$Properties$$Type): $TrackBlock
public static "allFromMod"(arg0: StringJS): $List<($TrackMaterial)>
public "getModelHolder"(): $TrackMaterial$TrackModelHolder
public "getBlockSupplier"(): $NonNullSupplier<($TrackBlock)>
public "isFromMod"(arg0: StringJS): boolean
public static "allBlocksFromMod"(arg0: StringJS): $List<($NonNullSupplier<($Block)>)>
public "getBlock"(): $TrackBlock
public "resourceName"(): StringJS
public static "deserialize"(arg0: StringJS): $TrackMaterial
public static "allBlocks"(): $List<($NonNullSupplier<($Block)>)>
get "modelHolder"(): $TrackMaterial$TrackModelHolder
get "blockSupplier"(): $NonNullSupplier<($TrackBlock)>
get "block"(): $TrackBlock
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackMaterial$$Type = ($TrackMaterial);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackMaterial$$Original = $TrackMaterial;}
declare module "com.simibubi.create.content.schematics.table.SchematicTableBlockEntity$SchematicTableInventory" {
import {$SchematicTableBlockEntity$$Type} from "com.simibubi.create.content.schematics.table.SchematicTableBlockEntity"
import {$ItemStackHandler} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $SchematicTableBlockEntity$SchematicTableInventory extends $ItemStackHandler {
constructor(arg0: $SchematicTableBlockEntity$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicTableBlockEntity$SchematicTableInventory$$Type = ($SchematicTableBlockEntity$SchematicTableInventory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicTableBlockEntity$SchematicTableInventory$$Original = $SchematicTableBlockEntity$SchematicTableInventory;}
declare module "com.simibubi.create.content.redstone.displayLink.DisplayLinkBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$DisplayLinkBlockEntity, $DisplayLinkBlockEntity$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkBlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $DisplayLinkBlock extends $WrenchableDirectionalBlock implements $IBE$$Interface<($DisplayLinkBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DisplayLinkBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($DisplayLinkBlockEntity)>
public "getBlockEntityClass"(): $Class<($DisplayLinkBlockEntity)>
public static "sendToGatherers"<T extends $DisplaySource>(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BiConsumer$$Type<($DisplayLinkBlockEntity), (T)>, arg3: $Class$$Type<(T)>): void
public static "notifyGatherers"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($DisplayLinkBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($DisplayLinkBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($DisplayLinkBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($DisplayLinkBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $DisplayLinkBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($DisplayLinkBlockEntity)>
get "blockEntityClass"(): $Class<($DisplayLinkBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayLinkBlock$$Type = ($DisplayLinkBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DisplayLinkBlock$$Original = $DisplayLinkBlock;}
declare module "com.simibubi.create.content.contraptions.elevator.ElevatorContactBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ElevatorColumn$ColumnCoords} from "com.simibubi.create.content.contraptions.elevator.ElevatorColumn$ColumnCoords"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ElevatorColumn$$Type} from "com.simibubi.create.content.contraptions.elevator.ElevatorColumn"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$ElevatorContactBlockEntity, $ElevatorContactBlockEntity$$Type} from "com.simibubi.create.content.contraptions.elevator.ElevatorContactBlockEntity"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $ElevatorContactBlock extends $WrenchableDirectionalBlock implements $IBE$$Interface<($ElevatorContactBlockEntity)>, $SpecialBlockItemRequirement$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ElevatorContactBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "POWERING": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "CALLING": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public static "getLight"(arg0: $BlockState$$Type): integer
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($ElevatorContactBlockEntity)>
public "getBlockEntityClass"(): $Class<($ElevatorContactBlockEntity)>
public "callToContactAndUpdate"(arg0: $ElevatorColumn$$Type, arg1: $BlockState$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: boolean): void
public static "getColumnCoords"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): $ElevatorColumn$ColumnCoords
public "scheduleActivation"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ElevatorContactBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ElevatorContactBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ElevatorContactBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ElevatorContactBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ElevatorContactBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ElevatorContactBlockEntity)>
get "blockEntityClass"(): $Class<($ElevatorContactBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElevatorContactBlock$$Type = ($ElevatorContactBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ElevatorContactBlock$$Original = $ElevatorContactBlock;}
declare module "com.simibubi.create.content.fluids.drain.ItemDrainBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$ItemDrainBlockEntity, $ItemDrainBlockEntity$$Type} from "com.simibubi.create.content.fluids.drain.ItemDrainBlockEntity"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $ItemDrainBlock extends $Block implements $IWrenchable$$Interface, $IBE$$Interface<($ItemDrainBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($ItemDrainBlockEntity)>
public "getBlockEntityClass"(): $Class<($ItemDrainBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ItemDrainBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ItemDrainBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ItemDrainBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ItemDrainBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ItemDrainBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ItemDrainBlockEntity)>
get "blockEntityClass"(): $Class<($ItemDrainBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDrainBlock$$Type = ($ItemDrainBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemDrainBlock$$Original = $ItemDrainBlock;}
declare module "com.simibubi.create.content.contraptions.minecart.TrainCargoManager" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$MountedStorageManager} from "com.simibubi.create.content.contraptions.MountedStorageManager"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $TrainCargoManager extends $MountedStorageManager {
constructor()

public "resetIdleCargoTracker"(): void
public "tickIdleCargoTracker"(): void
public "getTicksSinceLastExchange"(): integer
public "getVersion"(): integer
public "initialize"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean, arg3: $Contraption$$Type): void
get "ticksSinceLastExchange"(): integer
get "version"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrainCargoManager$$Type = ($TrainCargoManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrainCargoManager$$Original = $TrainCargoManager;}
declare module "com.simibubi.create.content.fluids.tank.storage.creative.CreativeFluidTankMountedStorageType" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$CreativeFluidTankMountedStorage} from "com.simibubi.create.content.fluids.tank.storage.creative.CreativeFluidTankMountedStorage"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$MountedFluidStorageType} from "com.simibubi.create.api.contraption.storage.fluid.MountedFluidStorageType"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CreativeFluidTankMountedStorageType extends $MountedFluidStorageType<($CreativeFluidTankMountedStorage)> {
readonly "codec": $MapCodec<(T)>
static readonly "CODEC": $Codec<($MountedFluidStorageType<(never)>)>
static readonly "REGISTRY": $SimpleRegistry<($Block), ($MountedFluidStorageType<(never)>)>

constructor()

public "mount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): $CreativeFluidTankMountedStorage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeFluidTankMountedStorageType$$Type = ($CreativeFluidTankMountedStorageType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeFluidTankMountedStorageType$$Original = $CreativeFluidTankMountedStorageType;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.attributes.BookCopyAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $BookCopyAttribute$Type implements $ItemAttributeType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BookCopyAttribute$Type$$Type = ($BookCopyAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BookCopyAttribute$Type$$Original = $BookCopyAttribute$Type;}
declare module "com.simibubi.create.content.schematics.SchematicPrinter$PrintStage" {
import {$Enum} from "java.lang.Enum"

export class $SchematicPrinter$PrintStage extends $Enum<($SchematicPrinter$PrintStage)> {
static readonly "BLOCKS": $SchematicPrinter$PrintStage
static readonly "DEFERRED_BLOCKS": $SchematicPrinter$PrintStage
static readonly "ENTITIES": $SchematicPrinter$PrintStage

public static "values"(): ($SchematicPrinter$PrintStage)[]
public static "valueOf"(arg0: StringJS): $SchematicPrinter$PrintStage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicPrinter$PrintStage$$Type = (("blocks") | ("deferred_blocks") | ("entities"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicPrinter$PrintStage$$Original = $SchematicPrinter$PrintStage;}
declare module "com.simibubi.create.content.kinetics.belt.BeltBlockEntity$CasingType" {
import {$Enum} from "java.lang.Enum"

export class $BeltBlockEntity$CasingType extends $Enum<($BeltBlockEntity$CasingType)> {
static readonly "BRASS": $BeltBlockEntity$CasingType
static readonly "ANDESITE": $BeltBlockEntity$CasingType
static readonly "NONE": $BeltBlockEntity$CasingType

public static "encased$initInvoker$createcasing_$md$b00d76$0"(arg0: StringJS, arg1: integer): $BeltBlockEntity$CasingType
public static "values"(): ($BeltBlockEntity$CasingType)[]
public static "valueOf"(arg0: StringJS): $BeltBlockEntity$CasingType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltBlockEntity$CasingType$$Type = (("none") | ("andesite") | ("brass") | ("copper") | ("railway") | ("shadow_steel") | ("refined_radiance") | ("creative") | ("industrial_iron") | ("weathered_iron"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltBlockEntity$CasingType$$Original = $BeltBlockEntity$CasingType;}
declare module "com.simibubi.create.content.equipment.symmetryWand.SymmetryWandItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$SymmetryMirror, $SymmetryMirror$$Type} from "com.simibubi.create.content.equipment.symmetryWand.mirror.SymmetryMirror"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IClientItemExtensions$$Type} from "net.neoforged.neoforge.client.extensions.common.IClientItemExtensions"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SymmetryWandItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "initializeClient"(arg0: $Consumer$$Type<($IClientItemExtensions)>): void
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public static "presentInHotbar"(arg0: $Player$$Type): boolean
public static "configureSettings"(arg0: $ItemStack$$Type, arg1: $SymmetryMirror$$Type): void
public static "remove"(arg0: $Level$$Type, arg1: $ItemStack$$Type, arg2: $Player$$Type, arg3: $BlockPos$$Type): void
public static "apply"(arg0: $Level$$Type, arg1: $ItemStack$$Type, arg2: $Player$$Type, arg3: $BlockPos$$Type, arg4: $BlockState$$Type): void
public static "isEnabled"(arg0: $ItemStack$$Type): boolean
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "getMirror"(arg0: $ItemStack$$Type): $SymmetryMirror
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SymmetryWandItem$$Type = ($SymmetryWandItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SymmetryWandItem$$Original = $SymmetryWandItem;}
declare module "com.simibubi.create.content.redstone.analogLever.AnalogLeverBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$FaceAttachedHorizontalDirectionalBlock} from "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$AnalogLeverBlockEntity, $AnalogLeverBlockEntity$$Type} from "com.simibubi.create.content.redstone.analogLever.AnalogLeverBlockEntity"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $AnalogLeverBlock extends $FaceAttachedHorizontalDirectionalBlock implements $IBE$$Interface<($AnalogLeverBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($AnalogLeverBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($AttachFace)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "useWithoutItem"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type, arg4: $BlockHitResult$$Type): $InteractionResult
public "getBlockEntityType"(): $BlockEntityType<($AnalogLeverBlockEntity)>
public "getBlockEntityClass"(): $Class<($AnalogLeverBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getDirectSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($AnalogLeverBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($AnalogLeverBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($AnalogLeverBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($AnalogLeverBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $AnalogLeverBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($AnalogLeverBlockEntity)>
get "blockEntityClass"(): $Class<($AnalogLeverBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnalogLeverBlock$$Type = ($AnalogLeverBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AnalogLeverBlock$$Original = $AnalogLeverBlock;}
declare module "com.simibubi.create.content.kinetics.base.IRotate$SpeedLevel" {
import {$Enum} from "java.lang.Enum"
import {$LangBuilder} from "net.createmod.catnip.lang.LangBuilder"
import {$ChatFormatting} from "net.minecraft.ChatFormatting"

export class $IRotate$SpeedLevel extends $Enum<($IRotate$SpeedLevel)> {
static readonly "MEDIUM": $IRotate$SpeedLevel
static readonly "SLOW": $IRotate$SpeedLevel
static readonly "NONE": $IRotate$SpeedLevel
static readonly "FAST": $IRotate$SpeedLevel

public static "getFormattedSpeedText"(arg0: float, arg1: boolean): $LangBuilder
public "getParticleSpeed"(): integer
public "getSpeedValue"(): float
public "getTextColor"(): $ChatFormatting
public static "values"(): ($IRotate$SpeedLevel)[]
public static "valueOf"(arg0: StringJS): $IRotate$SpeedLevel
public static "of"(arg0: float): $IRotate$SpeedLevel
public "getColor"(): integer
get "particleSpeed"(): integer
get "speedValue"(): float
get "textColor"(): $ChatFormatting
get "color"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRotate$SpeedLevel$$Type = (("none") | ("slow") | ("medium") | ("fast"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IRotate$SpeedLevel$$Original = $IRotate$SpeedLevel;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.ArmBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ArmBlockEntity extends $KineticBlockEntity implements $TransformableBlockEntity$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "writeInteractionPoints"(arg0: $CompoundTag$$Type): void
public "addToTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "redstoneUpdate"(): void
public "tick"(): void
public "setLevel"(arg0: $Level$$Type): void
public static "getRange"(): integer
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "destroy"(): void
set "level"(value: $Level$$Type)
public static get "range"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmBlockEntity$$Type = ($ArmBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmBlockEntity$$Original = $ArmBlockEntity;}
declare module "com.simibubi.create.content.equipment.wrench.WrenchItem" {
import {$IClientItemExtensions$$Type} from "net.neoforged.neoforge.client.extensions.common.IClientItemExtensions"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$AttackEntityEvent$$Type} from "net.neoforged.neoforge.event.entity.player.AttackEntityEvent"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $WrenchItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "initializeClient"(arg0: $Consumer$$Type<($IClientItemExtensions)>): void
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public static "wrenchInstaKillsMinecarts"(arg0: $AttackEntityEvent$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrenchItem$$Type = ($WrenchItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WrenchItem$$Original = $WrenchItem;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$CampfireType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$CampfireType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$CampfireType$$Type = ($AllArmInteractionPointTypes$CampfireType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$CampfireType$$Original = $AllArmInteractionPointTypes$CampfireType;}
declare module "com.simibubi.create.content.kinetics.clock.CuckooClockBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$HorizontalKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalKineticBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$CuckooClockBlockEntity, $CuckooClockBlockEntity$$Type} from "com.simibubi.create.content.kinetics.clock.CuckooClockBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $CuckooClockBlock extends $HorizontalKineticBlock implements $IBE$$Interface<($CuckooClockBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "HORIZONTAL_FACING": $Property<($Direction)>

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($CuckooClockBlockEntity)>
public "getBlockEntityClass"(): $Class<($CuckooClockBlockEntity)>
public static "mysterious"(arg0: $BlockBehaviour$Properties$$Type): $CuckooClockBlock
public static "containsSurprise"(arg0: $BlockState$$Type): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public static "regular"(arg0: $BlockBehaviour$Properties$$Type): $CuckooClockBlock
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($CuckooClockBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($CuckooClockBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CuckooClockBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CuckooClockBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $CuckooClockBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($CuckooClockBlockEntity)>
get "blockEntityClass"(): $Class<($CuckooClockBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CuckooClockBlock$$Type = ($CuckooClockBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CuckooClockBlock$$Original = $CuckooClockBlock;}
declare module "com.simibubi.create.content.logistics.packagePort.PackagePortTarget$TrainStationFrogportTarget" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$PackagePortBlockEntity$$Type} from "com.simibubi.create.content.logistics.packagePort.PackagePortBlockEntity"
import {$PackagePortTarget} from "com.simibubi.create.content.logistics.packagePort.PackagePortTarget"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $PackagePortTarget$TrainStationFrogportTarget extends $PackagePortTarget {
static "CODEC": $MapCodec<($PackagePortTarget$TrainStationFrogportTarget)>
 "relativePos": $BlockPos
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($PackagePortTarget$TrainStationFrogportTarget)>

constructor(arg0: $BlockPos$$Type)

public "getExactTargetLocation"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): $Vec3
public "depositImmediately"(): boolean
public "deregister"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): void
public "register"(arg0: $PackagePortBlockEntity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): void
public "getIcon"(): $ItemStack
public "export"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type, arg3: boolean): boolean
public "canSupport"(arg0: $BlockEntity$$Type): boolean
get "icon"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagePortTarget$TrainStationFrogportTarget$$Type = ($PackagePortTarget$TrainStationFrogportTarget);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagePortTarget$TrainStationFrogportTarget$$Original = $PackagePortTarget$TrainStationFrogportTarget;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour$TransportedResult" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$TransportedItemStack, $TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"

export class $TransportedItemStackHandlerBehaviour$TransportedResult {
public static "convertToAndLeaveHeld"(arg0: $List$$Type<($TransportedItemStack$$Type)>, arg1: $TransportedItemStack$$Type): $TransportedItemStackHandlerBehaviour$TransportedResult
public static "doNothing"(): $TransportedItemStackHandlerBehaviour$TransportedResult
public "hasHeldOutput"(): boolean
public "doesNothing"(): boolean
public "didntChangeFrom"(arg0: $ItemStack$$Type): boolean
public "getHeldOutput"(): $TransportedItemStack
public static "removeItem"(): $TransportedItemStackHandlerBehaviour$TransportedResult
public "getOutputs"(): $List<($TransportedItemStack)>
public static "convertTo"(arg0: $TransportedItemStack$$Type): $TransportedItemStackHandlerBehaviour$TransportedResult
public static "convertTo"(arg0: $List$$Type<($TransportedItemStack$$Type)>): $TransportedItemStackHandlerBehaviour$TransportedResult
get "heldOutput"(): $TransportedItemStack
get "outputs"(): $List<($TransportedItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransportedItemStackHandlerBehaviour$TransportedResult$$Type = ($TransportedItemStackHandlerBehaviour$TransportedResult);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TransportedItemStackHandlerBehaviour$TransportedResult$$Original = $TransportedItemStackHandlerBehaviour$TransportedResult;}
declare module "com.simibubi.create.content.trains.track.BezierConnection$GirderAngles" {
import {$PoseStack$Pose} from "com.mojang.blaze3d.vertex.PoseStack$Pose"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos} from "net.minecraft.core.BlockPos"

export class $BezierConnection$GirderAngles {
readonly "beams": ($Couple<($PoseStack$Pose)>)[]
readonly "lightPosition": ($BlockPos)[]
readonly "length": integer
readonly "beamCaps": ($Couple<($Couple<($PoseStack$Pose)>)>)[]

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BezierConnection$GirderAngles$$Type = ($BezierConnection$GirderAngles);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BezierConnection$GirderAngles$$Original = $BezierConnection$GirderAngles;}
declare module "com.simibubi.create.content.processing.basin.BasinBlockEntity" {
import {$SmartFluidTankBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.fluid.SmartFluidTankBehaviour"
import {$SmartInventory} from "com.simibubi.create.foundation.item.SmartInventory"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BasinInventory} from "com.simibubi.create.content.processing.basin.BasinInventory"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlazeBurnerBlock$HeatLevel} from "com.simibubi.create.content.processing.burner.BlazeBurnerBlock$HeatLevel"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$FilteringBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.filtering.FilteringBehaviour"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveGoggleInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveGoggleInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BasinBlockEntity extends $SmartBlockEntity implements $IHaveGoggleInformation$$Interface, $Clearable$$Interface {
static readonly "OUTPUT_ANIMATION_TIME": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inputTank": $SmartFluidTankBehaviour
 "inputInventory": $BasinInventory

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "clearContent"(): void
public "notifyUpdate"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "getTanks"(): $Couple<($SmartFluidTankBehaviour)>
public "getInputInventory"(): $SmartInventory
public "notifyChangeOfContents"(): void
public static "getHeatLevelOf"(arg0: $BlockState$$Type): $BlazeBurnerBlock$HeatLevel
public "onEmptied"(): void
public "areFluidsMoving"(): boolean
public "setAreFluidsMoving"(arg0: boolean): boolean
public "acceptOutputs"(arg0: $List$$Type<($ItemStack$$Type)>, arg1: $List$$Type<($FluidStack$$Type)>, arg2: boolean): boolean
public "getTotalFluidUnits"(arg0: float): float
public "getOutputInventory"(): $SmartInventory
public "canContinueProcessing"(): boolean
public "readOnlyItems"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getInvs"(): $Couple<($SmartInventory)>
public "onWrenched"(arg0: $Direction$$Type): void
public "tick"(): void
public "getFilter"(): $FilteringBehaviour
public "remove"(): void
public "isEmpty"(): boolean
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "destroy"(): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public "containedFluidTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean, arg2: $IFluidHandler$$Type): boolean
public static "tryClear"(arg0: any): void
public "getIcon"(arg0: boolean): $ItemStack
get "tanks"(): $Couple<($SmartFluidTankBehaviour)>
get "outputInventory"(): $SmartInventory
get "invs"(): $Couple<($SmartInventory)>
get "filter"(): $FilteringBehaviour
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasinBlockEntity$$Type = ($BasinBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasinBlockEntity$$Original = $BasinBlockEntity;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$FunnelType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$FunnelType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$FunnelType$$Type = ($AllArmInteractionPointTypes$FunnelType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$FunnelType$$Original = $AllArmInteractionPointTypes$FunnelType;}
declare module "com.simibubi.create.content.redstone.displayLink.source.ObservedTrainNameSource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $ObservedTrainNameSource extends $SingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "getPassiveRefreshTicks"(): integer
get "passiveRefreshTicks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObservedTrainNameSource$$Type = ($ObservedTrainNameSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ObservedTrainNameSource$$Original = $ObservedTrainNameSource;}
declare module "com.simibubi.create.content.fluids.tank.FluidTankBlockEntity" {
import {$BoilerData} from "com.simibubi.create.content.fluids.tank.BoilerData"
import {$LerpedFloat, $LerpedFloat$$Type} from "net.createmod.catnip.animation.LerpedFloat"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$IFluidTank} from "net.neoforged.neoforge.fluids.IFluidTank"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$FluidStack} from "net.neoforged.neoforge.fluids.FluidStack"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Direction$Axis, $Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$FluidTank} from "net.neoforged.neoforge.fluids.capability.templates.FluidTank"
import {$IMultiBlockEntityContainer$Fluid$$Interface} from "com.simibubi.create.foundation.blockEntity.IMultiBlockEntityContainer$Fluid"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveGoggleInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveGoggleInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FluidTankBlockEntity extends $SmartBlockEntity implements $IHaveGoggleInformation$$Interface, $IMultiBlockEntityContainer$Fluid$$Interface {
 "boiler": $BoilerData
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "getFluid"(arg0: integer): $FluidStack
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "sendData"(): void
public "getMaxWidth"(): integer
public static "getMaxHeight"(): integer
public static "getCapacityMultiplier"(): integer
public "sendDataImmediately"(): void
public "updateBoilerState"(): void
public "getFillState"(): float
public "toggleWindows"(): void
public "updateBoilerTemperature"(): void
public "getOtherFluidTankBlockEntity"(arg0: $Direction$$Type): $FluidTankBlockEntity
public "applyFluidTankSize"(arg0: integer): void
public "setWindows"(arg0: boolean): void
public "getTankSize"(arg0: integer): integer
public "setTankSize"(arg0: integer, arg1: integer): void
public "hasTank"(): boolean
public "getController"(): $BlockPos
public "setController"(arg0: $BlockPos$$Type): void
public "getControllerBE"(): $FluidTankBlockEntity
public "isController"(): boolean
public "getTotalTankSize"(): integer
public "removeController"(arg0: boolean): void
public "getTankInventory"(): $FluidTank
public "getFluidLevel"(): $LerpedFloat
public "setFluidLevel"(arg0: $LerpedFloat$$Type): void
public "notifyMultiUpdated"(): void
public "getMainConnectionAxis"(): $Direction$Axis
public "getLastKnownPos"(): $BlockPos
public "preventConnectivityUpdate"(): void
public "setExtraData"(arg0: any): void
public "modifyExtraData"(arg0: any): any
public static "getMaxSize"(): integer
public "tick"(): void
public "getWidth"(): integer
public "getHeight"(): integer
public "initialize"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "getMaxLength"(arg0: $Direction$Axis$$Type, arg1: integer): integer
public "setWidth"(arg0: integer): void
public "setHeight"(arg0: integer): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public "getTank"(arg0: integer): $IFluidTank
public "getExtraData"(): any
public "containedFluidTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean, arg2: $IFluidHandler$$Type): boolean
public "getIcon"(arg0: boolean): $ItemStack
public "getMainAxisOf"(arg0: $BlockEntity$$Type): $Direction$Axis
get "maxWidth"(): integer
public static get "maxHeight"(): integer
public static get "capacityMultiplier"(): integer
get "fillState"(): float
set "windows"(value: boolean)
get "controller"(): $BlockPos
set "controller"(value: $BlockPos$$Type)
get "controllerBE"(): $FluidTankBlockEntity
get "controller"(): boolean
get "totalTankSize"(): integer
get "tankInventory"(): $FluidTank
get "fluidLevel"(): $LerpedFloat
set "fluidLevel"(value: $LerpedFloat$$Type)
get "mainConnectionAxis"(): $Direction$Axis
get "lastKnownPos"(): $BlockPos
set "extraData"(value: any)
public static get "maxSize"(): integer
get "width"(): integer
get "height"(): integer
set "width"(value: integer)
set "height"(value: integer)
get "extraData"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankBlockEntity$$Type = ($FluidTankBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTankBlockEntity$$Original = $FluidTankBlockEntity;}
declare module "com.simibubi.create.content.equipment.bell.AbstractBellBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BellBlock} from "net.minecraft.world.level.block.BellBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BellAttachType} from "net.minecraft.world.level.block.state.properties.BellAttachType"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$AbstractBellBlockEntity} from "com.simibubi.create.content.equipment.bell.AbstractBellBlockEntity"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $AbstractBellBlock<BE extends $AbstractBellBlockEntity> extends $BellBlock implements $IBE$$Interface<(BE)> {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "ATTACHMENT": $EnumProperty<($BellAttachType)>
 "item": $Item
static readonly "CODEC": $MapCodec<($BellBlock)>
static readonly "EVENT_BELL_RING": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "onHit"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockHitResult$$Type, arg3: $Player$$Type, arg4: boolean): boolean
public "canRingFrom"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: double): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "playSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<(BE)>
public "getBlockEntityType"(): $BlockEntityType<(BE)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<(BE)>): void
public "getBlockEntityClass"(): $Class<(BE)>
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<(BE), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<(BE), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): BE
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<(BE)>
get "blockEntityClass"(): $Class<(BE)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractBellBlock$$Type<BE> = ($AbstractBellBlock<(BE)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractBellBlock$$Original<BE> = $AbstractBellBlock<(BE)>;}
declare module "com.simibubi.create.content.contraptions.render.ActorVisual" {
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$VisualizationContext$$Type} from "dev.engine_room.flywheel.api.visualization.VisualizationContext"
import {$MovementContext$$Type} from "com.simibubi.create.content.contraptions.behaviour.MovementContext"
import {$Visual$$Interface} from "dev.engine_room.flywheel.api.visual.Visual"

export class $ActorVisual implements $Visual$$Interface {
constructor(arg0: $VisualizationContext$$Type, arg1: $BlockAndTintGetter$$Type, arg2: $MovementContext$$Type)

public "tick"(): void
public "update"(arg0: float): void
public "delete"(): void
public "beginFrame"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ActorVisual$$Type = ($ActorVisual);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ActorVisual$$Original = $ActorVisual;}
declare module "com.simibubi.create.content.fluids.pipes.GlassFluidPipeBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$RotatedPillarBlock} from "net.minecraft.world.level.block.RotatedPillarBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$AxisPipeBlock} from "com.simibubi.create.content.fluids.pipes.AxisPipeBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$StraightPipeBlockEntity, $StraightPipeBlockEntity$$Type} from "com.simibubi.create.content.fluids.pipes.StraightPipeBlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $GlassFluidPipeBlock extends $AxisPipeBlock implements $IBE$$Interface<($StraightPipeBlockEntity)>, $SimpleWaterloggedBlock$$Interface, $SpecialBlockItemRequirement$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RotatedPillarBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "ALT": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($StraightPipeBlockEntity)>
public "getBlockEntityClass"(): $Class<($StraightPipeBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($StraightPipeBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($StraightPipeBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($StraightPipeBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($StraightPipeBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $StraightPipeBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "getAxisOf"(arg0: $BlockState$$Type): $Direction$Axis
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($StraightPipeBlockEntity)>
get "blockEntityClass"(): $Class<($StraightPipeBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlassFluidPipeBlock$$Type = ($GlassFluidPipeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GlassFluidPipeBlock$$Original = $GlassFluidPipeBlock;}
declare module "com.simibubi.create.content.kinetics.simpleRelays.ICogWheel" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IRotate$SpeedLevel} from "com.simibubi.create.content.kinetics.base.IRotate$SpeedLevel"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IRotate$$Interface} from "com.simibubi.create.content.kinetics.base.IRotate"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $ICogWheel$$Interface extends $IRotate$$Interface {
get "smallCog"(): boolean
get "largeCog"(): boolean
get "dedicatedCogWheel"(): boolean
get "minimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
}

export class $ICogWheel implements $ICogWheel$$Interface {
 "isSmallCog"(): boolean
static "isSmallCog"(arg0: $Block$$Type): boolean
static "isSmallCog"(arg0: $BlockState$$Type): boolean
 "isLargeCog"(): boolean
static "isLargeCog"(arg0: $Block$$Type): boolean
static "isLargeCog"(arg0: $BlockState$$Type): boolean
 "isDedicatedCogWheel"(): boolean
static "isDedicatedCogWheel"(arg0: $Block$$Type): boolean
static "isDedicatedCogItem"(arg0: $ItemStack$$Type): boolean
static "isSmallCogItem"(arg0: $ItemStack$$Type): boolean
static "isLargeCogItem"(arg0: $ItemStack$$Type): boolean
 "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
 "getMinimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
 "hideStressImpact"(): boolean
 "showCapacityWithAnnotation"(): boolean
 "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
 "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
 "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
 "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
 "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ICogWheel$$Type = ($ICogWheel);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ICogWheel$$Original = $ICogWheel;}
declare module "com.simibubi.create.content.redstone.link.controller.LinkedControllerItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$RedstoneLinkNetworkHandler$Frequency} from "com.simibubi.create.content.redstone.link.RedstoneLinkNetworkHandler$Frequency"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IClientItemExtensions$$Type} from "net.neoforged.neoforge.client.extensions.common.IClientItemExtensions"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$ItemStackHandler} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $LinkedControllerItem extends $Item implements $MenuProvider$$Interface {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "initializeClient"(arg0: $Consumer$$Type<($IClientItemExtensions)>): void
public "onItemUseFirst"(arg0: $ItemStack$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public static "getFrequencyItems"(arg0: $ItemStack$$Type): $ItemStackHandler
public static "toFrequency"(arg0: $ItemStack$$Type, arg1: integer): $Couple<($RedstoneLinkNetworkHandler$Frequency)>
public "getDisplayName"(): $Component
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LinkedControllerItem$$Type = ($LinkedControllerItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LinkedControllerItem$$Original = $LinkedControllerItem;}
declare module "com.simibubi.create.content.kinetics.drill.DrillBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DirectionalKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalKineticBlock"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$DrillBlockEntity, $DrillBlockEntity$$Type} from "com.simibubi.create.content.kinetics.drill.DrillBlockEntity"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"

export class $DrillBlock extends $DirectionalKineticBlock implements $IBE$$Interface<($DrillBlockEntity)>, $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($DrillBlockEntity)>
public "getBlockEntityClass"(): $Class<($DrillBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "entityInside"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): void
public static "getDamage"(arg0: float): double
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($DrillBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($DrillBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($DrillBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($DrillBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $DrillBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($DrillBlockEntity)>
get "blockEntityClass"(): $Class<($DrillBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DrillBlock$$Type = ($DrillBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DrillBlock$$Original = $DrillBlock;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType" {
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public static "getPrimaryType"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPointType
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
public static "init"(): void
public "getPriority"(): integer
get "priority"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.CreateArmInteractionPointType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.CreateArmInteractionPointTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmInteractionPointType$$Type = (Special.CreateArmInteractionPointType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmInteractionPointType$$Original = $ArmInteractionPointType;}
declare module "com.simibubi.create.content.contraptions.ContraptionRelocationPacket" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PacketFlow$$Type} from "net.minecraft.network.protocol.PacketFlow"
import {$ClientboundPacketPayload$$Interface} from "net.createmod.catnip.net.base.ClientboundPacketPayload"
import {$FriendlyByteBuf} from "net.minecraft.network.FriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$CustomPacketPayload$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$Type"
import {$StreamDecoder$$Type} from "net.minecraft.network.codec.StreamDecoder"
import {$CustomPacketPayload} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload"
import {$BasePacketPayload$PacketTypeProvider} from "net.createmod.catnip.net.base.BasePacketPayload$PacketTypeProvider"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$StreamMemberEncoder$$Type} from "net.minecraft.network.codec.StreamMemberEncoder"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ServerboundCustomPayloadPacket} from "net.minecraft.network.protocol.common.ServerboundCustomPayloadPacket"
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$ClientboundCustomPayloadPacket} from "net.minecraft.network.protocol.common.ClientboundCustomPayloadPacket"
import {$ConnectionProtocol$$Type} from "net.minecraft.network.ConnectionProtocol"
import {$CustomPacketPayload$TypeAndCodec$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$TypeAndCodec"
import {$CustomPacketPayload$FallbackProvider$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$FallbackProvider"
import {$Record} from "java.lang.Record"

export class $ContraptionRelocationPacket extends $Record implements $ClientboundPacketPayload$$Interface {
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($ContraptionRelocationPacket)>

constructor(entityId: integer)

public "entityId"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "handle"(arg0: $LocalPlayer$$Type): void
public "getTypeProvider"(): $BasePacketPayload$PacketTypeProvider
public "handleInternal"(arg0: $Player$$Type): void
public "type"(): $CustomPacketPayload$Type<($CustomPacketPayload)>
public static "codec"<B extends $FriendlyByteBuf>(arg0: $CustomPacketPayload$FallbackProvider$$Type<(B)>, arg1: $List$$Type<($CustomPacketPayload$TypeAndCodec$$Type<(B), (never)>)>, arg2: $ConnectionProtocol$$Type, arg3: $PacketFlow$$Type): $StreamCodec<(B), ($CustomPacketPayload)>
public static "codec"<B extends $ByteBuf, T extends $CustomPacketPayload>(arg0: $StreamMemberEncoder$$Type<(B), (T)>, arg1: $StreamDecoder$$Type<(B), (T)>): $StreamCodec<(B), (T)>
public "toVanillaClientbound"(): $ClientboundCustomPayloadPacket
public "toVanillaServerbound"(): $ServerboundCustomPayloadPacket
public static "createType"<T extends $CustomPacketPayload>(arg0: StringJS): $CustomPacketPayload$Type<(T)>
get "typeProvider"(): $BasePacketPayload$PacketTypeProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContraptionRelocationPacket$$Type = ({"entityId"?: integer}) | ([entityId?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ContraptionRelocationPacket$$Original = $ContraptionRelocationPacket;}
declare module "com.simibubi.create.content.trains.schedule.Schedule" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ScheduleWaitCondition} from "com.simibubi.create.content.trains.schedule.condition.ScheduleWaitCondition"
import {$List, $List$$Type} from "java.util.List"
import {$Pair, $Pair$$Type} from "net.createmod.catnip.data.Pair"
import {$Component} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ScheduleEntry, $ScheduleEntry$$Type} from "com.simibubi.create.content.trains.schedule.ScheduleEntry"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Supplier} from "java.util.function.Supplier"
import {$ScheduleInstruction} from "com.simibubi.create.content.trains.schedule.destination.ScheduleInstruction"

export class $Schedule {
 "entries": $List<($ScheduleEntry)>
static "CONDITION_TYPES": $List<($Pair<($ResourceLocation), ($Supplier<($ScheduleWaitCondition)>)>)>
static "INSTRUCTION_TYPES": $List<($Pair<($ResourceLocation), ($Supplier<($ScheduleInstruction)>)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Schedule)>
 "cyclic": boolean
 "savedProgress": integer

constructor(arg0: $List$$Type<($ScheduleEntry$$Type)>, arg1: boolean, arg2: integer)
constructor()

public static "getTypeOptions"<T>(arg0: $List$$Type<($Pair$$Type<($ResourceLocation$$Type), (T)>)>): $List<($Component)>
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "fromTag"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): $Schedule
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Schedule$$Type = ($Schedule);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Schedule$$Original = $Schedule;}
declare module "com.simibubi.create.content.contraptions.pulley.PulleyBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$PulleyBlockEntity, $PulleyBlockEntity$$Type} from "com.simibubi.create.content.contraptions.pulley.PulleyBlockEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$HorizontalAxisKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalAxisKineticBlock"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $PulleyBlock extends $HorizontalAxisKineticBlock implements $IBE$$Interface<($PulleyBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "HORIZONTAL_AXIS": $Property<($Direction$Axis)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($PulleyBlockEntity)>
public "getBlockEntityClass"(): $Class<($PulleyBlockEntity)>
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($PulleyBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($PulleyBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PulleyBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PulleyBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $PulleyBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($PulleyBlockEntity)>
get "blockEntityClass"(): $Class<($PulleyBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PulleyBlock$$Type = ($PulleyBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PulleyBlock$$Original = $PulleyBlock;}
declare module "com.simibubi.create.content.trains.bogey.BogeyRenderer" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$MultiBufferSource, $MultiBufferSource$$Type} from "net.minecraft.client.renderer.MultiBufferSource"
import {$PoseStack, $PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"

export interface $BogeyRenderer$$Interface {

(arg0: $CompoundTag, arg1: float, arg2: float, arg3: $PoseStack, arg4: $MultiBufferSource, arg5: integer, arg6: integer, arg7: boolean): void
}

export class $BogeyRenderer implements $BogeyRenderer$$Interface {
 "render"(arg0: $CompoundTag$$Type, arg1: float, arg2: float, arg3: $PoseStack$$Type, arg4: $MultiBufferSource$$Type, arg5: integer, arg6: integer, arg7: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BogeyRenderer$$Type = ((arg0: $CompoundTag, arg1: float, arg2: float, arg3: $PoseStack, arg4: $MultiBufferSource, arg5: integer, arg6: integer, arg7: boolean) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BogeyRenderer$$Original = $BogeyRenderer;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint$Mode" {
import {$Enum} from "java.lang.Enum"

export class $ArmInteractionPoint$Mode extends $Enum<($ArmInteractionPoint$Mode)> {
static readonly "TAKE": $ArmInteractionPoint$Mode
static readonly "DEPOSIT": $ArmInteractionPoint$Mode

public "getTranslationKey"(): StringJS
public static "values"(): ($ArmInteractionPoint$Mode)[]
public static "valueOf"(arg0: StringJS): $ArmInteractionPoint$Mode
public "getColor"(): integer
get "translationKey"(): StringJS
get "color"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmInteractionPoint$Mode$$Type = (("deposit") | ("take"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmInteractionPoint$Mode$$Original = $ArmInteractionPoint$Mode;}
declare module "com.simibubi.create.content.redstone.displayLink.source.PackageAddressDisplaySource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $PackageAddressDisplaySource extends $SingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackageAddressDisplaySource$$Type = ($PackageAddressDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackageAddressDisplaySource$$Original = $PackageAddressDisplaySource;}
declare module "com.simibubi.create.content.kinetics.gauge.GaugeShaper" {
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$VoxelShaper} from "net.createmod.catnip.math.VoxelShaper"

export class $GaugeShaper extends $VoxelShaper {
constructor()

public "get"(arg0: $Direction$$Type, arg1: boolean): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GaugeShaper$$Type = ($GaugeShaper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GaugeShaper$$Original = $GaugeShaper;}
declare module "com.simibubi.create.content.contraptions.actors.roller.RollerBlockEntity$RollingMode" {
import {$Enum} from "java.lang.Enum"
import {$INamedIconOptions$$Interface} from "com.simibubi.create.foundation.blockEntity.behaviour.scrollValue.INamedIconOptions"
import {$AllIcons} from "com.simibubi.create.foundation.gui.AllIcons"

export class $RollerBlockEntity$RollingMode extends $Enum<($RollerBlockEntity$RollingMode)> implements $INamedIconOptions$$Interface {
public "getTranslationKey"(): StringJS
public "getIcon"(): $AllIcons
get "translationKey"(): StringJS
get "icon"(): $AllIcons
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RollerBlockEntity$RollingMode$$Type = (("tunnel_pave") | ("straight_fill") | ("wide_fill") | ("track_replace"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RollerBlockEntity$RollingMode$$Original = $RollerBlockEntity$RollingMode;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$DepotType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$DepotType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$DepotType$$Type = ($AllArmInteractionPointTypes$DepotType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$DepotType$$Original = $AllArmInteractionPointTypes$DepotType;}
declare module "com.simibubi.create.content.decoration.girder.GirderEncasedShaftBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$KineticBlockEntity, $KineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$HorizontalAxisKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalAxisKineticBlock"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $GirderEncasedShaftBlock extends $HorizontalAxisKineticBlock implements $IBE$$Interface<($KineticBlockEntity)>, $SimpleWaterloggedBlock$$Interface, $IWrenchable$$Interface, $SpecialBlockItemRequirement$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "BOTTOM": $BooleanProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "HORIZONTAL_AXIS": $Property<($Direction$Axis)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "TOP": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockSupportShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
public "getBlockEntityClass"(): $Class<($KineticBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($KineticBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($KineticBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($KineticBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($KineticBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $KineticBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
get "blockEntityClass"(): $Class<($KineticBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GirderEncasedShaftBlock$$Type = ($GirderEncasedShaftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GirderEncasedShaftBlock$$Original = $GirderEncasedShaftBlock;}
declare module "com.simibubi.create.content.logistics.filter.PackageFilterItem" {
import {$FilterItemStack} from "com.simibubi.create.content.logistics.filter.FilterItemStack"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$List} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$FilterItem} from "com.simibubi.create.content.logistics.filter.FilterItem"
import {$Component} from "net.minecraft.network.chat.Component"
import {$DataComponentType} from "net.minecraft.core.component.DataComponentType"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$Item} from "net.minecraft.world.item.Item"

export class $PackageFilterItem extends $FilterItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "makeSummary"(arg0: $ItemStack$$Type): $List<($Component)>
public "makeStackWrapper"(arg0: $ItemStack$$Type): $FilterItemStack
public "getFilterItems"(arg0: $ItemStack$$Type): ($ItemStack)[]
public "getComponentType"(): $DataComponentType<(never)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "componentType"(): $DataComponentType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackageFilterItem$$Type = ($PackageFilterItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackageFilterItem$$Original = $PackageFilterItem;}
declare module "com.simibubi.create.content.kinetics.speedController.SpeedControllerBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ScrollValueBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.scrollValue.ScrollValueBehaviour"
import {$KineticBlockEntity, $KineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $SpeedControllerBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "targetSpeed": $ScrollValueBehaviour
static readonly "DEFAULT_SPEED": integer
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "computerBehaviour": $AbstractComputerBehaviour
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public static "getConveyedSpeed"(arg0: $KineticBlockEntity$$Type, arg1: $KineticBlockEntity$$Type, arg2: boolean): float
public static "getDesiredOutputSpeed"(arg0: $KineticBlockEntity$$Type, arg1: $KineticBlockEntity$$Type, arg2: boolean): float
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "updateBracket"(): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpeedControllerBlockEntity$$Type = ($SpeedControllerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpeedControllerBlockEntity$$Original = $SpeedControllerBlockEntity;}
declare module "com.simibubi.create.content.equipment.tool.CardboardSwordItem" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$PlayerInteractEvent$LeftClickBlock$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$LeftClickBlock"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SwordItem} from "net.minecraft.world.item.SwordItem"
import {$Tier} from "net.minecraft.world.item.Tier"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$IClientItemExtensions$$Type} from "net.neoforged.neoforge.client.extensions.common.IClientItemExtensions"
import {$Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$AttackEntityEvent$$Type} from "net.neoforged.neoforge.event.entity.player.AttackEntityEvent"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $CardboardSwordItem extends $SwordItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
 "tier": $Tier
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "initializeClient"(arg0: $Consumer$$Type<($IClientItemExtensions)>): void
public "isBookEnchantable"(arg0: $ItemStack$$Type, arg1: $ItemStack$$Type): boolean
public "supportsEnchantment"(arg0: $ItemStack$$Type, arg1: $Holder$$Type<($Enchantment)>): boolean
public static "cardboardSwordsMakeNoiseOnClick"(arg0: $PlayerInteractEvent$LeftClickBlock$$Type): void
public static "cardboardSwordsCannotHurtYou"(arg0: $AttackEntityEvent$$Type): void
public static "knockback"(arg0: $LivingEntity$$Type, arg1: double, arg2: float): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CardboardSwordItem$$Type = ($CardboardSwordItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CardboardSwordItem$$Original = $CardboardSwordItem;}
declare module "com.simibubi.create.content.logistics.packagerLink.PackagerLinkBlockEntity" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$IdentifiedInventory$$Type} from "com.simibubi.create.content.logistics.packager.IdentifiedInventory"
import {$Direction} from "net.minecraft.core.Direction"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$LinkWithBulbBlockEntity} from "com.simibubi.create.content.redstone.displayLink.LinkWithBulbBlockEntity"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$LogisticallyLinkedBehaviour} from "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBehaviour"
import {$PackagingRequest} from "com.simibubi.create.content.logistics.packager.PackagingRequest"
import {$PackageOrderWithCrafts$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$InventorySummary} from "com.simibubi.create.content.logistics.packager.InventorySummary"
import {$MutableBoolean$$Type} from "org.apache.commons.lang3.mutable.MutableBoolean"
import {$PackagerBlockEntity} from "com.simibubi.create.content.logistics.packager.PackagerBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PackagerLinkBlockEntity extends $LinkWithBulbBlockEntity {
 "placedBy": $UUID
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "behaviour": $LogisticallyLinkedBehaviour

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getPackager"(): $PackagerBlockEntity
public "fetchSummaryFromPackager"(arg0: $IdentifiedInventory$$Type): $InventorySummary
public "playEffect"(): void
public "processRequest"(arg0: $ItemStack$$Type, arg1: integer, arg2: StringJS, arg3: integer, arg4: $MutableBoolean$$Type, arg5: integer, arg6: $PackageOrderWithCrafts$$Type, arg7: $IdentifiedInventory$$Type): $Pair<($PackagerBlockEntity), ($PackagingRequest)>
public "getBulbFacing"(arg0: $BlockState$$Type): $Direction
public "getBulbOffset"(arg0: $BlockState$$Type): $Vec3
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "initialize"(): void
get "packager"(): $PackagerBlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagerLinkBlockEntity$$Type = ($PackagerLinkBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagerLinkBlockEntity$$Original = $PackagerLinkBlockEntity;}
declare module "com.simibubi.create.content.redstone.link.RedstoneLinkNetworkHandler$Frequency" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"

export class $RedstoneLinkNetworkHandler$Frequency {
static readonly "EMPTY": $RedstoneLinkNetworkHandler$Frequency

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "of"(arg0: $ItemStack$$Type): $RedstoneLinkNetworkHandler$Frequency
public "getStack"(): $ItemStack
get "stack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneLinkNetworkHandler$Frequency$$Type = ($RedstoneLinkNetworkHandler$Frequency);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneLinkNetworkHandler$Frequency$$Original = $RedstoneLinkNetworkHandler$Frequency;}
declare module "com.simibubi.create.content.contraptions.actors.roller.RollerBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$FilteringBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.filtering.FilteringBehaviour"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$RollerBlockEntity$RollingMode} from "com.simibubi.create.content.contraptions.actors.roller.RollerBlockEntity$RollingMode"
import {$List$$Type} from "java.util.List"
import {$ScrollOptionBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.scrollValue.ScrollOptionBehaviour"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RollerBlockEntity extends $SmartBlockEntity {
 "mode": $ScrollOptionBehaviour<($RollerBlockEntity$RollingMode)>
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "filtering": $FilteringBehaviour

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getAnimatedSpeed"(): float
public "setAnimatedSpeed"(arg0: float): void
public "shareValuesToAdjacent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "searchForSharedValues"(): void
get "animatedSpeed"(): float
set "animatedSpeed"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RollerBlockEntity$$Type = ($RollerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RollerBlockEntity$$Original = $RollerBlockEntity;}
declare module "com.simibubi.create.content.trains.graph.EdgeData" {
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TrackEdgePoint, $TrackEdgePoint$$Type} from "com.simibubi.create.content.trains.signal.TrackEdgePoint"
import {$ISwitchDisabledEdge$$Interface} from "com.railwayteam.railways.mixin_interfaces.ISwitchDisabledEdge"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$List} from "java.util.List"
import {$TrackEdgeIntersection} from "com.simibubi.create.content.trains.graph.TrackEdgeIntersection"
import {$EdgePointType$$Type} from "com.simibubi.create.content.trains.graph.EdgePointType"
import {$TrackEdge$$Type} from "com.simibubi.create.content.trains.graph.TrackEdge"

export class $EdgeData implements $ISwitchDisabledEdge$$Interface {
static readonly "passiveGroup": $UUID

constructor(arg0: $TrackEdge$$Type)

public "setSingleSignalGroup"(arg0: $TrackGraph$$Type, arg1: $UUID$$Type): void
public "hasSignalBoundaries"(): boolean
public "getSingleSignalGroup"(): $UUID
public "getEffectiveEdgeGroupId"(arg0: $TrackGraph$$Type): $UUID
public "getPoints"(): $List<($TrackEdgePoint)>
public "setAutomatic"(arg0: boolean): void
public "removePoint"(arg0: $TrackGraph$$Type, arg1: $TrackEdgePoint$$Type): void
public "getAutomaticallySelectedPriority"(): integer
public "isAutomaticallySelected"(): boolean
public "ackAutomaticSelection"(): void
public "hasPoints"(): boolean
public "addPoint"<T extends $TrackEdgePoint>(arg0: $TrackGraph$$Type, arg1: $TrackEdgePoint$$Type): void
public "getIntersections"(): $List<($TrackEdgeIntersection)>
public "addIntersection"(arg0: $TrackGraph$$Type, arg1: $UUID$$Type, arg2: double, arg3: $TrackNode$$Type, arg4: $TrackNode$$Type, arg5: double): void
public "getGroupAtPosition"(arg0: $TrackGraph$$Type, arg1: double): $UUID
public "refreshIntersectingSignalGroups"(arg0: $TrackGraph$$Type): void
public "setAutomaticallySelected"(): void
public "hasIntersections"(): boolean
public "removeIntersection"(arg0: $TrackGraph$$Type, arg1: $UUID$$Type): void
public "get"<T extends $TrackEdgePoint>(arg0: $EdgePointType$$Type<(T)>, arg1: double): T
public "next"(arg0: double): $TrackEdgePoint
public "next"<T extends $TrackEdgePoint>(arg0: $EdgePointType$$Type<(T)>, arg1: double): T
public "isEnabled"(): boolean
public "write"(arg0: $DimensionPalette$$Type): $CompoundTag
public static "read"(arg0: $CompoundTag$$Type, arg1: $TrackEdge$$Type, arg2: $TrackGraph$$Type, arg3: $DimensionPalette$$Type): $EdgeData
public "isAutomatic"(): boolean
public "setEnabled"(arg0: boolean): void
public static "isDisabled"(arg0: $TrackEdge$$Type): boolean
public static "automaticallySelect"(arg0: $TrackEdge$$Type): void
public static "isEnabled"(arg0: $TrackEdge$$Type): boolean
public static "isAutomatic"(arg0: $TrackEdge$$Type): boolean
get "singleSignalGroup"(): $UUID
get "points"(): $List<($TrackEdgePoint)>
set "automatic"(value: boolean)
get "automaticallySelectedPriority"(): integer
get "automaticallySelected"(): boolean
get "intersections"(): $List<($TrackEdgeIntersection)>
get "automaticallySelected"(): void
get "enabled"(): boolean
get "automatic"(): boolean
set "enabled"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EdgeData$$Type = ($EdgeData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EdgeData$$Original = $EdgeData;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$MillstoneType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$MillstoneType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$MillstoneType$$Type = ($AllArmInteractionPointTypes$MillstoneType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$MillstoneType$$Original = $AllArmInteractionPointTypes$MillstoneType;}
declare module "com.simibubi.create.content.kinetics.clock.CuckooClockBlockEntity" {
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$CuckooClockBlockEntity$Animation, $CuckooClockBlockEntity$Animation$$Type} from "com.simibubi.create.content.kinetics.clock.CuckooClockBlockEntity$Animation"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CuckooClockBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "minuteHand": $LerpedFloat
 "updateSpeed": boolean
 "animationProgress": $LerpedFloat
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "hourHand": $LerpedFloat
 "animationType": $CuckooClockBlockEntity$Animation
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "moveHands"(arg0: integer, arg1: integer): void
public "startAnimation"(arg0: $CuckooClockBlockEntity$Animation$$Type): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CuckooClockBlockEntity$$Type = ($CuckooClockBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CuckooClockBlockEntity$$Original = $CuckooClockBlockEntity;}
declare module "com.simibubi.create.content.equipment.goggles.GogglesItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Holder} from "net.minecraft.core.Holder"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Equipable, $Equipable$$Interface} from "net.minecraft.world.item.Equipable"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot} from "net.minecraft.world.entity.EquipmentSlot"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $GogglesItem extends $Item implements $Equipable$$Interface {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public static "addIsWearingPredicate"(arg0: $Predicate$$Type<($Player)>): void
public static "isWearingGoggles"(arg0: $Player$$Type): boolean
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "getEquipmentSlot"(): $EquipmentSlot
public "swapWithEquipmentSlot"(arg0: $Item$$Type, arg1: $Level$$Type, arg2: $Player$$Type, arg3: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public "getEquipSound"(): $Holder<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "equipmentSlot"(): $EquipmentSlot
get "equipSound"(): $Holder<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GogglesItem$$Type = ($GogglesItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GogglesItem$$Original = $GogglesItem;}
declare module "com.simibubi.create.content.kinetics.press.PressingBehaviour$Mode" {
import {$Enum} from "java.lang.Enum"

export class $PressingBehaviour$Mode extends $Enum<($PressingBehaviour$Mode)> {
 "headOffset": float
static readonly "BELT": $PressingBehaviour$Mode
static readonly "BASIN": $PressingBehaviour$Mode
static readonly "WORLD": $PressingBehaviour$Mode

public static "values"(): ($PressingBehaviour$Mode)[]
public static "valueOf"(arg0: StringJS): $PressingBehaviour$Mode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressingBehaviour$Mode$$Type = (("world") | ("belt") | ("basin"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PressingBehaviour$Mode$$Original = $PressingBehaviour$Mode;}
declare module "com.simibubi.create.content.kinetics.flywheel.FlywheelBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$FlywheelBlockEntity, $FlywheelBlockEntity$$Type} from "com.simibubi.create.content.kinetics.flywheel.FlywheelBlockEntity"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RotatedPillarKineticBlock} from "com.simibubi.create.content.kinetics.base.RotatedPillarKineticBlock"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $FlywheelBlock extends $RotatedPillarKineticBlock implements $IBE$$Interface<($FlywheelBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($FlywheelBlockEntity)>
public "getBlockEntityClass"(): $Class<($FlywheelBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($FlywheelBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($FlywheelBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FlywheelBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FlywheelBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $FlywheelBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
get "blockEntityType"(): $BlockEntityType<($FlywheelBlockEntity)>
get "blockEntityClass"(): $Class<($FlywheelBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlywheelBlock$$Type = ($FlywheelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlywheelBlock$$Original = $FlywheelBlock;}
declare module "com.simibubi.create.content.kinetics.belt.BeltPart" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BeltPart extends $Enum<($BeltPart)> implements $StringRepresentable$$Interface {
static readonly "START": $BeltPart
static readonly "END": $BeltPart
static readonly "MIDDLE": $BeltPart
static readonly "PULLEY": $BeltPart

public static "values"(): ($BeltPart)[]
public static "valueOf"(arg0: StringJS): $BeltPart
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltPart$$Type = (("start") | ("middle") | ("end") | ("pulley"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltPart$$Original = $BeltPart;}
declare module "com.simibubi.create.content.decoration.encasing.CasingBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CasingBlock extends $Block implements $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CasingBlock$$Type = ($CasingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CasingBlock$$Original = $CasingBlock;}
declare module "com.simibubi.create.content.decoration.slidingDoor.SlidingDoorBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$SlidingDoorBlockEntityAccessor$$Interface} from "com.copycatsplus.copycats.mixin.copycat.sliding_door.SlidingDoorBlockEntityAccessor"
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$SlidingDoorMode$IHasDoorMode$$Interface} from "com.railwayteam.railways.content.extended_sliding_doors.SlidingDoorMode$IHasDoorMode"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$SlidingDoorMode} from "com.railwayteam.railways.content.extended_sliding_doors.SlidingDoorMode"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SlidingDoorBlockEntity extends $SmartBlockEntity implements $SlidingDoorMode$IHasDoorMode$$Interface, $SlidingDoorBlockEntityAccessor$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "railways$getSlidingDoorMode"(): $SlidingDoorMode
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "tick"(): void
public static "isOpen"(arg0: $BlockState$$Type): boolean
public "getAnimation"(): $LerpedFloat
get "animation"(): $LerpedFloat
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlidingDoorBlockEntity$$Type = ($SlidingDoorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlidingDoorBlockEntity$$Original = $SlidingDoorBlockEntity;}
declare module "com.simibubi.create.content.trains.entity.TravellingPoint" {
import {$TravellingPoint$SteerDirection$$Type} from "com.simibubi.create.content.trains.entity.TravellingPoint$SteerDirection"
import {$TrackGraphLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackGraphLocation"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TravellingPoint$IEdgePointListener, $TravellingPoint$IEdgePointListener$$Type} from "com.simibubi.create.content.trains.entity.TravellingPoint$IEdgePointListener"
import {$List$$Type} from "java.util.List"
import {$TrackEdge, $TrackEdge$$Type} from "com.simibubi.create.content.trains.graph.TrackEdge"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TravellingPoint$ITurnListener, $TravellingPoint$ITurnListener$$Type} from "com.simibubi.create.content.trains.entity.TravellingPoint$ITurnListener"
import {$TravellingPoint$ITrackSelector, $TravellingPoint$ITrackSelector$$Type} from "com.simibubi.create.content.trains.entity.TravellingPoint$ITrackSelector"
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$TrackNode, $TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$TravellingPoint$IPortalListener, $TravellingPoint$IPortalListener$$Type} from "com.simibubi.create.content.trains.entity.TravellingPoint$IPortalListener"

export class $TravellingPoint {
 "node2": $TrackNode
 "edge": $TrackEdge
 "blocked": boolean
 "position": double
 "node1": $TrackNode
 "upsideDown": boolean

constructor(arg0: $TrackNode$$Type, arg1: $TrackNode$$Type, arg2: $TrackEdge$$Type, arg3: double, arg4: boolean)
constructor()

public "steer"(arg0: $TravellingPoint$SteerDirection$$Type, arg1: $Vec3$$Type): $TravellingPoint$ITrackSelector
public "ignoreTurns"(): $TravellingPoint$ITurnListener
public "ignorePortals"(): $TravellingPoint$IPortalListener
public "ignoreEdgePoints"(): $TravellingPoint$IEdgePointListener
public "getPositionWithOffset"(arg0: $TrackGraph$$Type, arg1: double, arg2: boolean): $Vec3
public "migrateTo"(arg0: $List$$Type<($TrackGraphLocation$$Type)>): void
public "reverse"(arg0: $TrackGraph$$Type): void
public "write"(arg0: $DimensionPalette$$Type): $CompoundTag
public static "read"(arg0: $CompoundTag$$Type, arg1: $TrackGraph$$Type, arg2: $DimensionPalette$$Type): $TravellingPoint
public "random"(): $TravellingPoint$ITrackSelector
public "getPosition"(arg0: $TrackGraph$$Type): $Vec3
public "getPosition"(arg0: $TrackGraph$$Type, arg1: boolean): $Vec3
public "follow"(arg0: $TravellingPoint$$Type, arg1: $Consumer$$Type<(boolean)>): $TravellingPoint$ITrackSelector
public "follow"(arg0: $TravellingPoint$$Type): $TravellingPoint$ITrackSelector
public "travel"(arg0: $TrackGraph$$Type, arg1: double, arg2: $TravellingPoint$ITrackSelector$$Type, arg3: $TravellingPoint$IEdgePointListener$$Type, arg4: $TravellingPoint$ITurnListener$$Type): double
public "travel"(arg0: $TrackGraph$$Type, arg1: double, arg2: $TravellingPoint$ITrackSelector$$Type, arg3: $TravellingPoint$IEdgePointListener$$Type, arg4: $TravellingPoint$ITurnListener$$Type, arg5: $TravellingPoint$IPortalListener$$Type): double
public "travel"(arg0: $TrackGraph$$Type, arg1: double, arg2: $TravellingPoint$ITrackSelector$$Type): double
public "travel"(arg0: $TrackGraph$$Type, arg1: double, arg2: $TravellingPoint$ITrackSelector$$Type, arg3: $TravellingPoint$IEdgePointListener$$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TravellingPoint$$Type = ($TravellingPoint);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TravellingPoint$$Original = $TravellingPoint;}
declare module "com.simibubi.create.content.trains.bogey.BogeyStyle$SizeRenderer" {
import {$BogeyRenderer, $BogeyRenderer$$Type} from "com.simibubi.create.content.trains.bogey.BogeyRenderer"
import {$BogeyVisualizer, $BogeyVisualizer$$Type} from "com.simibubi.create.content.trains.bogey.BogeyVisualizer"
import {$Record} from "java.lang.Record"

export class $BogeyStyle$SizeRenderer extends $Record {
constructor(renderer: $BogeyRenderer$$Type, visualizer: $BogeyVisualizer$$Type)

public "visualizer"(): $BogeyVisualizer
public "renderer"(): $BogeyRenderer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BogeyStyle$SizeRenderer$$Type = ({"visualizer"?: $BogeyVisualizer$$Type, "renderer"?: $BogeyRenderer$$Type}) | ([visualizer?: $BogeyVisualizer$$Type, renderer?: $BogeyRenderer$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BogeyStyle$SizeRenderer$$Original = $BogeyStyle$SizeRenderer;}
declare module "com.simibubi.create.content.kinetics.belt.BeltBlock" {
import {$LootParams$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootParams$Builder"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BeltSlope} from "com.simibubi.create.content.kinetics.belt.BeltSlope"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$HorizontalKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalKineticBlock"
import {$BeltBlockEntity, $BeltBlockEntity$$Type} from "com.simibubi.create.content.kinetics.belt.BeltBlockEntity"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BeltPart} from "com.simibubi.create.content.kinetics.belt.BeltPart"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$TransformableBlock$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlock"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $BeltBlock extends $HorizontalKineticBlock implements $IBE$$Interface<($BeltBlockEntity)>, $SpecialBlockItemRequirement$$Interface, $TransformableBlock$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "CASING": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "PART": $Property<($BeltPart)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "SLOPE": $Property<($BeltSlope)>
static readonly "HORIZONTAL_FACING": $Property<($Direction)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getBlockPathType"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type): $PathType
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getDrops"(arg0: $BlockState$$Type, arg1: $LootParams$Builder$$Type): $List<($ItemStack)>
public "spawnAfterBreak"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: boolean): void
public "isFlammable"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public static "nextSegmentPosition"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: boolean): $BlockPos
public "getBlockEntityType"(): $BlockEntityType<($BeltBlockEntity)>
public "getBlockEntityClass"(): $Class<($BeltBlockEntity)>
public static "canTransportObjects"(arg0: $BlockState$$Type): boolean
public "updateCoverProperty"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public static "initBelt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "getBeltChain"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): $List<($BlockPos)>
public static "isBlockCoveringBelt"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "transform"(arg0: $BlockState$$Type, arg1: $StructureTransform$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "entityInside"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($BeltBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($BeltBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BeltBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BeltBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $BeltBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($BeltBlockEntity)>
get "blockEntityClass"(): $Class<($BeltBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltBlock$$Type = ($BeltBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltBlock$$Original = $BeltBlock;}
declare module "com.simibubi.create.content.contraptions.chassis.StickerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$StickerBlockEntity, $StickerBlockEntity$$Type} from "com.simibubi.create.content.contraptions.chassis.StickerBlockEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $StickerBlock extends $WrenchableDirectionalBlock implements $IBE$$Interface<($StickerBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "EXTENDED": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($StickerBlockEntity)>
public "getBlockEntityClass"(): $Class<($StickerBlockEntity)>
public "addLandingEffects"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $LivingEntity$$Type, arg5: integer): boolean
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "stepOn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type): void
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public "addRunningEffects"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($StickerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($StickerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($StickerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($StickerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $StickerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($StickerBlockEntity)>
get "blockEntityClass"(): $Class<($StickerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StickerBlock$$Type = ($StickerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StickerBlock$$Original = $StickerBlock;}
declare module "com.simibubi.create.content.equipment.zapper.PlacementPatterns" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$List$$Type} from "java.util.List"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AllIcons} from "com.simibubi.create.foundation.gui.AllIcons"

export class $PlacementPatterns extends $Enum<($PlacementPatterns)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($PlacementPatterns)>
readonly "translationKey": StringJS
static readonly "Chance50": $PlacementPatterns
readonly "icon": $AllIcons
static readonly "Chance75": $PlacementPatterns
static readonly "InverseCheckered": $PlacementPatterns
static readonly "Solid": $PlacementPatterns
static readonly "Chance25": $PlacementPatterns
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($PlacementPatterns)>
static readonly "Checkered": $PlacementPatterns

public static "applyPattern"(arg0: $List$$Type<($BlockPos$$Type)>, arg1: $ItemStack$$Type, arg2: $RandomSource$$Type): void
public static "values"(): ($PlacementPatterns)[]
public static "valueOf"(arg0: StringJS): $PlacementPatterns
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacementPatterns$$Type = (("solid") | ("checkered") | ("inversecheckered") | ("chance25") | ("chance50") | ("chance75"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacementPatterns$$Original = $PlacementPatterns;}
declare module "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelConnection" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$FactoryPanelPosition, $FactoryPanelPosition$$Type} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelPosition"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FactoryPanelConnection {
 "path": $List<($Direction)>
 "amount": integer
static readonly "CODEC": $Codec<($FactoryPanelConnection)>
 "cachedSource": $WeakReference<(any)>
 "success": boolean
 "from": $FactoryPanelPosition
 "arrowBendMode": integer

constructor(arg0: $FactoryPanelPosition$$Type, arg1: integer)
constructor(arg0: $FactoryPanelPosition$$Type, arg1: integer, arg2: integer)

public "calculatePathDiff"(arg0: $BlockState$$Type, arg1: $FactoryPanelPosition$$Type): $Vec3
public "getPath"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $FactoryPanelPosition$$Type): $List<($Direction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryPanelConnection$$Type = ($FactoryPanelConnection);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FactoryPanelConnection$$Original = $FactoryPanelConnection;}
declare module "com.simibubi.create.content.schematics.requirement.ItemRequirement" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$ItemRequirement$ItemUseType$$Type} from "com.simibubi.create.content.schematics.requirement.ItemRequirement$ItemUseType"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$ItemRequirement$StackRequirement, $ItemRequirement$StackRequirement$$Type} from "com.simibubi.create.content.schematics.requirement.ItemRequirement$StackRequirement"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ItemRequirement {
static readonly "NONE": $ItemRequirement
static readonly "INVALID": $ItemRequirement

constructor(arg0: $List$$Type<($ItemRequirement$StackRequirement$$Type)>)
constructor(arg0: $ItemRequirement$StackRequirement$$Type)
constructor(arg0: $ItemRequirement$ItemUseType$$Type, arg1: $ItemStack$$Type)
constructor(arg0: $ItemRequirement$ItemUseType$$Type, arg1: $Item$$Type)
constructor(arg0: $ItemRequirement$ItemUseType$$Type, arg1: $List$$Type<($ItemStack$$Type)>)

public "getRequiredItems"(): $List<($ItemRequirement$StackRequirement)>
public "union"(arg0: $ItemRequirement$$Type): $ItemRequirement
public "isEmpty"(): boolean
public static "of"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public static "of"(arg0: $Entity$$Type): $ItemRequirement
public "isInvalid"(): boolean
get "requiredItems"(): $List<($ItemRequirement$StackRequirement)>
get "empty"(): boolean
get "invalid"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRequirement$$Type = ($ItemRequirement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemRequirement$$Original = $ItemRequirement;}
declare module "com.simibubi.create.content.redstone.link.controller.LecternControllerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LecternControllerBlockEntity, $LecternControllerBlockEntity$$Type} from "com.simibubi.create.content.redstone.link.controller.LecternControllerBlockEntity"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LecternBlock} from "net.minecraft.world.level.block.LecternBlock"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $LecternControllerBlock extends $LecternBlock implements $IBE$$Interface<($LecternControllerBlockEntity)>, $SpecialBlockItemRequirement$$Interface {
static readonly "SHAPE_NORTH": $VoxelShape
static readonly "SHAPE_SOUTH": $VoxelShape
static readonly "SHAPE_BASE": $VoxelShape
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "HAS_BOOK": $BooleanProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "SHAPE_COMMON": $VoxelShape
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE_POST": $VoxelShape
static readonly "SHAPE_TOP_PLATE": $VoxelShape
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "SHAPE_COLLISION": $VoxelShape
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "SHAPE_WEST": $VoxelShape
 "item": $Item
static readonly "CODEC": $MapCodec<($LecternBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "POWERED": $BooleanProperty
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "SHAPE_EAST": $VoxelShape

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($LecternControllerBlockEntity)>
public "getBlockEntityClass"(): $Class<($LecternControllerBlockEntity)>
public "replaceWithLectern"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): void
public "replaceLectern"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type): void
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($LecternControllerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($LecternControllerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($LecternControllerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($LecternControllerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $LecternControllerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($LecternControllerBlockEntity)>
get "blockEntityClass"(): $Class<($LecternControllerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LecternControllerBlock$$Type = ($LecternControllerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LecternControllerBlock$$Original = $LecternControllerBlock;}
declare module "com.simibubi.create.content.trains.track.TrackTargetingBehaviour$RenderedTrackOverlayType" {
import {$Enum} from "java.lang.Enum"

export class $TrackTargetingBehaviour$RenderedTrackOverlayType extends $Enum<($TrackTargetingBehaviour$RenderedTrackOverlayType)> {
static readonly "SIGNAL": $TrackTargetingBehaviour$RenderedTrackOverlayType
static readonly "STATION": $TrackTargetingBehaviour$RenderedTrackOverlayType
static readonly "DUAL_SIGNAL": $TrackTargetingBehaviour$RenderedTrackOverlayType
static readonly "OBSERVER": $TrackTargetingBehaviour$RenderedTrackOverlayType

public static "values"(): ($TrackTargetingBehaviour$RenderedTrackOverlayType)[]
public static "valueOf"(arg0: StringJS): $TrackTargetingBehaviour$RenderedTrackOverlayType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackTargetingBehaviour$RenderedTrackOverlayType$$Type = (("station") | ("signal") | ("dual_signal") | ("observer"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackTargetingBehaviour$RenderedTrackOverlayType$$Original = $TrackTargetingBehaviour$RenderedTrackOverlayType;}
declare module "com.simibubi.create.content.trains.track.FakeTrackBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$EntityBlock$$Interface} from "net.minecraft.world.level.block.EntityBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $FakeTrackBlock extends $Block implements $EntityBlock$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockPathType"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type): $PathType
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "randomTick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "keepAlive"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "addLandingEffects"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $LivingEntity$$Type, arg5: integer): boolean
public "addRunningEffects"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FakeTrackBlock$$Type = ($FakeTrackBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FakeTrackBlock$$Original = $FakeTrackBlock;}
declare module "com.simibubi.create.content.equipment.wrench.IWrenchableWithBracket" {
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $IWrenchableWithBracket$$Interface extends $IWrenchable$$Interface {

(arg0: $BlockGetter, arg1: $BlockPos, arg2: boolean): ($ItemStack$$Type)?
}

export class $IWrenchableWithBracket implements $IWrenchableWithBracket$$Interface {
 "tryRemoveBracket"(arg0: $UseOnContext$$Type): boolean
 "removeBracket"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: boolean): $Optional<($ItemStack)>
 "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
 "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
 "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
 "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IWrenchableWithBracket$$Type = ((arg0: $BlockGetter, arg1: $BlockPos, arg2: boolean) => ($ItemStack$$Type)?);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IWrenchableWithBracket$$Original = $IWrenchableWithBracket;}
declare module "com.simibubi.create.content.logistics.depot.EjectorBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$DirectBeltInputBehaviour} from "com.simibubi.create.content.kinetics.belt.behaviour.DirectBeltInputBehaviour"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$EjectorBlockEntity$State} from "com.simibubi.create.content.logistics.depot.EjectorBlockEntity$State"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB} from "net.minecraft.world.phys.AABB"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EjectorBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "deployElytra"(arg0: $Player$$Type): void
public "activateDeferred"(): void
public "getWindUpSpeed"(): float
public "getLaunchedItemLocation"(arg0: float): $Vec3
public "getTargetOpenInv"(): $DirectBeltInputBehaviour
public "getLaunchedItemMotion"(arg0: float): $Vec3
public "dropFlyingItems"(): void
public "getLidProgress"(arg0: float): float
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getRenderBoundingBox"(): $AABB
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "updateSignal"(): void
public "getTargetPosition"(): $BlockPos
public "tick"(): void
public "initialize"(): void
public "getState"(): $EjectorBlockEntity$State
public "destroy"(): void
public "setTarget"(arg0: integer, arg1: integer): void
public "activate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
get "windUpSpeed"(): float
get "targetOpenInv"(): $DirectBeltInputBehaviour
get "renderBoundingBox"(): $AABB
get "targetPosition"(): $BlockPos
get "state"(): $EjectorBlockEntity$State
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EjectorBlockEntity$$Type = ($EjectorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EjectorBlockEntity$$Original = $EjectorBlockEntity;}
declare module "com.simibubi.create.content.redstone.displayLink.target.NixieTubeDisplayTarget" {
import {$SingleLineDisplayTarget} from "com.simibubi.create.content.redstone.displayLink.target.SingleLineDisplayTarget"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$AABB} from "net.minecraft.world.phys.AABB"
import {$DisplayTarget} from "com.simibubi.create.api.behaviour.display.DisplayTarget"

export class $NixieTubeDisplayTarget extends $SingleLineDisplayTarget {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry<($BlockEntityType<(never)>), ($DisplayTarget)>
static readonly "BY_BLOCK": $SimpleRegistry<($Block), ($DisplayTarget)>

constructor()

public "getMultiblockBounds"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): $AABB
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NixieTubeDisplayTarget$$Type = ($NixieTubeDisplayTarget);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NixieTubeDisplayTarget$$Original = $NixieTubeDisplayTarget;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.attributes.AddedByAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $AddedByAttribute$Type implements $ItemAttributeType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddedByAttribute$Type$$Type = ($AddedByAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AddedByAttribute$Type$$Original = $AddedByAttribute$Type;}
declare module "com.simibubi.create.content.contraptions.ControlledContraptionEntity" {
import {$AbstractContraptionEntity$ContraptionRotationState} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity$ContraptionRotationState"
import {$Map} from "java.util.Map"
import {$Optional} from "java.util.Optional"
import {$PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$Entity$RemovalReason} from "net.minecraft.world.entity.Entity$RemovalReason"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AbstractContraptionEntity} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$Direction$Axis, $Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$IControlContraption$$Type} from "com.simibubi.create.content.contraptions.IControlContraption"
import {$ScoreHolder} from "net.minecraft.world.scores.ScoreHolder"
import {$EntityInLevelCallback} from "net.minecraft.world.level.entity.EntityInLevelCallback"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$MutableInt} from "org.apache.commons.lang3.mutable.MutableInt"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$PortalProcessor} from "net.minecraft.world.entity.PortalProcessor"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $ControlledContraptionEntity extends $AbstractContraptionEntity {
 "hasImpulse": boolean
 "tickCount": integer
 "noPhysics": boolean
 "yo": double
static readonly "BOARDING_COOLDOWN": integer
 "removalReason": $Entity$RemovalReason
 "yRotO": float
static readonly "CONTENTS_SLOT_INDEX": integer
 "level": $Level
 "moveDist": float
static readonly "ID_TAG": StringJS
 "mainSupportingBlockPos": $Optional<($BlockPos)>
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
 "xRotO": float
 "zo": double
 "walkDist": float
 "xOld": double
 "noCulling": boolean
 "wasInPowderSnow": boolean
 "hurtMarked": boolean
 "staleTicks": integer
 "invulnerableTime": integer
static readonly "UUID_TAG": StringJS
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
 "fallDistance": float
 "portalProcess": $PortalProcessor
 "verticalCollision": boolean
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
 "verticalCollisionBelow": boolean
 "yOld": double
static readonly "DEFAULT_BB_WIDTH": float
 "minorHorizontalCollision": boolean
static readonly "DEFAULT_BB_HEIGHT": float
 "levelCallback": $EntityInLevelCallback
 "walkDistO": float
static readonly "FREEZE_HURT_FREQUENCY": integer
 "flyDist": float
 "isInPowderSnow": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
static readonly "PASSENGERS_TAG": StringJS
 "blocksBuilding": boolean
 "wasOnFire": boolean
 "zOld": double
static readonly "TOTAL_AIR_SUPPLY": integer
 "xo": double
readonly "collidingEntities": $Map<($Entity), ($MutableInt)>
static readonly "BASE_SAFE_FALL_DISTANCE": integer
 "wasTouchingWater": boolean
 "horizontalCollision": boolean

constructor(arg0: $EntityType$$Type<(never)>, arg1: $Level$$Type)

public "setAngle"(arg0: float): void
public "getRotationAxis"(): $Direction$Axis
public "getAngle"(arg0: float): float
public "setRotationAxis"(arg0: $Direction$Axis$$Type): void
public "getRotationState"(): $AbstractContraptionEntity$ContraptionRotationState
public "applyRotation"(arg0: $Vec3$$Type, arg1: float): $Vec3
public "reverseRotation"(arg0: $Vec3$$Type, arg1: float): $Vec3
public "getContactPointMotion"(arg0: $Vec3$$Type): $Vec3
public "applyLocalTransforms"(arg0: $PoseStack$$Type, arg1: float): void
public static "create"(arg0: $Level$$Type, arg1: $IControlContraption$$Type, arg2: $Contraption$$Type): $ControlledContraptionEntity
public "setPos"(arg0: double, arg1: double, arg2: double): void
public "lerpTo"(arg0: double, arg1: double, arg2: double, arg3: float, arg4: float, arg5: integer): void
public "teleportTo"(arg0: double, arg1: double, arg2: double): void
public static "forNameOnly"(arg0: StringJS): $ScoreHolder
public static "fromGameProfile"(arg0: $GameProfile$$Type): $ScoreHolder
/**
 * 
 * @deprecated
 */
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
set "angle"(value: float)
get "rotationAxis"(): $Direction$Axis
set "rotationAxis"(value: $Direction$Axis$$Type)
get "rotationState"(): $AbstractContraptionEntity$ContraptionRotationState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ControlledContraptionEntity$$Type = ($ControlledContraptionEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ControlledContraptionEntity$$Original = $ControlledContraptionEntity;}
declare module "com.simibubi.create.content.kinetics.transmission.GearshiftBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SplitShaftBlockEntity, $SplitShaftBlockEntity$$Type} from "com.simibubi.create.content.kinetics.transmission.SplitShaftBlockEntity"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$AbstractEncasedShaftBlock} from "com.simibubi.create.content.kinetics.base.AbstractEncasedShaftBlock"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $GearshiftBlock extends $AbstractEncasedShaftBlock implements $IBE$$Interface<($SplitShaftBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "detachKinetics"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: boolean): void
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($SplitShaftBlockEntity)>
public "getBlockEntityClass"(): $Class<($SplitShaftBlockEntity)>
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SplitShaftBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SplitShaftBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SplitShaftBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SplitShaftBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SplitShaftBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SplitShaftBlockEntity)>
get "blockEntityClass"(): $Class<($SplitShaftBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GearshiftBlock$$Type = ($GearshiftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GearshiftBlock$$Original = $GearshiftBlock;}
declare module "com.simibubi.create.content.kinetics.motor.CreativeMotorBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DirectionalKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalKineticBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$CreativeMotorBlockEntity, $CreativeMotorBlockEntity$$Type} from "com.simibubi.create.content.kinetics.motor.CreativeMotorBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $CreativeMotorBlock extends $DirectionalKineticBlock implements $IBE$$Interface<($CreativeMotorBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "hideStressImpact"(): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($CreativeMotorBlockEntity)>
public "getBlockEntityClass"(): $Class<($CreativeMotorBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($CreativeMotorBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($CreativeMotorBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CreativeMotorBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CreativeMotorBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $CreativeMotorBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($CreativeMotorBlockEntity)>
get "blockEntityClass"(): $Class<($CreativeMotorBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeMotorBlock$$Type = ($CreativeMotorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeMotorBlock$$Original = $CreativeMotorBlock;}
declare module "com.simibubi.create.content.logistics.tunnel.BeltTunnelBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$BeltTunnelBlockEntity, $BeltTunnelBlockEntity$$Type} from "com.simibubi.create.content.logistics.tunnel.BeltTunnelBlockEntity"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BeltTunnelBlock$Shape} from "com.simibubi.create.content.logistics.tunnel.BeltTunnelBlock$Shape"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $BeltTunnelBlock extends $Block implements $IBE$$Interface<($BeltTunnelBlockEntity)>, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "HORIZONTAL_AXIS": $Property<($Direction$Axis)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $Property<($BeltTunnelBlock$Shape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "isStraight"(arg0: $BlockState$$Type): boolean
public "getBlockEntityType"(): $BlockEntityType<($BeltTunnelBlockEntity)>
public static "hasWindow"(arg0: $BlockState$$Type): boolean
public "getBlockEntityClass"(): $Class<($BeltTunnelBlockEntity)>
public static "isJunction"(arg0: $BlockState$$Type): boolean
public "updateTunnel"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): void
public "isValidPositionForPlacement"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($BeltTunnelBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($BeltTunnelBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BeltTunnelBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BeltTunnelBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $BeltTunnelBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($BeltTunnelBlockEntity)>
get "blockEntityClass"(): $Class<($BeltTunnelBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltTunnelBlock$$Type = ($BeltTunnelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltTunnelBlock$$Original = $BeltTunnelBlock;}
declare module "com.simibubi.create.content.logistics.packagePort.postbox.PostboxBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$SmartInventory} from "com.simibubi.create.foundation.item.SmartInventory"
import {$PackagePortBlockEntity} from "com.simibubi.create.content.logistics.packagePort.PackagePortBlockEntity"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$PackagePortTarget} from "com.simibubi.create.content.logistics.packagePort.PackagePortTarget"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GlobalStation} from "com.simibubi.create.content.trains.station.GlobalStation"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PostboxBlockEntity extends $PackagePortBlockEntity {
 "acceptsPackages": boolean
 "flag": $LerpedFloat
 "addressFilter": StringJS
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "forceFlag": boolean
 "computerBehaviour": $AbstractComputerBehaviour
 "inventory": $SmartInventory
 "trackedGlobalStation": $WeakReference<($GlobalStation)>
 "target": $PackagePortTarget

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "spawnParticles"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "tick"(): void
public "invalidate"(): void
public "setChanged"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PostboxBlockEntity$$Type = ($PostboxBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PostboxBlockEntity$$Original = $PostboxBlockEntity;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$SawType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$SawType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$SawType$$Type = ($AllArmInteractionPointTypes$SawType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$SawType$$Original = $AllArmInteractionPointTypes$SawType;}
declare module "com.simibubi.create.content.trains.bogey.AbstractBogeyBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Set} from "java.util.Set"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BogeySizes$BogeySize, $BogeySizes$BogeySize$$Type} from "com.simibubi.create.content.trains.bogey.BogeySizes$BogeySize"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Carriage$$Type} from "com.simibubi.create.content.trains.entity.Carriage"
import {$TrackMaterial$TrackType} from "com.simibubi.create.content.trains.track.TrackMaterial$TrackType"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$EnumSet} from "java.util.EnumSet"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$AbstractBogeyBlockEntity, $AbstractBogeyBlockEntity$$Type} from "com.simibubi.create.content.trains.bogey.AbstractBogeyBlockEntity"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BogeyStyle, $BogeyStyle$$Type} from "com.simibubi.create.content.trains.bogey.BogeyStyle"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AbstractBogeyBlock<T extends $AbstractBogeyBlockEntity> extends $Block implements $IBE$$Interface<(T)>, $ProperWaterloggedBlock$$Interface, $SpecialBlockItemRequirement$$Interface, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($AbstractBogeyBlock<(never)>)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
 "size": $BogeySizes$BogeySize
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $BogeySizes$BogeySize$$Type)

public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "isTrackAxisAlongFirstCoordinate"(arg0: $BlockState$$Type): boolean
public "isOnIncompatibleTrack"(arg0: $Carriage$$Type, arg1: boolean): boolean
public "getTrackType"(arg0: $BogeyStyle$$Type): $TrackMaterial$TrackType
public "getValidPathfindingTypes"(arg0: $BogeyStyle$$Type): $Set<($TrackMaterial$TrackType)>
public static "registerStandardBogey"(arg0: $ResourceLocation$$Type): void
public "getStickySurfaces"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $EnumSet<($Direction)>
public "getWheelPointSpacing"(): double
public "getWheelRadius"(): double
public "getConnectorAnchorOffset"(arg0: boolean): $Vec3
public "allowsSingleBogeyCarriage"(): boolean
public "captureBlockEntityForTrain"(): boolean
public "getBogeyUpDirection"(): $Direction
public "getMatchingBogey"(arg0: $Direction$$Type, arg1: boolean): $BlockState
public "getNextStyle"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $BogeyStyle
public "getNextStyle"(arg0: $BogeyStyle$$Type): $BogeyStyle
public "getStateOfSize"(arg0: $AbstractBogeyBlockEntity$$Type, arg1: $BogeySizes$BogeySize$$Type): $BlockState
public "getNextSize"(arg0: $AbstractBogeyBlockEntity$$Type): $BlockState
public "getNextSize"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $BlockState
public "propertiesToCopy"(): $List<($Property<(never)>)>
public "canBeUpsideDown"(): boolean
public "isUpsideDown"(arg0: $BlockState$$Type): boolean
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "getVersion"(arg0: $BlockState$$Type, arg1: boolean): $BlockState
public "getSize"(): $BogeySizes$BogeySize
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "getDefaultStyle"(): $BogeyStyle
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<(T)>
public "getBlockEntityType"(): $BlockEntityType<(T)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<(T)>): void
public "getBlockEntityClass"(): $Class<(T)>
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<(T), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<(T), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): T
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "wheelPointSpacing"(): double
get "wheelRadius"(): double
get "bogeyUpDirection"(): $Direction
get "defaultStyle"(): $BogeyStyle
get "blockEntityType"(): $BlockEntityType<(T)>
get "blockEntityClass"(): $Class<(T)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractBogeyBlock$$Type<T> = ($AbstractBogeyBlock<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractBogeyBlock$$Original<T> = $AbstractBogeyBlock<(T)>;}
declare module "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorPackage$ChainConveyorPackagePhysicsData" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$ChainConveyorBlockEntity, $ChainConveyorBlockEntity$$Type} from "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorBlockEntity"
import {$ChainConveyorPackage$$Type} from "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorPackage"
import {$WeakReference} from "java.lang.ref.WeakReference"

export class $ChainConveyorPackage$ChainConveyorPackagePhysicsData {
 "targetPos": $Vec3
 "lastTick": integer
 "flipped": boolean
 "motion": $Vec3
 "prevYaw": float
 "pos": $Vec3
 "prevTargetPos": $Vec3
 "prevPos": $Vec3
 "beReference": $WeakReference<($ChainConveyorBlockEntity)>
 "yaw": float
 "modelKey": $ResourceLocation

constructor(arg0: $ChainConveyorPackage$$Type, arg1: $Vec3$$Type)

public "setBE"(arg0: $ChainConveyorBlockEntity$$Type): void
public "shouldTick"(): boolean
set "BE"(value: $ChainConveyorBlockEntity$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainConveyorPackage$ChainConveyorPackagePhysicsData$$Type = ($ChainConveyorPackage$ChainConveyorPackagePhysicsData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainConveyorPackage$ChainConveyorPackagePhysicsData$$Original = $ChainConveyorPackage$ChainConveyorPackagePhysicsData;}
declare module "com.simibubi.create.content.kinetics.press.PressingRecipe" {
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$SingleRecipeInput, $SingleRecipeInput$$Type} from "net.minecraft.world.item.crafting.SingleRecipeInput"
import {$List$$Type} from "java.util.List"
import {$IAssemblyRecipe$$Interface} from "com.simibubi.create.content.processing.sequenced.IAssemblyRecipe"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SizedFluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$Component} from "net.minecraft.network.chat.Component"
import {$SequencedAssemblySubCategory} from "com.simibubi.create.compat.jei.category.sequencedAssembly.SequencedAssemblySubCategory"
import {$RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$Supplier} from "java.util.function.Supplier"
import {$Set$$Type} from "java.util.Set"
import {$ProcessingRecipeParams$$Type} from "com.simibubi.create.content.processing.recipe.ProcessingRecipeParams"
import {$StandardProcessingRecipe} from "com.simibubi.create.content.processing.recipe.StandardProcessingRecipe"

export class $PressingRecipe extends $StandardProcessingRecipe<($SingleRecipeInput)> implements $IAssemblyRecipe$$Interface {
constructor(arg0: $ProcessingRecipeParams$$Type)

public "addRequiredMachines"(arg0: $Set$$Type<($ItemLike$$Type)>): void
public "addAssemblyIngredients"(arg0: $List$$Type<($Ingredient$$Type)>): void
public "getJEISubCategory"(): $Supplier<($Supplier<($SequencedAssemblySubCategory)>)>
public "getDescriptionForAssembly"(): $Component
public "matches"(arg0: $SingleRecipeInput$$Type, arg1: $Level$$Type): boolean
public "matches"(arg0: $RecipeInput$$Type, arg1: $Level$$Type): boolean
public "supportsAssembly"(): boolean
public "addAssemblyFluidIngredients"(arg0: $List$$Type<($SizedFluidIngredient$$Type)>): void
get "JEISubCategory"(): $Supplier<($Supplier<($SequencedAssemblySubCategory)>)>
get "descriptionForAssembly"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressingRecipe$$Type = ($PressingRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PressingRecipe$$Original = $PressingRecipe;}
declare module "com.simibubi.create.content.redstone.displayLink.source.ItemNameDisplaySource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $ItemNameDisplaySource extends $SingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemNameDisplaySource$$Type = ($ItemNameDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemNameDisplaySource$$Original = $ItemNameDisplaySource;}
declare module "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBlock$PanelSlot" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $FactoryPanelBlock$PanelSlot extends $Enum<($FactoryPanelBlock$PanelSlot)> implements $StringRepresentable$$Interface {
static readonly "TOP_LEFT": $FactoryPanelBlock$PanelSlot
readonly "yOffset": integer
static readonly "CODEC": $Codec<($FactoryPanelBlock$PanelSlot)>
readonly "xOffset": integer
static readonly "BOTTOM_RIGHT": $FactoryPanelBlock$PanelSlot
static readonly "TOP_RIGHT": $FactoryPanelBlock$PanelSlot
static readonly "BOTTOM_LEFT": $FactoryPanelBlock$PanelSlot
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($FactoryPanelBlock$PanelSlot)>

public static "values"(): ($FactoryPanelBlock$PanelSlot)[]
public static "valueOf"(arg0: StringJS): $FactoryPanelBlock$PanelSlot
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryPanelBlock$PanelSlot$$Type = (("top_left") | ("top_right") | ("bottom_left") | ("bottom_right"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FactoryPanelBlock$PanelSlot$$Original = $FactoryPanelBlock$PanelSlot;}
declare module "com.simibubi.create.content.kinetics.simpleRelays.encased.EncasedCogwheelBlock" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$SimpleKineticBlockEntity, $SimpleKineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.simpleRelays.SimpleKineticBlockEntity"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$EncasedBlock$$Interface} from "com.simibubi.create.content.decoration.encasing.EncasedBlock"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ICogWheel$$Interface} from "com.simibubi.create.content.kinetics.simpleRelays.ICogWheel"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RotatedPillarKineticBlock} from "com.simibubi.create.content.kinetics.base.RotatedPillarKineticBlock"
import {$Direction$Axis, $Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$TransformableBlock$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $EncasedCogwheelBlock extends $RotatedPillarKineticBlock implements $ICogWheel$$Interface, $IBE$$Interface<($SimpleKineticBlockEntity)>, $SpecialBlockItemRequirement$$Interface, $TransformableBlock$$Interface, $EncasedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "TOP_SHAFT": $BooleanProperty
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "BOTTOM_SHAFT": $BooleanProperty
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: boolean, arg2: $Supplier$$Type<($Block$$Type)>)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "isSmallCog"(): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "skipRendering"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($SimpleKineticBlockEntity)>
public "getBlockEntityClass"(): $Class<($SimpleKineticBlockEntity)>
public "swapShafts"(arg0: $BlockState$$Type): $BlockState
public "isLargeCog"(): boolean
public "getCasing"(): $Block
public "handleEncasing"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): void
public "swapShaftsForRotation"(arg0: $BlockState$$Type, arg1: $Rotation$$Type, arg2: $Direction$Axis$$Type): $BlockState
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "transform"(arg0: $BlockState$$Type, arg1: $StructureTransform$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public static "isSmallCog"(arg0: $Block$$Type): boolean
public static "isSmallCog"(arg0: $BlockState$$Type): boolean
public static "isLargeCog"(arg0: $Block$$Type): boolean
public static "isLargeCog"(arg0: $BlockState$$Type): boolean
public "isDedicatedCogWheel"(): boolean
public static "isDedicatedCogWheel"(arg0: $Block$$Type): boolean
public static "isDedicatedCogItem"(arg0: $ItemStack$$Type): boolean
public static "isSmallCogItem"(arg0: $ItemStack$$Type): boolean
public static "isLargeCogItem"(arg0: $ItemStack$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SimpleKineticBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SimpleKineticBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SimpleKineticBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SimpleKineticBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SimpleKineticBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "smallCog"(): boolean
get "blockEntityType"(): $BlockEntityType<($SimpleKineticBlockEntity)>
get "blockEntityClass"(): $Class<($SimpleKineticBlockEntity)>
get "largeCog"(): boolean
get "casing"(): $Block
get "dedicatedCogWheel"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EncasedCogwheelBlock$$Type = ($EncasedCogwheelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EncasedCogwheelBlock$$Original = $EncasedCogwheelBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.PercentOrProgressBarDisplaySource" {
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$NumericSingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.NumericSingleLineDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $PercentOrProgressBarDisplaySource extends $NumericSingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PercentOrProgressBarDisplaySource$$Type = ($PercentOrProgressBarDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PercentOrProgressBarDisplaySource$$Original = $PercentOrProgressBarDisplaySource;}
declare module "com.simibubi.create.content.equipment.clipboard.ClipboardCloneable" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export interface $ClipboardCloneable$$Interface {
get "clipboardKey"(): StringJS
}

export class $ClipboardCloneable implements $ClipboardCloneable$$Interface {
 "getClipboardKey"(): StringJS
 "writeToClipboard"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type, arg2: $Direction$$Type): boolean
 "readFromClipboard"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type, arg2: $Player$$Type, arg3: $Direction$$Type, arg4: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipboardCloneable$$Type = ($ClipboardCloneable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipboardCloneable$$Original = $ClipboardCloneable;}
declare module "com.simibubi.create.content.redstone.displayLink.LinkWithBulbBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Direction} from "net.minecraft.core.Direction"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LinkWithBulbBlockEntity extends $SmartBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getBulbFacing"(arg0: $BlockState$$Type): $Direction
public "getBulbOffset"(arg0: $BlockState$$Type): $Vec3
public "getGlow"(arg0: float): float
public "sendPulseNextSync"(): void
public "pulse"(): void
public "tick"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LinkWithBulbBlockEntity$$Type = ($LinkWithBulbBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LinkWithBulbBlockEntity$$Original = $LinkWithBulbBlockEntity;}
declare module "com.simibubi.create.content.contraptions.MountedStorageSyncPacket" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ClientboundPacketPayload$$Interface} from "net.createmod.catnip.net.base.ClientboundPacketPayload"
import {$List$$Type} from "java.util.List"
import {$CustomPacketPayload$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$Type"
import {$StreamDecoder$$Type} from "net.minecraft.network.codec.StreamDecoder"
import {$MountedFluidStorage, $MountedFluidStorage$$Type} from "com.simibubi.create.api.contraption.storage.fluid.MountedFluidStorage"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$MountedItemStorage, $MountedItemStorage$$Type} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorage"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CustomPacketPayload$FallbackProvider$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$FallbackProvider"
import {$PacketFlow$$Type} from "net.minecraft.network.protocol.PacketFlow"
import {$Map, $Map$$Type} from "java.util.Map"
import {$FriendlyByteBuf} from "net.minecraft.network.FriendlyByteBuf"
import {$CustomPacketPayload} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload"
import {$BasePacketPayload$PacketTypeProvider} from "net.createmod.catnip.net.base.BasePacketPayload$PacketTypeProvider"
import {$StreamMemberEncoder$$Type} from "net.minecraft.network.codec.StreamMemberEncoder"
import {$ServerboundCustomPayloadPacket} from "net.minecraft.network.protocol.common.ServerboundCustomPayloadPacket"
import {$ClientboundCustomPayloadPacket} from "net.minecraft.network.protocol.common.ClientboundCustomPayloadPacket"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ConnectionProtocol$$Type} from "net.minecraft.network.ConnectionProtocol"
import {$CustomPacketPayload$TypeAndCodec$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$TypeAndCodec"
import {$Record} from "java.lang.Record"

export class $MountedStorageSyncPacket extends $Record implements $ClientboundPacketPayload$$Interface {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MountedStorageSyncPacket)>

constructor(contraptionId: integer, items: $Map$$Type<($BlockPos$$Type), ($MountedItemStorage$$Type)>, fluids: $Map$$Type<($BlockPos$$Type), ($MountedFluidStorage$$Type)>)

public "contraptionId"(): integer
public "items"(): $Map<($BlockPos), ($MountedItemStorage)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "handle"(arg0: $LocalPlayer$$Type): void
public "getTypeProvider"(): $BasePacketPayload$PacketTypeProvider
public "fluids"(): $Map<($BlockPos), ($MountedFluidStorage)>
public "handleInternal"(arg0: $Player$$Type): void
public "type"(): $CustomPacketPayload$Type<($CustomPacketPayload)>
public static "codec"<B extends $FriendlyByteBuf>(arg0: $CustomPacketPayload$FallbackProvider$$Type<(B)>, arg1: $List$$Type<($CustomPacketPayload$TypeAndCodec$$Type<(B), (never)>)>, arg2: $ConnectionProtocol$$Type, arg3: $PacketFlow$$Type): $StreamCodec<(B), ($CustomPacketPayload)>
public static "codec"<B extends $ByteBuf, T extends $CustomPacketPayload>(arg0: $StreamMemberEncoder$$Type<(B), (T)>, arg1: $StreamDecoder$$Type<(B), (T)>): $StreamCodec<(B), (T)>
public "toVanillaClientbound"(): $ClientboundCustomPayloadPacket
public "toVanillaServerbound"(): $ServerboundCustomPayloadPacket
public static "createType"<T extends $CustomPacketPayload>(arg0: StringJS): $CustomPacketPayload$Type<(T)>
get "typeProvider"(): $BasePacketPayload$PacketTypeProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MountedStorageSyncPacket$$Type = ({"items"?: $Map$$Type<($BlockPos$$Type), ($MountedItemStorage$$Type)>, "fluids"?: $Map$$Type<($BlockPos$$Type), ($MountedFluidStorage$$Type)>, "contraptionId"?: integer}) | ([items?: $Map$$Type<($BlockPos$$Type), ($MountedItemStorage$$Type)>, fluids?: $Map$$Type<($BlockPos$$Type), ($MountedFluidStorage$$Type)>, contraptionId?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MountedStorageSyncPacket$$Original = $MountedStorageSyncPacket;}
declare module "com.simibubi.create.content.kinetics.transmission.SplitShaftBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$DirectionalShaftHalvesBlockEntity} from "com.simibubi.create.content.kinetics.base.DirectionalShaftHalvesBlockEntity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $SplitShaftBlockEntity extends $DirectionalShaftHalvesBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getRotationSpeedModifier"(arg0: $Direction$$Type): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SplitShaftBlockEntity$$Type = ($SplitShaftBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SplitShaftBlockEntity$$Original = $SplitShaftBlockEntity;}
declare module "com.simibubi.create.content.kinetics.transmission.sequencer.InstructionSpeedModifiers" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$InstructionSpeedModifiersAccessor$$Interface} from "com.hlysine.create_connected.mixin.sequencedgearshift.InstructionSpeedModifiersAccessor"
import {$Enum} from "java.lang.Enum"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $InstructionSpeedModifiers extends $Enum<($InstructionSpeedModifiers)> implements $InstructionSpeedModifiersAccessor$$Interface {
static readonly "FORWARD_FAST": $InstructionSpeedModifiers
static readonly "BACK": $InstructionSpeedModifiers
static readonly "FORWARD": $InstructionSpeedModifiers
static readonly "BACK_FAST": $InstructionSpeedModifiers
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($InstructionSpeedModifiers)>

public static "getByModifier"(arg0: integer): $InstructionSpeedModifiers
public static "values"(): ($InstructionSpeedModifiers)[]
public static "valueOf"(arg0: StringJS): $InstructionSpeedModifiers
public "getValue"(): integer
get "value"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InstructionSpeedModifiers$$Type = (("forward_fast") | ("forward") | ("back") | ("back_fast"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InstructionSpeedModifiers$$Original = $InstructionSpeedModifiers;}
declare module "com.simibubi.create.content.logistics.chute.SmartChuteBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ChuteBlockEntity} from "com.simibubi.create.content.logistics.chute.ChuteBlockEntity"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$AbstractChuteBlock} from "com.simibubi.create.content.logistics.chute.AbstractChuteBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SmartChuteBlock extends $AbstractChuteBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($ChuteBlockEntity)>
public "updateChuteState"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): $BlockState
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ChuteBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmartChuteBlock$$Type = ($SmartChuteBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmartChuteBlock$$Original = $SmartChuteBlock;}
declare module "com.simibubi.create.content.contraptions.ContraptionWorld" {
import {$Iterable} from "java.lang.Iterable"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$BlockSnapshot} from "net.neoforged.neoforge.common.util.BlockSnapshot"
import {$List} from "java.util.List"
import {$Trackable} from "dev.uncandango.alltheleaks.mixin.Trackable"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Codec} from "com.mojang.serialization.Codec"
import {$SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$Function$$Type} from "java.util.function.Function"
import {$Class} from "java.lang.Class"
import {$WrappedLevel} from "net.createmod.catnip.levelWrappers.WrappedLevel"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$ObjectOpenCustomHashSet} from "it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"
import {$ArrayList} from "java.util.ArrayList"
import {$Map} from "java.util.Map"
import {$TickingBlockEntity} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"

export class $ContraptionWorld extends $WrappedLevel {
 "restoringBlockSnapshots": boolean
 "oThunderLevel": float
static readonly "LONG_PARTICLE_CLIP_RANGE": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "thunderLevel": float
readonly "random": $RandomSource
 "capturedBlockSnapshots": $ArrayList<($BlockSnapshot)>
static readonly "OVERWORLD": $ResourceKey<($Level)>
static readonly "TICKS_PER_DAY": integer
static readonly "MAX_ENTITY_SPAWN_Y": integer
static readonly "NETHER": $ResourceKey<($Level)>
 "oRainLevel": float
static readonly "RESOURCE_KEY_CODEC": $Codec<($ResourceKey<($Level)>)>
static readonly "MAX_BRIGHTNESS": integer
static readonly "END": $ResourceKey<($Level)>
static readonly "MAX_LEVEL_SIZE": integer
static readonly "SHORT_PARTICLE_CLIP_RANGE": integer
static readonly "MIN_ENTITY_SPAWN_Y": integer
readonly "blockEntityTickers": $List<($TickingBlockEntity)>
 "rainLevel": float
 "captureBlockSnapshots": boolean

constructor(arg0: $Level$$Type, arg1: $Contraption$$Type)

public "getHeight"(): integer
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "playLocalSound"(arg0: double, arg1: double, arg2: double, arg3: $SoundEvent$$Type, arg4: $SoundSource$$Type, arg5: float, arg6: float, arg7: boolean): void
public "getMinBuildHeight"(): integer
public "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
public "self"(): $EntityGetter
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
public static "startTracking"(arg0: any): void
public static "createWeakRefBasedSet"(): $ObjectOpenCustomHashSet<($WeakReference<($Trackable)>)>
public static "clearNullReferences"(): void
public static "getSummary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
public static "getAllLoadedEntities"(level: $Level$$Type): $Iterable<($Entity)>
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
get "height"(): integer
get "minBuildHeight"(): integer
public static get "summary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContraptionWorld$$Type = ($ContraptionWorld);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ContraptionWorld$$Original = $ContraptionWorld;}
declare module "com.simibubi.create.content.trains.graph.DimensionPalette" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $DimensionPalette {
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($DimensionPalette)>

constructor()
constructor(arg0: $List$$Type<($ResourceKey$$Type<($Level$$Type)>)>)

public static "receive"(arg0: $FriendlyByteBuf$$Type): $DimensionPalette
public "decode"(arg0: integer): $ResourceKey<($Level)>
public "encode"(arg0: $ResourceKey$$Type<($Level)>): integer
public "write"(arg0: $CompoundTag$$Type): void
public static "read"(arg0: $CompoundTag$$Type): $DimensionPalette
public "send"(arg0: $FriendlyByteBuf$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionPalette$$Type = ($DimensionPalette);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionPalette$$Original = $DimensionPalette;}
declare module "com.simibubi.create.content.kinetics.waterwheel.LargeWaterWheelBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$LargeWaterWheelBlockEntity, $LargeWaterWheelBlockEntity$$Type} from "com.simibubi.create.content.kinetics.waterwheel.LargeWaterWheelBlockEntity"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RotatedPillarKineticBlock} from "com.simibubi.create.content.kinetics.base.RotatedPillarKineticBlock"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $LargeWaterWheelBlock extends $RotatedPillarKineticBlock implements $IBE$$Interface<($LargeWaterWheelBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "EXTENSION": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "isFlammable"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($LargeWaterWheelBlockEntity)>
public "getBlockEntityClass"(): $Class<($LargeWaterWheelBlockEntity)>
public "getAxisForPlacement"(arg0: $BlockPlaceContext$$Type): $Direction$Axis
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($LargeWaterWheelBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($LargeWaterWheelBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($LargeWaterWheelBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($LargeWaterWheelBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $LargeWaterWheelBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
get "blockEntityType"(): $BlockEntityType<($LargeWaterWheelBlockEntity)>
get "blockEntityClass"(): $Class<($LargeWaterWheelBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LargeWaterWheelBlock$$Type = ($LargeWaterWheelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LargeWaterWheelBlock$$Original = $LargeWaterWheelBlock;}
declare module "com.simibubi.create.content.trains.track.TrackTargetingBlockItem$OverlapResult" {
import {$Enum} from "java.lang.Enum"

export class $TrackTargetingBlockItem$OverlapResult extends $Enum<($TrackTargetingBlockItem$OverlapResult)> {
 "feedback": StringJS
static readonly "VALID": $TrackTargetingBlockItem$OverlapResult
static readonly "NO_TRACK": $TrackTargetingBlockItem$OverlapResult
static readonly "OCCUPIED": $TrackTargetingBlockItem$OverlapResult
static readonly "JUNCTION": $TrackTargetingBlockItem$OverlapResult

public static "values"(): ($TrackTargetingBlockItem$OverlapResult)[]
public static "valueOf"(arg0: StringJS): $TrackTargetingBlockItem$OverlapResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackTargetingBlockItem$OverlapResult$$Type = (("valid") | ("occupied") | ("junction") | ("no_track"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackTargetingBlockItem$OverlapResult$$Original = $TrackTargetingBlockItem$OverlapResult;}
declare module "com.simibubi.create.content.trains.bogey.BogeyVisualizer" {
import {$BogeyVisual, $BogeyVisual$$Type} from "com.simibubi.create.content.trains.bogey.BogeyVisual"
import {$VisualizationContext, $VisualizationContext$$Type} from "dev.engine_room.flywheel.api.visualization.VisualizationContext"

export interface $BogeyVisualizer$$Interface {

(arg0: $VisualizationContext, arg1: float, arg2: boolean): $BogeyVisual$$Type
}

export class $BogeyVisualizer implements $BogeyVisualizer$$Interface {
 "createVisual"(arg0: $VisualizationContext$$Type, arg1: float, arg2: boolean): $BogeyVisual
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BogeyVisualizer$$Type = ((arg0: $VisualizationContext, arg1: float, arg2: boolean) => $BogeyVisual$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BogeyVisualizer$$Original = $BogeyVisualizer;}
declare module "com.simibubi.create.content.kinetics.fan.NozzleBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NozzleBlockEntity extends $SmartBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "setRange"(arg0: float): void
public "tick"(): void
public "initialize"(): void
set "range"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NozzleBlockEntity$$Type = ($NozzleBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NozzleBlockEntity$$Original = $NozzleBlockEntity;}
declare module "com.simibubi.create.content.kinetics.base.DirectionalKineticBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$KineticBlock} from "com.simibubi.create.content.kinetics.base.KineticBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DirectionalKineticBlock extends $KineticBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getPreferredFacing"(arg0: $BlockPlaceContext$$Type): $Direction
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionalKineticBlock$$Type = ($DirectionalKineticBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectionalKineticBlock$$Original = $DirectionalKineticBlock;}
declare module "com.simibubi.create.content.contraptions.elevator.ElevatorPulleyBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List$$Type} from "java.util.List"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$AbstractContraptionEntity} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$ControlledContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.ControlledContraptionEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$PulleyBlockEntity} from "com.simibubi.create.content.contraptions.pulley.PulleyBlockEntity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ElevatorPulleyBlockEntity extends $PulleyBlockEntity {
 "offset": float
 "sharedMirrorContraption": $WeakReference<($AbstractContraptionEntity)>
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "needsContraption": boolean
 "movedContraption": $AbstractContraptionEntity
 "network": long
 "running": boolean
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "assembleNextTick": boolean
 "updateSpeed": boolean
 "preventSpeedUpdate": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getMovementSpeed"(): float
public "clicked"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "onSpeedChanged"(arg0: float): void
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "attach"(arg0: $ControlledContraptionEntity$$Type): void
public "disassemble"(): void
get "movementSpeed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElevatorPulleyBlockEntity$$Type = ($ElevatorPulleyBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ElevatorPulleyBlockEntity$$Original = $ElevatorPulleyBlockEntity;}
declare module "com.simibubi.create.content.trains.graph.TrackNodeLocation" {
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$Collection} from "java.util.Collection"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos} from "net.minecraft.core.BlockPos"

export class $TrackNodeLocation extends $Vec3i {
static readonly "ZERO": $Vec3i
static readonly "CODEC": $Codec<($Vec3i)>
 "yOffsetPixels": integer
 "dimension": $ResourceKey<($Level)>

constructor(arg0: $Vec3$$Type)
constructor(arg0: double, arg1: double, arg2: double)

public static "receive"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): $TrackNodeLocation
public "allAdjacent"(): $Collection<($BlockPos)>
public "equalsIgnoreDim"(arg0: any): boolean
public "getDimension"(): $ResourceKey<($Level)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "getLocation"(): $Vec3
public "write"(arg0: $DimensionPalette$$Type): $CompoundTag
public "in"(arg0: $ResourceKey$$Type<($Level)>): $TrackNodeLocation
public "in"(arg0: $Level$$Type): $TrackNodeLocation
public static "read"(arg0: $CompoundTag$$Type, arg1: $DimensionPalette$$Type): $TrackNodeLocation
public "send"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): void
get "location"(): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackNodeLocation$$Type = ($TrackNodeLocation);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackNodeLocation$$Original = $TrackNodeLocation;}
declare module "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorRoutingTable$RoutingTableEntry" {
import {$MutableInt, $MutableInt$$Type} from "org.apache.commons.lang3.mutable.MutableInt"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"

export class $ChainConveyorRoutingTable$RoutingTableEntry extends $Record {
constructor(port: StringJS, distance: integer, nextConnection: $BlockPos$$Type, timeout: $MutableInt$$Type, endOfRoute: boolean)

public "endOfRoute"(): boolean
public "copyForNeighbour"(arg0: $BlockPos$$Type): $ChainConveyorRoutingTable$RoutingTableEntry
public "tick"(): void
public "invalid"(): boolean
public "nextConnection"(): $BlockPos
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "port"(): StringJS
public "distance"(): integer
public "timeout"(): $MutableInt
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainConveyorRoutingTable$RoutingTableEntry$$Type = ({"nextConnection"?: $BlockPos$$Type, "endOfRoute"?: boolean, "port"?: StringJS, "distance"?: integer, "timeout"?: $MutableInt$$Type}) | ([nextConnection?: $BlockPos$$Type, endOfRoute?: boolean, port?: StringJS, distance?: integer, timeout?: $MutableInt$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainConveyorRoutingTable$RoutingTableEntry$$Original = $ChainConveyorRoutingTable$RoutingTableEntry;}
declare module "com.simibubi.create.content.decoration.copycat.CopycatBlock" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$CopycatBlockEntity, $CopycatBlockEntity$$Type} from "com.simibubi.create.content.decoration.copycat.CopycatBlockEntity"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$IntegerProperty$$Type} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$ICopycatBlock$OnRemoveHandler$$Type} from "com.copycatsplus.copycats.foundation.copycat.ICopycatBlock$OnRemoveHandler"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$ICopycatBlockEntity} from "com.copycatsplus.copycats.foundation.copycat.ICopycatBlockEntity"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$ICopycatBlock$$Type, $ICopycatBlock$$Interface} from "com.copycatsplus.copycats.foundation.copycat.ICopycatBlock"
import {$BlockColor} from "net.minecraft.client.color.block.BlockColor"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$StateType} from "com.copycatsplus.copycats.foundation.copycat.StateType"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $CopycatBlock extends $Block implements $IBE$$Interface<($CopycatBlockEntity)>, $IWrenchable$$Interface, $ICopycatBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getExplosionResistance"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type): float
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "hasDynamicLightEmission"(arg0: $BlockState$$Type): boolean
public "canHarvestBlock"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): boolean
public "getEnchantPowerBonus"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): float
public "canEntityDestroy"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "getAppearance"(arg0: $BlockState$$Type, arg1: $BlockAndTintGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $BlockState$$Type, arg5: $BlockPos$$Type): $BlockState
public "getDestroyProgress"(arg0: $BlockState$$Type, arg1: $Player$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): float
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "getBlockEntityType"(): $BlockEntityType<($CopycatBlockEntity)>
public "canFaceBeOccluded"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "isIgnoredConnectivitySide"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type): boolean
public "canConnectTexturesToward"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "shouldFaceAlwaysRender"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "getAcceptedBlockState"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type, arg3: $Direction$$Type): $BlockState
public "prepareMaterial"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type, arg4: $InteractionHand$$Type, arg5: $BlockHitResult$$Type, arg6: $BlockState$$Type): $BlockState
public "isAcceptedRegardless"(arg0: $BlockState$$Type): boolean
public "getBlockEntityClass"(): $Class<($CopycatBlockEntity)>
public static "wrappedColor"(): $BlockColor
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "addLandingEffects"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $LivingEntity$$Type, arg5: integer): boolean
public "getSoundType"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): $SoundType
public "getFriction"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): float
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public "addRunningEffects"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getLightEmission"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): integer
public static "getMaterial"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $BlockState
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($CopycatBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($CopycatBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CopycatBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CopycatBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $CopycatBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "useWithoutItem"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, player: $Player$$Type, hitResult: $BlockHitResult$$Type): $InteractionResult
public static "hidesNeighborFace"(level: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, neighborState: $BlockState$$Type, dir: $Direction$$Type): boolean
public "canOcclude"(level: $BlockGetter$$Type, state: $BlockState$$Type, pos: $BlockPos$$Type): boolean
public "shapeCanOccludeNeighbor"(level: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, neighborPos: $BlockPos$$Type, dir: $Direction$$Type): $Optional<(boolean)>
public static "getAppearance"(block: $ICopycatBlock$$Type, state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, side: $Direction$$Type, queryState: $BlockState$$Type, queryPos: $BlockPos$$Type): $BlockState
public "isIgnoredConnectivitySide"(reader: $BlockAndTintGetter$$Type, fromState: $BlockState$$Type, face: $Direction$$Type, fromPos: $BlockPos$$Type, toPos: $BlockPos$$Type, toState: $BlockState$$Type): boolean
public "getCopycatBlockEntity"(worldIn: $BlockGetter$$Type, pos: $BlockPos$$Type): $ICopycatBlockEntity
public "canToggleCT"(state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type): boolean
public "isCTEnabled"(state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type): boolean
public "toggleCT"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, player: $Player$$Type, hitResult: $BlockHitResult$$Type): $InteractionResult
public static "getRequiredItemsForLayer"(state: $BlockState$$Type, property: $IntegerProperty$$Type): $ItemRequirement
public "checkConnection"(reader: $BlockAndTintGetter$$Type, fromPos: $BlockPos$$Type, toPos: $BlockPos$$Type, fromState: $BlockState$$Type): boolean
public "transform"(state: $BlockState$$Type, transform: $StructureTransform$$Type): $BlockState
public "rotate"(pState: $BlockState$$Type, pRot: $Rotation$$Type): $BlockState
public "mirror"(pState: $BlockState$$Type, pMirror: $Mirror$$Type): $BlockState
public "useItemOn"(stack: $ItemStack$$Type, state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, player: $Player$$Type, hand: $InteractionHand$$Type, hitResult: $BlockHitResult$$Type): $ItemInteractionResult
public "onRemove"(state: $BlockState$$Type, world: $Level$$Type, pos: $BlockPos$$Type, newState: $BlockState$$Type, isMoving: boolean, handler: $ICopycatBlock$OnRemoveHandler$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "stateType"(): $StateType
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($CopycatBlockEntity)>
get "blockEntityClass"(): $Class<($CopycatBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopycatBlock$$Type = ($CopycatBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CopycatBlock$$Original = $CopycatBlock;}
declare module "com.simibubi.create.content.processing.sequenced.IAssemblyRecipe" {
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List$$Type} from "java.util.List"
import {$Supplier} from "java.util.function.Supplier"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$Set$$Type} from "java.util.Set"
import {$SizedFluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$Component} from "net.minecraft.network.chat.Component"
import {$SequencedAssemblySubCategory} from "com.simibubi.create.compat.jei.category.sequencedAssembly.SequencedAssemblySubCategory"

export interface $IAssemblyRecipe$$Interface {
get "JEISubCategory"(): $Supplier<($Supplier<($SequencedAssemblySubCategory)>)>
get "descriptionForAssembly"(): $Component
}

export class $IAssemblyRecipe implements $IAssemblyRecipe$$Interface {
 "addRequiredMachines"(arg0: $Set$$Type<($ItemLike$$Type)>): void
 "addAssemblyIngredients"(arg0: $List$$Type<($Ingredient$$Type)>): void
 "getJEISubCategory"(): $Supplier<($Supplier<($SequencedAssemblySubCategory)>)>
 "supportsAssembly"(): boolean
 "addAssemblyFluidIngredients"(arg0: $List$$Type<($SizedFluidIngredient$$Type)>): void
 "getDescriptionForAssembly"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAssemblyRecipe$$Type = ($IAssemblyRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IAssemblyRecipe$$Original = $IAssemblyRecipe;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttributeType} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export interface $ItemAttribute$$Interface {
get "translationKey"(): StringJS
get "translationParameters"(): (any)[]
get "type"(): $ItemAttributeType
}

export class $ItemAttribute implements $ItemAttribute$$Interface {
static readonly "CODEC": $Codec<($ItemAttribute)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>

static "loadStatic"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $ItemAttribute
 "appliesTo"(arg0: $ItemStack$$Type, arg1: $Level$$Type): boolean
static "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
 "getTranslationKey"(): StringJS
 "getTranslationParameters"(): (any)[]
static "saveStatic"(arg0: $ItemAttribute$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
 "format"(arg0: boolean): $MutableComponent
 "getType"(): $ItemAttributeType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemAttribute$$Type = ($ItemAttribute);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemAttribute$$Original = $ItemAttribute;}
declare module "com.simibubi.create.content.logistics.depot.storage.DepotMountedStorageType" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$DepotMountedStorage} from "com.simibubi.create.content.logistics.depot.storage.DepotMountedStorage"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MountedItemStorageType} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageType"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DepotMountedStorageType extends $MountedItemStorageType<($DepotMountedStorage)> {
readonly "codec": $MapCodec<(T)>
static readonly "CODEC": $Codec<($MountedItemStorageType<(never)>)>
readonly "holder": $Holder$Reference<($MountedItemStorageType<(never)>)>
static readonly "REGISTRY": $SimpleRegistry<($Block), ($MountedItemStorageType<(never)>)>

constructor()

public "mount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): $DepotMountedStorage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DepotMountedStorageType$$Type = ($DepotMountedStorageType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DepotMountedStorageType$$Original = $DepotMountedStorageType;}
declare module "com.simibubi.create.content.fluids.pipes.SmartFluidPipeBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$FaceAttachedHorizontalDirectionalBlock} from "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$SmartFluidPipeBlockEntity, $SmartFluidPipeBlockEntity$$Type} from "com.simibubi.create.content.fluids.pipes.SmartFluidPipeBlockEntity"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IAxisPipe$$Interface} from "com.simibubi.create.content.fluids.pipes.IAxisPipe"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $SmartFluidPipeBlock extends $FaceAttachedHorizontalDirectionalBlock implements $IBE$$Interface<($SmartFluidPipeBlockEntity)>, $IAxisPipe$$Interface, $IWrenchable$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SmartFluidPipeBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($AttachFace)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getBlockEntityType"(): $BlockEntityType<($SmartFluidPipeBlockEntity)>
public "getBlockEntityClass"(): $Class<($SmartFluidPipeBlockEntity)>
public static "isOpenAt"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SmartFluidPipeBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SmartFluidPipeBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SmartFluidPipeBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SmartFluidPipeBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SmartFluidPipeBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "getAxisOf"(arg0: $BlockState$$Type): $Direction$Axis
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SmartFluidPipeBlockEntity)>
get "blockEntityClass"(): $Class<($SmartFluidPipeBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmartFluidPipeBlock$$Type = ($SmartFluidPipeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmartFluidPipeBlock$$Original = $SmartFluidPipeBlock;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$ComposterType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$ComposterType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$ComposterType$$Type = ($AllArmInteractionPointTypes$ComposterType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$ComposterType$$Original = $AllArmInteractionPointTypes$ComposterType;}
declare module "com.simibubi.create.content.kinetics.base.AbstractEncasedShaftBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RotatedPillarKineticBlock} from "com.simibubi.create.content.kinetics.base.RotatedPillarKineticBlock"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractEncasedShaftBlock extends $RotatedPillarKineticBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractEncasedShaftBlock$$Type = ($AbstractEncasedShaftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractEncasedShaftBlock$$Original = $AbstractEncasedShaftBlock;}
declare module "com.simibubi.create.content.logistics.funnel.FunnelBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$AbstractDirectionalFunnelBlock} from "com.simibubi.create.content.logistics.funnel.AbstractDirectionalFunnelBlock"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $FunnelBlock extends $AbstractDirectionalFunnelBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "EXTRACTING": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getEquivalentBeltFunnel"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "entityInside"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunnelBlock$$Type = ($FunnelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FunnelBlock$$Original = $FunnelBlock;}
declare module "com.simibubi.create.content.processing.recipe.ProcessingRecipe$Factory" {
import {$ProcessingRecipe, $ProcessingRecipe$$Type} from "com.simibubi.create.content.processing.recipe.ProcessingRecipe"
import {$ProcessingRecipeParams, $ProcessingRecipeParams$$Type} from "com.simibubi.create.content.processing.recipe.ProcessingRecipeParams"

export interface $ProcessingRecipe$Factory$$Interface<P extends $ProcessingRecipeParams, R extends $ProcessingRecipe<(object), (object)>> {

(arg0: P): R
}

export class $ProcessingRecipe$Factory<P extends $ProcessingRecipeParams, R extends $ProcessingRecipe<(object), (object)>> implements $ProcessingRecipe$Factory$$Interface {
 "create"(arg0: P): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProcessingRecipe$Factory$$Type<P, R> = ((arg0: P) => R);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProcessingRecipe$Factory$$Original<P, R> = $ProcessingRecipe$Factory<(P), (R)>;}
declare module "com.simibubi.create.content.kinetics.millstone.MillstoneBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$IItemHandler} from "net.neoforged.neoforge.items.IItemHandler"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$ItemStackHandler} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $MillstoneBlockEntity extends $KineticBlockEntity implements $Clearable$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "timer": integer
 "networkDirty": boolean
 "capability": $IItemHandler
 "updateSpeed": boolean
 "inputInv": $ItemStackHandler
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "outputInv": $ItemStackHandler
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getProcessingSpeed"(): integer
public "tickAudio"(): void
public "clearContent"(): void
public "spawnParticles"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "destroy"(): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
get "processingSpeed"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MillstoneBlockEntity$$Type = ($MillstoneBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MillstoneBlockEntity$$Original = $MillstoneBlockEntity;}
declare module "com.simibubi.create.content.kinetics.simpleRelays.AbstractShaftBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$KineticBlockEntity, $KineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RotatedPillarKineticBlock} from "com.simibubi.create.content.kinetics.base.RotatedPillarKineticBlock"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AbstractShaftBlock extends $RotatedPillarKineticBlock implements $IBE$$Interface<($KineticBlockEntity)>, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityClass"(): $Class<($KineticBlockEntity)>
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($KineticBlockEntity)>
public "getBlockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($KineticBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($KineticBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($KineticBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $KineticBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityClass"(): $Class<($KineticBlockEntity)>
get "blockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractShaftBlock$$Type = ($AbstractShaftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractShaftBlock$$Original = $AbstractShaftBlock;}
declare module "com.simibubi.create.content.decoration.copycat.CopycatStepBlock" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Half} from "net.minecraft.world.level.block.state.properties.Half"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ICopycatBlock$$Type, $ICopycatBlock$$Interface} from "com.copycatsplus.copycats.foundation.copycat.ICopycatBlock"
import {$BlockColor} from "net.minecraft.client.color.block.BlockColor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty$$Type} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$WaterloggedCopycatBlock} from "com.simibubi.create.content.decoration.copycat.WaterloggedCopycatBlock"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $CopycatStepBlock extends $WaterloggedCopycatBlock implements $ICopycatBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($Half)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "useWithoutItem"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, player: $Player$$Type, hitResult: $BlockHitResult$$Type): $InteractionResult
public "hidesNeighborFace"(level: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, neighborState: $BlockState$$Type, dir: $Direction$$Type): boolean
public "supportsExternalFaceHiding"(state: $BlockState$$Type): boolean
public "getAppearance"(state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, side: $Direction$$Type, queryState: $BlockState$$Type, queryPos: $BlockPos$$Type): $BlockState
public "canFaceBeOccluded"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "isIgnoredConnectivitySide"(reader: $BlockAndTintGetter$$Type, state: $BlockState$$Type, face: $Direction$$Type, fromPos: $BlockPos$$Type, toPos: $BlockPos$$Type): boolean
public "canConnectTexturesToward"(reader: $BlockAndTintGetter$$Type, fromPos: $BlockPos$$Type, toPos: $BlockPos$$Type, fromState: $BlockState$$Type): boolean
public "shouldFaceAlwaysRender"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public static "isOccluded"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "transform"(state: $BlockState$$Type, transform: $StructureTransform$$Type): $BlockState
public "rotate"(state: $BlockState$$Type, rotation: $Rotation$$Type): $BlockState
public "mirror"(state: $BlockState$$Type, mirror: $Mirror$$Type): $BlockState
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $BlockEntity
public "setPlacedBy"(worldIn: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, placer: $LivingEntity$$Type, stack: $ItemStack$$Type): void
public "playerWillDestroy"(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, player: $Player$$Type): $BlockState
public static "getAppearance"(block: $ICopycatBlock$$Type, state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, side: $Direction$$Type, queryState: $BlockState$$Type, queryPos: $BlockPos$$Type): $BlockState
public "getAcceptedBlockState"(pLevel: $Level$$Type, pPos: $BlockPos$$Type, item: $ItemStack$$Type, face: $Direction$$Type): $BlockState
public "prepareMaterial"(pLevel: $Level$$Type, pPos: $BlockPos$$Type, pState: $BlockState$$Type, pPlayer: $Player$$Type, pHand: $InteractionHand$$Type, pHit: $BlockHitResult$$Type, material: $BlockState$$Type): $BlockState
public "isAcceptedRegardless"(material: $BlockState$$Type): boolean
public static "getRequiredItemsForLayer"(state: $BlockState$$Type, property: $IntegerProperty$$Type): $ItemRequirement
public static "wrappedColor"(): $BlockColor
public "onWrenched"(state: $BlockState$$Type, context: $UseOnContext$$Type): $InteractionResult
public "onSneakWrenched"(state: $BlockState$$Type, context: $UseOnContext$$Type): $InteractionResult
public static "getMaterial"(reader: $BlockGetter$$Type, targetPos: $BlockPos$$Type): $BlockState
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopycatStepBlock$$Type = ($CopycatStepBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CopycatStepBlock$$Original = $CopycatStepBlock;}
declare module "com.simibubi.create.content.processing.recipe.HeatCondition" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$BlazeBurnerBlock$HeatLevel, $BlazeBurnerBlock$HeatLevel$$Type} from "com.simibubi.create.content.processing.burner.BlazeBurnerBlock$HeatLevel"

export class $HeatCondition extends $Enum<($HeatCondition)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($HeatCondition)>
static readonly "HEATED": $HeatCondition
static readonly "SUPERHEATED": $HeatCondition
static readonly "NONE": $HeatCondition
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($HeatCondition)>

public "testBlazeBurner"(arg0: $BlazeBurnerBlock$HeatLevel$$Type): boolean
public "visualizeAsBlazeBurner"(): $BlazeBurnerBlock$HeatLevel
public "getTranslationKey"(): StringJS
public static "values"(): ($HeatCondition)[]
public static "valueOf"(arg0: StringJS): $HeatCondition
public "getSerializedName"(): StringJS
public "getColor"(): integer
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "translationKey"(): StringJS
get "serializedName"(): StringJS
get "color"(): integer
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeatCondition$$Type = (("none") | ("heated") | ("superheated"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HeatCondition$$Original = $HeatCondition;}
declare module "com.simibubi.create.content.redstone.nixieTube.DoubleFaceAttachedBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$DoubleFaceAttachedBlock$DoubleAttachFace} from "com.simibubi.create.content.redstone.nixieTube.DoubleFaceAttachedBlock$DoubleAttachFace"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $DoubleFaceAttachedBlock extends $HorizontalDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DoubleFaceAttachedBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($DoubleFaceAttachedBlock$DoubleAttachFace)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleFaceAttachedBlock$$Type = ($DoubleFaceAttachedBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoubleFaceAttachedBlock$$Original = $DoubleFaceAttachedBlock;}
declare module "com.simibubi.create.content.logistics.depot.storage.DepotMountedStorage" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$DepotMountedStorage$Handler} from "com.simibubi.create.content.logistics.depot.storage.DepotMountedStorage$Handler"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$WrapperMountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.WrapperMountedItemStorage"
import {$MountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorage"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$DepotBlockEntity$$Type} from "com.simibubi.create.content.logistics.depot.DepotBlockEntity"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SyncedMountedStorage$$Interface} from "com.simibubi.create.api.contraption.storage.SyncedMountedStorage"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MountedItemStorageType} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageType"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DepotMountedStorage extends $WrapperMountedItemStorage<($DepotMountedStorage$Handler)> implements $SyncedMountedStorage$$Interface {
static readonly "CODEC": $MapCodec<($DepotMountedStorage)>
readonly "type": $MountedItemStorageType<($MountedItemStorage)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MountedItemStorage)>

public "setItem"(arg0: $ItemStack$$Type): void
public "handleInteraction"(arg0: $ServerPlayer$$Type, arg1: $Contraption$$Type, arg2: $StructureTemplate$StructureBlockInfo$$Type): boolean
public static "fromLegacy"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): $DepotMountedStorage
public static "fromDepot"(arg0: $DepotBlockEntity$$Type): $DepotMountedStorage
public "markClean"(): void
public "afterSync"(arg0: $Contraption$$Type, arg1: $BlockPos$$Type): void
public "isDirty"(): boolean
public "getItem"(): $ItemStack
public "unmount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): void
set "item"(value: $ItemStack$$Type)
get "dirty"(): boolean
get "item"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DepotMountedStorage$$Type = ($DepotMountedStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DepotMountedStorage$$Original = $DepotMountedStorage;}
declare module "com.simibubi.create.content.logistics.packagerLink.PackagerLinkBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$FaceAttachedHorizontalDirectionalBlock} from "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$PackagerLinkBlockEntity, $PackagerLinkBlockEntity$$Type} from "com.simibubi.create.content.logistics.packagerLink.PackagerLinkBlockEntity"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $PackagerLinkBlock extends $FaceAttachedHorizontalDirectionalBlock implements $IBE$$Interface<($PackagerLinkBlockEntity)>, $ProperWaterloggedBlock$$Interface, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PackagerLinkBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($AttachFace)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public static "getConnectedDirection"(arg0: $BlockState$$Type): $Direction
public "getBlockEntityType"(): $BlockEntityType<($PackagerLinkBlockEntity)>
public "getBlockEntityClass"(): $Class<($PackagerLinkBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public static "getPower"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($PackagerLinkBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($PackagerLinkBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PackagerLinkBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PackagerLinkBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $PackagerLinkBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($PackagerLinkBlockEntity)>
get "blockEntityClass"(): $Class<($PackagerLinkBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagerLinkBlock$$Type = ($PackagerLinkBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagerLinkBlock$$Original = $PackagerLinkBlock;}
declare module "com.simibubi.create.content.logistics.depot.EjectorItem" {
import {$Map} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EjectorItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "canAttackBlock"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): boolean
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EjectorItem$$Type = ($EjectorItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EjectorItem$$Original = $EjectorItem;}
declare module "com.simibubi.create.content.trains.signal.SignalBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$TrackTargetingBehaviour} from "com.simibubi.create.content.trains.track.TrackTargetingBehaviour"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$SignalBoundary} from "com.simibubi.create.content.trains.signal.SignalBoundary"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$SignalBlockEntity$SignalState, $SignalBlockEntity$SignalState$$Type} from "com.simibubi.create.content.trains.signal.SignalBlockEntity$SignalState"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SignalBlockEntity$OverlayState, $SignalBlockEntity$OverlayState$$Type} from "com.simibubi.create.content.trains.signal.SignalBlockEntity$OverlayState"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SignalBlockEntity extends $SmartBlockEntity implements $TransformableBlockEntity$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "computerBehaviour": $AbstractComputerBehaviour
 "edgePoint": $TrackTargetingBehaviour<($SignalBoundary)>

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isPowered"(): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getReportedPower"(): boolean
public "enterState"(arg0: $SignalBlockEntity$SignalState$$Type): void
public "tick"(): void
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "getState"(): $SignalBlockEntity$SignalState
public "invalidate"(): void
public "setOverlay"(arg0: $SignalBlockEntity$OverlayState$$Type): void
public "getOverlay"(): $SignalBlockEntity$OverlayState
public "getSignal"(): $SignalBoundary
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
get "powered"(): boolean
get "reportedPower"(): boolean
get "state"(): $SignalBlockEntity$SignalState
set "overlay"(value: $SignalBlockEntity$OverlayState$$Type)
get "overlay"(): $SignalBlockEntity$OverlayState
get "signal"(): $SignalBoundary
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignalBlockEntity$$Type = ($SignalBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignalBlockEntity$$Original = $SignalBlockEntity;}
declare module "com.simibubi.create.content.contraptions.chassis.ChassisBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Queue$$Type} from "java.util.Queue"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ChassisBlockEntity extends $SmartBlockEntity {
 "currentlySelectedRange": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addAttachedChasses"(arg0: $Queue$$Type<($BlockPos$$Type)>, arg1: $Set$$Type<($BlockPos$$Type)>): boolean
public "getIncludedBlockPositions"(arg0: $Direction$$Type, arg1: boolean): $List<($BlockPos)>
public "collectChassisGroup"(): $List<($ChassisBlockEntity)>
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getRange"(): integer
public "initialize"(): void
get "range"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChassisBlockEntity$$Type = ($ChassisBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChassisBlockEntity$$Original = $ChassisBlockEntity;}
declare module "com.simibubi.create.content.kinetics.crank.ValveHandleBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$PlayerInteractEvent$RightClickBlock$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$RightClickBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$HandCrankBlockEntity} from "com.simibubi.create.content.kinetics.crank.HandCrankBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HandCrankBlock} from "com.simibubi.create.content.kinetics.crank.HandCrankBlock"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ValveHandleBlock extends $HandCrankBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
readonly "color": $DyeColor
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

public "clicked"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type, arg4: $InteractionHand$$Type): boolean
public static "copper"(arg0: $BlockBehaviour$Properties$$Type): $ValveHandleBlock
public static "dyed"(arg0: $BlockBehaviour$Properties$$Type, arg1: $DyeColor$$Type): $ValveHandleBlock
public "getBlockEntityType"(): $BlockEntityType<($HandCrankBlockEntity)>
public static "onBlockActivated"(arg0: $PlayerInteractEvent$RightClickBlock$$Type): void
public "getRotationSpeed"(): integer
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($HandCrankBlockEntity)>
get "rotationSpeed"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ValveHandleBlock$$Type = ($ValveHandleBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ValveHandleBlock$$Original = $ValveHandleBlock;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.attributes.BookAuthorAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $BookAuthorAttribute$Type implements $ItemAttributeType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BookAuthorAttribute$Type$$Type = ($BookAuthorAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BookAuthorAttribute$Type$$Original = $BookAuthorAttribute$Type;}
declare module "com.simibubi.create.content.redstone.displayLink.source.StopWatchDisplaySource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $StopWatchDisplaySource extends $SingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "onSignalReset"(arg0: $DisplayLinkContext$$Type): void
public "getPassiveRefreshTicks"(): integer
get "passiveRefreshTicks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StopWatchDisplaySource$$Type = ($StopWatchDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StopWatchDisplaySource$$Original = $StopWatchDisplaySource;}
declare module "com.simibubi.create.content.logistics.packagePort.PackagePortTarget$TrainStationFrogportTarget$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PackagePortTargetType$$Interface} from "com.simibubi.create.content.logistics.packagePort.PackagePortTargetType"
import {$PackagePortTarget$TrainStationFrogportTarget} from "com.simibubi.create.content.logistics.packagePort.PackagePortTarget$TrainStationFrogportTarget"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $PackagePortTarget$TrainStationFrogportTarget$Type implements $PackagePortTargetType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($ByteBuf), ($PackagePortTarget$TrainStationFrogportTarget)>
public "codec"(): $MapCodec<($PackagePortTarget$TrainStationFrogportTarget)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagePortTarget$TrainStationFrogportTarget$Type$$Type = ($PackagePortTarget$TrainStationFrogportTarget$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagePortTarget$TrainStationFrogportTarget$Type$$Original = $PackagePortTarget$TrainStationFrogportTarget$Type;}
declare module "com.simibubi.create.content.equipment.bell.AbstractBellBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$PartialModel} from "dev.engine_room.flywheel.lib.model.baked.PartialModel"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractBellBlockEntity extends $SmartBlockEntity {
 "ringDirection": $Direction
 "ringingTicks": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "isRinging": boolean
static readonly "RING_DURATION": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getBellModel"(): $PartialModel
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "ring"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "tick"(): void
get "bellModel"(): $PartialModel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractBellBlockEntity$$Type = ($AbstractBellBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractBellBlockEntity$$Original = $AbstractBellBlockEntity;}
declare module "com.simibubi.create.content.logistics.tunnel.BrassTunnelBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BeltTunnelBlockEntity} from "com.simibubi.create.content.logistics.tunnel.BeltTunnelBlockEntity"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BeltTunnelBlock} from "com.simibubi.create.content.logistics.tunnel.BeltTunnelBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BeltTunnelBlock$Shape} from "com.simibubi.create.content.logistics.tunnel.BeltTunnelBlock$Shape"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $BrassTunnelBlock extends $BeltTunnelBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "HORIZONTAL_AXIS": $Property<($Direction$Axis)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $Property<($BeltTunnelBlock$Shape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($BeltTunnelBlockEntity)>
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($BeltTunnelBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrassTunnelBlock$$Type = ($BrassTunnelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BrassTunnelBlock$$Original = $BrassTunnelBlock;}
declare module "com.simibubi.create.content.kinetics.deployer.DeployerBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BeltProcessingBehaviour} from "com.simibubi.create.content.kinetics.belt.behaviour.BeltProcessingBehaviour"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$PartialModel} from "dev.engine_room.flywheel.lib.model.baked.PartialModel"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$DeployerBlockEntityAccessor$$Interface} from "fr.iglee42.createcasing.mixins.create.DeployerBlockEntityAccessor"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$DeployerFakePlayer} from "com.simibubi.create.content.kinetics.deployer.DeployerFakePlayer"
import {$RecipeInput} from "net.minecraft.world.item.crafting.RecipeInput"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeHolder} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$IItemHandlerModifiable} from "net.neoforged.neoforge.items.IItemHandlerModifiable"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DeployerBlockEntity extends $KineticBlockEntity implements $Clearable$$Interface, $DeployerBlockEntityAccessor$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "processingBehaviour": $BeltProcessingBehaviour
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "startFistBump"(arg0: $Direction$$Type): boolean
public "triggerFistBump"(): void
public "getHandOffset"(arg0: float): float
public "setAnimatedOffset"(arg0: float): void
public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "clearContent"(): void
public "addToTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "getRecipe"(arg0: $ItemStack$$Type): $RecipeHolder<($Recipe<($RecipeInput)>)>
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "changeMode"(): void
public "discardPlayer"(): void
public "redstoneUpdate"(): void
public "getHandPose"(): $PartialModel
public "tick"(): void
public "initialize"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "invalidate"(): void
public "getPlayer"(): $DeployerFakePlayer
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public "getInvHandler"(): $IItemHandlerModifiable
public "invokeInitHandler"(): void
public static "tryClear"(arg0: any): void
set "animatedOffset"(value: float)
get "handPose"(): $PartialModel
get "player"(): $DeployerFakePlayer
get "invHandler"(): $IItemHandlerModifiable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeployerBlockEntity$$Type = ($DeployerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeployerBlockEntity$$Original = $DeployerBlockEntity;}
declare module "com.simibubi.create.content.trains.graph.TrackNode" {
import {$TrackNodeLocation, $TrackNodeLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"

export class $TrackNode {
constructor(arg0: $TrackNodeLocation$$Type, arg1: integer, arg2: $Vec3$$Type)

public "getNetId"(): integer
public "getLocation"(): $TrackNodeLocation
public "getNormal"(): $Vec3
get "netId"(): integer
get "location"(): $TrackNodeLocation
get "normal"(): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackNode$$Type = ($TrackNode);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackNode$$Original = $TrackNode;}
declare module "com.simibubi.create.content.trains.station.GlobalStation" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$ILimitedGlobalStation$$Interface} from "com.railwayteam.railways.mixin_interfaces.ILimitedGlobalStation"
import {$UUID} from "java.util.UUID"
import {$Train, $Train$$Type} from "com.simibubi.create.content.trains.entity.Train"
import {$Level} from "net.minecraft.world.level.Level"
import {$StationChunkLoader, $StationChunkLoader$$Type} from "com.hlysine.create_power_loader.content.trains.StationChunkLoader"
import {$GlobalPackagePort} from "com.simibubi.create.content.trains.station.GlobalPackagePort"
import {$CPLGlobalStation$$Interface} from "com.hlysine.create_power_loader.content.trains.CPLGlobalStation"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$TrackNodeLocation} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$SingleBlockEntityEdgePoint} from "com.simibubi.create.content.trains.signal.SingleBlockEntityEdgePoint"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $GlobalStation extends $SingleBlockEntityEdgePoint implements $ILimitedGlobalStation$$Interface, $CPLGlobalStation$$Interface {
 "edgeLocation": $Couple<($TrackNodeLocation)>
 "blockEntityPos": $BlockPos
 "cpl$chunkLoader": $StationChunkLoader
 "connectedPorts": $Map<($BlockPos), ($GlobalPackagePort)>
 "blockEntityDimension": $ResourceKey<($Level)>
 "name": StringJS
 "assembling": boolean
 "id": $UUID
 "position": double
 "nearestTrain": $WeakReference<($Train)>

constructor()

public "setLoader"(arg0: $StationChunkLoader$$Type): void
public "isLimitEnabled"(): boolean
public "canApproachFrom"(arg0: $TrackNode$$Type): boolean
public "reserveFor"(arg0: $Train$$Type): void
public "getNearestTrain"(): $Train
public "cancelReservation"(arg0: $Train$$Type): void
public "trainDeparted"(arg0: $Train$$Type): void
public "getImminentTrain"(): $Train
public "runMailTransfer"(): void
public "blockEntityAdded"(arg0: $BlockEntity$$Type, arg1: boolean): void
public "canNavigateVia"(arg0: $TrackNode$$Type): boolean
public "isStationEnabled"(): boolean
public "getDisablingTrain"(): $Train
public "orDisablingTrain"(arg0: $Train$$Type, arg1: $Train$$Type): $Train
public "setLimitEnabled"(arg0: boolean): void
public "getPresentTrain"(): $Train
public "getLoader"(): $StationChunkLoader
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $DimensionPalette$$Type): void
public "write"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean, arg3: $DimensionPalette$$Type): void
public "read"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): void
set "loader"(value: $StationChunkLoader$$Type)
get "limitEnabled"(): boolean
get "imminentTrain"(): $Train
get "stationEnabled"(): boolean
get "disablingTrain"(): $Train
set "limitEnabled"(value: boolean)
get "presentTrain"(): $Train
get "loader"(): $StationChunkLoader
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlobalStation$$Type = ($GlobalStation);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GlobalStation$$Original = $GlobalStation;}
declare module "com.simibubi.create.content.equipment.toolbox.ToolboxBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ToolboxBlockEntity, $ToolboxBlockEntity$$Type} from "com.simibubi.create.content.equipment.toolbox.ToolboxBlockEntity"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $ToolboxBlock extends $HorizontalDirectionalBlock implements $SimpleWaterloggedBlock$$Interface, $IBE$$Interface<($ToolboxBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ToolboxBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $DyeColor$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($ToolboxBlockEntity)>
public "getBlockEntityClass"(): $Class<($ToolboxBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getColor"(): $DyeColor
public "attack"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ToolboxBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ToolboxBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ToolboxBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ToolboxBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ToolboxBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ToolboxBlockEntity)>
get "blockEntityClass"(): $Class<($ToolboxBlockEntity)>
get "color"(): $DyeColor
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolboxBlock$$Type = ($ToolboxBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ToolboxBlock$$Original = $ToolboxBlock;}
declare module "com.simibubi.create.content.kinetics.clock.CuckooClockBlockEntity$Animation" {
import {$Enum} from "java.lang.Enum"

export class $CuckooClockBlockEntity$Animation extends $Enum<($CuckooClockBlockEntity$Animation)> {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CuckooClockBlockEntity$Animation$$Type = (("pig") | ("creeper") | ("surprise") | ("none"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CuckooClockBlockEntity$Animation$$Original = $CuckooClockBlockEntity$Animation;}
declare module "com.simibubi.create.content.fluids.tank.storage.FluidTankMountedStorage" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$MountedFluidStorageType} from "com.simibubi.create.api.contraption.storage.fluid.MountedFluidStorageType"
import {$FluidStack} from "net.neoforged.neoforge.fluids.FluidStack"
import {$MountedFluidStorage} from "com.simibubi.create.api.contraption.storage.fluid.MountedFluidStorage"
import {$FluidTankBlockEntity$$Type} from "com.simibubi.create.content.fluids.tank.FluidTankBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$WrapperMountedFluidStorage} from "com.simibubi.create.api.contraption.storage.fluid.WrapperMountedFluidStorage"
import {$FluidTankMountedStorage$Handler} from "com.simibubi.create.content.fluids.tank.storage.FluidTankMountedStorage$Handler"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SyncedMountedStorage$$Interface} from "com.simibubi.create.api.contraption.storage.SyncedMountedStorage"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FluidTankMountedStorage extends $WrapperMountedFluidStorage<($FluidTankMountedStorage$Handler)> implements $SyncedMountedStorage$$Interface {
static readonly "CODEC": $MapCodec<($FluidTankMountedStorage)>
readonly "type": $MountedFluidStorageType<($MountedFluidStorage)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MountedFluidStorage)>

public "getFluid"(): $FluidStack
public static "fromLegacy"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): $FluidTankMountedStorage
public "markClean"(): void
public "afterSync"(arg0: $Contraption$$Type, arg1: $BlockPos$$Type): void
public static "fromTank"(arg0: $FluidTankBlockEntity$$Type): $FluidTankMountedStorage
public "isDirty"(): boolean
public "unmount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): void
public "getCapacity"(): integer
get "fluid"(): $FluidStack
get "dirty"(): boolean
get "capacity"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankMountedStorage$$Type = ($FluidTankMountedStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTankMountedStorage$$Original = $FluidTankMountedStorage;}
declare module "com.simibubi.create.content.decoration.encasing.EncasedBlock" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $EncasedBlock$$Interface {

(): $Block$$Type
get "casing"(): $Block
}

export class $EncasedBlock implements $EncasedBlock$$Interface {
 "getCasing"(): $Block
 "handleEncasing"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EncasedBlock$$Type = (() => $Block$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EncasedBlock$$Original = $EncasedBlock;}
declare module "com.simibubi.create.content.kinetics.crafter.MechanicalCraftingRecipe" {
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ShapedRecipePattern, $ShapedRecipePattern$$Type} from "net.minecraft.world.item.crafting.ShapedRecipePattern"
import {$RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$ShapedRecipe} from "net.minecraft.world.item.crafting.ShapedRecipe"
import {$RecipeType} from "net.minecraft.world.item.crafting.RecipeType"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$CraftingBookCategory$$Type} from "net.minecraft.world.item.crafting.CraftingBookCategory"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $MechanicalCraftingRecipe extends $ShapedRecipe {
readonly "result": $ItemStack
readonly "pattern": $ShapedRecipePattern

constructor(arg0: StringJS, arg1: $CraftingBookCategory$$Type, arg2: $ShapedRecipePattern$$Type, arg3: $ItemStack$$Type, arg4: boolean)

public "acceptsMirrored"(): boolean
public "getSerializer"(): $RecipeSerializer<(never)>
public "matches"(arg0: $CraftingInput$$Type, arg1: $Level$$Type): boolean
public "matches"(arg0: $RecipeInput$$Type, arg1: $Level$$Type): boolean
public "getType"(): $RecipeType<(never)>
public "isSpecial"(): boolean
get "serializer"(): $RecipeSerializer<(never)>
get "type"(): $RecipeType<(never)>
get "special"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalCraftingRecipe$$Type = ($MechanicalCraftingRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalCraftingRecipe$$Original = $MechanicalCraftingRecipe;}
declare module "com.simibubi.create.content.trains.observer.TrackObserverBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$TrackObserverBlockEntity, $TrackObserverBlockEntity$$Type} from "com.simibubi.create.content.trains.observer.TrackObserverBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $TrackObserverBlock extends $Block implements $IBE$$Interface<($TrackObserverBlockEntity)>, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getBlockEntityType"(): $BlockEntityType<($TrackObserverBlockEntity)>
public "getBlockEntityClass"(): $Class<($TrackObserverBlockEntity)>
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($TrackObserverBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($TrackObserverBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($TrackObserverBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($TrackObserverBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $TrackObserverBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($TrackObserverBlockEntity)>
get "blockEntityClass"(): $Class<($TrackObserverBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackObserverBlock$$Type = ($TrackObserverBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackObserverBlock$$Original = $TrackObserverBlock;}
declare module "com.simibubi.create.content.decoration.TrainTrapdoorBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Half} from "net.minecraft.world.level.block.state.properties.Half"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$TrapDoorBlock} from "net.minecraft.world.level.block.TrapDoorBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TrainTrapdoorBlock extends $TrapDoorBlock implements $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TrapDoorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($Half)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockSetType$$Type, arg1: $BlockBehaviour$Properties$$Type)
/**
 * 
 * @deprecated
 */
constructor(arg0: $BlockBehaviour$Properties$$Type)

public "skipRendering"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public static "glass"(arg0: $BlockBehaviour$Properties$$Type): $TrainTrapdoorBlock
public static "metal"(arg0: $BlockBehaviour$Properties$$Type): $TrainTrapdoorBlock
public static "isConnected"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrainTrapdoorBlock$$Type = ($TrainTrapdoorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrainTrapdoorBlock$$Original = $TrainTrapdoorBlock;}
declare module "com.simibubi.create.content.logistics.BigItemStack" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Comparator} from "java.util.Comparator"
import {$List, $List$$Type} from "java.util.List"

export class $BigItemStack {
static readonly "INF": integer
 "stack": $ItemStack
static readonly "CODEC": $Codec<($BigItemStack)>
 "count": integer
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($BigItemStack)>

constructor(arg0: $ItemStack$$Type)
constructor(arg0: $ItemStack$$Type, arg1: integer)

public static "receive"(arg0: $RegistryFriendlyByteBuf$$Type): $BigItemStack
public static "duplicateWrappers"(arg0: $List$$Type<($BigItemStack$$Type)>): $List<($BigItemStack)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isInfinite"(): boolean
public static "comparator"(): $Comparator<($BigItemStack)>
get "infinite"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BigItemStack$$Type = ($BigItemStack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BigItemStack$$Original = $BigItemStack;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$RespawnAnchorType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$RespawnAnchorType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$RespawnAnchorType$$Type = ($AllArmInteractionPointTypes$RespawnAnchorType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$RespawnAnchorType$$Original = $AllArmInteractionPointTypes$RespawnAnchorType;}
declare module "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$Instruction} from "com.simibubi.create.content.kinetics.transmission.sequencer.Instruction"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$SplitShaftBlockEntity} from "com.simibubi.create.content.kinetics.transmission.SplitShaftBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Vector} from "java.util.Vector"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SequencedGearshiftBlockEntity extends $SplitShaftBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "computerBehaviour": $AbstractComputerBehaviour
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "risingFlank"(): void
public "isIdle"(): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getInstructions"(): $Vector<($Instruction)>
public "onRedstoneUpdate"(arg0: boolean, arg1: boolean): void
public "onSpeedChanged"(arg0: float): void
public "getRotationSpeedModifier"(arg0: $Direction$$Type): float
public "getInstruction"(arg0: integer): $Instruction
public "tick"(): void
public "run"(arg0: integer): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "invalidate"(): void
public "getModifier"(): integer
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
get "idle"(): boolean
get "instructions"(): $Vector<($Instruction)>
get "modifier"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencedGearshiftBlockEntity$$Type = ($SequencedGearshiftBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SequencedGearshiftBlockEntity$$Original = $SequencedGearshiftBlockEntity;}
declare module "com.simibubi.create.content.trains.track.TrackTargetingBlockItem" {
import {$TrackGraphLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackGraphLocation"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$BezierTrackPointLocation$$Type} from "com.simibubi.create.content.trains.track.BezierTrackPointLocation"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$TrackTargetingBlockItem$OverlapResult$$Type} from "com.simibubi.create.content.trains.track.TrackTargetingBlockItem$OverlapResult"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$EdgePointType, $EdgePointType$$Type} from "com.simibubi.create.content.trains.graph.EdgePointType"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$TrackBlockOutline$BezierPointSelection$$Type} from "com.simibubi.create.content.trains.track.TrackBlockOutline$BezierPointSelection"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$NonNullBiFunction} from "com.tterrag.registrate.util.nullness.NonNullBiFunction"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $TrackTargetingBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type, arg2: $EdgePointType$$Type<(never)>)

public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public static "withGraphLocation"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: boolean, arg3: $BezierTrackPointLocation$$Type, arg4: $EdgePointType$$Type<(never)>, arg5: $BiConsumer$$Type<($TrackTargetingBlockItem$OverlapResult), ($TrackGraphLocation)>): void
public "useOnCurve"(arg0: $TrackBlockOutline$BezierPointSelection$$Type, arg1: $ItemStack$$Type): boolean
public "getType"(arg0: $ItemStack$$Type): $EdgePointType<(never)>
public static "ofType"<T extends $Block>(arg0: $EdgePointType$$Type<(never)>): $NonNullBiFunction<(T), ($Item$Properties), ($TrackTargetingBlockItem)>
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackTargetingBlockItem$$Type = ($TrackTargetingBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackTargetingBlockItem$$Original = $TrackTargetingBlockItem;}
declare module "com.simibubi.create.content.equipment.toolbox.ToolboxMountedStorageType" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ToolboxMountedStorage} from "com.simibubi.create.content.equipment.toolbox.ToolboxMountedStorage"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MountedItemStorageType} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageType"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ToolboxMountedStorageType extends $MountedItemStorageType<($ToolboxMountedStorage)> {
readonly "codec": $MapCodec<(T)>
static readonly "CODEC": $Codec<($MountedItemStorageType<(never)>)>
readonly "holder": $Holder$Reference<($MountedItemStorageType<(never)>)>
static readonly "REGISTRY": $SimpleRegistry<($Block), ($MountedItemStorageType<(never)>)>

constructor()

public "mount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): $ToolboxMountedStorage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolboxMountedStorageType$$Type = ($ToolboxMountedStorageType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ToolboxMountedStorageType$$Original = $ToolboxMountedStorageType;}
declare module "com.simibubi.create.content.redstone.displayLink.source.FluidListDisplaySource" {
import {$FlapDisplayBlockEntity$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayBlockEntity"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$FlapDisplayLayout$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayLayout"
import {$ValueListDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.ValueListDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $FluidListDisplaySource extends $ValueListDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "loadFlapDisplayLayout"(arg0: $DisplayLinkContext$$Type, arg1: $FlapDisplayBlockEntity$$Type, arg2: $FlapDisplayLayout$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidListDisplaySource$$Type = ($FluidListDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidListDisplaySource$$Original = $FluidListDisplaySource;}
declare module "com.simibubi.create.content.contraptions.minecart.MinecartCouplingItem" {
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$PlayerInteractEvent$EntityInteract$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$EntityInteract"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"

export class $MinecartCouplingItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public static "handleInteractionWithMinecart"(arg0: $PlayerInteractEvent$EntityInteract$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecartCouplingItem$$Type = ($MinecartCouplingItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecartCouplingItem$$Original = $MinecartCouplingItem;}
declare module "com.simibubi.create.content.redstone.nixieTube.NixieTubeBlockEntity$ComputerSignal" {
import {$NixieTubeBlockEntity$ComputerSignal$TubeDisplay} from "com.simibubi.create.content.redstone.nixieTube.NixieTubeBlockEntity$ComputerSignal$TubeDisplay"

export class $NixieTubeBlockEntity$ComputerSignal {
 "first": $NixieTubeBlockEntity$ComputerSignal$TubeDisplay
 "second": $NixieTubeBlockEntity$ComputerSignal$TubeDisplay

constructor()

public "decode"(arg0: (byte)[]): void
public "encode"(): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NixieTubeBlockEntity$ComputerSignal$$Type = ($NixieTubeBlockEntity$ComputerSignal);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NixieTubeBlockEntity$ComputerSignal$$Original = $NixieTubeBlockEntity$ComputerSignal;}
declare module "com.simibubi.create.content.logistics.funnel.BeltFunnelBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$FunnelBlock$$Type} from "com.simibubi.create.content.logistics.funnel.FunnelBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$AbstractHorizontalFunnelBlock} from "com.simibubi.create.content.logistics.funnel.AbstractHorizontalFunnelBlock"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BeltFunnelBlock$Shape} from "com.simibubi.create.content.logistics.funnel.BeltFunnelBlock$Shape"
import {$BlockEntry$$Type} from "com.tterrag.registrate.util.entry.BlockEntry"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $BeltFunnelBlock extends $AbstractHorizontalFunnelBlock implements $SpecialBlockItemRequirement$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $EnumProperty<($BeltFunnelBlock$Shape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "HORIZONTAL_FACING": $DirectionProperty

constructor(arg0: $BlockEntry$$Type<($FunnelBlock$$Type)>, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "isOfSameType"(arg0: $FunnelBlock$$Type): boolean
public static "getShapeForPosition"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: boolean): $BeltFunnelBlock$Shape
public static "isOnValidBelt"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltFunnelBlock$$Type = ($BeltFunnelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltFunnelBlock$$Original = $BeltFunnelBlock;}
declare module "com.simibubi.create.content.decoration.girder.GirderBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $GirderBlock extends $Block implements $SimpleWaterloggedBlock$$Interface, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "BOTTOM": $BooleanProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "TOP": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "X": $BooleanProperty
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "Z": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockSupportShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public static "updateVerticalProperty"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Property$$Type<(boolean)>, arg4: $BlockState$$Type, arg5: $Direction$$Type): $BlockState
public static "isFacingBracket"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public static "isGirder"(arg0: $BlockState$$Type): boolean
public static "isXGirder"(arg0: $BlockState$$Type): boolean
public static "isZGirder"(arg0: $BlockState$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "isConnected"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public static "updateState"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GirderBlock$$Type = ($GirderBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GirderBlock$$Original = $GirderBlock;}
declare module "com.simibubi.create.content.logistics.chute.ChuteBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$ChuteBlockEntity} from "com.simibubi.create.content.logistics.chute.ChuteBlockEntity"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$AbstractChuteBlock} from "com.simibubi.create.content.logistics.chute.AbstractChuteBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$ChuteBlock$Shape} from "com.simibubi.create.content.logistics.chute.ChuteBlock$Shape"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $ChuteBlock extends $AbstractChuteBlock implements $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $Property<($ChuteBlock$Shape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isTransparent"(arg0: $BlockState$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($ChuteBlockEntity)>
public "getFacing"(arg0: $BlockState$$Type): $Direction
public "updateChuteState"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): $BlockState
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "isOpen"(arg0: $BlockState$$Type): boolean
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ChuteBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChuteBlock$$Type = ($ChuteBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChuteBlock$$Original = $ChuteBlock;}
declare module "com.simibubi.create.content.fluids.tank.CreativeFluidTankBlockEntity" {
import {$BoilerData} from "com.simibubi.create.content.fluids.tank.BoilerData"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidTankBlockEntity} from "com.simibubi.create.content.fluids.tank.FluidTankBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CreativeFluidTankBlockEntity extends $FluidTankBlockEntity {
 "boiler": $BoilerData
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeFluidTankBlockEntity$$Type = ($CreativeFluidTankBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeFluidTankBlockEntity$$Original = $CreativeFluidTankBlockEntity;}
declare module "com.simibubi.create.content.contraptions.bearing.MechanicalBearingBlockEntity" {
import {$GeneratingKineticBlockEntity} from "com.simibubi.create.content.kinetics.base.GeneratingKineticBlockEntity"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List$$Type} from "java.util.List"
import {$IBearingBlockEntity$$Interface} from "com.simibubi.create.content.contraptions.bearing.IBearingBlockEntity"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$ValueBoxTransform} from "com.simibubi.create.foundation.blockEntity.behaviour.ValueBoxTransform"
import {$AbstractContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$ControlledContraptionEntity, $ControlledContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.ControlledContraptionEntity"
import {$IDisplayAssemblyExceptions$$Interface} from "com.simibubi.create.content.contraptions.IDisplayAssemblyExceptions"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AssemblyException} from "com.simibubi.create.content.contraptions.AssemblyException"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MechanicalBearingBlockEntity extends $GeneratingKineticBlockEntity implements $IBearingBlockEntity$$Interface, $IDisplayAssemblyExceptions$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
 "reActivateSource": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isAttachedTo"(arg0: $AbstractContraptionEntity$$Type): boolean
public "onStall"(): void
public "setAngle"(arg0: float): void
public "getLastAssemblyException"(): $AssemblyException
public "isWoodenTop"(): boolean
public "getAngularSpeed"(): float
public "isNearInitialAngle"(): boolean
public "getInterpolatedAngle"(arg0: float): float
public "getMovedContraption"(): $ControlledContraptionEntity
public "assemble"(): void
public "addToTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "onSpeedChanged"(arg0: float): void
public "tick"(): void
public "remove"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "attach"(arg0: $ControlledContraptionEntity$$Type): void
public "isValid"(): boolean
public "isRunning"(): boolean
public "getBlockPosition"(): $BlockPos
public "disassemble"(): void
public "getMovementModeSlot"(): $ValueBoxTransform
public "addExceptionToTooltip"(arg0: $List$$Type<($Component$$Type)>): boolean
set "angle"(value: float)
get "lastAssemblyException"(): $AssemblyException
get "woodenTop"(): boolean
get "angularSpeed"(): float
get "nearInitialAngle"(): boolean
get "movedContraption"(): $ControlledContraptionEntity
get "valid"(): boolean
get "running"(): boolean
get "blockPosition"(): $BlockPos
get "movementModeSlot"(): $ValueBoxTransform
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalBearingBlockEntity$$Type = ($MechanicalBearingBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalBearingBlockEntity$$Original = $MechanicalBearingBlockEntity;}
declare module "com.simibubi.create.content.contraptions.chassis.LinearChassisBlock" {
import {$RotatedPillarBlock} from "net.minecraft.world.level.block.RotatedPillarBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$AbstractChassisBlock} from "com.simibubi.create.content.contraptions.chassis.AbstractChassisBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LinearChassisBlock extends $AbstractChassisBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RotatedPillarBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "STICKY_TOP": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "STICKY_BOTTOM": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public static "isChassis"(arg0: $BlockState$$Type): boolean
public static "sameKind"(arg0: $BlockState$$Type, arg1: $BlockState$$Type): boolean
public "getGlueableSide"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BooleanProperty
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LinearChassisBlock$$Type = ($LinearChassisBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LinearChassisBlock$$Original = $LinearChassisBlock;}
declare module "com.simibubi.create.content.logistics.funnel.BeltFunnelBlock$Shape" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BeltFunnelBlock$Shape extends $Enum<($BeltFunnelBlock$Shape)> implements $StringRepresentable$$Interface {
static readonly "EXTENDED": $BeltFunnelBlock$Shape
static readonly "RETRACTED": $BeltFunnelBlock$Shape
static readonly "PUSHING": $BeltFunnelBlock$Shape
static readonly "PULLING": $BeltFunnelBlock$Shape

public static "values"(): ($BeltFunnelBlock$Shape)[]
public static "valueOf"(arg0: StringJS): $BeltFunnelBlock$Shape
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltFunnelBlock$Shape$$Type = (("retracted") | ("extended") | ("pushing") | ("pulling"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltFunnelBlock$Shape$$Original = $BeltFunnelBlock$Shape;}
declare module "com.simibubi.create.content.equipment.armor.BacktankBlockEntity" {
import {$Nameable$$Interface} from "net.minecraft.world.Nameable"
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BacktankBlockEntity extends $KineticBlockEntity implements $Nameable$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "airLevelTimer": integer
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "airLevel": integer
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getComparatorOutput"(): integer
public static "getDefaultName"(arg0: $BlockState$$Type): $Component
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onSpeedChanged"(arg0: float): void
public "getComponentPatch"(): $DataComponentPatch
public "setCapacityEnchantLevel"(arg0: integer): void
public "setAirLevel"(arg0: integer): void
public "setComponentPatch"(arg0: $DataComponentPatch$$Type): void
public "getAirLevel"(): integer
public "tick"(): void
public "getName"(): $Component
public "setCustomName"(arg0: $Component$$Type): void
public "getDisplayName"(): $Component
public "hasCustomName"(): boolean
public "getCustomName"(): $Component
get "comparatorOutput"(): integer
get "componentPatch"(): $DataComponentPatch
set "capacityEnchantLevel"(value: integer)
set "componentPatch"(value: $DataComponentPatch$$Type)
get "name"(): $Component
set "customName"(value: $Component$$Type)
get "displayName"(): $Component
get "customName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BacktankBlockEntity$$Type = ($BacktankBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BacktankBlockEntity$$Original = $BacktankBlockEntity;}
declare module "com.simibubi.create.content.logistics.funnel.AbstractHorizontalFunnelBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$AbstractFunnelBlock} from "com.simibubi.create.content.logistics.funnel.AbstractFunnelBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractHorizontalFunnelBlock extends $AbstractFunnelBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "HORIZONTAL_FACING": $DirectionProperty

public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractHorizontalFunnelBlock$$Type = ($AbstractHorizontalFunnelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractHorizontalFunnelBlock$$Original = $AbstractHorizontalFunnelBlock;}
declare module "com.simibubi.create.content.contraptions.actors.psi.PortableStorageInterfaceBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$AccessorPortableStorageInterfaceBlockEntity$$Interface} from "com.railwayteam.railways.mixin.AccessorPortableStorageInterfaceBlockEntity"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PortableStorageInterfaceBlockEntity extends $SmartBlockEntity implements $AccessorPortableStorageInterfaceBlockEntity$$Interface {
 "keepAlive": integer
static readonly "ANIMATION": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isPowered"(): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "startConnecting"(): void
public "neighbourChanged"(): void
public "startTransferringTo"(arg0: $Contraption$$Type, arg1: float): void
public "railways$isConnected"(): boolean
public "canTransfer"(): boolean
public "isTransferring"(): boolean
public "onContentTransferred"(): void
public "tick"(): void
public "initialize"(): void
public "invalidate"(): void
get "powered"(): boolean
get "transferring"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PortableStorageInterfaceBlockEntity$$Type = ($PortableStorageInterfaceBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PortableStorageInterfaceBlockEntity$$Original = $PortableStorageInterfaceBlockEntity;}
declare module "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorPackage" {
import {$ChainConveyorPackage$ChainConveyorPackagePhysicsData} from "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorPackage$ChainConveyorPackagePhysicsData"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$AtomicInteger} from "java.util.concurrent.atomic.AtomicInteger"
import {$Cache} from "com.google.common.cache.Cache"
import {$WorldAttached} from "net.createmod.catnip.data.WorldAttached"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $ChainConveyorPackage {
 "worldPosition": $Vec3
 "item": $ItemStack
 "justFlipped": boolean
 "netId": integer
static readonly "physicsDataCache": $WorldAttached<($Cache<(integer), ($ChainConveyorPackage$ChainConveyorPackagePhysicsData)>)>
 "chainPosition": float
static readonly "netIdGenerator": $AtomicInteger
 "yaw": float

constructor(arg0: float, arg1: $ItemStack$$Type, arg2: integer)
constructor(arg0: float, arg1: $ItemStack$$Type)

public "physicsData"(arg0: $LevelAccessor$$Type): $ChainConveyorPackage$ChainConveyorPackagePhysicsData
public "writeToClient"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $ChainConveyorPackage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainConveyorPackage$$Type = ($ChainConveyorPackage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainConveyorPackage$$Original = $ChainConveyorPackage;}
declare module "com.simibubi.create.content.contraptions.actors.harvester.HarvesterBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$AttachedActorBlock} from "com.simibubi.create.content.contraptions.actors.AttachedActorBlock"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$HarvesterBlockEntity, $HarvesterBlockEntity$$Type} from "com.simibubi.create.content.contraptions.actors.harvester.HarvesterBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $HarvesterBlock extends $AttachedActorBlock implements $IBE$$Interface<($HarvesterBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($HarvesterBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($HarvesterBlockEntity)>
public "getBlockEntityClass"(): $Class<($HarvesterBlockEntity)>
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($HarvesterBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($HarvesterBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($HarvesterBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($HarvesterBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $HarvesterBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($HarvesterBlockEntity)>
get "blockEntityClass"(): $Class<($HarvesterBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HarvesterBlock$$Type = ($HarvesterBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HarvesterBlock$$Original = $HarvesterBlock;}
declare module "com.simibubi.create.content.kinetics.press.PressingBehaviour" {
import {$SmartBlockEntity, $SmartBlockEntity$$Type} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BeltProcessingBehaviour} from "com.simibubi.create.content.kinetics.belt.behaviour.BeltProcessingBehaviour"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$BehaviourType} from "com.simibubi.create.foundation.blockEntity.behaviour.BehaviourType"
import {$PressingBehaviour$PressingBehaviourSpecifics} from "com.simibubi.create.content.kinetics.press.PressingBehaviour$PressingBehaviourSpecifics"
import {$PressingBehaviour$Mode, $PressingBehaviour$Mode$$Type} from "com.simibubi.create.content.kinetics.press.PressingBehaviour$Mode"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $PressingBehaviour extends $BeltProcessingBehaviour {
 "running": boolean
 "mode": $PressingBehaviour$Mode
 "prevRunningTicks": integer
static readonly "ENTITY_SCAN": integer
 "runningTicks": integer
 "particleItems": $List<($ItemStack)>
 "blockEntity": $SmartBlockEntity
 "finished": boolean
static readonly "TYPE": $BehaviourType<($BeltProcessingBehaviour)>
static readonly "CYCLE": integer
 "specifics": $PressingBehaviour$PressingBehaviourSpecifics

constructor<T extends $SmartBlockEntity>(arg0: T)

public "onBasin"(): boolean
public "getRenderedHeadOffset"(arg0: float): float
public "inWorld"(): boolean
public "getRunningTickSpeed"(): integer
public "tick"(): void
public "makePressingParticleEffect"(arg0: $Vec3$$Type, arg1: $ItemStack$$Type, arg2: integer): void
public "makePressingParticleEffect"(arg0: $Vec3$$Type, arg1: $ItemStack$$Type): void
public "makeCompactingParticleEffect"(arg0: $Vec3$$Type, arg1: $ItemStack$$Type): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "start"(arg0: $PressingBehaviour$Mode$$Type): void
get "runningTickSpeed"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressingBehaviour$$Type = ($PressingBehaviour);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PressingBehaviour$$Original = $PressingBehaviour;}
declare module "com.simibubi.create.content.kinetics.base.GeneratingKineticBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $GeneratingKineticBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
 "reActivateSource": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "updateGeneratedRotation"(): void
public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "removeSource"(): void
public "applyNewSpeed"(arg0: float, arg1: float): void
public "createNetworkId"(): long
public "tick"(): void
public "setSource"(arg0: $BlockPos$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratingKineticBlockEntity$$Type = ($GeneratingKineticBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeneratingKineticBlockEntity$$Original = $GeneratingKineticBlockEntity;}
declare module "com.simibubi.create.content.logistics.redstoneRequester.RedstoneRequesterBlockItem" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$LogisticallyLinkedBlockItem} from "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBlockItem"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $RedstoneRequesterBlockItem extends $LogisticallyLinkedBlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneRequesterBlockItem$$Type = ($RedstoneRequesterBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneRequesterBlockItem$$Original = $RedstoneRequesterBlockItem;}
declare module "com.simibubi.create.content.equipment.zapper.terrainzapper.WorldshaperItem" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ZapperItem} from "com.simibubi.create.content.equipment.zapper.ZapperItem"
import {$TerrainBrushes$$Type} from "com.simibubi.create.content.equipment.zapper.terrainzapper.TerrainBrushes"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlacementOptions$$Type} from "com.simibubi.create.content.equipment.zapper.terrainzapper.PlacementOptions"
import {$IClientItemExtensions$$Type} from "net.neoforged.neoforge.client.extensions.common.IClientItemExtensions"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$PlacementPatterns$$Type} from "com.simibubi.create.content.equipment.zapper.PlacementPatterns"
import {$TerrainTools$$Type} from "com.simibubi.create.content.equipment.zapper.terrainzapper.TerrainTools"

export class $WorldshaperItem extends $ZapperItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "initializeClient"(arg0: $Consumer$$Type<($IClientItemExtensions)>): void
public "validateUsage"(arg0: $ItemStack$$Type): $Component
public static "configureSettings"(arg0: $ItemStack$$Type, arg1: $PlacementPatterns$$Type, arg2: $TerrainBrushes$$Type, arg3: integer, arg4: integer, arg5: integer, arg6: $TerrainTools$$Type, arg7: $PlacementOptions$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldshaperItem$$Type = ($WorldshaperItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldshaperItem$$Original = $WorldshaperItem;}
declare module "com.simibubi.create.content.equipment.clipboard.ClipboardBlockItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$DataComponentType} from "net.minecraft.core.component.DataComponentType"
import {$ItemCopyingRecipe$SupportsItemCopying$$Interface} from "com.simibubi.create.foundation.recipe.ItemCopyingRecipe$SupportsItemCopying"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $ClipboardBlockItem extends $BlockItem implements $ItemCopyingRecipe$SupportsItemCopying$$Interface {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "registerModelOverrides"(): void
public "getComponentType"(): $DataComponentType<(never)>
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "createCopy"(arg0: $ItemStack$$Type, arg1: integer): $ItemStack
public "canCopyFromItem"(arg0: $ItemStack$$Type): boolean
public "canCopyToItem"(arg0: $ItemStack$$Type): boolean
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "componentType"(): $DataComponentType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipboardBlockItem$$Type = ($ClipboardBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipboardBlockItem$$Original = $ClipboardBlockItem;}
declare module "com.simibubi.create.content.logistics.tunnel.BeltTunnelBlockEntity" {
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$Set} from "java.util.Set"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BeltTunnelBlockEntity extends $SmartBlockEntity {
 "flaps": $Map<($Direction), ($LerpedFloat)>
 "sides": $Set<($Direction)>
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "flap"(arg0: $Direction$$Type, arg1: boolean): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "updateTunnelConnections"(): void
public "tick"(): void
public "initialize"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltTunnelBlockEntity$$Type = ($BeltTunnelBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltTunnelBlockEntity$$Original = $BeltTunnelBlockEntity;}
declare module "com.simibubi.create.content.legacy.ChromaticCompoundItem" {
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Item} from "net.minecraft.world.item.Item"
import {$ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ChromaticCompoundItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "onEntityItemUpdate"(arg0: $ItemStack$$Type, arg1: $ItemEntity$$Type): boolean
public "getLight"(arg0: $ItemStack$$Type): integer
public "checkLight"(arg0: $ItemStack$$Type, arg1: $ItemEntity$$Type, arg2: $Level$$Type, arg3: $ItemStack$$Type, arg4: $Vec3$$Type, arg5: $BlockPos$$Type, arg6: $BlockState$$Type): boolean
public "getMaxStackSize"(arg0: $ItemStack$$Type): integer
public "isBarVisible"(arg0: $ItemStack$$Type): boolean
public "getBarWidth"(arg0: $ItemStack$$Type): integer
public "getBarColor"(arg0: $ItemStack$$Type): integer
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChromaticCompoundItem$$Type = ($ChromaticCompoundItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChromaticCompoundItem$$Original = $ChromaticCompoundItem;}
declare module "com.simibubi.create.content.decoration.steamWhistle.WhistleBlock$WhistleSize" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $WhistleBlock$WhistleSize extends $Enum<($WhistleBlock$WhistleSize)> implements $StringRepresentable$$Interface {
static readonly "SMALL": $WhistleBlock$WhistleSize
static readonly "MEDIUM": $WhistleBlock$WhistleSize
static readonly "LARGE": $WhistleBlock$WhistleSize

public static "values"(): ($WhistleBlock$WhistleSize)[]
public static "valueOf"(arg0: StringJS): $WhistleBlock$WhistleSize
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WhistleBlock$WhistleSize$$Type = (("small") | ("medium") | ("large"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WhistleBlock$WhistleSize$$Original = $WhistleBlock$WhistleSize;}
declare module "com.simibubi.create.content.equipment.extendoGrip.ExtendoGripItem" {
import {$LivingKnockBackEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingKnockBackEvent"
import {$AttributeModifier} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$LivingIncomingDamageEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingIncomingDamageEvent"
import {$PlayerInteractEvent$EntityInteractSpecific$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$EntityInteractSpecific"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$EntityTickEvent$Pre$$Type} from "net.neoforged.neoforge.event.tick.EntityTickEvent$Pre"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InputEvent$InteractionKeyMappingTriggered$$Type} from "net.neoforged.neoforge.client.event.InputEvent$InteractionKeyMappingTriggered"
import {$IClientItemExtensions$$Type} from "net.neoforged.neoforge.client.extensions.common.IClientItemExtensions"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$PlayerInteractEvent$EntityInteract$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$EntityInteract"
import {$BlockEvent$EntityPlaceEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$EntityPlaceEvent"
import {$AttackEntityEvent$$Type} from "net.neoforged.neoforge.event.entity.player.AttackEntityEvent"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$BlockEvent$BreakEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$BreakEvent"
import {$Item} from "net.minecraft.world.item.Item"
import {$PlayerEvent$PlayerLoggedInEvent$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerEvent$PlayerLoggedInEvent"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $ExtendoGripItem extends $Item {
static readonly "doubleRangeAttributeModifier": $AttributeModifier
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "MAX_DAMAGE": integer
static readonly "EXTENDO_MARKER": StringJS
static readonly "singleRangeAttributeModifier": $AttributeModifier
static readonly "DUAL_EXTENDO_MARKER": StringJS
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "initializeClient"(arg0: $Consumer$$Type<($IClientItemExtensions)>): void
public "doesSneakBypassUse"(arg0: $ItemStack$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): boolean
public static "isHoldingExtendoGrip"(arg0: $Player$$Type): boolean
public static "holdingExtendoGripIncreasesRange"(arg0: $EntityTickEvent$Pre$$Type): void
public static "addReachToJoiningPlayersHoldingExtendo"(arg0: $PlayerEvent$PlayerLoggedInEvent$$Type): void
public static "dontMissEntitiesWhenYouHaveHighReachDistance"(arg0: $InputEvent$InteractionKeyMappingTriggered$$Type): void
public static "consumeDurabilityOnBlockBreak"(arg0: $BlockEvent$BreakEvent$$Type): void
public static "consumeDurabilityOnPlace"(arg0: $BlockEvent$EntityPlaceEvent$$Type): void
public static "bufferLivingAttackEvent"(arg0: $LivingIncomingDamageEvent$$Type): void
public static "attacksByExtendoGripHaveMoreKnockback"(arg0: $LivingKnockBackEvent$$Type): void
public static "notifyServerOfLongRangeAttacks"(arg0: $AttackEntityEvent$$Type): void
public static "notifyServerOfLongRangeInteractions"(arg0: $PlayerInteractEvent$EntityInteract$$Type): void
public static "notifyServerOfLongRangeSpecificInteractions"(arg0: $PlayerInteractEvent$EntityInteractSpecific$$Type): void
public "isBarVisible"(arg0: $ItemStack$$Type): boolean
public "getBarWidth"(arg0: $ItemStack$$Type): integer
public "getBarColor"(arg0: $ItemStack$$Type): integer
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtendoGripItem$$Type = ($ExtendoGripItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExtendoGripItem$$Original = $ExtendoGripItem;}
declare module "com.simibubi.create.content.contraptions.render.ContraptionMatrices" {
import {$PoseStack, $PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Matrix4f, $Matrix4f$$Type} from "org.joml.Matrix4f"

export class $ContraptionMatrices {
constructor()

public "getLight"(): $Matrix4f
public "getWorld"(): $Matrix4f
public "getViewProjection"(): $PoseStack
public static "translateToEntity"(arg0: $Matrix4f$$Type, arg1: $Entity$$Type, arg2: float): void
public static "transform"(arg0: $PoseStack$$Type, arg1: $PoseStack$$Type): void
public static "clearStack"(arg0: $PoseStack$$Type): void
public "getModel"(): $PoseStack
public "getModelViewProjection"(): $PoseStack
get "light"(): $Matrix4f
get "world"(): $Matrix4f
get "viewProjection"(): $PoseStack
get "model"(): $PoseStack
get "modelViewProjection"(): $PoseStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContraptionMatrices$$Type = ($ContraptionMatrices);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ContraptionMatrices$$Original = $ContraptionMatrices;}
declare module "com.simibubi.create.content.schematics.table.SchematicTableBlockEntity" {
import {$List$$Type} from "java.util.List"
import {$IInteractionChecker$$Interface} from "com.simibubi.create.foundation.utility.IInteractionChecker"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SchematicTableBlockEntity$SchematicTableInventory} from "com.simibubi.create.content.schematics.table.SchematicTableBlockEntity$SchematicTableInventory"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SchematicTableBlockEntity extends $SmartBlockEntity implements $MenuProvider$$Interface, $IInteractionChecker$$Interface, $Clearable$$Interface {
 "uploadingProgress": float
 "sendUpdate": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventory": $SchematicTableBlockEntity$SchematicTableInventory
 "isUploading": boolean
 "uploadingSchematic": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "finishUpload"(): void
public "startUpload"(arg0: StringJS): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "canPlayerUse"(arg0: $Player$$Type): boolean
public "tick"(): void
public "getDisplayName"(): $Component
public static "tryClear"(arg0: any): void
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicTableBlockEntity$$Type = ($SchematicTableBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicTableBlockEntity$$Original = $SchematicTableBlockEntity;}
declare module "com.simibubi.create.content.kinetics.chainDrive.ChainDriveBlock$Part" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $ChainDriveBlock$Part extends $Enum<($ChainDriveBlock$Part)> implements $StringRepresentable$$Interface {
static readonly "START": $ChainDriveBlock$Part
static readonly "END": $ChainDriveBlock$Part
static readonly "MIDDLE": $ChainDriveBlock$Part
static readonly "NONE": $ChainDriveBlock$Part

public static "values"(): ($ChainDriveBlock$Part)[]
public static "valueOf"(arg0: StringJS): $ChainDriveBlock$Part
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainDriveBlock$Part$$Type = (("start") | ("middle") | ("end") | ("none"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainDriveBlock$Part$$Original = $ChainDriveBlock$Part;}
declare module "com.simibubi.create.content.kinetics.base.IRotate" {
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IRotate$SpeedLevel} from "com.simibubi.create.content.kinetics.base.IRotate$SpeedLevel"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $IRotate$$Interface extends $IWrenchable$$Interface {
get "minimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
}

export class $IRotate implements $IRotate$$Interface {
 "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
 "getMinimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
 "hideStressImpact"(): boolean
 "showCapacityWithAnnotation"(): boolean
 "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
 "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
 "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
 "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
 "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRotate$$Type = ($IRotate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IRotate$$Original = $IRotate;}
declare module "com.simibubi.create.content.kinetics.steamEngine.PoweredShaftBlockEntity" {
import {$GeneratingKineticBlockEntity} from "com.simibubi.create.content.kinetics.base.GeneratingKineticBlockEntity"
import {$Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $PoweredShaftBlockEntity extends $GeneratingKineticBlockEntity {
 "movementDirection": integer
 "initialTicks": integer
 "reActivateSource": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "network": long
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "engineEfficiency": float
 "networkDirty": boolean
 "updateSpeed": boolean
 "capacityKey": $Block
 "preventSpeedUpdate": integer
 "enginePos": $BlockPos

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "canBePoweredBy"(arg0: $BlockPos$$Type): boolean
public "isPoweredBy"(arg0: $BlockPos$$Type): boolean
public "addToEngineTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "getGeneratedSpeed"(): float
public "calculateAddedStressCapacity"(): float
public "getRotationAngleOffset"(arg0: $Direction$Axis$$Type): integer
public "tick"(): void
public "remove"(arg0: $BlockPos$$Type): void
public "update"(arg0: $BlockPos$$Type, arg1: integer, arg2: float): void
get "generatedSpeed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoweredShaftBlockEntity$$Type = ($PoweredShaftBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PoweredShaftBlockEntity$$Original = $PoweredShaftBlockEntity;}
declare module "com.simibubi.create.content.schematics.SchematicAndQuillItem" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Item} from "net.minecraft.world.item.Item"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export class $SchematicAndQuillItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public static "replaceStructureVoidWithAir"(arg0: $CompoundTag$$Type): void
public static "clampGlueBoxes"(arg0: $Level$$Type, arg1: $AABB$$Type, arg2: $CompoundTag$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicAndQuillItem$$Type = ($SchematicAndQuillItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicAndQuillItem$$Original = $SchematicAndQuillItem;}
declare module "com.simibubi.create.content.processing.recipe.ProcessingInventory" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ItemStackHandler} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $ProcessingInventory extends $ItemStackHandler {
 "appliedRecipe": boolean
 "recipeDuration": float
 "callback": $Consumer<($ItemStack)>
 "remainingTime": float

constructor(arg0: $Consumer$$Type<($ItemStack)>)

public "withSlotLimit"(arg0: boolean): $ProcessingInventory
public "clear"(): void
public "isEmpty"(): boolean
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $Tag$$Type): void
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProcessingInventory$$Type = ($ProcessingInventory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProcessingInventory$$Original = $ProcessingInventory;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$JukeboxType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$JukeboxType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$JukeboxType$$Type = ($AllArmInteractionPointTypes$JukeboxType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$JukeboxType$$Original = $AllArmInteractionPointTypes$JukeboxType;}
declare module "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorBlockEntity$ConnectionStats" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Record} from "java.lang.Record"

export class $ChainConveyorBlockEntity$ConnectionStats extends $Record {
constructor(tangentAngle: float, chainLength: float, start: $Vec3$$Type, end: $Vec3$$Type)

public "chainLength"(): float
public "tangentAngle"(): float
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "end"(): $Vec3
public "start"(): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainConveyorBlockEntity$ConnectionStats$$Type = ({"chainLength"?: float, "start"?: $Vec3$$Type, "end"?: $Vec3$$Type, "tangentAngle"?: float}) | ([chainLength?: float, start?: $Vec3$$Type, end?: $Vec3$$Type, tangentAngle?: float]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainConveyorBlockEntity$ConnectionStats$$Original = $ChainConveyorBlockEntity$ConnectionStats;}
declare module "com.simibubi.create.content.redstone.thresholdSwitch.ThresholdSwitchBlockEntity" {
import {$ThresholdSwitchBlockEntity$ThresholdType} from "com.simibubi.create.content.redstone.thresholdSwitch.ThresholdSwitchBlockEntity$ThresholdType"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ThresholdSwitchBlockEntity extends $SmartBlockEntity implements $Clearable$$Interface {
 "currentLevel": integer
 "onWhenAbove": integer
 "currentMinLevel": integer
 "offWhenBelow": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "currentMaxLevel": integer
 "inStacks": boolean

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getStockLevel"(): integer
public "getLevelForDisplay"(): float
public "clearContent"(): void
public "isPowered"(): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "setInverted"(arg0: boolean): void
public "shouldBePowered"(): boolean
public "getTypeOfCurrentTarget"(): $ThresholdSwitchBlockEntity$ThresholdType
public "getDisplayItemForScreen"(): $ItemStack
public "isInverted"(): boolean
public "updateCurrentLevel"(): void
public "updatePowerAfterDelay"(): void
public "format"(arg0: integer, arg1: boolean): $MutableComponent
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "getState"(): boolean
public "getMinLevel"(): integer
public "getMaxLevel"(): integer
public static "tryClear"(arg0: any): void
get "stockLevel"(): integer
get "levelForDisplay"(): float
get "powered"(): boolean
set "inverted"(value: boolean)
get "typeOfCurrentTarget"(): $ThresholdSwitchBlockEntity$ThresholdType
get "displayItemForScreen"(): $ItemStack
get "inverted"(): boolean
get "state"(): boolean
get "minLevel"(): integer
get "maxLevel"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThresholdSwitchBlockEntity$$Type = ($ThresholdSwitchBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThresholdSwitchBlockEntity$$Original = $ThresholdSwitchBlockEntity;}
declare module "com.simibubi.create.content.contraptions.bearing.SailBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SailBlock extends $WrenchableDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "applyDye"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Vec3$$Type, arg4: $DyeColor$$Type): void
public "isFrame"(): boolean
public static "withCanvas"(arg0: $BlockBehaviour$Properties$$Type, arg1: $DyeColor$$Type): $SailBlock
public static "frame"(arg0: $BlockBehaviour$Properties$$Type): $SailBlock
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getColor"(): $DyeColor
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SailBlock$$Type = ($SailBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SailBlock$$Original = $SailBlock;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.attributes.InTagAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $InTagAttribute$Type implements $ItemAttributeType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InTagAttribute$Type$$Type = ($InTagAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InTagAttribute$Type$$Original = $InTagAttribute$Type;}
declare module "com.simibubi.create.content.trains.signal.SignalBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SignalBlockEntity, $SignalBlockEntity$$Type} from "com.simibubi.create.content.trains.signal.SignalBlockEntity"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SignalBlock$SignalType} from "com.simibubi.create.content.trains.signal.SignalBlock$SignalType"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SignalBlock extends $Block implements $IBE$$Interface<($SignalBlockEntity)>, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "TYPE": $EnumProperty<($SignalBlock$SignalType)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "getBlockEntityType"(): $BlockEntityType<($SignalBlockEntity)>
public "getBlockEntityClass"(): $Class<($SignalBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SignalBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SignalBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SignalBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SignalBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SignalBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SignalBlockEntity)>
get "blockEntityClass"(): $Class<($SignalBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignalBlock$$Type = ($SignalBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignalBlock$$Original = $SignalBlock;}
declare module "com.simibubi.create.content.redstone.smartObserver.SmartObserverBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$SmartObserverBlockEntity, $SmartObserverBlockEntity$$Type} from "com.simibubi.create.content.redstone.smartObserver.SmartObserverBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$DirectedDirectionalBlock} from "com.simibubi.create.content.redstone.DirectedDirectionalBlock"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $SmartObserverBlock extends $DirectedDirectionalBlock implements $IBE$$Interface<($SmartObserverBlockEntity)> {
static readonly "TARGET": $EnumProperty<($AttachFace)>
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DirectedDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getBlockEntityType"(): $BlockEntityType<($SmartObserverBlockEntity)>
public "getBlockEntityClass"(): $Class<($SmartObserverBlockEntity)>
public "onFunnelTransfer"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type): void
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SmartObserverBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SmartObserverBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SmartObserverBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SmartObserverBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SmartObserverBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SmartObserverBlockEntity)>
get "blockEntityClass"(): $Class<($SmartObserverBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmartObserverBlock$$Type = ($SmartObserverBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmartObserverBlock$$Original = $SmartObserverBlock;}
declare module "com.simibubi.create.content.trains.display.FlapDisplayBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$IRotate$SpeedLevel} from "com.simibubi.create.content.kinetics.base.IRotate$SpeedLevel"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$HorizontalKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalKineticBlock"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ICogWheel$$Interface} from "com.simibubi.create.content.kinetics.simpleRelays.ICogWheel"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$FlapDisplayBlockEntity, $FlapDisplayBlockEntity$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayBlockEntity"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $FlapDisplayBlock extends $HorizontalKineticBlock implements $IBE$$Interface<($FlapDisplayBlockEntity)>, $IWrenchable$$Interface, $ICogWheel$$Interface, $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "DOWN": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UP": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "HORIZONTAL_FACING": $Property<($Direction)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "getMinimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($FlapDisplayBlockEntity)>
public static "setConnection"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: boolean): $BlockState
public "getBlockEntityClass"(): $Class<($FlapDisplayBlockEntity)>
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public static "getConnection"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($FlapDisplayBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($FlapDisplayBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FlapDisplayBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FlapDisplayBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $FlapDisplayBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "isSmallCog"(): boolean
public static "isSmallCog"(arg0: $Block$$Type): boolean
public static "isSmallCog"(arg0: $BlockState$$Type): boolean
public "isLargeCog"(): boolean
public static "isLargeCog"(arg0: $Block$$Type): boolean
public static "isLargeCog"(arg0: $BlockState$$Type): boolean
public "isDedicatedCogWheel"(): boolean
public static "isDedicatedCogWheel"(arg0: $Block$$Type): boolean
public static "isDedicatedCogItem"(arg0: $ItemStack$$Type): boolean
public static "isSmallCogItem"(arg0: $ItemStack$$Type): boolean
public static "isLargeCogItem"(arg0: $ItemStack$$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
get "minimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
get "blockEntityType"(): $BlockEntityType<($FlapDisplayBlockEntity)>
get "blockEntityClass"(): $Class<($FlapDisplayBlockEntity)>
get "smallCog"(): boolean
get "largeCog"(): boolean
get "dedicatedCogWheel"(): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlapDisplayBlock$$Type = ($FlapDisplayBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlapDisplayBlock$$Original = $FlapDisplayBlock;}
declare module "com.simibubi.create.content.kinetics.steamEngine.SteamEngineBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$FaceAttachedHorizontalDirectionalBlock} from "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$SteamEngineBlockEntity, $SteamEngineBlockEntity$$Type} from "com.simibubi.create.content.kinetics.steamEngine.SteamEngineBlockEntity"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $SteamEngineBlock extends $FaceAttachedHorizontalDirectionalBlock implements $SimpleWaterloggedBlock$$Interface, $IWrenchable$$Interface, $IBE$$Interface<($SteamEngineBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SteamEngineBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($AttachFace)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "getConnectedDirection"(arg0: $BlockState$$Type): $Direction
public static "canAttach"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "getBlockEntityType"(): $BlockEntityType<($SteamEngineBlockEntity)>
public static "getFacing"(arg0: $BlockState$$Type): $Direction
public "getBlockEntityClass"(): $Class<($SteamEngineBlockEntity)>
public static "getShaftPos"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type): $BlockPos
public static "isShaftValid"(arg0: $BlockState$$Type, arg1: $BlockState$$Type): boolean
public static "getSpeedRange"(): $Couple<(integer)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SteamEngineBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SteamEngineBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SteamEngineBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SteamEngineBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SteamEngineBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SteamEngineBlockEntity)>
get "blockEntityClass"(): $Class<($SteamEngineBlockEntity)>
public static get "speedRange"(): $Couple<(integer)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SteamEngineBlock$$Type = ($SteamEngineBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SteamEngineBlock$$Original = $SteamEngineBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.target.SingleLineDisplayTarget" {
import {$DisplayTargetStats} from "com.simibubi.create.content.redstone.displayLink.target.DisplayTargetStats"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List$$Type} from "java.util.List"
import {$MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$Component} from "net.minecraft.network.chat.Component"
import {$DisplayTarget} from "com.simibubi.create.api.behaviour.display.DisplayTarget"

export class $SingleLineDisplayTarget extends $DisplayTarget {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry<($BlockEntityType<(never)>), ($DisplayTarget)>
static readonly "BY_BLOCK": $SimpleRegistry<($Block), ($DisplayTarget)>

constructor()

public "getLineOptionText"(arg0: integer): $Component
public "provideStats"(arg0: $DisplayLinkContext$$Type): $DisplayTargetStats
public "acceptText"(arg0: integer, arg1: $List$$Type<($MutableComponent$$Type)>, arg2: $DisplayLinkContext$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingleLineDisplayTarget$$Type = ($SingleLineDisplayTarget);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SingleLineDisplayTarget$$Original = $SingleLineDisplayTarget;}
declare module "com.simibubi.create.content.kinetics.base.RotatedPillarKineticBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$KineticBlock} from "com.simibubi.create.content.kinetics.base.KineticBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RotatedPillarKineticBlock extends $KineticBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "getPreferredAxis"(arg0: $BlockPlaceContext$$Type): $Direction$Axis
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotatedPillarKineticBlock$$Type = ($RotatedPillarKineticBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RotatedPillarKineticBlock$$Original = $RotatedPillarKineticBlock;}
declare module "com.simibubi.create.content.equipment.bell.PeculiarBellBlockEntity" {
import {$PartialModel} from "dev.engine_room.flywheel.lib.model.baked.PartialModel"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Direction} from "net.minecraft.core.Direction"
import {$AbstractBellBlockEntity} from "com.simibubi.create.content.equipment.bell.AbstractBellBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PeculiarBellBlockEntity extends $AbstractBellBlockEntity {
 "ringDirection": $Direction
 "ringingTicks": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "isRinging": boolean
static readonly "RING_DURATION": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getBellModel"(): $PartialModel
get "bellModel"(): $PartialModel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PeculiarBellBlockEntity$$Type = ($PeculiarBellBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PeculiarBellBlockEntity$$Original = $PeculiarBellBlockEntity;}
declare module "com.simibubi.create.content.fluids.drain.ItemDrainBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveGoggleInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveGoggleInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ItemDrainBlockEntity extends $SmartBlockEntity implements $IHaveGoggleInformation$$Interface {
static readonly "FILLING_TIME": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getHeldItemStack"(): $ItemStack
public "setHeldItem"(arg0: $TransportedItemStack$$Type, arg1: $Direction$$Type): void
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public "containedFluidTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean, arg2: $IFluidHandler$$Type): boolean
public "getIcon"(arg0: boolean): $ItemStack
get "heldItemStack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDrainBlockEntity$$Type = ($ItemDrainBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemDrainBlockEntity$$Original = $ItemDrainBlockEntity;}
declare module "com.simibubi.create.content.kinetics.steamEngine.SteamEngineBlockEntity" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidTankBlockEntity} from "com.simibubi.create.content.fluids.tank.FluidTankBlockEntity"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$PoweredShaftBlockEntity} from "com.simibubi.create.content.kinetics.steamEngine.PoweredShaftBlockEntity"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveGoggleInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveGoggleInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SteamEngineBlockEntity extends $SmartBlockEntity implements $IHaveGoggleInformation$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $WeakReference<($FluidTankBlockEntity)>
 "target": $WeakReference<($PoweredShaftBlockEntity)>

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "getShaft"(): $PoweredShaftBlockEntity
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getTargetAngle"(): float
public "tick"(): void
public "remove"(): void
public "isValid"(): boolean
public "getTank"(): $FluidTankBlockEntity
public "containedFluidTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean, arg2: $IFluidHandler$$Type): boolean
public "getIcon"(arg0: boolean): $ItemStack
get "shaft"(): $PoweredShaftBlockEntity
get "targetAngle"(): float
get "valid"(): boolean
get "tank"(): $FluidTankBlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SteamEngineBlockEntity$$Type = ($SteamEngineBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SteamEngineBlockEntity$$Original = $SteamEngineBlockEntity;}
declare module "com.simibubi.create.content.kinetics.simpleRelays.encased.EncasedShaftBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$EncasedBlock$$Interface} from "com.simibubi.create.content.decoration.encasing.EncasedBlock"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$AbstractEncasedShaftBlock} from "com.simibubi.create.content.kinetics.base.AbstractEncasedShaftBlock"
import {$KineticBlockEntity, $KineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $EncasedShaftBlock extends $AbstractEncasedShaftBlock implements $IBE$$Interface<($KineticBlockEntity)>, $SpecialBlockItemRequirement$$Interface, $EncasedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $Supplier$$Type<($Block$$Type)>)

public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
public "getBlockEntityClass"(): $Class<($KineticBlockEntity)>
public "getCasing"(): $Block
public "handleEncasing"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($KineticBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($KineticBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($KineticBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($KineticBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $KineticBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
get "blockEntityClass"(): $Class<($KineticBlockEntity)>
get "casing"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EncasedShaftBlock$$Type = ($EncasedShaftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EncasedShaftBlock$$Original = $EncasedShaftBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.StationSummaryDisplaySource" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$FlapDisplayBlockEntity$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayBlockEntity"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$DisplayTargetStats$$Type} from "com.simibubi.create.content.redstone.displayLink.target.DisplayTargetStats"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$FlapDisplayLayout$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayLayout"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $StationSummaryDisplaySource extends $DisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
public "provideText"(arg0: $DisplayLinkContext$$Type, arg1: $DisplayTargetStats$$Type): $List<($MutableComponent)>
public "provideFlapDisplayText"(arg0: $DisplayLinkContext$$Type, arg1: $DisplayTargetStats$$Type): $List<($List<($MutableComponent)>)>
public "loadFlapDisplayLayout"(arg0: $DisplayLinkContext$$Type, arg1: $FlapDisplayBlockEntity$$Type, arg2: $FlapDisplayLayout$$Type): void
public "populateData"(arg0: $DisplayLinkContext$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StationSummaryDisplaySource$$Type = ($StationSummaryDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StationSummaryDisplaySource$$Original = $StationSummaryDisplaySource;}
declare module "com.simibubi.create.content.logistics.packager.PackagerBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$LogisticallyLinkedBehaviour$RequestType$$Type} from "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBehaviour$RequestType"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List, $List$$Type} from "java.util.List"
import {$IdentifiedInventory$$Type} from "com.simibubi.create.content.logistics.packager.IdentifiedInventory"
import {$InvManipulationBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.inventory.InvManipulationBehaviour"
import {$BigItemStack} from "com.simibubi.create.content.logistics.BigItemStack"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$PackagerItemHandler} from "com.simibubi.create.content.logistics.packager.PackagerItemHandler"
import {$PackagingRequest$$Type} from "com.simibubi.create.content.logistics.packager.PackagingRequest"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$InventorySummary} from "com.simibubi.create.content.logistics.packager.InventorySummary"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PackagerBlockEntity extends $SmartBlockEntity implements $Clearable$$Interface {
 "targetInventory": $InvManipulationBehaviour
 "previouslyUnwrapped": $ItemStack
 "queuedExitingPackages": $List<($BigItemStack)>
 "customComputerAddress": StringJS
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "buttonCooldown": integer
readonly "inventory": $PackagerItemHandler
 "animationTicks": integer
 "computerBehaviour": $AbstractComputerBehaviour
 "hasCustomComputerAddress": boolean
 "redstonePowered": boolean
 "heldBox": $ItemStack
 "signBasedAddress": StringJS
 "animationInward": boolean
static readonly "CYCLE": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "recheckIfLinksPresent"(): void
public "getAvailableItems"(): $InventorySummary
public "redstoneModeActive"(): boolean
public "updateSignAddress"(): void
public "attemptToSend"(arg0: $List$$Type<($PackagingRequest$$Type)>): void
public "flashLink"(): void
public "isTooBusyFor"(arg0: $LogisticallyLinkedBehaviour$RequestType$$Type): boolean
public "getTrayOffset"(arg0: float): float
public "getRenderedBox"(): $ItemStack
public "isTargetingSameInventory"(arg0: $IdentifiedInventory$$Type): boolean
public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "triggerStockCheck"(): void
public "unwrapBox"(arg0: $ItemStack$$Type, arg1: boolean): boolean
public "tick"(): void
public "initialize"(): void
public "destroy"(): void
public "invalidate"(): void
public "activate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
get "availableItems"(): $InventorySummary
get "renderedBox"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagerBlockEntity$$Type = ($PackagerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagerBlockEntity$$Original = $PackagerBlockEntity;}
declare module "com.simibubi.create.content.schematics.cannon.SchematicannonBlockEntity" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$SchematicPrinter} from "com.simibubi.create.content.schematics.SchematicPrinter"
import {$CSchematics} from "com.simibubi.create.infrastructure.config.CSchematics"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$MaterialChecklist} from "com.simibubi.create.content.schematics.cannon.MaterialChecklist"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SchematicannonBlockEntity$State} from "com.simibubi.create.content.schematics.cannon.SchematicannonBlockEntity$State"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$SchematicannonInventory} from "com.simibubi.create.content.schematics.cannon.SchematicannonInventory"
import {$LinkedHashSet} from "java.util.LinkedHashSet"
import {$IItemHandler} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$LaunchedItem} from "com.simibubi.create.content.schematics.cannon.LaunchedItem"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $SchematicannonBlockEntity extends $SmartBlockEntity implements $MenuProvider$$Interface, $Clearable$$Interface {
 "flyingBlocks": $List<($LaunchedItem)>
 "schematicProgress": float
 "replaceBlockEntities": boolean
 "firstRenderTick": boolean
 "inventory": $SchematicannonInventory
 "previousTarget": $BlockPos
 "missingItem": $ItemStack
 "dontUpdateChecklist": boolean
 "replaceMode": integer
static readonly "NEIGHBOUR_CHECKING": integer
 "positionNotLoaded": boolean
 "blocksPlaced": integer
 "state": $SchematicannonBlockEntity$State
 "bookPrintingProgress": float
 "blocksToPlace": integer
 "skipMissing": boolean
 "defaultYaw": float
 "sendUpdate": boolean
 "neighbourCheckCooldown": integer
 "printer": $SchematicPrinter
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "checklist": $MaterialChecklist
 "remainingFuel": integer
 "hasCreativeCrate": boolean
static readonly "MAX_ANCHOR_DISTANCE": integer
 "statusMsg": StringJS
 "attachedInventories": $LinkedHashSet<($IItemHandler)>

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "clearContent"(): void
public "findInventories"(): void
public "finishedPrinting"(): void
public "getShotsPerGunpowder"(): integer
public "updateChecklist"(): void
public static "stripBeltIfNotLast"(arg0: $BlockState$$Type): $BlockState
public "playFiringSound"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "getRenderBoundingBox"(): $AABB
public "tick"(): void
public "getDisplayName"(): $Component
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "config"(): $CSchematics
public static "tryClear"(arg0: any): void
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
get "shotsPerGunpowder"(): integer
get "renderBoundingBox"(): $AABB
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicannonBlockEntity$$Type = ($SchematicannonBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicannonBlockEntity$$Original = $SchematicannonBlockEntity;}
declare module "com.simibubi.create.content.trains.schedule.destination.ScheduleInstruction" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ScheduleRuntime$$Type} from "com.simibubi.create.content.trains.schedule.ScheduleRuntime"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ScheduleDataEntry} from "com.simibubi.create.content.trains.schedule.ScheduleDataEntry"
import {$DiscoveredPath} from "com.simibubi.create.content.trains.graph.DiscoveredPath"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $ScheduleInstruction extends $ScheduleDataEntry {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ScheduleInstruction)>

constructor()

public "supportsConditions"(): boolean
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "start"(arg0: $ScheduleRuntime$$Type, arg1: $Level$$Type): $DiscoveredPath
public static "fromTag"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): $ScheduleInstruction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduleInstruction$$Type = ($ScheduleInstruction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduleInstruction$$Original = $ScheduleInstruction;}
declare module "com.simibubi.create.content.equipment.armor.BacktankItem" {
import {$ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BacktankItem$BacktankBlockItem$$Type} from "com.simibubi.create.content.equipment.armor.BacktankItem$BacktankBlockItem"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot} from "net.minecraft.world.entity.EquipmentSlot"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$BaseArmorItem} from "com.simibubi.create.content.equipment.armor.BaseArmorItem"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$DispenseItemBehavior} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $BacktankItem extends $BaseArmorItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BAR_COLOR": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "SLOT": $EquipmentSlot
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
static readonly "TYPE": $ArmorItem$Type
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Holder$$Type<($ArmorMaterial)>, arg1: $Item$Properties$$Type, arg2: $ResourceLocation$$Type, arg3: $Supplier$$Type<($BacktankItem$BacktankBlockItem$$Type)>)

public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "isEnchantable"(arg0: $ItemStack$$Type): boolean
public "supportsEnchantment"(arg0: $ItemStack$$Type, arg1: $Holder$$Type<($Enchantment)>): boolean
public static "getRemainingAir"(arg0: $ItemStack$$Type): integer
public static "getWornBy"(arg0: $Entity$$Type): $BacktankItem
public "getBlock"(): $Block
public "isBarVisible"(arg0: $ItemStack$$Type): boolean
public "getBarWidth"(arg0: $ItemStack$$Type): integer
public "getBarColor"(arg0: $ItemStack$$Type): integer
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "block"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BacktankItem$$Type = ($BacktankItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BacktankItem$$Original = $BacktankItem;}
declare module "com.simibubi.create.content.logistics.itemHatch.ItemHatchBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$FilteringBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.filtering.FilteringBehaviour"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ItemHatchBlockEntity extends $SmartBlockEntity implements $Clearable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "filtering": $FilteringBehaviour

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public static "tryClear"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemHatchBlockEntity$$Type = ($ItemHatchBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemHatchBlockEntity$$Original = $ItemHatchBlockEntity;}
declare module "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext" {
import {$SequencerInstructions, $SequencerInstructions$$Type} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencerInstructions"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Record} from "java.lang.Record"

export class $SequencedGearshiftBlockEntity$SequenceContext extends $Record {
constructor(instruction: $SequencerInstructions$$Type, relativeValue: double)

public static "fromGearshift"(arg0: $SequencerInstructions$$Type, arg1: double, arg2: integer): $SequencedGearshiftBlockEntity$SequenceContext
public "getEffectiveValue"(arg0: double): double
public static "fromNBT"(arg0: $CompoundTag$$Type): $SequencedGearshiftBlockEntity$SequenceContext
public "relativeValue"(): double
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "instruction"(): $SequencerInstructions
public "serializeNBT"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencedGearshiftBlockEntity$SequenceContext$$Type = ({"relativeValue"?: double, "instruction"?: $SequencerInstructions$$Type}) | ([relativeValue?: double, instruction?: $SequencerInstructions$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SequencedGearshiftBlockEntity$SequenceContext$$Original = $SequencedGearshiftBlockEntity$SequenceContext;}
declare module "com.simibubi.create.content.redstone.displayLink.source.FactoryGaugeDisplaySource" {
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$IntAttached} from "net.createmod.catnip.data.IntAttached"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ValueListDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.ValueListDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"
import {$FactoryPanelPosition$$Type} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelPosition"

export class $FactoryGaugeDisplaySource extends $ValueListDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "createEntry"(arg0: $Level$$Type, arg1: $FactoryPanelPosition$$Type): $IntAttached<($MutableComponent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryGaugeDisplaySource$$Type = ($FactoryGaugeDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FactoryGaugeDisplaySource$$Original = $FactoryGaugeDisplaySource;}
declare module "com.simibubi.create.content.trains.graph.DiscoveredPath" {
import {$TrackNode, $TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$List, $List$$Type} from "java.util.List"
import {$Couple, $Couple$$Type} from "net.createmod.catnip.data.Couple"
import {$GlobalStation, $GlobalStation$$Type} from "com.simibubi.create.content.trains.station.GlobalStation"

export class $DiscoveredPath {
 "path": $List<($Couple<($TrackNode)>)>
 "cost": double
 "distance": double
 "destination": $GlobalStation

constructor(arg0: double, arg1: double, arg2: $List$$Type<($Couple$$Type<($TrackNode$$Type)>)>, arg3: $GlobalStation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiscoveredPath$$Type = ($DiscoveredPath);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiscoveredPath$$Original = $DiscoveredPath;}
declare module "com.simibubi.create.content.redstone.thresholdSwitch.ThresholdSwitchBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$ThresholdSwitchBlockEntity, $ThresholdSwitchBlockEntity$$Type} from "com.simibubi.create.content.redstone.thresholdSwitch.ThresholdSwitchBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$DirectedDirectionalBlock} from "com.simibubi.create.content.redstone.DirectedDirectionalBlock"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $ThresholdSwitchBlock extends $DirectedDirectionalBlock implements $IBE$$Interface<($ThresholdSwitchBlockEntity)> {
static readonly "TARGET": $EnumProperty<($AttachFace)>
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DirectedDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "LEVEL": $IntegerProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getBlockEntityType"(): $BlockEntityType<($ThresholdSwitchBlockEntity)>
public "getBlockEntityClass"(): $Class<($ThresholdSwitchBlockEntity)>
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ThresholdSwitchBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ThresholdSwitchBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ThresholdSwitchBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ThresholdSwitchBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ThresholdSwitchBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ThresholdSwitchBlockEntity)>
get "blockEntityClass"(): $Class<($ThresholdSwitchBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThresholdSwitchBlock$$Type = ($ThresholdSwitchBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThresholdSwitchBlock$$Original = $ThresholdSwitchBlock;}
declare module "com.simibubi.create.content.decoration.steamWhistle.WhistleExtenderBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$WhistleBlock$WhistleSize} from "com.simibubi.create.content.decoration.steamWhistle.WhistleBlock$WhistleSize"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$WhistleExtenderBlock$WhistleExtenderShape} from "com.simibubi.create.content.decoration.steamWhistle.WhistleExtenderBlock$WhistleExtenderShape"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $WhistleExtenderBlock extends $Block implements $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "SIZE": $EnumProperty<($WhistleBlock$WhistleSize)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $EnumProperty<($WhistleExtenderBlock$WhistleExtenderShape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "hidesNeighborFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $Direction$$Type): boolean
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "findRoot"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): $BlockPos
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WhistleExtenderBlock$$Type = ($WhistleExtenderBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WhistleExtenderBlock$$Original = $WhistleExtenderBlock;}
declare module "com.simibubi.create.content.logistics.filter.FilterItem" {
import {$FilterItemStack} from "com.simibubi.create.content.logistics.filter.FilterItemStack"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DataComponentType} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$AttributeFilterItem} from "com.simibubi.create.content.logistics.filter.AttributeFilterItem"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$ListFilterItem} from "com.simibubi.create.content.logistics.filter.ListFilterItem"
import {$Map} from "java.util.Map"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$ItemCopyingRecipe$SupportsItemCopying$$Interface} from "com.simibubi.create.foundation.recipe.ItemCopyingRecipe$SupportsItemCopying"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$PackageFilterItem} from "com.simibubi.create.content.logistics.filter.PackageFilterItem"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"

export class $FilterItem extends $Item implements $MenuProvider$$Interface, $ItemCopyingRecipe$SupportsItemCopying$$Interface {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "makeSummary"(arg0: $ItemStack$$Type): $List<($Component)>
public static "doPackagesHaveSameData"(arg0: $ItemStack$$Type, arg1: $ItemStack$$Type): boolean
public static "testDirect"(arg0: $ItemStack$$Type, arg1: $ItemStack$$Type, arg2: boolean): boolean
public "makeStackWrapper"(arg0: $ItemStack$$Type): $FilterItemStack
public "getFilterItems"(arg0: $ItemStack$$Type): ($ItemStack)[]
public static "attribute"(arg0: $Item$Properties$$Type): $AttributeFilterItem
public "getDisplayName"(): $Component
public "getComponentType"(): $DataComponentType<(never)>
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "address"(arg0: $Item$Properties$$Type): $PackageFilterItem
public static "regular"(arg0: $Item$Properties$$Type): $ListFilterItem
public "createCopy"(arg0: $ItemStack$$Type, arg1: integer): $ItemStack
public "canCopyFromItem"(arg0: $ItemStack$$Type): boolean
public "canCopyToItem"(arg0: $ItemStack$$Type): boolean
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "displayName"(): $Component
get "componentType"(): $DataComponentType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterItem$$Type = ($FilterItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FilterItem$$Original = $FilterItem;}
declare module "com.simibubi.create.content.logistics.crate.CreativeCrateMountedStorage" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MountedItemStorageType} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageType"
import {$MountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorage"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CreativeCrateMountedStorage extends $MountedItemStorage {
static readonly "CODEC": $MapCodec<($CreativeCrateMountedStorage)>
readonly "type": $MountedItemStorageType<($MountedItemStorage)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MountedItemStorage)>

constructor(arg0: $ItemStack$$Type)

public "unmount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): void
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
get "slots"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeCrateMountedStorage$$Type = ($CreativeCrateMountedStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeCrateMountedStorage$$Original = $CreativeCrateMountedStorage;}
declare module "com.simibubi.create.content.logistics.stockTicker.StockTickerBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$LogisticallyLinkedBehaviour$RequestType$$Type} from "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBehaviour$RequestType"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List, $List$$Type} from "java.util.List"
import {$IdentifiedInventory$$Type} from "com.simibubi.create.content.logistics.packager.IdentifiedInventory"
import {$BigItemStack, $BigItemStack$$Type} from "com.simibubi.create.content.logistics.BigItemStack"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$IItemHandler} from "net.neoforged.neoforge.items.IItemHandler"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveHoveringInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveHoveringInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$LogisticallyLinkedBehaviour} from "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBehaviour"
import {$StockCheckingBlockEntity} from "com.simibubi.create.content.logistics.stockTicker.StockCheckingBlockEntity"
import {$PackageOrderWithCrafts$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$InventorySummary} from "com.simibubi.create.content.logistics.packager.InventorySummary"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StockTickerBlockEntity extends $StockCheckingBlockEntity implements $IHaveHoveringInformation$$Interface, $Clearable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "behaviour": $LogisticallyLinkedBehaviour
 "computerBehaviour": $AbstractComputerBehaviour

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getTicksSinceLastUpdate"(): integer
public "refreshClientStockSnapshot"(): void
public "getLastClientsideStockSnapshotAsSummary"(): $InventorySummary
public "getRecentSummary"(): $InventorySummary
public "broadcastPackageRequest"(arg0: $LogisticallyLinkedBehaviour$RequestType$$Type, arg1: $PackageOrderWithCrafts$$Type, arg2: $IdentifiedInventory$$Type, arg3: StringJS): boolean
public "getReceivedPaymentsHandler"(): $IItemHandler
public "getClientStockSnapshot"(): $List<($List<($BigItemStack)>)>
public "receiveStockPacket"(arg0: $List$$Type<($BigItemStack$$Type)>, arg1: boolean): void
public "playEffect"(): void
public "clearContent"(): void
public "addToTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "isKeeperPresent"(): boolean
public "tick"(): void
public "destroy"(): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
public "getIcon"(arg0: boolean): $ItemStack
get "ticksSinceLastUpdate"(): integer
get "lastClientsideStockSnapshotAsSummary"(): $InventorySummary
get "recentSummary"(): $InventorySummary
get "receivedPaymentsHandler"(): $IItemHandler
get "clientStockSnapshot"(): $List<($List<($BigItemStack)>)>
get "keeperPresent"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StockTickerBlockEntity$$Type = ($StockTickerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StockTickerBlockEntity$$Original = $StockTickerBlockEntity;}
declare module "com.simibubi.create.content.fluids.pipes.FluidPipeBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FluidPipeBlockEntity extends $SmartBlockEntity implements $TransformableBlockEntity$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPipeBlockEntity$$Type = ($FluidPipeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidPipeBlockEntity$$Original = $FluidPipeBlockEntity;}
declare module "com.simibubi.create.content.contraptions.bearing.IBearingBlockEntity" {
import {$AbstractContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$ControlledContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.ControlledContraptionEntity"
import {$IControlContraption$$Interface} from "com.simibubi.create.content.contraptions.IControlContraption"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$ValueBoxTransform} from "com.simibubi.create.foundation.blockEntity.behaviour.ValueBoxTransform"

export interface $IBearingBlockEntity$$Interface extends $IControlContraption$$Interface {
set "angle"(value: float)
get "movementModeSlot"(): $ValueBoxTransform
get "woodenTop"(): boolean
get "valid"(): boolean
get "blockPosition"(): $BlockPos
}

export class $IBearingBlockEntity implements $IBearingBlockEntity$$Interface {
 "setAngle"(arg0: float): void
 "getMovementModeSlot"(): $ValueBoxTransform
 "isWoodenTop"(): boolean
 "getInterpolatedAngle"(arg0: float): float
 "isAttachedTo"(arg0: $AbstractContraptionEntity$$Type): boolean
 "onStall"(): void
 "attach"(arg0: $ControlledContraptionEntity$$Type): void
 "isValid"(): boolean
 "getBlockPosition"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IBearingBlockEntity$$Type = ($IBearingBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IBearingBlockEntity$$Original = $IBearingBlockEntity;}
declare module "com.simibubi.create.content.decoration.steamWhistle.WhistleExtenderBlock$WhistleExtenderShape" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $WhistleExtenderBlock$WhistleExtenderShape extends $Enum<($WhistleExtenderBlock$WhistleExtenderShape)> implements $StringRepresentable$$Interface {
static readonly "SINGLE": $WhistleExtenderBlock$WhistleExtenderShape
static readonly "DOUBLE": $WhistleExtenderBlock$WhistleExtenderShape
static readonly "DOUBLE_CONNECTED": $WhistleExtenderBlock$WhistleExtenderShape

public static "values"(): ($WhistleExtenderBlock$WhistleExtenderShape)[]
public static "valueOf"(arg0: StringJS): $WhistleExtenderBlock$WhistleExtenderShape
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WhistleExtenderBlock$WhistleExtenderShape$$Type = (("single") | ("double") | ("double_connected"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WhistleExtenderBlock$WhistleExtenderShape$$Original = $WhistleExtenderBlock$WhistleExtenderShape;}
declare module "com.simibubi.create.content.kinetics.fan.AirCurrent" {
import {$FanProcessingType} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$AirCurrent$AirCurrentSegment} from "com.simibubi.create.content.kinetics.fan.AirCurrent$AirCurrentSegment"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$AABB} from "net.minecraft.world.phys.AABB"
import {$IAirCurrentSource, $IAirCurrentSource$$Type} from "com.simibubi.create.content.kinetics.fan.IAirCurrentSource"

export class $AirCurrent {
 "bounds": $AABB
 "maxDistance": float
readonly "source": $IAirCurrentSource
 "pushing": boolean
 "segments": $List<($AirCurrent$AirCurrentSegment)>
 "direction": $Direction

constructor(arg0: $IAirCurrentSource$$Type)

public static "isPlayerCreativeFlying"(arg0: $Entity$$Type): boolean
public static "getFlowLimit"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: float, arg3: $Direction$$Type): float
public "findEntities"(): void
public "tickAffectedHandlers"(): void
public "findAffectedHandlers"(): void
public "tick"(): void
public "rebuild"(): void
public "getTypeAt"(arg0: float): $FanProcessingType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AirCurrent$$Type = ($AirCurrent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AirCurrent$$Original = $AirCurrent;}
declare module "com.simibubi.create.content.trains.signal.SignalBlockEntity$OverlayState" {
import {$Enum} from "java.lang.Enum"

export class $SignalBlockEntity$OverlayState extends $Enum<($SignalBlockEntity$OverlayState)> {
static readonly "RENDER": $SignalBlockEntity$OverlayState
static readonly "SKIP": $SignalBlockEntity$OverlayState
static readonly "DUAL": $SignalBlockEntity$OverlayState

public static "values"(): ($SignalBlockEntity$OverlayState)[]
public static "valueOf"(arg0: StringJS): $SignalBlockEntity$OverlayState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignalBlockEntity$OverlayState$$Type = (("render") | ("skip") | ("dual"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignalBlockEntity$OverlayState$$Original = $SignalBlockEntity$OverlayState;}
declare module "com.simibubi.create.content.trains.entity.CarriageContraption" {
import {$CarriageContraptionEntity$$Type} from "com.simibubi.create.content.trains.entity.CarriageContraptionEntity"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Contraption} from "com.simibubi.create.content.contraptions.Contraption"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AbstractContraptionEntity} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$CollisionList} from "com.simibubi.create.foundation.collision.CollisionList"
import {$Object2BooleanMap} from "it.unimi.dsi.fastutil.objects.Object2BooleanMap"
import {$MountedStorageManager, $MountedStorageManager$$Type} from "com.simibubi.create.content.contraptions.MountedStorageManager"
import {$ArrivalSoundQueue} from "com.simibubi.create.content.trains.entity.ArrivalSoundQueue"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB} from "net.minecraft.world.phys.AABB"
import {$ContraptionType} from "com.simibubi.create.api.contraption.ContraptionType"

export class $CarriageContraption extends $Contraption {
 "hasUniversalCreativeCrate": boolean
 "isLegacy": $Object2BooleanMap<($BlockPos)>
 "conductorSeats": $Map<($BlockPos), ($Couple<(boolean)>)>
 "portalCutoffMax": integer
readonly "simplifiedEntityColliders": $CollisionList
 "soundQueue": $ArrivalSoundQueue
 "blockConductors": $Couple<(boolean)>
 "anchor": $BlockPos
 "stalled": boolean
 "bounds": $AABB
 "portalCutoffMin": integer
 "disassembled": boolean
 "entity": $AbstractContraptionEntity

constructor(arg0: $Direction$$Type)
constructor()

public "withinVisible"(arg0: $BlockPos$$Type): boolean
public "withinVisible"(arg0: integer): boolean
public "setSoundQueueOffset"(arg0: integer): void
public "returnStorageForDisassembly"(arg0: $MountedStorageManager$$Type): void
public "hasForwardControls"(): boolean
public "hasBackwardControls"(): boolean
public "getSecondBogeyPos"(): $BlockPos
public "writeStorage"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "isHiddenInPortal"(arg0: integer): boolean
public "isHiddenInPortal"(arg0: $BlockPos$$Type): boolean
public "getSimplifiedEntityColliders"(): $CollisionList
public "getStorage"(): $MountedStorageManager
public "assemble"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public "writeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: boolean): $CompoundTag
public "readNBT"(arg0: $Level$$Type, arg1: $CompoundTag$$Type, arg2: boolean): void
public "getAssemblyDirection"(): $Direction
public "inControl"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
public "swapStorageAfterAssembly"(arg0: $CarriageContraptionEntity$$Type): void
public "atSeam"(arg0: $BlockPos$$Type): boolean
public "atSeam"(arg0: integer): boolean
public "notInPortal"(): boolean
public "canBeStabilized"(arg0: $Direction$$Type, arg1: $BlockPos$$Type): boolean
public "getType"(): $ContraptionType
set "soundQueueOffset"(value: integer)
get "secondBogeyPos"(): $BlockPos
get "storage"(): $MountedStorageManager
get "assemblyDirection"(): $Direction
get "type"(): $ContraptionType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarriageContraption$$Type = ($CarriageContraption);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarriageContraption$$Original = $CarriageContraption;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$BeltType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$BeltType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$BeltType$$Type = ($AllArmInteractionPointTypes$BeltType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$BeltType$$Original = $AllArmInteractionPointTypes$BeltType;}
declare module "com.simibubi.create.content.logistics.packagePort.PackagePortItem" {
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $PackagePortItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagePortItem$$Type = ($PackagePortItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagePortItem$$Original = $PackagePortItem;}
declare module "com.simibubi.create.content.trains.entity.TrainIconType" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Map} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$GuiGraphics$$Type} from "net.minecraft.client.gui.GuiGraphics"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $TrainIconType {
static readonly "FLIPPED_ENGINE": integer
static readonly "ENGINE": integer
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($TrainIconType)>
static "REGISTRY": $Map<($ResourceLocation), ($TrainIconType)>

constructor(arg0: $ResourceLocation$$Type, arg1: $ResourceLocation$$Type, arg2: integer, arg3: integer)

public "getIconOffset"(arg0: integer): integer
public "getIconWidth"(arg0: integer): integer
public static "getDefault"(): $TrainIconType
public static "register"(arg0: $ResourceLocation$$Type, arg1: $ResourceLocation$$Type, arg2: integer, arg3: integer): void
public "getId"(): $ResourceLocation
public "render"(arg0: integer, arg1: $GuiGraphics$$Type, arg2: integer, arg3: integer): integer
public static "byId"(arg0: $ResourceLocation$$Type): $TrainIconType
public static get "default"(): $TrainIconType
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrainIconType$$Type = ($TrainIconType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrainIconType$$Original = $TrainIconType;}
declare module "com.simibubi.create.content.redstone.contact.RedstoneContactItem" {
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $RedstoneContactItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneContactItem$$Type = ($RedstoneContactItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneContactItem$$Original = $RedstoneContactItem;}
declare module "com.simibubi.create.content.legacy.ShadowSteelItem" {
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$NoGravMagicalDohickyItem} from "com.simibubi.create.content.legacy.NoGravMagicalDohickyItem"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"

export class $ShadowSteelItem extends $NoGravMagicalDohickyItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShadowSteelItem$$Type = ($ShadowSteelItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShadowSteelItem$$Original = $ShadowSteelItem;}
declare module "com.simibubi.create.content.kinetics.crusher.CrushingWheelBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$CrushingWheelBlockEntity, $CrushingWheelBlockEntity$$Type} from "com.simibubi.create.content.kinetics.crusher.CrushingWheelBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RotatedPillarKineticBlock} from "com.simibubi.create.content.kinetics.base.RotatedPillarKineticBlock"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $CrushingWheelBlock extends $RotatedPillarKineticBlock implements $IBE$$Interface<($CrushingWheelBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($CrushingWheelBlockEntity)>
public "getBlockEntityClass"(): $Class<($CrushingWheelBlockEntity)>
public "updateControllers"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): void
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "entityInside"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($CrushingWheelBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($CrushingWheelBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CrushingWheelBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CrushingWheelBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $CrushingWheelBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
get "blockEntityType"(): $BlockEntityType<($CrushingWheelBlockEntity)>
get "blockEntityClass"(): $Class<($CrushingWheelBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrushingWheelBlock$$Type = ($CrushingWheelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CrushingWheelBlock$$Original = $CrushingWheelBlock;}
declare module "com.simibubi.create.content.processing.burner.BlazeBurnerBlockEntity$FuelType" {
import {$Enum} from "java.lang.Enum"

export class $BlazeBurnerBlockEntity$FuelType extends $Enum<($BlazeBurnerBlockEntity$FuelType)> {
static readonly "NONE": $BlazeBurnerBlockEntity$FuelType
static readonly "SPECIAL": $BlazeBurnerBlockEntity$FuelType
static readonly "NORMAL": $BlazeBurnerBlockEntity$FuelType

public static "values"(): ($BlazeBurnerBlockEntity$FuelType)[]
public static "valueOf"(arg0: StringJS): $BlazeBurnerBlockEntity$FuelType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlazeBurnerBlockEntity$FuelType$$Type = (("none") | ("normal") | ("special"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlazeBurnerBlockEntity$FuelType$$Original = $BlazeBurnerBlockEntity$FuelType;}
declare module "com.simibubi.create.content.redstone.diodes.AbstractDiodeBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$DiodeBlock} from "net.minecraft.world.level.block.DiodeBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractDiodeBlock extends $DiodeBlock implements $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractDiodeBlock$$Type = ($AbstractDiodeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractDiodeBlock$$Original = $AbstractDiodeBlock;}
declare module "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack" {
import {$FanProcessingType} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Comparable$$Interface} from "java.lang.Comparable"
import {$Direction} from "net.minecraft.core.Direction"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $TransportedItemStack implements $Comparable$$Interface<($TransportedItemStack)> {
 "lockedExternally": boolean
 "stack": $ItemStack
 "beltPosition": float
 "insertedAt": integer
 "insertedFrom": $Direction
 "prevSideOffset": float
 "angle": integer
 "prevBeltPosition": float
 "sideOffset": float
 "locked": boolean
 "processedBy": $FanProcessingType
 "processingTime": integer

constructor(arg0: $ItemStack$$Type)

public "clearFanProcessingData"(): void
public "getTargetSideOffset"(): float
public "getSimilar"(): $TransportedItemStack
public "compareTo"(arg0: $TransportedItemStack$$Type): integer
public "compareTo"(arg0: any): integer
public static "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $TransportedItemStack
public "copy"(): $TransportedItemStack
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
get "targetSideOffset"(): float
get "similar"(): $TransportedItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransportedItemStack$$Type = ($TransportedItemStack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TransportedItemStack$$Original = $TransportedItemStack;}
declare module "com.simibubi.create.content.processing.basin.BasinOperatingBlockEntity" {
import {$DeferralBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.simple.DeferralBehaviour"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $BasinOperatingBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "basinRemoved": boolean
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "basinChecker": $DeferralBehaviour
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "startProcessingBasin"(): void
public "continueWithPreviousRecipe"(): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onSpeedChanged"(arg0: float): void
public "tick"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasinOperatingBlockEntity$$Type = ($BasinOperatingBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasinOperatingBlockEntity$$Original = $BasinOperatingBlockEntity;}
declare module "com.simibubi.create.content.fluids.hosePulley.HosePulleyBlockEntity" {
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $HosePulleyBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getMovementSpeed"(): float
public "getInterpolatedOffset"(arg0: float): float
public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "sendData"(): void
public "onSpeedChanged"(arg0: float): void
public "tick"(): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
get "movementSpeed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HosePulleyBlockEntity$$Type = ($HosePulleyBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HosePulleyBlockEntity$$Original = $HosePulleyBlockEntity;}
declare module "com.simibubi.create.content.kinetics.simpleRelays.AbstractSimpleShaftBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$AbstractShaftBlock} from "com.simibubi.create.content.kinetics.simpleRelays.AbstractShaftBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IWrenchableWithBracket$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchableWithBracket"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"

export class $AbstractSimpleShaftBlock extends $AbstractShaftBlock implements $IWrenchableWithBracket$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
public "removeBracket"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: boolean): $Optional<($ItemStack)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "tryRemoveBracket"(arg0: $UseOnContext$$Type): boolean
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractSimpleShaftBlock$$Type = ($AbstractSimpleShaftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractSimpleShaftBlock$$Original = $AbstractSimpleShaftBlock;}
declare module "com.simibubi.create.content.processing.recipe.StandardProcessingRecipe$Factory" {
import {$ProcessingRecipe$Factory$$Interface} from "com.simibubi.create.content.processing.recipe.ProcessingRecipe$Factory"
import {$ProcessingRecipeParams, $ProcessingRecipeParams$$Type} from "com.simibubi.create.content.processing.recipe.ProcessingRecipeParams"
import {$StandardProcessingRecipe, $StandardProcessingRecipe$$Type} from "com.simibubi.create.content.processing.recipe.StandardProcessingRecipe"

export interface $StandardProcessingRecipe$Factory$$Interface<R extends $StandardProcessingRecipe<(object)>> extends $ProcessingRecipe$Factory$$Interface<($ProcessingRecipeParams), (R)> {

(arg0: $ProcessingRecipeParams): R
}

export class $StandardProcessingRecipe$Factory<R extends $StandardProcessingRecipe<(object)>> implements $StandardProcessingRecipe$Factory$$Interface {
 "create"(arg0: $ProcessingRecipeParams$$Type): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StandardProcessingRecipe$Factory$$Type<R> = ((arg0: $ProcessingRecipeParams) => R);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StandardProcessingRecipe$Factory$$Original<R> = $StandardProcessingRecipe$Factory<(R)>;}
declare module "com.simibubi.create.content.trains.track.ITrackBlock" {
import {$BezierConnection$$Type} from "com.simibubi.create.content.trains.track.BezierConnection"
import {$Direction$AxisDirection, $Direction$AxisDirection$$Type} from "net.minecraft.core.Direction$AxisDirection"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$BezierTrackPointLocation$$Type} from "com.simibubi.create.content.trains.track.BezierTrackPointLocation"
import {$PartialModel} from "dev.engine_room.flywheel.lib.model.baked.PartialModel"
import {$Affine, $Affine$$Type} from "dev.engine_room.flywheel.lib.transform.Affine"
import {$List} from "java.util.List"
import {$PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$TrackMaterial, $TrackMaterial$$Type} from "com.simibubi.create.content.trains.track.TrackMaterial"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$TrackNodeLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$TrackTargetingBehaviour$RenderedTrackOverlayType$$Type} from "com.simibubi.create.content.trains.track.TrackTargetingBehaviour$RenderedTrackOverlayType"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$TrackNodeLocation$DiscoveredLocation, $TrackNodeLocation$DiscoveredLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackNodeLocation$DiscoveredLocation"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Function$$Type} from "java.util.function.Function"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $ITrackBlock$$Interface {
get "material"(): $TrackMaterial
}

export class $ITrackBlock implements $ITrackBlock$$Interface {
 "getNearestTrackAxis"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Vec3$$Type): $Pair<($Vec3), ($Direction$AxisDirection)>
 "getUpNormal"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $Vec3
 "getCurveStart"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Vec3$$Type): $Vec3
 "getBogeyAnchor"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
 "getYOffsetAt"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Vec3$$Type): integer
 "getConnected"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: boolean, arg4: $TrackNodeLocation$$Type): $Collection<($TrackNodeLocation$DiscoveredLocation)>
 "getTrackAxes"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $List<($Vec3)>
 "getElevationAtCenter"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): double
static "addToListIfConnected"(arg0: $TrackNodeLocation$$Type, arg1: $Collection$$Type<($TrackNodeLocation$DiscoveredLocation$$Type)>, arg2: $BiFunction$$Type<(double), (boolean), ($Vec3$$Type)>, arg3: $Function$$Type<(boolean), ($Vec3$$Type)>, arg4: $Function$$Type<(boolean), ($ResourceKey$$Type<($Level$$Type)>)>, arg5: $Function$$Type<($Vec3), (integer)>, arg6: $Vec3$$Type, arg7: $BezierConnection$$Type, arg8: $BiFunction$$Type<(boolean), ($Vec3), ($TrackMaterial$$Type)>): void
 "prepareAssemblyOverlay"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type, arg4: $PoseStack$$Type): $PartialModel
 "prepareTrackOverlay"<Self extends $Affine<(object)>>(arg0: $Affine$$Type<(Self)>, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BezierTrackPointLocation$$Type, arg5: $Direction$AxisDirection$$Type, arg6: $TrackTargetingBehaviour$RenderedTrackOverlayType$$Type): $PartialModel
 "trackEquals"(arg0: $BlockState$$Type, arg1: $BlockState$$Type): boolean
static "getMaterialSimple"(arg0: $BlockGetter$$Type, arg1: $Vec3$$Type): $TrackMaterial
static "getMaterialSimple"(arg0: $BlockGetter$$Type, arg1: $Vec3$$Type, arg2: $TrackMaterial$$Type): $TrackMaterial
 "isSlope"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
static "walkConnectedTracks"(arg0: $BlockGetter$$Type, arg1: $TrackNodeLocation$$Type, arg2: boolean): $Collection<($TrackNodeLocation$DiscoveredLocation)>
 "overlay"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type): $BlockState
 "getMaterial"(): $TrackMaterial
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ITrackBlock$$Type = ($ITrackBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ITrackBlock$$Original = $ITrackBlock;}
declare module "com.simibubi.create.content.processing.sequenced.SequencedAssemblyRecipeSerializer" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$SequencedAssemblyRecipe} from "com.simibubi.create.content.processing.sequenced.SequencedAssemblyRecipe"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$RecipeSerializer, $RecipeSerializer$$Type, $RecipeSerializer$$Interface} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $SequencedAssemblyRecipeSerializer implements $RecipeSerializer$$Interface<($SequencedAssemblyRecipe)> {
readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($SequencedAssemblyRecipe)>

constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($SequencedAssemblyRecipe)>
public "codec"(): $MapCodec<($SequencedAssemblyRecipe)>
public static "register"<S extends $RecipeSerializer<(object)>, T extends $Recipe<(object)>>(arg0: StringJS, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencedAssemblyRecipeSerializer$$Type = ($SequencedAssemblyRecipeSerializer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SequencedAssemblyRecipeSerializer$$Original = $SequencedAssemblyRecipeSerializer;}
declare module "com.simibubi.create.content.trains.schedule.condition.ScheduleWaitCondition" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Train$$Type} from "com.simibubi.create.content.trains.entity.Train"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ScheduleDataEntry} from "com.simibubi.create.content.trains.schedule.ScheduleDataEntry"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $ScheduleWaitCondition extends $ScheduleDataEntry {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ScheduleWaitCondition)>

constructor()

public "getWaitingStatus"(arg0: $Level$$Type, arg1: $Train$$Type, arg2: $CompoundTag$$Type): $MutableComponent
public "tickCompletion"(arg0: $Level$$Type, arg1: $Train$$Type, arg2: $CompoundTag$$Type): boolean
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "fromTag"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): $ScheduleWaitCondition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduleWaitCondition$$Type = ($ScheduleWaitCondition);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduleWaitCondition$$Original = $ScheduleWaitCondition;}
declare module "com.simibubi.create.content.contraptions.behaviour.MovementContext" {
import {$UnaryOperator} from "java.util.function.UnaryOperator"
import {$FilterItemStack} from "com.simibubi.create.content.logistics.filter.FilterItemStack"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$Contraption, $Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$MountedFluidStorage} from "com.simibubi.create.api.contraption.storage.fluid.MountedFluidStorage"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"
import {$MountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorage"

export class $MovementContext {
 "localPos": $BlockPos
 "motion": $Vec3
 "data": $CompoundTag
 "contraption": $Contraption
 "rotation": $UnaryOperator<($Vec3)>
 "stall": boolean
 "firstMovement": boolean
 "temporaryData": any
 "world": $Level
 "blockEntityData": $CompoundTag
 "disabled": boolean
 "position": $Vec3
 "state": $BlockState
 "relativeMotion": $Vec3

constructor(arg0: $Level$$Type, arg1: $StructureTemplate$StructureBlockInfo$$Type, arg2: $Contraption$$Type)

public static "readNBT"(arg0: $Level$$Type, arg1: $StructureTemplate$StructureBlockInfo$$Type, arg2: $CompoundTag$$Type, arg3: $Contraption$$Type): $MovementContext
public "writeToNBT"(arg0: $CompoundTag$$Type): $CompoundTag
public "getAnimationSpeed"(): float
public "getFilterFromBE"(): $FilterItemStack
public "getFluidStorage"(): $MountedFluidStorage
public "getItemStorage"(): $MountedItemStorage
get "animationSpeed"(): float
get "filterFromBE"(): $FilterItemStack
get "fluidStorage"(): $MountedFluidStorage
get "itemStorage"(): $MountedItemStorage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MovementContext$$Type = ($MovementContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MovementContext$$Original = $MovementContext;}
declare module "com.simibubi.create.content.logistics.packager.IdentifiedInventory" {
import {$InventoryIdentifier, $InventoryIdentifier$$Type} from "com.simibubi.create.api.packager.InventoryIdentifier"
import {$IItemHandler, $IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$Record} from "java.lang.Record"

export class $IdentifiedInventory extends $Record {
constructor(identifier: $InventoryIdentifier$$Type, handler: $IItemHandler$$Type)

public "identifier"(): $InventoryIdentifier
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "handler"(): $IItemHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdentifiedInventory$$Type = ({"identifier"?: $InventoryIdentifier$$Type, "handler"?: $IItemHandler$$Type}) | ([identifier?: $InventoryIdentifier$$Type, handler?: $IItemHandler$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IdentifiedInventory$$Original = $IdentifiedInventory;}
declare module "com.simibubi.create.content.kinetics.steamEngine.PoweredShaftBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$AbstractShaftBlock} from "com.simibubi.create.content.kinetics.simpleRelays.AbstractShaftBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $PoweredShaftBlock extends $AbstractShaftBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
public static "getEquivalent"(arg0: $BlockState$$Type): $BlockState
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public static "stillValid"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoweredShaftBlock$$Type = ($PoweredShaftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PoweredShaftBlock$$Original = $PoweredShaftBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.KineticStressDisplaySource" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$PercentOrProgressBarDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.PercentOrProgressBarDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $KineticStressDisplaySource extends $PercentOrProgressBarDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KineticStressDisplaySource$$Type = ($KineticStressDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KineticStressDisplaySource$$Original = $KineticStressDisplaySource;}
declare module "com.simibubi.create.content.logistics.funnel.FunnelBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveHoveringInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveHoveringInformation"
import {$List$$Type} from "java.util.List"
import {$ItemHelper$ExtractionCountMode} from "com.simibubi.create.foundation.item.ItemHelper$ExtractionCountMode"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FunnelBlockEntity extends $SmartBlockEntity implements $IHaveHoveringInformation$$Interface, $Clearable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getAmountToExtract"(): integer
public "getModeToExtract"(): $ItemHelper$ExtractionCountMode
public "getFlapOffset"(): float
public "flap"(arg0: boolean): void
public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onTransfer"(arg0: $ItemStack$$Type): void
public "hasFlap"(): boolean
public "tick"(): void
public "addToTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public static "tryClear"(arg0: any): void
public "getIcon"(arg0: boolean): $ItemStack
get "amountToExtract"(): integer
get "modeToExtract"(): $ItemHelper$ExtractionCountMode
get "flapOffset"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunnelBlockEntity$$Type = ($FunnelBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FunnelBlockEntity$$Original = $FunnelBlockEntity;}
declare module "com.simibubi.create.content.kinetics.chainDrive.ChainDriveBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$KineticBlockEntity, $KineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RotatedPillarKineticBlock} from "com.simibubi.create.content.kinetics.base.RotatedPillarKineticBlock"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ChainDriveBlock$Part} from "com.simibubi.create.content.kinetics.chainDrive.ChainDriveBlock$Part"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$TransformableBlock$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $ChainDriveBlock extends $RotatedPillarKineticBlock implements $IBE$$Interface<($KineticBlockEntity)>, $TransformableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "CONNECTED_ALONG_FIRST_COORDINATE": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "PART": $Property<($ChainDriveBlock$Part)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
public "getBlockEntityClass"(): $Class<($KineticBlockEntity)>
public static "areBlocksConnected"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public static "getRotationSpeedModifier"(arg0: $KineticBlockEntity$$Type, arg1: $KineticBlockEntity$$Type): float
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public "transform"(arg0: $BlockState$$Type, arg1: $StructureTransform$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($KineticBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($KineticBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($KineticBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($KineticBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $KineticBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
get "blockEntityClass"(): $Class<($KineticBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainDriveBlock$$Type = ($ChainDriveBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainDriveBlock$$Original = $ChainDriveBlock;}
declare module "com.simibubi.create.content.fluids.hosePulley.HosePulleyBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$HorizontalKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalKineticBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$HosePulleyBlockEntity, $HosePulleyBlockEntity$$Type} from "com.simibubi.create.content.fluids.hosePulley.HosePulleyBlockEntity"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $HosePulleyBlock extends $HorizontalKineticBlock implements $IBE$$Interface<($HosePulleyBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "HORIZONTAL_FACING": $Property<($Direction)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getPreferredHorizontalFacing"(arg0: $BlockPlaceContext$$Type): $Direction
public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($HosePulleyBlockEntity)>
public "getBlockEntityClass"(): $Class<($HosePulleyBlockEntity)>
public static "hasPipeTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($HosePulleyBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($HosePulleyBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($HosePulleyBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($HosePulleyBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $HosePulleyBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($HosePulleyBlockEntity)>
get "blockEntityClass"(): $Class<($HosePulleyBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HosePulleyBlock$$Type = ($HosePulleyBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HosePulleyBlock$$Original = $HosePulleyBlock;}
declare module "com.simibubi.create.content.fluids.pipes.valve.FluidValveBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $FluidValveBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onSpeedChanged"(arg0: float): void
public "tick"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidValveBlockEntity$$Type = ($FluidValveBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidValveBlockEntity$$Original = $FluidValveBlockEntity;}
declare module "com.simibubi.create.content.kinetics.base.HorizontalAxisKineticBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$KineticBlock} from "com.simibubi.create.content.kinetics.base.KineticBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $HorizontalAxisKineticBlock extends $KineticBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "HORIZONTAL_AXIS": $Property<($Direction$Axis)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public static "getPreferredHorizontalAxis"(arg0: $BlockPlaceContext$$Type): $Direction$Axis
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HorizontalAxisKineticBlock$$Type = ($HorizontalAxisKineticBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HorizontalAxisKineticBlock$$Original = $HorizontalAxisKineticBlock;}
declare module "com.simibubi.create.content.kinetics.simpleRelays.CogwheelBlockItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$CogWheelBlock$$Type} from "com.simibubi.create.content.kinetics.simpleRelays.CogWheelBlock"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $CogwheelBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $CogWheelBlock$$Type, arg1: $Item$Properties$$Type)

public "onItemUseFirst"(arg0: $ItemStack$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CogwheelBlockItem$$Type = ($CogwheelBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CogwheelBlockItem$$Original = $CogwheelBlockItem;}
declare module "com.simibubi.create.content.kinetics.waterwheel.WaterWheelStructuralBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$DirectionalBlock} from "net.minecraft.world.level.block.DirectionalBlock"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$IProxyHoveringInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IProxyHoveringInformation"

export class $WaterWheelStructuralBlock extends $DirectionalBlock implements $IWrenchable$$Interface, $IProxyHoveringInformation$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WaterWheelStructuralBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "isFlammable"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public static "getMaster"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockPos
public "getInformationSource"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockPos
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "addLandingEffects"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $LivingEntity$$Type, arg5: integer): boolean
public "stillValid"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: boolean): boolean
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterWheelStructuralBlock$$Type = ($WaterWheelStructuralBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WaterWheelStructuralBlock$$Original = $WaterWheelStructuralBlock;}
declare module "com.simibubi.create.content.trains.track.BezierConnection$Segment" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"

export class $BezierConnection$Segment {
 "normal": $Vec3
 "faceNormal": $Vec3
 "index": integer
 "derivative": $Vec3
 "position": $Vec3

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BezierConnection$Segment$$Type = ($BezierConnection$Segment);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BezierConnection$Segment$$Original = $BezierConnection$Segment;}
declare module "com.simibubi.create.content.trains.track.TrackMaterial$TrackType" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$TrackMaterial$TrackType$TrackBlockFactory$$Type} from "com.simibubi.create.content.trains.track.TrackMaterial$TrackType$TrackBlockFactory"

export class $TrackMaterial$TrackType {
readonly "id": $ResourceLocation
static readonly "STANDARD": $TrackMaterial$TrackType

constructor(arg0: $ResourceLocation$$Type, arg1: $TrackMaterial$TrackType$TrackBlockFactory$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackMaterial$TrackType$$Type = ($TrackMaterial$TrackType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackMaterial$TrackType$$Original = $TrackMaterial$TrackType;}
declare module "com.simibubi.create.content.redstone.nixieTube.NixieTubeBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$DoubleFaceAttachedBlock$DoubleAttachFace} from "com.simibubi.create.content.redstone.nixieTube.DoubleFaceAttachedBlock$DoubleAttachFace"
import {$NixieTubeBlockEntity, $NixieTubeBlockEntity$$Type} from "com.simibubi.create.content.redstone.nixieTube.NixieTubeBlockEntity"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$DoubleFaceAttachedBlock} from "com.simibubi.create.content.redstone.nixieTube.DoubleFaceAttachedBlock"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $NixieTubeBlock extends $DoubleFaceAttachedBlock implements $IBE$$Interface<($NixieTubeBlockEntity)>, $IWrenchable$$Interface, $SimpleWaterloggedBlock$$Interface, $SpecialBlockItemRequirement$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DoubleFaceAttachedBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($DoubleFaceAttachedBlock$DoubleAttachFace)>

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $DyeColor$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($NixieTubeBlockEntity)>
public static "getFacing"(arg0: $BlockState$$Type): $Direction
public "getBlockEntityClass"(): $Class<($NixieTubeBlockEntity)>
public static "updateDisplayedRedstoneValue"(arg0: $NixieTubeBlockEntity$$Type, arg1: $BlockState$$Type, arg2: boolean): void
public static "isInComputerControlledRow"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): boolean
public static "walkNixies"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: boolean, arg3: $BiConsumer$$Type<($BlockPos), (integer)>): boolean
public static "getLeftNixieDirection"(arg0: $BlockState$$Type): $Direction
public static "areNixieBlocksEqual"(arg0: $BlockState$$Type, arg1: $BlockState$$Type): boolean
public static "getRightNixieDirection"(arg0: $BlockState$$Type): $Direction
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "colorOf"(arg0: $BlockState$$Type): $DyeColor
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getColor"(): $DyeColor
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public static "withColor"(arg0: $BlockState$$Type, arg1: $DyeColor$$Type): $BlockState
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($NixieTubeBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($NixieTubeBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($NixieTubeBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($NixieTubeBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $NixieTubeBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($NixieTubeBlockEntity)>
get "blockEntityClass"(): $Class<($NixieTubeBlockEntity)>
get "color"(): $DyeColor
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NixieTubeBlock$$Type = ($NixieTubeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NixieTubeBlock$$Original = $NixieTubeBlock;}
declare module "com.simibubi.create.content.kinetics.flywheel.FlywheelBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ICarriageFlywheel$$Interface} from "com.railwayteam.railways.mixin_interfaces.ICarriageFlywheel"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $FlywheelBlockEntity extends $KineticBlockEntity implements $ICarriageFlywheel$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "railways$getAngle"(): float
public "railways$setAngle"(arg0: float): void
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlywheelBlockEntity$$Type = ($FlywheelBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlywheelBlockEntity$$Original = $FlywheelBlockEntity;}
declare module "com.simibubi.create.content.kinetics.drill.DrillBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$AtomicInteger} from "java.util.concurrent.atomic.AtomicInteger"
import {$BlockBreakingKineticBlockEntity} from "com.simibubi.create.content.kinetics.base.BlockBreakingKineticBlockEntity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $DrillBlockEntity extends $BlockBreakingKineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "NEXT_BREAKER_ID": $AtomicInteger
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "optimiseCobbleGen"(arg0: $BlockState$$Type): boolean
public "onBlockBroken"(arg0: $BlockState$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DrillBlockEntity$$Type = ($DrillBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DrillBlockEntity$$Original = $DrillBlockEntity;}
declare module "com.simibubi.create.content.logistics.chute.AbstractChuteBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ChuteBlockEntity, $ChuteBlockEntity$$Type} from "com.simibubi.create.content.logistics.chute.ChuteBlockEntity"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AbstractChuteBlock extends $Block implements $IWrenchable$$Interface, $IBE$$Interface<($ChuteBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isTransparent"(arg0: $BlockState$$Type): boolean
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getFacing"(arg0: $BlockState$$Type): $Direction
public "getBlockEntityClass"(): $Class<($ChuteBlockEntity)>
public static "getChuteFacing"(arg0: $BlockState$$Type): $Direction
public static "isChute"(arg0: $BlockState$$Type): boolean
public "updateChuteState"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): $BlockState
public static "isOpenChute"(arg0: $BlockState$$Type): boolean
public static "isTransparentChute"(arg0: $BlockState$$Type): boolean
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "isOpen"(arg0: $BlockState$$Type): boolean
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ChuteBlockEntity)>
public "getBlockEntityType"(): $BlockEntityType<($ChuteBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ChuteBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ChuteBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ChuteBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ChuteBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityClass"(): $Class<($ChuteBlockEntity)>
get "blockEntityType"(): $BlockEntityType<($ChuteBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractChuteBlock$$Type = ($AbstractChuteBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractChuteBlock$$Original = $AbstractChuteBlock;}
declare module "com.simibubi.create.content.contraptions.bearing.WindmillBearingBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$MechanicalBearingBlockEntity} from "com.simibubi.create.content.contraptions.bearing.MechanicalBearingBlockEntity"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $WindmillBearingBlockEntity extends $MechanicalBearingBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
 "reActivateSource": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "disassembleForMovement"(): void
public "isWoodenTop"(): boolean
public "updateGeneratedRotation"(): void
public "getGeneratedSpeed"(): float
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onSpeedChanged"(arg0: float): void
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
get "woodenTop"(): boolean
get "generatedSpeed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindmillBearingBlockEntity$$Type = ($WindmillBearingBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WindmillBearingBlockEntity$$Original = $WindmillBearingBlockEntity;}
declare module "com.simibubi.create.content.decoration.palettes.GlassPaneBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Map} from "java.util.Map"
import {$Direction} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IronBarsBlock} from "net.minecraft.world.level.block.IronBarsBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $GlassPaneBlock extends $IronBarsBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($IronBarsBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($BooleanProperty)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "SOUTH": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "EAST": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlassPaneBlock$$Type = ($GlassPaneBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GlassPaneBlock$$Original = $GlassPaneBlock;}
declare module "com.simibubi.create.content.kinetics.gearbox.GearboxBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DirectionalShaftHalvesBlockEntity} from "com.simibubi.create.content.kinetics.base.DirectionalShaftHalvesBlockEntity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $GearboxBlockEntity extends $DirectionalShaftHalvesBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GearboxBlockEntity$$Type = ($GearboxBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GearboxBlockEntity$$Original = $GearboxBlockEntity;}
declare module "com.simibubi.create.content.kinetics.crusher.CrushingWheelBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$LivingDropsEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDropsEvent"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $CrushingWheelBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "fixControllers"(): void
public static "handleCrushedMobDrops"(arg0: $LivingDropsEvent$$Type): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "onSpeedChanged"(arg0: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrushingWheelBlockEntity$$Type = ($CrushingWheelBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CrushingWheelBlockEntity$$Original = $CrushingWheelBlockEntity;}
declare module "com.simibubi.create.content.trains.track.TrackBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Random$$Type} from "java.util.Random"
import {$TrackMaterial, $TrackMaterial$$Type} from "com.simibubi.create.content.trains.track.TrackMaterial"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$TrackTargetingBehaviour$RenderedTrackOverlayType$$Type} from "com.simibubi.create.content.trains.track.TrackTargetingBehaviour$RenderedTrackOverlayType"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TrackNodeLocation$DiscoveredLocation, $TrackNodeLocation$DiscoveredLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackNodeLocation$DiscoveredLocation"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$TrackShape} from "com.simibubi.create.content.trains.track.TrackShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BezierConnection$$Type} from "com.simibubi.create.content.trains.track.BezierConnection"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$ITrackBlock$$Interface} from "com.simibubi.create.content.trains.track.ITrackBlock"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Affine, $Affine$$Type} from "dev.engine_room.flywheel.lib.transform.Affine"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$TrackNodeLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IHaveBigOutline$$Interface} from "com.simibubi.create.foundation.block.IHaveBigOutline"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$TrackBlockEntity, $TrackBlockEntity$$Type} from "com.simibubi.create.content.trains.track.TrackBlockEntity"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$Direction$AxisDirection, $Direction$AxisDirection$$Type} from "net.minecraft.core.Direction$AxisDirection"
import {$BezierTrackPointLocation$$Type} from "com.simibubi.create.content.trains.track.BezierTrackPointLocation"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$PartialModel} from "dev.engine_room.flywheel.lib.model.baked.PartialModel"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"

export class $TrackBlock extends $Block implements $IBE$$Interface<($TrackBlockEntity)>, $IWrenchable$$Interface, $ITrackBlock$$Interface, $SpecialBlockItemRequirement$$Interface, $ProperWaterloggedBlock$$Interface, $IHaveBigOutline$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "HAS_BE": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $EnumProperty<($TrackShape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $TrackMaterial$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockPathType"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type): $PathType
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getUpNormal"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $Vec3
public "getCurveStart"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Vec3$$Type): $Vec3
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($TrackBlockEntity)>
public "getBlockEntityClass"(): $Class<($TrackBlockEntity)>
public "getBogeyAnchor"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
public "getYOffsetAt"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Vec3$$Type): integer
public "getConnected"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: boolean, arg4: $TrackNodeLocation$$Type): $Collection<($TrackNodeLocation$DiscoveredLocation)>
public "getTrackAxes"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $List<($Vec3)>
public "prepareAssemblyOverlay"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type, arg4: $PoseStack$$Type): $PartialModel
public "prepareTrackOverlay"<Self extends $Affine<(object)>>(arg0: $Affine$$Type<(Self)>, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BezierTrackPointLocation$$Type, arg5: $Direction$AxisDirection$$Type, arg6: $TrackTargetingBehaviour$RenderedTrackOverlayType$$Type): $PartialModel
public "trackEquals"(arg0: $BlockState$$Type, arg1: $BlockState$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "overlay"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type): $BlockState
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Random$$Type): void
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getMaterial"(): $TrackMaterial
public "getInteractionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($TrackBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($TrackBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($TrackBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($TrackBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $TrackBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getNearestTrackAxis"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Vec3$$Type): $Pair<($Vec3), ($Direction$AxisDirection)>
public "getElevationAtCenter"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): double
public static "addToListIfConnected"(arg0: $TrackNodeLocation$$Type, arg1: $Collection$$Type<($TrackNodeLocation$DiscoveredLocation$$Type)>, arg2: $BiFunction$$Type<(double), (boolean), ($Vec3$$Type)>, arg3: $Function$$Type<(boolean), ($Vec3$$Type)>, arg4: $Function$$Type<(boolean), ($ResourceKey$$Type<($Level$$Type)>)>, arg5: $Function$$Type<($Vec3), (integer)>, arg6: $Vec3$$Type, arg7: $BezierConnection$$Type, arg8: $BiFunction$$Type<(boolean), ($Vec3), ($TrackMaterial$$Type)>): void
public static "getMaterialSimple"(arg0: $BlockGetter$$Type, arg1: $Vec3$$Type): $TrackMaterial
public static "getMaterialSimple"(arg0: $BlockGetter$$Type, arg1: $Vec3$$Type, arg2: $TrackMaterial$$Type): $TrackMaterial
public "isSlope"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public static "walkConnectedTracks"(arg0: $BlockGetter$$Type, arg1: $TrackNodeLocation$$Type, arg2: boolean): $Collection<($TrackNodeLocation$DiscoveredLocation)>
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($TrackBlockEntity)>
get "blockEntityClass"(): $Class<($TrackBlockEntity)>
get "material"(): $TrackMaterial
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackBlock$$Type = ($TrackBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackBlock$$Original = $TrackBlock;}
declare module "com.simibubi.create.content.fluids.pump.PumpBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $PumpBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "updatePressureChange"(): void
public "isPullingOnSide"(arg0: boolean): boolean
public "updatePipesOnSide"(arg0: $Direction$$Type): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "isSideAccessible"(arg0: $Direction$$Type): boolean
public "onSpeedChanged"(arg0: float): void
public "tick"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PumpBlockEntity$$Type = ($PumpBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PumpBlockEntity$$Original = $PumpBlockEntity;}
declare module "com.simibubi.create.content.logistics.chute.ChuteItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $ChuteItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "place"(arg0: $BlockPlaceContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChuteItem$$Type = ($ChuteItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChuteItem$$Original = $ChuteItem;}
declare module "com.simibubi.create.content.contraptions.mounted.CartAssemblerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$LootParams$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootParams$Builder"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$AbstractMinecart$$Type} from "net.minecraft.world.entity.vehicle.AbstractMinecart"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$CartAssemblerBlockEntity, $CartAssemblerBlockEntity$$Type} from "com.simibubi.create.content.contraptions.mounted.CartAssemblerBlockEntity"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$CartAssembleRailType} from "com.simibubi.create.content.contraptions.mounted.CartAssembleRailType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RailShape} from "net.minecraft.world.level.block.state.properties.RailShape"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BaseRailBlock} from "net.minecraft.world.level.block.BaseRailBlock"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$CartAssemblerBlock$CartAssemblerAction} from "com.simibubi.create.content.contraptions.mounted.CartAssemblerBlock$CartAssemblerAction"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $CartAssemblerBlock extends $BaseRailBlock implements $IBE$$Interface<($CartAssemblerBlockEntity)>, $IWrenchable$$Interface, $SpecialBlockItemRequirement$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CartAssemblerBlock)>
static readonly "BACKWARDS": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "RAIL_SHAPE": $Property<($RailShape)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "RAIL_TYPE": $Property<($CartAssembleRailType)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getDrops"(arg0: $BlockState$$Type, arg1: $LootParams$Builder$$Type): $List<($ItemStack)>
public static "getHorizontalDirection"(arg0: $BlockState$$Type): $Direction
public "getShapeProperty"(): $Property<($RailShape)>
public "canMakeSlopes"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "onMinecartPass"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $AbstractMinecart$$Type): void
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($CartAssemblerBlockEntity)>
public "getBlockEntityClass"(): $Class<($CartAssemblerBlockEntity)>
public static "canAssembleTo"(arg0: $AbstractMinecart$$Type): boolean
public "getDropsNoRail"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): $List<($ItemStack)>
public static "createAnchor"(arg0: $BlockState$$Type): $BlockState
public static "getActionForCart"(arg0: $BlockState$$Type, arg1: $AbstractMinecart$$Type): $CartAssemblerBlock$CartAssemblerAction
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "getRailBlock"(arg0: $BlockState$$Type): $BlockState
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($CartAssemblerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($CartAssemblerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CartAssemblerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CartAssemblerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $CartAssemblerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "shapeProperty"(): $Property<($RailShape)>
get "blockEntityType"(): $BlockEntityType<($CartAssemblerBlockEntity)>
get "blockEntityClass"(): $Class<($CartAssemblerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CartAssemblerBlock$$Type = ($CartAssemblerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CartAssemblerBlock$$Original = $CartAssemblerBlock;}
declare module "com.simibubi.create.content.kinetics.belt.BeltBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$Map} from "java.util.Map"
import {$Optional} from "java.util.Optional"
import {$List$$Type} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$BeltMovementHandler$TransportedEntityInfo} from "com.simibubi.create.content.kinetics.belt.transport.BeltMovementHandler$TransportedEntityInfo"
import {$BeltInventory} from "com.simibubi.create.content.kinetics.belt.transport.BeltInventory"
import {$KineticBlockEntity, $KineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$VersionedInventoryTrackerBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.inventory.VersionedInventoryTrackerBehaviour"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BeltBlockEntity$CasingType, $BeltBlockEntity$CasingType$$Type} from "com.simibubi.create.content.kinetics.belt.BeltBlockEntity$CasingType"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$AABB} from "net.minecraft.world.phys.AABB"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BeltBlockEntity extends $KineticBlockEntity implements $Clearable$$Interface {
 "passengers": $Map<($Entity), ($BeltMovementHandler$TransportedEntityInfo)>
 "color": $Optional<($DyeColor)>
 "index": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "trackerUpdateTag": $CompoundTag
 "createCasing$newCasing": $BeltBlockEntity$CasingType
 "network": long
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "casing": $BeltBlockEntity$CasingType
 "networkDirty": boolean
 "beltLength": integer
 "lastInsert": $Direction
 "covered": boolean
 "updateSpeed": boolean
 "invVersionTracker": $VersionedInventoryTrackerBehaviour
 "preventSpeedUpdate": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "clearKineticInformation"(): void
public "calculateStressApplied"(): float
public "propagateRotationTo"(arg0: $KineticBlockEntity$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: boolean, arg5: boolean): float
public "clearContent"(): void
public "getMovementDirection"(arg0: boolean): $Vec3i
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "createRenderBoundingBox"(): $AABB
public "getController"(): $BlockPos
public "setController"(arg0: $BlockPos$$Type): void
public "hasPulley"(): boolean
public "getControllerBE"(): $BeltBlockEntity
public "isController"(): boolean
public "setCovered"(arg0: boolean): void
public "setCasingType"(arg0: $BeltBlockEntity$CasingType$$Type): void
public "applyColor"(arg0: $DyeColor$$Type): boolean
public "getBeltMovementSpeed"(): float
public "getDirectionAwareBeltMovementSpeed"(): float
public "getBeltChainDirection"(): $Vec3i
public "getMovementFacing"(): $Direction
public "invalidateItemHandler"(): void
public "shouldRenderNormally"(): boolean
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "destroy"(): void
public "invalidate"(): void
public "getInventory"(): $BeltInventory
public "getModelData"(): $ModelData
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
get "controller"(): $BlockPos
set "controller"(value: $BlockPos$$Type)
get "controllerBE"(): $BeltBlockEntity
get "controller"(): boolean
set "casingType"(value: $BeltBlockEntity$CasingType$$Type)
get "beltMovementSpeed"(): float
get "directionAwareBeltMovementSpeed"(): float
get "beltChainDirection"(): $Vec3i
get "movementFacing"(): $Direction
get "inventory"(): $BeltInventory
get "modelData"(): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltBlockEntity$$Type = ($BeltBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltBlockEntity$$Original = $BeltBlockEntity;}
declare module "com.simibubi.create.content.trains.bogey.StandardBogeyBlockEntity" {
import {$IStandardBogeyTEVirtualCoupling$$Interface} from "com.railwayteam.railways.mixin_interfaces.IStandardBogeyTEVirtualCoupling"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BogeyStyle} from "com.simibubi.create.content.trains.bogey.BogeyStyle"
import {$AbstractBogeyBlockEntity} from "com.simibubi.create.content.trains.bogey.AbstractBogeyBlockEntity"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StandardBogeyBlockEntity extends $AbstractBogeyBlockEntity implements $IStandardBogeyTEVirtualCoupling$$Interface {
static readonly "BOGEY_STYLE_KEY": StringJS
static readonly "BOGEY_DATA_KEY": StringJS
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "setFront"(arg0: boolean): void
public "setCouplingDistance"(arg0: double): void
public "getCouplingDistance"(): double
public "setCouplingDirection"(arg0: $Direction$$Type): void
public "getCouplingDirection"(): $Direction
public "getFront"(): boolean
public "getDefaultStyle"(): $BogeyStyle
set "front"(value: boolean)
set "couplingDistance"(value: double)
get "couplingDistance"(): double
set "couplingDirection"(value: $Direction$$Type)
get "couplingDirection"(): $Direction
get "front"(): boolean
get "defaultStyle"(): $BogeyStyle
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StandardBogeyBlockEntity$$Type = ($StandardBogeyBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StandardBogeyBlockEntity$$Original = $StandardBogeyBlockEntity;}
declare module "com.simibubi.create.content.kinetics.simpleRelays.ShaftBlock" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$EncasableBlock$$Interface} from "com.simibubi.create.content.decoration.encasing.EncasableBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$AbstractSimpleShaftBlock} from "com.simibubi.create.content.kinetics.simpleRelays.AbstractSimpleShaftBlock"

export class $ShaftBlock extends $AbstractSimpleShaftBlock implements $EncasableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "placementHelperId": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "pickCorrectShaftType"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): $BlockState
public static "isShaft"(arg0: $BlockState$$Type): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "playEncaseSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "tryEncase"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): $ItemInteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShaftBlock$$Type = ($ShaftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShaftBlock$$Original = $ShaftBlock;}
declare module "com.simibubi.create.content.logistics.redstoneRequester.RedstoneRequesterBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$LogisticallyLinkedBehaviour} from "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBehaviour"
import {$StockCheckingBlockEntity} from "com.simibubi.create.content.logistics.stockTicker.StockCheckingBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PackageOrderWithCrafts} from "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RedstoneRequesterBlockEntity extends $StockCheckingBlockEntity implements $MenuProvider$$Interface {
 "encodedTargetAdress": StringJS
 "encodedRequest": $PackageOrderWithCrafts
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "behaviour": $LogisticallyLinkedBehaviour
 "lastRequestSucceeded": boolean
 "computerBehaviour": $AbstractComputerBehaviour
 "allowPartialRequests": boolean

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "playEffect"(arg0: boolean): void
public "triggerRequest"(): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getDisplayName"(): $Component
public "use"(arg0: $Player$$Type): $InteractionResult
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneRequesterBlockEntity$$Type = ($RedstoneRequesterBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneRequesterBlockEntity$$Original = $RedstoneRequesterBlockEntity;}
declare module "com.simibubi.create.content.fluids.tank.FluidTankBlock" {
import {$FluidTankBlock$Shape} from "com.simibubi.create.content.fluids.tank.FluidTankBlock$Shape"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$FluidTankBlockEntity, $FluidTankBlockEntity$$Type} from "com.simibubi.create.content.fluids.tank.FluidTankBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $FluidTankBlock extends $Block implements $IWrenchable$$Interface, $IBE$$Interface<($FluidTankBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "SILENCED_METAL": $SoundType
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "BOTTOM": $BooleanProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $EnumProperty<($FluidTankBlock$Shape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "TOP": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "getBlockSupportShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getBlockEntityType"(): $BlockEntityType<($FluidTankBlockEntity)>
public static "updateBoilerState"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): void
public static "isTank"(arg0: $BlockState$$Type): boolean
public "getBlockEntityClass"(): $Class<($FluidTankBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public static "regular"(arg0: $BlockBehaviour$Properties$$Type): $FluidTankBlock
public static "creative"(arg0: $BlockBehaviour$Properties$$Type): $FluidTankBlock
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getSoundType"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): $SoundType
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getLightEmission"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): integer
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($FluidTankBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($FluidTankBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FluidTankBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FluidTankBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $FluidTankBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($FluidTankBlockEntity)>
get "blockEntityClass"(): $Class<($FluidTankBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankBlock$$Type = ($FluidTankBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTankBlock$$Original = $FluidTankBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.KineticSpeedDisplaySource" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$NumericSingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.NumericSingleLineDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $KineticSpeedDisplaySource extends $NumericSingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KineticSpeedDisplaySource$$Type = ($KineticSpeedDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KineticSpeedDisplaySource$$Original = $KineticSpeedDisplaySource;}
declare module "com.simibubi.create.content.trains.track.BezierConnection$SegmentAngles" {
import {$PoseStack$Pose} from "com.mojang.blaze3d.vertex.PoseStack$Pose"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos} from "net.minecraft.core.BlockPos"

export class $BezierConnection$SegmentAngles {
readonly "lightPosition": ($BlockPos)[]
readonly "length": integer
readonly "tieTransform": ($PoseStack$Pose)[]
readonly "railTransforms": ($Couple<($PoseStack$Pose)>)[]

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BezierConnection$SegmentAngles$$Type = ($BezierConnection$SegmentAngles);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BezierConnection$SegmentAngles$$Original = $BezierConnection$SegmentAngles;}
declare module "com.simibubi.create.content.equipment.blueprint.BlueprintItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$ItemStackHandler$$Type} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $BlueprintItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public static "assignCompleteRecipe"(arg0: $Level$$Type, arg1: $ItemStackHandler$$Type, arg2: $Recipe$$Type<(never)>): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlueprintItem$$Type = ($BlueprintItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlueprintItem$$Original = $BlueprintItem;}
declare module "com.simibubi.create.content.kinetics.saw.SawBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$ProcessingInventory} from "com.simibubi.create.content.processing.recipe.ProcessingInventory"
import {$List$$Type} from "java.util.List"
import {$RecipeType} from "net.minecraft.world.item.crafting.RecipeType"
import {$ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Supplier} from "java.util.function.Supplier"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$AtomicInteger} from "java.util.concurrent.atomic.AtomicInteger"
import {$BlockBreakingKineticBlockEntity} from "com.simibubi.create.content.kinetics.base.BlockBreakingKineticBlockEntity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SawBlockEntity extends $BlockBreakingKineticBlockEntity implements $Clearable$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
static readonly "woodcuttingRecipeType": $Supplier<($RecipeType<(never)>)>
 "updateSpeed": boolean
static readonly "NEXT_BREAKER_ID": $AtomicInteger
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "inventory": $ProcessingInventory
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getItemMovementVec"(): $Vec3
public "tickAudio"(): void
public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "dropItemFromCutTree"(arg0: $BlockPos$$Type, arg1: $ItemStack$$Type): void
public "canBreak"(arg0: $BlockState$$Type, arg1: float): boolean
public "onBlockBroken"(arg0: $BlockState$$Type): void
public static "isSawable"(arg0: $BlockState$$Type): boolean
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "start"(arg0: $ItemStack$$Type): void
public "destroy"(): void
public "invalidate"(): void
public "insertItem"(arg0: $ItemEntity$$Type): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
get "itemMovementVec"(): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SawBlockEntity$$Type = ($SawBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SawBlockEntity$$Original = $SawBlockEntity;}
declare module "com.simibubi.create.content.kinetics.turntable.TurntableBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$KineticBlock} from "com.simibubi.create.content.kinetics.base.KineticBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$TurntableBlockEntity, $TurntableBlockEntity$$Type} from "com.simibubi.create.content.kinetics.turntable.TurntableBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $TurntableBlock extends $KineticBlock implements $IBE$$Interface<($TurntableBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($TurntableBlockEntity)>
public "getBlockEntityClass"(): $Class<($TurntableBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "entityInside"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($TurntableBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($TurntableBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($TurntableBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($TurntableBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $TurntableBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($TurntableBlockEntity)>
get "blockEntityClass"(): $Class<($TurntableBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurntableBlock$$Type = ($TurntableBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurntableBlock$$Original = $TurntableBlock;}
declare module "com.simibubi.create.content.logistics.tableCloth.ShoppingListItem$ShoppingList" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$IntAttached, $IntAttached$$Type} from "net.createmod.catnip.data.IntAttached"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$InventorySummary} from "com.simibubi.create.content.logistics.packager.InventorySummary"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Record} from "java.lang.Record"

export class $ShoppingListItem$ShoppingList extends $Record {
static readonly "CODEC": $Codec<($ShoppingListItem$ShoppingList)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($ShoppingListItem$ShoppingList)>

constructor(purchases: $List$$Type<($IntAttached$$Type<($BlockPos$$Type)>)>, shopOwner: $UUID$$Type, shopNetwork: $UUID$$Type)

public "purchases"(): $List<($IntAttached<($BlockPos)>)>
public "shopOwner"(): $UUID
public "shopNetwork"(): $UUID
public "getPurchases"(arg0: $BlockPos$$Type): integer
public "bakeEntries"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): $Couple<($InventorySummary)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "duplicate"(): $ShoppingListItem$ShoppingList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShoppingListItem$ShoppingList$$Type = ({"purchases"?: $List$$Type<($IntAttached$$Type<($BlockPos$$Type)>)>, "shopOwner"?: $UUID$$Type, "shopNetwork"?: $UUID$$Type}) | ([purchases?: $List$$Type<($IntAttached$$Type<($BlockPos$$Type)>)>, shopOwner?: $UUID$$Type, shopNetwork?: $UUID$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShoppingListItem$ShoppingList$$Original = $ShoppingListItem$ShoppingList;}
declare module "com.simibubi.create.content.contraptions.mounted.CartAssemblerBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$AbstractMinecart$$Type} from "net.minecraft.world.entity.vehicle.AbstractMinecart"
import {$IDisplayAssemblyExceptions$$Interface} from "com.simibubi.create.content.contraptions.IDisplayAssemblyExceptions"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AssemblyException} from "com.simibubi.create.content.contraptions.AssemblyException"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CartAssemblerBlockEntity extends $SmartBlockEntity implements $IDisplayAssemblyExceptions$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getLastAssemblyException"(): $AssemblyException
public "resetTicksSinceMinecartUpdate"(): void
public "isMinecartUpdateValid"(): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "assembleNextTick"(arg0: $AbstractMinecart$$Type): void
public "tryAssemble"(arg0: $AbstractMinecart$$Type): void
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "addExceptionToTooltip"(arg0: $List$$Type<($Component$$Type)>): boolean
get "lastAssemblyException"(): $AssemblyException
get "minecartUpdateValid"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CartAssemblerBlockEntity$$Type = ($CartAssemblerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CartAssemblerBlockEntity$$Original = $CartAssemblerBlockEntity;}
declare module "com.simibubi.create.content.contraptions.gantry.GantryCarriageBlockEntity" {
import {$IDisplayAssemblyExceptions$$Interface} from "com.simibubi.create.content.contraptions.IDisplayAssemblyExceptions"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity, $KineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$AssemblyException} from "com.simibubi.create.content.contraptions.AssemblyException"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $GantryCarriageBlockEntity extends $KineticBlockEntity implements $IDisplayAssemblyExceptions$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getLastAssemblyException"(): $AssemblyException
public "queueAssembly"(): void
public static "getGantryPinionModifier"(arg0: $Direction$$Type, arg1: $Direction$$Type): float
public "propagateRotationTo"(arg0: $KineticBlockEntity$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: boolean, arg5: boolean): float
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onSpeedChanged"(arg0: float): void
public "checkValidGantryShaft"(): void
public "tick"(): void
public "initialize"(): void
public "addExceptionToTooltip"(arg0: $List$$Type<($Component$$Type)>): boolean
get "lastAssemblyException"(): $AssemblyException
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GantryCarriageBlockEntity$$Type = ($GantryCarriageBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GantryCarriageBlockEntity$$Original = $GantryCarriageBlockEntity;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.BeltProcessingBehaviour$ProcessingCallback" {
import {$TransportedItemStackHandlerBehaviour, $TransportedItemStackHandlerBehaviour$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour"
import {$BeltProcessingBehaviour$ProcessingResult, $BeltProcessingBehaviour$ProcessingResult$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.BeltProcessingBehaviour$ProcessingResult"
import {$TransportedItemStack, $TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"

export interface $BeltProcessingBehaviour$ProcessingCallback$$Interface {

(arg0: $TransportedItemStack, arg1: $TransportedItemStackHandlerBehaviour): $BeltProcessingBehaviour$ProcessingResult$$Type
}

export class $BeltProcessingBehaviour$ProcessingCallback implements $BeltProcessingBehaviour$ProcessingCallback$$Interface {
 "apply"(arg0: $TransportedItemStack$$Type, arg1: $TransportedItemStackHandlerBehaviour$$Type): $BeltProcessingBehaviour$ProcessingResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltProcessingBehaviour$ProcessingCallback$$Type = ((arg0: $TransportedItemStack, arg1: $TransportedItemStackHandlerBehaviour) => $BeltProcessingBehaviour$ProcessingResult$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltProcessingBehaviour$ProcessingCallback$$Original = $BeltProcessingBehaviour$ProcessingCallback;}
declare module "com.simibubi.create.content.redstone.displayLink.source.NumericSingleLineDisplaySource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $NumericSingleLineDisplaySource extends $SingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumericSingleLineDisplaySource$$Type = ($NumericSingleLineDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NumericSingleLineDisplaySource$$Original = $NumericSingleLineDisplaySource;}
declare module "com.simibubi.create.content.decoration.placard.PlacardBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$FaceAttachedHorizontalDirectionalBlock} from "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$PlacardBlockEntity, $PlacardBlockEntity$$Type} from "com.simibubi.create.content.decoration.placard.PlacardBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $PlacardBlock extends $FaceAttachedHorizontalDirectionalBlock implements $ProperWaterloggedBlock$$Interface, $IBE$$Interface<($PlacardBlockEntity)>, $SpecialBlockItemRequirement$$Interface, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PlacardBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($AttachFace)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public static "updateNeighbours"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): void
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($PlacardBlockEntity)>
public "getBlockEntityClass"(): $Class<($PlacardBlockEntity)>
public static "connectedDirection"(arg0: $BlockState$$Type): $Direction
public static "canAttachLenient"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "attack"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): void
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getDirectSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($PlacardBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($PlacardBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PlacardBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PlacardBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $PlacardBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($PlacardBlockEntity)>
get "blockEntityClass"(): $Class<($PlacardBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacardBlock$$Type = ($PlacardBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacardBlock$$Original = $PlacardBlock;}
declare module "com.simibubi.create.content.redstone.diodes.ToggleLatchBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$AbstractDiodeBlock} from "com.simibubi.create.content.redstone.diodes.AbstractDiodeBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ToggleLatchBlock extends $AbstractDiodeBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ToggleLatchBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static "POWERING": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToggleLatchBlock$$Type = ($ToggleLatchBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ToggleLatchBlock$$Original = $ToggleLatchBlock;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.DirectBeltInputBehaviour" {
import {$SmartBlockEntity, $SmartBlockEntity$$Type} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DirectBeltInputBehaviour$InsertionCallback$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.DirectBeltInputBehaviour$InsertionCallback"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockEntityBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BehaviourType} from "com.simibubi.create.foundation.blockEntity.behaviour.BehaviourType"
import {$DirectBeltInputBehaviour$AvailabilityPredicate$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.DirectBeltInputBehaviour$AvailabilityPredicate"
import {$TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"
import {$DirectBeltInputBehaviour$OccupiedPredicate$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.DirectBeltInputBehaviour$OccupiedPredicate"

export class $DirectBeltInputBehaviour extends $BlockEntityBehaviour {
 "blockEntity": $SmartBlockEntity
static readonly "TYPE": $BehaviourType<($DirectBeltInputBehaviour)>

constructor(arg0: $SmartBlockEntity$$Type)

public "allowingBeltFunnelsWhen"(arg0: $Supplier$$Type<(boolean)>): $DirectBeltInputBehaviour
public "canSupportBeltFunnels"(): boolean
public "onlyInsertWhen"(arg0: $DirectBeltInputBehaviour$AvailabilityPredicate$$Type): $DirectBeltInputBehaviour
public "setInsertionHandler"(arg0: $DirectBeltInputBehaviour$InsertionCallback$$Type): $DirectBeltInputBehaviour
public "isOccupied"(arg0: $Direction$$Type): boolean
public "considerOccupiedWhen"(arg0: $DirectBeltInputBehaviour$OccupiedPredicate$$Type): $DirectBeltInputBehaviour
public "canInsertFromSide"(arg0: $Direction$$Type): boolean
public "handleInsertion"(arg0: $ItemStack$$Type, arg1: $Direction$$Type, arg2: boolean): $ItemStack
public "handleInsertion"(arg0: $TransportedItemStack$$Type, arg1: $Direction$$Type, arg2: boolean): $ItemStack
public "allowingBeltFunnels"(): $DirectBeltInputBehaviour
public "tryExportingToBeltFunnel"(arg0: $ItemStack$$Type, arg1: $Direction$$Type, arg2: boolean): $ItemStack
public "getType"(): $BehaviourType<(never)>
set "insertionHandler"(value: $DirectBeltInputBehaviour$InsertionCallback$$Type)
get "type"(): $BehaviourType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectBeltInputBehaviour$$Type = ($DirectBeltInputBehaviour);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectBeltInputBehaviour$$Original = $DirectBeltInputBehaviour;}
declare module "com.simibubi.create.content.fluids.spout.SpoutBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$SpoutBlockEntity, $SpoutBlockEntity$$Type} from "com.simibubi.create.content.fluids.spout.SpoutBlockEntity"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SpoutBlock extends $Block implements $IWrenchable$$Interface, $IBE$$Interface<($SpoutBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($SpoutBlockEntity)>
public "getBlockEntityClass"(): $Class<($SpoutBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SpoutBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SpoutBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SpoutBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SpoutBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SpoutBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SpoutBlockEntity)>
get "blockEntityClass"(): $Class<($SpoutBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpoutBlock$$Type = ($SpoutBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpoutBlock$$Original = $SpoutBlock;}
declare module "com.simibubi.create.content.logistics.funnel.AbstractFunnelBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$FunnelBlockEntity, $FunnelBlockEntity$$Type} from "com.simibubi.create.content.logistics.funnel.FunnelBlockEntity"

export class $AbstractFunnelBlock extends $Block implements $IBE$$Interface<($FunnelBlockEntity)>, $IWrenchable$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public static "tryInsert"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type, arg3: boolean): $ItemStack
public "getBlockEntityType"(): $BlockEntityType<($FunnelBlockEntity)>
public "getBlockEntityClass"(): $Class<($FunnelBlockEntity)>
public static "getFunnelFacing"(arg0: $BlockState$$Type): $Direction
public static "isFunnel"(arg0: $BlockState$$Type): boolean
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($FunnelBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($FunnelBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FunnelBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FunnelBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $FunnelBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($FunnelBlockEntity)>
get "blockEntityClass"(): $Class<($FunnelBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractFunnelBlock$$Type = ($AbstractFunnelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractFunnelBlock$$Original = $AbstractFunnelBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.EntityNameDisplaySource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $EntityNameDisplaySource extends $SingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityNameDisplaySource$$Type = ($EntityNameDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityNameDisplaySource$$Original = $EntityNameDisplaySource;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$CrafterType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$CrafterType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$CrafterType$$Type = ($AllArmInteractionPointTypes$CrafterType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$CrafterType$$Original = $AllArmInteractionPointTypes$CrafterType;}
declare module "com.simibubi.create.content.logistics.filter.FilterItemStack" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $FilterItemStack {
public "fluid"(arg0: $Level$$Type): $FluidStack
public "isFilterItem"(): boolean
public "item"(): $ItemStack
public "test"(arg0: $Level$$Type, arg1: $ItemStack$$Type, arg2: boolean): boolean
public "test"(arg0: $Level$$Type, arg1: $FluidStack$$Type, arg2: boolean): boolean
public "test"(arg0: $Level$$Type, arg1: $ItemStack$$Type): boolean
public "test"(arg0: $Level$$Type, arg1: $FluidStack$$Type): boolean
public "isEmpty"(): boolean
public static "of"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): $FilterItemStack
public static "of"(arg0: $ItemStack$$Type): $FilterItemStack
public static "empty"(): $FilterItemStack
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
get "filterItem"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FilterItemStack$$Type = ($FilterItemStack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FilterItemStack$$Original = $FilterItemStack;}
declare module "com.simibubi.create.content.equipment.potatoCannon.PotatoCannonItem$Ammo" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$PotatoCannonProjectileType, $PotatoCannonProjectileType$$Type} from "com.simibubi.create.api.equipment.potatoCannon.PotatoCannonProjectileType"
import {$Record} from "java.lang.Record"

export class $PotatoCannonItem$Ammo extends $Record {
constructor(stack: $ItemStack$$Type, type: $PotatoCannonProjectileType$$Type)

public "stack"(): $ItemStack
public "type"(): $PotatoCannonProjectileType
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotatoCannonItem$Ammo$$Type = ({"stack"?: $ItemStack$$Type, "type"?: $PotatoCannonProjectileType$$Type}) | ([stack?: $ItemStack$$Type, type?: $PotatoCannonProjectileType$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotatoCannonItem$Ammo$$Original = $PotatoCannonItem$Ammo;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour$PositionGetter" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$TransportedItemStack, $TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"

export interface $TransportedItemStackHandlerBehaviour$PositionGetter$$Interface {

(arg0: $TransportedItemStack): $Vec3$$Type
}

export class $TransportedItemStackHandlerBehaviour$PositionGetter implements $TransportedItemStackHandlerBehaviour$PositionGetter$$Interface {
 "getWorldPositionVector"(arg0: $TransportedItemStack$$Type): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransportedItemStackHandlerBehaviour$PositionGetter$$Type = ((arg0: $TransportedItemStack) => $Vec3$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TransportedItemStackHandlerBehaviour$PositionGetter$$Original = $TransportedItemStackHandlerBehaviour$PositionGetter;}
declare module "com.simibubi.create.content.schematics.cannon.SchematicannonInventory" {
import {$SchematicannonBlockEntity$$Type} from "com.simibubi.create.content.schematics.cannon.SchematicannonBlockEntity"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemStackHandler} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $SchematicannonInventory extends $ItemStackHandler {
constructor(arg0: $SchematicannonBlockEntity$$Type)

public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicannonInventory$$Type = ($SchematicannonInventory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicannonInventory$$Original = $SchematicannonInventory;}
declare module "com.simibubi.create.content.trains.entity.CarriageSyncDataSerializer" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$EntityDataSerializer, $EntityDataSerializer$$Interface} from "net.minecraft.network.syncher.EntityDataSerializer"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$EntityDataAccessor} from "net.minecraft.network.syncher.EntityDataAccessor"
import {$CarriageSyncData, $CarriageSyncData$$Type} from "com.simibubi.create.content.trains.entity.CarriageSyncData"

export class $CarriageSyncDataSerializer implements $EntityDataSerializer$$Interface<($CarriageSyncData)> {
constructor()

public "copy"(arg0: $CarriageSyncData$$Type): $CarriageSyncData
public "copy"(arg0: any): any
public "codec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($CarriageSyncData)>
public "createAccessor"(arg0: integer): $EntityDataAccessor<($CarriageSyncData)>
public static "forValueType"<T>(arg0: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), ($CarriageSyncData$$Type)>): $EntityDataSerializer<($CarriageSyncData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarriageSyncDataSerializer$$Type = ($CarriageSyncDataSerializer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarriageSyncDataSerializer$$Original = $CarriageSyncDataSerializer;}
declare module "com.simibubi.create.content.kinetics.base.DirectionalAxisKineticBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DirectionalKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalKineticBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$TransformableBlock$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DirectionalAxisKineticBlock extends $DirectionalKineticBlock implements $TransformableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "AXIS_ALONG_FIRST_COORDINATE": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "transform"(arg0: $BlockState$$Type, arg1: $StructureTransform$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionalAxisKineticBlock$$Type = ($DirectionalAxisKineticBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectionalAxisKineticBlock$$Original = $DirectionalAxisKineticBlock;}
declare module "com.simibubi.create.content.trains.station.StationBlockEntity" {
import {$ITrackBlock$$Type} from "com.simibubi.create.content.trains.track.ITrackBlock"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$UUID$$Type} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$DoorControlBehaviour} from "com.simibubi.create.content.decoration.slidingDoor.DoorControlBehaviour"
import {$Map} from "java.util.Map"
import {$PackagePortBlockEntity$$Type} from "com.simibubi.create.content.logistics.packagePort.PackagePortBlockEntity"
import {$BoundingBox} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$Train$$Type} from "com.simibubi.create.content.trains.entity.Train"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$TrackTargetingBehaviour} from "com.simibubi.create.content.trains.track.TrackTargetingBehaviour"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$WorldAttached} from "net.createmod.catnip.data.WorldAttached"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GlobalStation} from "com.simibubi.create.content.trains.station.GlobalStation"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $StationBlockEntity extends $SmartBlockEntity implements $TransformableBlockEntity$$Interface {
 "lastDisassembledTrainName": $Component
 "flag": $LerpedFloat
static "assemblyAreas": $WorldAttached<($Map<($BlockPos), ($BoundingBox)>)>
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "doorControls": $DoorControlBehaviour
 "lastDisassembledMapColorIndex": integer
 "computerBehaviour": $AbstractComputerBehaviour
 "edgePoint": $TrackTargetingBehaviour<($GlobalStation)>

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isValidBogeyOffset"(arg0: integer): boolean
public "enterAssemblyMode"(arg0: $ServerPlayer$$Type): boolean
public "tryDisassembleTrain"(arg0: $ServerPlayer$$Type): boolean
public "exitAssemblyMode"(): boolean
public "updateMapColor"(arg0: integer): void
public "attachPackagePort"(arg0: $PackagePortBlockEntity$$Type): void
public "removePackagePort"(arg0: $PackagePortBlockEntity$$Type): void
public "cancelAssembly"(): void
public "updateName"(arg0: StringJS): boolean
public "assemble"(arg0: $UUID$$Type): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "getRenderBoundingBox"(): $AABB
public "trackClicked"(arg0: $Player$$Type, arg1: $InteractionHand$$Type, arg2: $ITrackBlock$$Type, arg3: $BlockState$$Type, arg4: $BlockPos$$Type): boolean
public "getAssemblyDirection"(): $Direction
public "resolveFlagAngle"(): boolean
public "getAutoSchedule"(): $ItemStack
public "getStation"(): $GlobalStation
public "isAssembling"(): boolean
public "tryEnterAssemblyMode"(): boolean
public "refreshAssemblyInfo"(): void
public "dropSchedule"(arg0: $ServerPlayer$$Type, arg1: $Train$$Type): void
public "tick"(): void
public "remove"(): void
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
get "renderBoundingBox"(): $AABB
get "assemblyDirection"(): $Direction
get "autoSchedule"(): $ItemStack
get "station"(): $GlobalStation
get "assembling"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StationBlockEntity$$Type = ($StationBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StationBlockEntity$$Original = $StationBlockEntity;}
declare module "com.simibubi.create.content.contraptions.mounted.CartAssemblerBlock$MinecartAnchorBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CartAssemblerBlock$MinecartAnchorBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CartAssemblerBlock$MinecartAnchorBlock$$Type = ($CartAssemblerBlock$MinecartAnchorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CartAssemblerBlock$MinecartAnchorBlock$$Original = $CartAssemblerBlock$MinecartAnchorBlock;}
declare module "com.simibubi.create.content.trains.track.TrackShape" {
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Function, $Function$$Type} from "java.util.function.Function"

export class $TrackShape extends $Enum<($TrackShape)> implements $StringRepresentable$$Interface {
static readonly "CR_O": $TrackShape
static readonly "TW": $TrackShape
static readonly "AE": $TrackShape
static readonly "CR_D": $TrackShape
static readonly "AN": $TrackShape
static readonly "CR_PDX": $TrackShape
static readonly "CR_NDZ": $TrackShape
static readonly "TE": $TrackShape
static readonly "AS": $TrackShape
static readonly "CR_PDZ": $TrackShape
static readonly "PD": $TrackShape
static readonly "ZO": $TrackShape
static readonly "ND": $TrackShape
static readonly "AW": $TrackShape
static readonly "CR_NDX": $TrackShape
static readonly "XO": $TrackShape
static readonly "TN": $TrackShape
static readonly "NONE": $TrackShape
static readonly "TS": $TrackShape

public "isPortal"(): boolean
public static "asPortal"(arg0: $Direction$$Type): $TrackShape
public "getAxes"(): $List<($Vec3)>
public "isJunction"(): boolean
public "getModelRotation"(): integer
public static "values"(): ($TrackShape)[]
public static "valueOf"(arg0: StringJS): $TrackShape
public "rotate"(arg0: $Rotation$$Type): $TrackShape
public "mirror"(arg0: $Mirror$$Type): $TrackShape
public "getSerializedName"(): StringJS
public "getNormal"(): $Vec3
public "getModel"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "portal"(): boolean
get "axes"(): $List<($Vec3)>
get "junction"(): boolean
get "modelRotation"(): integer
get "serializedName"(): StringJS
get "normal"(): $Vec3
get "model"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackShape$$Type = (("none") | ("zo") | ("xo") | ("pd") | ("nd") | ("an") | ("as") | ("ae") | ("aw") | ("tn") | ("ts") | ("te") | ("tw") | ("cr_o") | ("cr_d") | ("cr_pdx") | ("cr_pdz") | ("cr_ndx") | ("cr_ndz"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackShape$$Original = $TrackShape;}
declare module "com.simibubi.create.content.contraptions.mounted.CartAssemblerBlock$CartAssemblerAction" {
import {$Enum} from "java.lang.Enum"

export class $CartAssemblerBlock$CartAssemblerAction extends $Enum<($CartAssemblerBlock$CartAssemblerAction)> {
static readonly "ASSEMBLE_ACCELERATE_DIRECTIONAL": $CartAssemblerBlock$CartAssemblerAction
static readonly "DISASSEMBLE": $CartAssemblerBlock$CartAssemblerAction
static readonly "PASS": $CartAssemblerBlock$CartAssemblerAction
static readonly "ASSEMBLE": $CartAssemblerBlock$CartAssemblerAction
static readonly "DISASSEMBLE_BRAKE": $CartAssemblerBlock$CartAssemblerAction
static readonly "ASSEMBLE_ACCELERATE": $CartAssemblerBlock$CartAssemblerAction

public "shouldAssemble"(): boolean
public "shouldDisassemble"(): boolean
public static "values"(): ($CartAssemblerBlock$CartAssemblerAction)[]
public static "valueOf"(arg0: StringJS): $CartAssemblerBlock$CartAssemblerAction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CartAssemblerBlock$CartAssemblerAction$$Type = (("assemble") | ("disassemble") | ("assemble_accelerate") | ("disassemble_brake") | ("assemble_accelerate_directional") | ("pass"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CartAssemblerBlock$CartAssemblerAction$$Original = $CartAssemblerBlock$CartAssemblerAction;}
declare module "com.simibubi.create.content.trains.entity.TravellingPoint$ITrackSelector" {
import {$BiFunction, $BiFunction$$Interface} from "java.util.function.BiFunction"
import {$TrackGraph, $TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$TrackNode, $TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$Function$$Type} from "java.util.function.Function"
import {$List, $List$$Type} from "java.util.List"
import {$Pair, $Pair$$Type} from "net.createmod.catnip.data.Pair"
import {$TrackEdge, $TrackEdge$$Type} from "com.simibubi.create.content.trains.graph.TrackEdge"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"

export interface $TravellingPoint$ITrackSelector$$Interface extends $BiFunction$$Interface<($TrackGraph), ($Pair<(boolean), ($List<($Map$Entry<($TrackNode), ($TrackEdge)>)>)>), ($Map$Entry<($TrackNode), ($TrackEdge)>)> {

(arg0: $TrackGraph, arg1: $Pair<(boolean), ($List<($Map$Entry<($TrackNode), ($TrackEdge)>)>)>): $Map$Entry$$Type<($TrackNode$$Type), ($TrackEdge$$Type)>
}

export class $TravellingPoint$ITrackSelector implements $TravellingPoint$ITrackSelector$$Interface {
 "apply"(arg0: $TrackGraph$$Type, arg1: $Pair$$Type<(boolean), ($List$$Type<($Map$Entry$$Type<($TrackNode$$Type), ($TrackEdge$$Type)>)>)>): $Map$Entry<($TrackNode), ($TrackEdge)>
 "andThen"<V>(arg0: $Function$$Type<($Map$Entry<($TrackNode), ($TrackEdge)>), (V)>): $BiFunction<($TrackGraph), ($Pair<(boolean), ($List<($Map$Entry<($TrackNode), ($TrackEdge)>)>)>), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TravellingPoint$ITrackSelector$$Type = ((arg0: $TrackGraph, arg1: $Pair<(boolean), ($List<($Map$Entry<($TrackNode), ($TrackEdge)>)>)>) => $Map$Entry$$Type<($TrackNode$$Type), ($TrackEdge$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TravellingPoint$ITrackSelector$$Original = $TravellingPoint$ITrackSelector;}
declare module "com.simibubi.create.content.redstone.contact.RedstoneContactBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RedstoneContactBlock extends $WrenchableDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public static "hasValidContact"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneContactBlock$$Type = ($RedstoneContactBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneContactBlock$$Original = $RedstoneContactBlock;}
declare module "com.simibubi.create.content.contraptions.IControlContraption" {
import {$AbstractContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$ControlledContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.ControlledContraptionEntity"
import {$BlockPos} from "net.minecraft.core.BlockPos"

export interface $IControlContraption$$Interface {
get "valid"(): boolean
get "blockPosition"(): $BlockPos
}

export class $IControlContraption implements $IControlContraption$$Interface {
 "isAttachedTo"(arg0: $AbstractContraptionEntity$$Type): boolean
 "onStall"(): void
 "attach"(arg0: $ControlledContraptionEntity$$Type): void
 "isValid"(): boolean
 "getBlockPosition"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IControlContraption$$Type = ($IControlContraption);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IControlContraption$$Original = $IControlContraption;}
declare module "com.simibubi.create.content.trains.entity.CarriageContraptionEntity" {
import {$IDistanceTravelled$$Interface} from "com.railwayteam.railways.mixin_interfaces.IDistanceTravelled"
import {$Optional} from "java.util.Optional"
import {$UUID} from "java.util.UUID"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$CarriageSounds} from "com.simibubi.create.content.trains.entity.CarriageSounds"
import {$EntityDataAccessor$$Type} from "net.minecraft.network.syncher.EntityDataAccessor"
import {$CarriageParticles} from "com.simibubi.create.content.trains.entity.CarriageParticles"
import {$ScoreHolder} from "net.minecraft.world.scores.ScoreHolder"
import {$StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$PortalProcessor} from "net.minecraft.world.entity.PortalProcessor"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$OrientedContraptionEntity} from "com.simibubi.create.content.contraptions.OrientedContraptionEntity"
import {$Collection$$Type} from "java.util.Collection"
import {$Map} from "java.util.Map"
import {$Carriage, $Carriage$$Type} from "com.simibubi.create.content.trains.entity.Carriage"
import {$CarriageContraption$$Type} from "com.simibubi.create.content.trains.entity.CarriageContraption"
import {$AccessorCarriageContraptionEntity$$Interface} from "com.railwayteam.railways.mixin.AccessorCarriageContraptionEntity"
import {$Entity$RemovalReason} from "net.minecraft.world.entity.Entity$RemovalReason"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$IUpdateCount$$Type, $IUpdateCount$$Interface} from "com.railwayteam.railways.mixin_interfaces.IUpdateCount"
import {$EntityInLevelCallback} from "net.minecraft.world.level.entity.EntityInLevelCallback"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$MutableInt} from "org.apache.commons.lang3.mutable.MutableInt"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$CarriageSyncData} from "com.simibubi.create.content.trains.entity.CarriageSyncData"

export class $CarriageContraptionEntity extends $OrientedContraptionEntity implements $AccessorCarriageContraptionEntity$$Interface, $IUpdateCount$$Interface, $IDistanceTravelled$$Interface {
 "carriageIndex": integer
 "hasImpulse": boolean
 "tickCount": integer
 "noPhysics": boolean
 "yo": double
 "pitch": float
 "particles": $CarriageParticles
static readonly "BOARDING_COOLDOWN": integer
 "removalReason": $Entity$RemovalReason
 "trainId": $UUID
 "yRotO": float
static readonly "CONTENTS_SLOT_INDEX": integer
 "level": $Level
 "moveDist": float
static readonly "ID_TAG": StringJS
 "mainSupportingBlockPos": $Optional<($BlockPos)>
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
 "xRotO": float
 "prevYaw": float
 "zo": double
 "walkDist": float
 "movingBackwards": boolean
 "xOld": double
 "noCulling": boolean
 "wasInPowderSnow": boolean
 "hurtMarked": boolean
 "leftTickingChunks": boolean
 "staleTicks": integer
 "invulnerableTime": integer
static readonly "UUID_TAG": StringJS
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
 "fallDistance": float
 "portalProcess": $PortalProcessor
 "verticalCollision": boolean
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
 "prevPitch": float
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
 "verticalCollisionBelow": boolean
 "sounds": $CarriageSounds
 "yOld": double
static readonly "DEFAULT_BB_WIDTH": float
 "minorHorizontalCollision": boolean
static readonly "DEFAULT_BB_HEIGHT": float
 "levelCallback": $EntityInLevelCallback
 "walkDistO": float
static readonly "FREEZE_HURT_FREQUENCY": integer
 "flyDist": float
 "isInPowderSnow": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "yaw": float
static readonly "PASSENGERS_TAG": StringJS
 "blocksBuilding": boolean
 "wasOnFire": boolean
 "firstPositionUpdate": boolean
 "zOld": double
static readonly "TOTAL_AIR_SUPPLY": integer
 "xo": double
readonly "collidingEntities": $Map<($Entity), ($MutableInt)>
static readonly "BASE_SAFE_FALL_DISTANCE": integer
 "validForRender": boolean
 "nonDamageTicks": integer
 "targetYaw": float
 "wasTouchingWater": boolean
 "horizontalCollision": boolean

constructor(arg0: $EntityType$$Type<(never)>, arg1: $Level$$Type)

public "startControlling"(arg0: $BlockPos$$Type, arg1: $Player$$Type): boolean
public "hasSchedule"(): boolean
public "getCarriage"(): $Carriage
public "syncCarriage"(): void
public "getCarriageData"(): $CarriageSyncData
public "setServerSidePrevPosition"(): void
public "isLocalCoordWithin"(arg0: $BlockPos$$Type, arg1: integer, arg2: integer): boolean
public "checkConductors"(): $Couple<(boolean)>
public "setCarriage"(arg0: $Carriage$$Type): void
public "updateRenderedPortalCutoff"(): void
public "railways$getUpdateCount"(): integer
public "railways$fromParent"(arg0: $IUpdateCount$$Type): void
public "railways$markUpdate"(): void
public "railways$getDistanceTravelled"(): double
public "railways$getCarriage"(): $Carriage
public "railways$setCarriage"(arg0: $Carriage$$Type): void
public "railways$bindCarriage"(): void
public "tickActors"(): void
public "getContraptionName"(): $Component
public "getPrevPositionVec"(): $Vec3
public "tick"(): void
public "control"(arg0: $BlockPos$$Type, arg1: $Collection$$Type<(integer)>, arg2: $Player$$Type): boolean
public "getDisplayName"(): $Component
public static "create"(arg0: $Level$$Type, arg1: $CarriageContraption$$Type): $CarriageContraptionEntity
public "setBlock"(arg0: $BlockPos$$Type, arg1: $StructureTemplate$StructureBlockInfo$$Type): void
public "isControlledByLocalInstance"(): boolean
public "onSyncedDataUpdated"(arg0: $EntityDataAccessor$$Type<(never)>): void
public "onClientRemoval"(): void
public "shouldBeSaved"(): boolean
public static "outOfSync"(arg0: $IUpdateCount$$Type, arg1: $IUpdateCount$$Type): boolean
public static "forNameOnly"(arg0: StringJS): $ScoreHolder
public static "fromGameProfile"(arg0: $GameProfile$$Type): $ScoreHolder
/**
 * 
 * @deprecated
 */
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
get "carriage"(): $Carriage
get "carriageData"(): $CarriageSyncData
get "serverSidePrevPosition"(): void
set "carriage"(value: $Carriage$$Type)
get "contraptionName"(): $Component
get "prevPositionVec"(): $Vec3
get "displayName"(): $Component
get "controlledByLocalInstance"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarriageContraptionEntity$$Type = ($CarriageContraptionEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarriageContraptionEntity$$Original = $CarriageContraptionEntity;}
declare module "com.simibubi.create.content.redstone.RoseQuartzLampBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RoseQuartzLampBlock extends $Block implements $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "ACTIVATE": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "POWERING": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RoseQuartzLampBlock$$Type = ($RoseQuartzLampBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RoseQuartzLampBlock$$Original = $RoseQuartzLampBlock;}
declare module "com.simibubi.create.content.schematics.cannon.SchematicannonBlockEntity$State" {
import {$Enum} from "java.lang.Enum"

export class $SchematicannonBlockEntity$State extends $Enum<($SchematicannonBlockEntity$State)> {
static readonly "PAUSED": $SchematicannonBlockEntity$State
static readonly "RUNNING": $SchematicannonBlockEntity$State
static readonly "STOPPED": $SchematicannonBlockEntity$State

public static "values"(): ($SchematicannonBlockEntity$State)[]
public static "valueOf"(arg0: StringJS): $SchematicannonBlockEntity$State
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicannonBlockEntity$State$$Type = (("stopped") | ("paused") | ("running"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicannonBlockEntity$State$$Original = $SchematicannonBlockEntity$State;}
declare module "com.simibubi.create.content.contraptions.actors.seat.SeatBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Optional as $Optional$0} from "com.google.common.base.Optional"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SeatBlock extends $Block implements $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $DyeColor$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockPathType"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type): $PathType
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public static "sitDown"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): void
public static "canBePickedUp"(arg0: $Entity$$Type): boolean
public static "isSeatOccupied"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public static "getLeashed"(arg0: $Level$$Type, arg1: $Player$$Type): $Optional$0<($Entity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getColor"(): $DyeColor
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "color"(): $DyeColor
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeatBlock$$Type = ($SeatBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SeatBlock$$Original = $SeatBlock;}
declare module "com.simibubi.create.content.contraptions.pulley.PulleyBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List$$Type} from "java.util.List"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$AbstractContraptionEntity} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$LinearActuatorBlockEntity} from "com.simibubi.create.content.contraptions.piston.LinearActuatorBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$ThresholdSwitchObservable$$Interface} from "com.simibubi.create.content.redstone.thresholdSwitch.ThresholdSwitchObservable"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PulleyBlockEntity extends $LinearActuatorBlockEntity implements $ThresholdSwitchObservable$$Interface {
 "offset": float
 "sharedMirrorContraption": $WeakReference<($AbstractContraptionEntity)>
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "needsContraption": boolean
 "movedContraption": $AbstractContraptionEntity
 "network": long
 "running": boolean
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "assembleNextTick": boolean
 "updateSpeed": boolean
 "preventSpeedUpdate": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getInterpolatedOffset"(arg0: float): float
public "startMirroringOther"(arg0: $BlockPos$$Type): void
public "notifyMirrorsOfDisassembly"(): void
public "getAttachedContraption"(): $AbstractContraptionEntity
public "animateOffset"(arg0: float): void
public "getMirrorParent"(): $BlockPos
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getCurrentValue"(): integer
public "getMinValue"(): integer
public "getMaxValue"(): integer
public "tick"(): void
public "format"(arg0: integer): $MutableComponent
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "disassemble"(): void
get "attachedContraption"(): $AbstractContraptionEntity
get "mirrorParent"(): $BlockPos
get "currentValue"(): integer
get "minValue"(): integer
get "maxValue"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PulleyBlockEntity$$Type = ($PulleyBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PulleyBlockEntity$$Original = $PulleyBlockEntity;}
declare module "com.simibubi.create.content.trains.display.FlapDisplayLayout" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List, $List$$Type} from "java.util.List"
import {$FlapDisplaySection, $FlapDisplaySection$$Type} from "com.simibubi.create.content.trains.display.FlapDisplaySection"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $FlapDisplayLayout {
constructor(arg0: integer)

public "isLayout"(arg0: StringJS): boolean
public "configure"(arg0: StringJS, arg1: $List$$Type<($FlapDisplaySection$$Type)>): void
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getSections"(): $List<($FlapDisplaySection)>
public "loadDefault"(arg0: integer): void
get "sections"(): $List<($FlapDisplaySection)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlapDisplayLayout$$Type = ($FlapDisplayLayout);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlapDisplayLayout$$Original = $FlapDisplayLayout;}
declare module "com.simibubi.create.content.logistics.funnel.AbstractDirectionalFunnelBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$AbstractFunnelBlock} from "com.simibubi.create.content.logistics.funnel.AbstractFunnelBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractDirectionalFunnelBlock extends $AbstractFunnelBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractDirectionalFunnelBlock$$Type = ($AbstractDirectionalFunnelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractDirectionalFunnelBlock$$Original = $AbstractDirectionalFunnelBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.AccumulatedItemCountDisplaySource" {
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$NumericSingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.NumericSingleLineDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"
import {$DisplayLinkBlockEntity$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkBlockEntity"

export class $AccumulatedItemCountDisplaySource extends $NumericSingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "onSignalReset"(arg0: $DisplayLinkContext$$Type): void
public "getPassiveRefreshTicks"(): integer
public "itemReceived"(arg0: $DisplayLinkBlockEntity$$Type, arg1: integer): void
get "passiveRefreshTicks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AccumulatedItemCountDisplaySource$$Type = ($AccumulatedItemCountDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AccumulatedItemCountDisplaySource$$Original = $AccumulatedItemCountDisplaySource;}
declare module "com.simibubi.create.content.fluids.pipes.EncasedPipeBlock" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$EncasedBlock$$Interface} from "com.simibubi.create.content.decoration.encasing.EncasedBlock"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Map} from "java.util.Map"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$FluidPipeBlockEntity, $FluidPipeBlockEntity$$Type} from "com.simibubi.create.content.fluids.pipes.FluidPipeBlockEntity"
import {$TransformableBlock$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $EncasedPipeBlock extends $Block implements $IWrenchable$$Interface, $SpecialBlockItemRequirement$$Interface, $IBE$$Interface<($FluidPipeBlockEntity)>, $EncasedBlock$$Interface, $TransformableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "FACING_TO_PROPERTY_MAP": $Map<($Direction), ($BooleanProperty)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $Supplier$$Type<($Block$$Type)>)

public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($FluidPipeBlockEntity)>
public "getBlockEntityClass"(): $Class<($FluidPipeBlockEntity)>
public "getCasing"(): $Block
public "handleEncasing"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): void
public static "transferSixWayProperties"(arg0: $BlockState$$Type, arg1: $BlockState$$Type): $BlockState
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "transform"(arg0: $BlockState$$Type, arg1: $StructureTransform$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($FluidPipeBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($FluidPipeBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FluidPipeBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FluidPipeBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $FluidPipeBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($FluidPipeBlockEntity)>
get "blockEntityClass"(): $Class<($FluidPipeBlockEntity)>
get "casing"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EncasedPipeBlock$$Type = ($EncasedPipeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EncasedPipeBlock$$Original = $EncasedPipeBlock;}
declare module "com.simibubi.create.content.contraptions.glue.SuperGlueItem" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$PlayerInteractEvent$RightClickBlock$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$RightClickBlock"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SuperGlueItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "canAttackBlock"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): boolean
public static "spawnParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: boolean): void
public static "glueItemAlwaysPlacesWhenUsed"(arg0: $PlayerInteractEvent$RightClickBlock$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SuperGlueItem$$Type = ($SuperGlueItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SuperGlueItem$$Original = $SuperGlueItem;}
declare module "com.simibubi.create.content.processing.recipe.ProcessingRecipeParams" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $ProcessingRecipeParams {
static "CODEC": $MapCodec<($ProcessingRecipeParams)>
static "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ProcessingRecipeParams)>

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProcessingRecipeParams$$Type = ($ProcessingRecipeParams);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProcessingRecipeParams$$Original = $ProcessingRecipeParams;}
declare module "com.simibubi.create.content.contraptions.AssemblyException" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Exception} from "java.lang.Exception"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AssemblyException extends $Exception {
readonly "component": $Component

constructor(arg0: $Component$$Type)
constructor(arg0: StringJS, ...arg1: (any)[])

public static "structureTooLarge"(): $AssemblyException
public static "unloadedChunk"(arg0: $BlockPos$$Type): $AssemblyException
public static "unmovableBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $AssemblyException
public static "tooManyPistonPoles"(): $AssemblyException
public static "noPistonPoles"(): $AssemblyException
public static "notEnoughSails"(arg0: integer): $AssemblyException
public static "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $AssemblyException$$Type): void
public static "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $AssemblyException
public "hasPosition"(): boolean
public "getPosition"(): $BlockPos
get "position"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AssemblyException$$Type = ($AssemblyException);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AssemblyException$$Original = $AssemblyException;}
declare module "com.simibubi.create.content.kinetics.crafter.MechanicalCrafterBlockEntity$Inventory" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$MechanicalCrafterBlockEntity$$Type} from "com.simibubi.create.content.kinetics.crafter.MechanicalCrafterBlockEntity"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$SmartInventory} from "com.simibubi.create.foundation.item.SmartInventory"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container} from "net.minecraft.world.Container"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$IItemHandler} from "net.neoforged.neoforge.items.IItemHandler"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $MechanicalCrafterBlockEntity$Inventory extends $SmartInventory {
constructor(arg0: $MechanicalCrafterBlockEntity$$Type)

public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
public "self"(): $IItemHandler
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getBlock"(level: $Level$$Type): $LevelBlock
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "clear"(): void
public "getWidth"(): integer
public "getHeight"(): integer
public "setChanged"(): void
public "asContainer"(): $Container
public static "tryClear"(arg0: any): void
get "mutable"(): boolean
get "slots"(): integer
get "width"(): integer
get "height"(): integer
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalCrafterBlockEntity$Inventory$$Type = ($MechanicalCrafterBlockEntity$Inventory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalCrafterBlockEntity$Inventory$$Original = $MechanicalCrafterBlockEntity$Inventory;}
declare module "com.simibubi.create.content.fluids.spout.SpoutBlockEntity" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$BlockSpoutingBehaviour} from "com.simibubi.create.api.behaviour.spouting.BlockSpoutingBehaviour"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveGoggleInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveGoggleInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SpoutBlockEntity extends $SmartBlockEntity implements $IHaveGoggleInformation$$Interface {
 "sendSplash": boolean
static readonly "FILLING_TIME": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "processingTicks": integer
 "customProcess": $BlockSpoutingBehaviour

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "tick"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public "containedFluidTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean, arg2: $IFluidHandler$$Type): boolean
public "getIcon"(arg0: boolean): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpoutBlockEntity$$Type = ($SpoutBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpoutBlockEntity$$Original = $SpoutBlockEntity;}
declare module "com.simibubi.create.content.processing.recipe.ProcessingOutput" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Item$$Type} from "net.minecraft.world.item.Item"

export class $ProcessingOutput {
/**
 * 
 * @deprecated
 */
static readonly "CODEC": $Codec<($ProcessingOutput)>
/**
 * 
 * @deprecated
 */
static readonly "CODEC_OLD": $Codec<($ProcessingOutput)>
static readonly "EMPTY": $ProcessingOutput
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ProcessingOutput)>
static readonly "CODEC_NEW": $Codec<($ProcessingOutput)>

constructor(arg0: $ItemStack$$Type, arg1: float)
constructor(arg0: $Item$$Type, arg1: integer, arg2: float)
constructor(arg0: $Item$$Type, arg1: integer, arg2: $DataComponentPatch$$Type, arg3: float)
constructor(arg0: $ResourceLocation$$Type, arg1: integer, arg2: float)
constructor(arg0: $ResourceLocation$$Type, arg1: integer, arg2: $DataComponentPatch$$Type, arg3: float)

public "rollOutput"(arg0: $RandomSource$$Type): $ItemStack
public "getChance"(): float
public "getStack"(): $ItemStack
get "chance"(): float
get "stack"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProcessingOutput$$Type = ($ProcessingOutput);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProcessingOutput$$Original = $ProcessingOutput;}
declare module "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBehaviour$RequestType" {
import {$Enum} from "java.lang.Enum"

export class $LogisticallyLinkedBehaviour$RequestType extends $Enum<($LogisticallyLinkedBehaviour$RequestType)> {
static readonly "PLAYER": $LogisticallyLinkedBehaviour$RequestType
static readonly "REDSTONE": $LogisticallyLinkedBehaviour$RequestType
static readonly "RESTOCK": $LogisticallyLinkedBehaviour$RequestType

public static "values"(): ($LogisticallyLinkedBehaviour$RequestType)[]
public static "valueOf"(arg0: StringJS): $LogisticallyLinkedBehaviour$RequestType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogisticallyLinkedBehaviour$RequestType$$Type = (("restock") | ("redstone") | ("player"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LogisticallyLinkedBehaviour$RequestType$$Original = $LogisticallyLinkedBehaviour$RequestType;}
declare module "com.simibubi.create.content.fluids.tank.FluidTankBlock$Shape" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $FluidTankBlock$Shape extends $Enum<($FluidTankBlock$Shape)> implements $StringRepresentable$$Interface {
static readonly "PLAIN": $FluidTankBlock$Shape
static readonly "WINDOW_NW": $FluidTankBlock$Shape
static readonly "WINDOW_SE": $FluidTankBlock$Shape
static readonly "WINDOW_SW": $FluidTankBlock$Shape
static readonly "WINDOW": $FluidTankBlock$Shape
static readonly "WINDOW_NE": $FluidTankBlock$Shape

public static "values"(): ($FluidTankBlock$Shape)[]
public static "valueOf"(arg0: StringJS): $FluidTankBlock$Shape
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankBlock$Shape$$Type = (("plain") | ("window") | ("window_nw") | ("window_sw") | ("window_ne") | ("window_se"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTankBlock$Shape$$Original = $FluidTankBlock$Shape;}
declare module "com.simibubi.create.content.trains.schedule.ScheduleRuntime" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Collection} from "java.util.Collection"
import {$List} from "java.util.List"
import {$Train, $Train$$Type} from "com.simibubi.create.content.trains.entity.Train"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DiscoveredPath} from "com.simibubi.create.content.trains.graph.DiscoveredPath"
import {$ScheduleRuntime$State} from "com.simibubi.create.content.trains.schedule.ScheduleRuntime$State"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AccessorScheduleRuntime$$Interface} from "com.railwayteam.railways.mixin.AccessorScheduleRuntime"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Schedule, $Schedule$$Type} from "com.simibubi.create.content.trains.schedule.Schedule"
import {$GlobalTrainDisplayData$TrainDeparturePrediction} from "com.simibubi.create.content.trains.display.GlobalTrainDisplayData$TrainDeparturePrediction"

export class $ScheduleRuntime implements $AccessorScheduleRuntime$$Interface {
 "paused": boolean
 "predictionTicks": $List<(integer)>
 "currentEntry": integer
 "completed": boolean
 "displayLinkUpdateRequested": boolean
 "schedule": $Schedule
 "currentTitle": StringJS
 "conditionContext": $List<($CompoundTag)>
 "isAutoSchedule": boolean
 "state": $ScheduleRuntime$State
 "conditionProgress": $List<(integer)>
 "train": $Train
 "ticksInTransit": integer

constructor(arg0: $Train$$Type)

public "startCurrentInstruction"(arg0: $Level$$Type): $DiscoveredPath
public "destinationReached"(): void
public "submitPredictions"(): $Collection<($GlobalTrainDisplayData$TrainDeparturePrediction)>
public "setCooldown"(arg0: integer): void
public "setSchedule"(arg0: $Schedule$$Type, arg1: boolean): void
public "returnSchedule"(arg0: $HolderLookup$Provider$$Type): $ItemStack
public "getWaitingStatus"(arg0: $Level$$Type): $MutableComponent
public "startCooldown"(): void
public "discardSchedule"(): void
public "getTrain"(): $Train
public "setSchedulePresentClientside"(arg0: boolean): void
public "transitInterrupted"(): void
public "tickConditions"(arg0: $Level$$Type): void
public "tick"(arg0: $Level$$Type): void
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "read"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
public "getSchedule"(): $Schedule
set "cooldown"(value: integer)
set "schedulePresentClientside"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduleRuntime$$Type = ($ScheduleRuntime);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduleRuntime$$Original = $ScheduleRuntime;}
declare module "com.simibubi.create.content.contraptions.OrientedContraptionEntity" {
import {$Optional} from "java.util.Optional"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecartController} from "com.simibubi.create.content.contraptions.minecart.capability.MinecartController"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$EntityDataAccessor$$Type} from "net.minecraft.network.syncher.EntityDataAccessor"
import {$ScoreHolder} from "net.minecraft.world.scores.ScoreHolder"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$PortalProcessor} from "net.minecraft.world.entity.PortalProcessor"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$AbstractContraptionEntity$ContraptionRotationState} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity$ContraptionRotationState"
import {$Map} from "java.util.Map"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$ContraptionRelocationPacket$$Type} from "com.simibubi.create.content.contraptions.ContraptionRelocationPacket"
import {$AccessorOrientedContraptionEntity$$Interface} from "com.railwayteam.railways.mixin.AccessorOrientedContraptionEntity"
import {$Entity$RemovalReason} from "net.minecraft.world.entity.Entity$RemovalReason"
import {$StructureTransform} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AbstractContraptionEntity} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$EntityInLevelCallback} from "net.minecraft.world.level.entity.EntityInLevelCallback"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$MutableInt} from "org.apache.commons.lang3.mutable.MutableInt"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"

export class $OrientedContraptionEntity extends $AbstractContraptionEntity implements $AccessorOrientedContraptionEntity$$Interface {
 "hasImpulse": boolean
 "tickCount": integer
 "noPhysics": boolean
 "yo": double
 "pitch": float
static readonly "BOARDING_COOLDOWN": integer
 "removalReason": $Entity$RemovalReason
 "yRotO": float
static readonly "CONTENTS_SLOT_INDEX": integer
 "level": $Level
 "moveDist": float
static readonly "ID_TAG": StringJS
 "mainSupportingBlockPos": $Optional<($BlockPos)>
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
 "xRotO": float
 "prevYaw": float
 "zo": double
 "walkDist": float
 "xOld": double
 "noCulling": boolean
 "wasInPowderSnow": boolean
 "hurtMarked": boolean
 "staleTicks": integer
 "invulnerableTime": integer
static readonly "UUID_TAG": StringJS
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
 "fallDistance": float
 "portalProcess": $PortalProcessor
 "verticalCollision": boolean
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
 "prevPitch": float
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
 "verticalCollisionBelow": boolean
 "yOld": double
static readonly "DEFAULT_BB_WIDTH": float
 "minorHorizontalCollision": boolean
static readonly "DEFAULT_BB_HEIGHT": float
 "levelCallback": $EntityInLevelCallback
 "walkDistO": float
static readonly "FREEZE_HURT_FREQUENCY": integer
 "flyDist": float
 "isInPowderSnow": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "yaw": float
static readonly "PASSENGERS_TAG": StringJS
 "blocksBuilding": boolean
 "wasOnFire": boolean
 "zOld": double
static readonly "TOTAL_AIR_SUPPLY": integer
 "xo": double
readonly "collidingEntities": $Map<($Entity), ($MutableInt)>
static readonly "BASE_SAFE_FALL_DISTANCE": integer
 "nonDamageTicks": integer
 "targetYaw": float
 "wasTouchingWater": boolean
 "horizontalCollision": boolean

constructor(arg0: $EntityType$$Type<(never)>, arg1: $Level$$Type)

public static "handleRelocationPacket"(arg0: $ContraptionRelocationPacket$$Type): void
public static "createAtYaw"(arg0: $Level$$Type, arg1: $Contraption$$Type, arg2: $Direction$$Type, arg3: float): $OrientedContraptionEntity
public "getInitialOrientation"(): $Direction
public "setInitialOrientation"(arg0: $Direction$$Type): void
public "startAtInitialYaw"(): void
public "startAtYaw"(arg0: float): void
public "getYawOffset"(): float
public "getInitialYaw"(): float
public "isInitialOrientationPresent"(): boolean
public "getRotationState"(): $AbstractContraptionEntity$ContraptionRotationState
public "setCouplingId"(arg0: $UUID$$Type): void
public "getCouplingId"(): $UUID
public "applyRotation"(arg0: $Vec3$$Type, arg1: float): $Vec3
public "reverseRotation"(arg0: $Vec3$$Type, arg1: float): $Vec3
public "getCoupledCartsIfPresent"(): $Couple<($MinecartController)>
public "getAnchorVec"(): $Vec3
public "getPrevAnchorVec"(): $Vec3
public "applyLocalTransforms"(arg0: $PoseStack$$Type, arg1: float): void
public "railways$makeStructureTransform"(): $StructureTransform
public static "create"(arg0: $Level$$Type, arg1: $Contraption$$Type, arg2: $Direction$$Type): $OrientedContraptionEntity
public "getViewXRot"(arg0: float): float
public "stopRiding"(): void
public "getViewYRot"(arg0: float): float
public "onSyncedDataUpdated"(arg0: $EntityDataAccessor$$Type<(never)>): void
public "getVehicleAttachmentPoint"(arg0: $Entity$$Type): $Vec3
public static "forNameOnly"(arg0: StringJS): $ScoreHolder
public static "fromGameProfile"(arg0: $GameProfile$$Type): $ScoreHolder
/**
 * 
 * @deprecated
 */
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
get "initialOrientation"(): $Direction
set "initialOrientation"(value: $Direction$$Type)
get "yawOffset"(): float
get "initialYaw"(): float
get "initialOrientationPresent"(): boolean
get "rotationState"(): $AbstractContraptionEntity$ContraptionRotationState
set "couplingId"(value: $UUID$$Type)
get "couplingId"(): $UUID
get "coupledCartsIfPresent"(): $Couple<($MinecartController)>
get "anchorVec"(): $Vec3
get "prevAnchorVec"(): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrientedContraptionEntity$$Type = ($OrientedContraptionEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OrientedContraptionEntity$$Original = $OrientedContraptionEntity;}
declare module "com.simibubi.create.content.logistics.packagerLink.RequestPromiseQueue" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Runnable$$Type} from "java.lang.Runnable"
import {$RequestPromise, $RequestPromise$$Type} from "com.simibubi.create.content.logistics.packagerLink.RequestPromise"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $RequestPromiseQueue {
constructor(arg0: $Runnable$$Type)

public "itemEnteredSystem"(arg0: $ItemStack$$Type, arg1: integer): void
public "setOnChanged"(arg0: $Runnable$$Type): void
public "forceClear"(arg0: $ItemStack$$Type): void
public "getTotalPromisedAndRemoveExpired"(arg0: $ItemStack$$Type, arg1: integer): integer
public "tick"(): void
public "flatten"(arg0: boolean): $List<($RequestPromise)>
public "isEmpty"(): boolean
public "add"(arg0: $RequestPromise$$Type): void
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $Runnable$$Type): $RequestPromiseQueue
set "onChanged"(value: $Runnable$$Type)
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequestPromiseQueue$$Type = ($RequestPromiseQueue);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RequestPromiseQueue$$Original = $RequestPromiseQueue;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export interface $ItemAttributeType$$Interface {
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.CreateItemAttributeType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.CreateItemAttributeTypeTag
}

export class $ItemAttributeType implements $ItemAttributeType$$Interface {
 "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
 "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
 "createAttribute"(): $ItemAttribute
 "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemAttributeType$$Type = (Special.CreateItemAttributeType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemAttributeType$$Original = $ItemAttributeType;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.ArmAngleTarget" {
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $ArmAngleTarget {
constructor(arg0: $BlockPos$$Type, arg1: $Vec3$$Type, arg2: $Direction$$Type, arg3: boolean)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmAngleTarget$$Type = ($ArmAngleTarget);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmAngleTarget$$Original = $ArmAngleTarget;}
declare module "com.simibubi.create.content.decoration.bracket.BracketBlock$BracketType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BracketBlock$BracketType extends $Enum<($BracketBlock$BracketType)> implements $StringRepresentable$$Interface {
static readonly "SHAFT": $BracketBlock$BracketType
static readonly "COG": $BracketBlock$BracketType
static readonly "PIPE": $BracketBlock$BracketType

public static "values"(): ($BracketBlock$BracketType)[]
public static "valueOf"(arg0: StringJS): $BracketBlock$BracketType
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BracketBlock$BracketType$$Type = (("pipe") | ("cog") | ("shaft"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BracketBlock$BracketType$$Original = $BracketBlock$BracketType;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.BeltProcessingBehaviour" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$SmartBlockEntity, $SmartBlockEntity$$Type} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BeltProcessingBehaviour$ProcessingCallback$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.BeltProcessingBehaviour$ProcessingCallback"
import {$BeltProcessingBehaviour$ProcessingResult} from "com.simibubi.create.content.kinetics.belt.behaviour.BeltProcessingBehaviour$ProcessingResult"
import {$TransportedItemStackHandlerBehaviour$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour"
import {$BlockEntityBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BehaviourType} from "com.simibubi.create.foundation.blockEntity.behaviour.BehaviourType"
import {$TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $BeltProcessingBehaviour extends $BlockEntityBehaviour {
 "blockEntity": $SmartBlockEntity
static readonly "TYPE": $BehaviourType<($BeltProcessingBehaviour)>

constructor(arg0: $SmartBlockEntity$$Type)

public "whenItemEnters"(arg0: $BeltProcessingBehaviour$ProcessingCallback$$Type): $BeltProcessingBehaviour
public "whileItemHeld"(arg0: $BeltProcessingBehaviour$ProcessingCallback$$Type): $BeltProcessingBehaviour
public "handleHeldItem"(arg0: $TransportedItemStack$$Type, arg1: $TransportedItemStackHandlerBehaviour$$Type): $BeltProcessingBehaviour$ProcessingResult
public "handleReceivedItem"(arg0: $TransportedItemStack$$Type, arg1: $TransportedItemStackHandlerBehaviour$$Type): $BeltProcessingBehaviour$ProcessingResult
public "getType"(): $BehaviourType<(never)>
public static "isBlocked"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
get "type"(): $BehaviourType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltProcessingBehaviour$$Type = ($BeltProcessingBehaviour);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltProcessingBehaviour$$Original = $BeltProcessingBehaviour;}
declare module "com.simibubi.create.content.kinetics.fan.EncasedFanBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List$$Type} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$IAirCurrentSource$$Interface} from "com.simibubi.create.content.kinetics.fan.IAirCurrentSource"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AirCurrent} from "com.simibubi.create.content.kinetics.fan.AirCurrent"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EncasedFanBlockEntity extends $KineticBlockEntity implements $IAirCurrentSource$$Interface {
 "airCurrent": $AirCurrent
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "updateChute"(): void
public "getAirCurrent"(): $AirCurrent
public "getAirCurrentWorld"(): $Level
public "getAirCurrentPos"(): $BlockPos
public "getAirFlowDirection"(): $Direction
public "isSourceRemoved"(): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onSpeedChanged"(arg0: float): void
public "blockInFrontChanged"(): void
public "getAirflowOriginSide"(): $Direction
public "tick"(): void
public "remove"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "getMaxDistance"(): float
public "getSpeed"(): float
get "airCurrentWorld"(): $Level
get "airCurrentPos"(): $BlockPos
get "airFlowDirection"(): $Direction
get "sourceRemoved"(): boolean
get "airflowOriginSide"(): $Direction
get "maxDistance"(): float
get "speed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EncasedFanBlockEntity$$Type = ($EncasedFanBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EncasedFanBlockEntity$$Original = $EncasedFanBlockEntity;}
declare module "com.simibubi.create.content.equipment.wrench.IWrenchable" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $IWrenchable$$Interface {
}

export class $IWrenchable implements $IWrenchable$$Interface {
 "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
 "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
 "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
 "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IWrenchable$$Type = ($IWrenchable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IWrenchable$$Original = $IWrenchable;}
declare module "com.simibubi.create.content.equipment.bell.PeculiarBellBlock" {
import {$PeculiarBellBlockEntity} from "com.simibubi.create.content.equipment.bell.PeculiarBellBlockEntity"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BellBlock} from "net.minecraft.world.level.block.BellBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BellAttachType} from "net.minecraft.world.level.block.state.properties.BellAttachType"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$AbstractBellBlock} from "com.simibubi.create.content.equipment.bell.AbstractBellBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Class} from "java.lang.Class"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PeculiarBellBlock extends $AbstractBellBlock<($PeculiarBellBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "ATTACHMENT": $EnumProperty<($BellAttachType)>
 "item": $Item
static readonly "CODEC": $MapCodec<($BellBlock)>
static readonly "EVENT_BELL_RING": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($PeculiarBellBlockEntity)>
public "getBlockEntityClass"(): $Class<($PeculiarBellBlockEntity)>
public "spawnConversionParticles"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): void
public "playSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($PeculiarBellBlockEntity)>
get "blockEntityClass"(): $Class<($PeculiarBellBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PeculiarBellBlock$$Type = ($PeculiarBellBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PeculiarBellBlock$$Original = $PeculiarBellBlock;}
declare module "com.simibubi.create.content.contraptions.chassis.StickerBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StickerBlockEntity extends $SmartBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "computerBehaviour": $AbstractComputerBehaviour

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isBlockStateExtended"(): boolean
public "isAttachedToBlock"(): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "tick"(): void
public "initialize"(): void
public "invalidate"(): void
public "playSound"(arg0: boolean): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
get "blockStateExtended"(): boolean
get "attachedToBlock"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StickerBlockEntity$$Type = ($StickerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StickerBlockEntity$$Original = $StickerBlockEntity;}
declare module "com.simibubi.create.content.contraptions.actors.roller.RollerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$AttachedActorBlock} from "com.simibubi.create.content.contraptions.actors.AttachedActorBlock"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$RollerBlockEntity, $RollerBlockEntity$$Type} from "com.simibubi.create.content.contraptions.actors.roller.RollerBlockEntity"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $RollerBlock extends $AttachedActorBlock implements $IBE$$Interface<($RollerBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RollerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($RollerBlockEntity)>
public "getBlockEntityClass"(): $Class<($RollerBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($RollerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($RollerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($RollerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($RollerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $RollerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($RollerBlockEntity)>
get "blockEntityClass"(): $Class<($RollerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RollerBlock$$Type = ($RollerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RollerBlock$$Original = $RollerBlock;}
declare module "com.simibubi.create.content.contraptions.piston.PistonExtensionPoleBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $PistonExtensionPoleBlock extends $WrenchableDirectionalBlock implements $IWrenchable$$Interface, $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonExtensionPoleBlock$$Type = ($PistonExtensionPoleBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PistonExtensionPoleBlock$$Original = $PistonExtensionPoleBlock;}
declare module "com.simibubi.create.content.kinetics.belt.BeltSlope" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BeltSlope extends $Enum<($BeltSlope)> implements $StringRepresentable$$Interface {
static readonly "VERTICAL": $BeltSlope
static readonly "HORIZONTAL": $BeltSlope
static readonly "DOWNWARD": $BeltSlope
static readonly "UPWARD": $BeltSlope
static readonly "SIDEWAYS": $BeltSlope

public "isDiagonal"(): boolean
public static "values"(): ($BeltSlope)[]
public static "valueOf"(arg0: StringJS): $BeltSlope
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "diagonal"(): boolean
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltSlope$$Type = (("horizontal") | ("upward") | ("downward") | ("vertical") | ("sideways"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltSlope$$Original = $BeltSlope;}
declare module "com.simibubi.create.content.kinetics.crank.HandCrankBlockEntity" {
import {$GeneratingKineticBlockEntity} from "com.simibubi.create.content.kinetics.base.GeneratingKineticBlockEntity"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SuperByteBuffer} from "net.createmod.catnip.render.SuperByteBuffer"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $HandCrankBlockEntity extends $GeneratingKineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "independentAngle": float
 "chasingVelocity": float
 "inUse": integer
 "updateSpeed": boolean
 "reActivateSource": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "backwards": boolean
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getGeneratedSpeed"(): float
public "tickAudio"(): void
public "getRenderedHandle"(): $SuperByteBuffer
public "getIndependentAngle"(arg0: float): float
public "shouldRenderShaft"(): boolean
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "turn"(arg0: boolean): void
get "generatedSpeed"(): float
get "renderedHandle"(): $SuperByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandCrankBlockEntity$$Type = ($HandCrankBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HandCrankBlockEntity$$Original = $HandCrankBlockEntity;}
declare module "com.simibubi.create.content.logistics.packager.InventorySummary" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List, $List$$Type} from "java.util.List"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Item} from "net.minecraft.world.item.Item"
import {$BigItemStack, $BigItemStack$$Type} from "com.simibubi.create.content.logistics.BigItemStack"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $InventorySummary {
static "CODEC": $Codec<($InventorySummary)>
 "contributingLinks": integer
static readonly "EMPTY": $InventorySummary

constructor()

public "divideAndSendTo"(arg0: $ServerPlayer$$Type, arg1: $BlockPos$$Type): void
public "getStacksByCount"(): $List<($BigItemStack)>
public "getCountOf"(arg0: $ItemStack$$Type): integer
public "addAllBigItemStacks"(arg0: $List$$Type<($BigItemStack$$Type)>): void
public "addAllItemStacks"(arg0: $List$$Type<($ItemStack$$Type)>): void
public "getTotalOfMatching"(arg0: $Predicate$$Type<($ItemStack)>): integer
public "getItemMap"(): $Map<($Item), ($List<($BigItemStack)>)>
public "getStacks"(): $List<($BigItemStack)>
public "isEmpty"(): boolean
public "add"(arg0: $BigItemStack$$Type): void
public "add"(arg0: $ItemStack$$Type): void
public "add"(arg0: $InventorySummary$$Type): void
public "add"(arg0: $ItemStack$$Type, arg1: integer): void
public "copy"(): $InventorySummary
public "erase"(arg0: $ItemStack$$Type): boolean
public "getTotalCount"(): integer
get "stacksByCount"(): $List<($BigItemStack)>
get "itemMap"(): $Map<($Item), ($List<($BigItemStack)>)>
get "stacks"(): $List<($BigItemStack)>
get "empty"(): boolean
get "totalCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventorySummary$$Type = ($InventorySummary);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventorySummary$$Original = $InventorySummary;}
declare module "com.simibubi.create.content.kinetics.crafter.MechanicalCrafterBlockEntity" {
import {$MechanicalCrafterBlockEntity$Inventory} from "com.simibubi.create.content.kinetics.crafter.MechanicalCrafterBlockEntity$Inventory"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockFace} from "net.createmod.catnip.math.BlockFace"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$ConnectedInputHandler$ConnectedInput} from "com.simibubi.create.content.kinetics.crafter.ConnectedInputHandler$ConnectedInput"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MechanicalCrafterBlockEntity extends $KineticBlockEntity implements $TransformableBlockEntity$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "connectivityChanged"(): void
public "checkCompletedRecipe"(arg0: boolean): void
public "getCountDownSpeed"(): integer
public "getTargetFace"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockFace
public "craftingItemPresent"(): boolean
public "eject"(): void
public "craftingItemOrCoverPresent"(): boolean
public "setScriptedResult"(arg0: $ItemStack$$Type): void
public "dropItem"(arg0: $Vec3$$Type, arg1: $ItemStack$$Type): void
public "tryInsert"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "onSpeedChanged"(arg0: float): void
public "getTargetDirection"(): $Direction
public "ejectWholeGrid"(): void
public "tick"(): void
public "getInput"(): $ConnectedInputHandler$ConnectedInput
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "invalidate"(): void
public "getInventory"(): $MechanicalCrafterBlockEntity$Inventory
public "blockChanged"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
get "countDownSpeed"(): integer
set "scriptedResult"(value: $ItemStack$$Type)
get "targetDirection"(): $Direction
get "input"(): $ConnectedInputHandler$ConnectedInput
get "inventory"(): $MechanicalCrafterBlockEntity$Inventory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalCrafterBlockEntity$$Type = ($MechanicalCrafterBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalCrafterBlockEntity$$Original = $MechanicalCrafterBlockEntity;}
declare module "com.simibubi.create.content.decoration.palettes.LayeredBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$RotatedPillarBlock} from "net.minecraft.world.level.block.RotatedPillarBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $LayeredBlock extends $RotatedPillarBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RotatedPillarBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LayeredBlock$$Type = ($LayeredBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LayeredBlock$$Original = $LayeredBlock;}
declare module "com.simibubi.create.content.logistics.box.PackageStyles$PackageStyle" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Record} from "java.lang.Record"

export class $PackageStyles$PackageStyle extends $Record {
constructor(type: StringJS, width: integer, height: integer, riggingOffset: float, rare: boolean)

public "rare"(): boolean
public "riggingOffset"(): float
public "getItemId"(): $ResourceLocation
public "getRiggingModel"(): $ResourceLocation
public "type"(): StringJS
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "width"(): integer
public "height"(): integer
get "itemId"(): $ResourceLocation
get "riggingModel"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackageStyles$PackageStyle$$Type = ({"riggingOffset"?: float, "type"?: StringJS, "width"?: integer, "rare"?: boolean, "height"?: integer}) | ([riggingOffset?: float, type?: StringJS, width?: integer, rare?: boolean, height?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackageStyles$PackageStyle$$Original = $PackageStyles$PackageStyle;}
declare module "com.simibubi.create.content.kinetics.waterwheel.LargeWaterWheelBlockEntity" {
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$Map} from "java.util.Map"
import {$WaterWheelBlockEntity} from "com.simibubi.create.content.kinetics.waterwheel.WaterWheelBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Set} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $LargeWaterWheelBlockEntity extends $WaterWheelBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
static readonly "SMALL_OFFSETS": $Map<($Direction$Axis), ($Set<($BlockPos)>)>
 "flowScore": integer
 "material": $BlockState
 "updateSpeed": boolean
 "reActivateSource": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
static readonly "LARGE_OFFSETS": $Map<($Direction$Axis), ($Set<($BlockPos)>)>
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LargeWaterWheelBlockEntity$$Type = ($LargeWaterWheelBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LargeWaterWheelBlockEntity$$Original = $LargeWaterWheelBlockEntity;}
declare module "com.simibubi.create.content.logistics.vault.ItemVaultItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $ItemVaultItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "place"(arg0: $BlockPlaceContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemVaultItem$$Type = ($ItemVaultItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemVaultItem$$Original = $ItemVaultItem;}
declare module "com.simibubi.create.content.trains.display.FlapDisplaySection" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $FlapDisplaySection {
static readonly "WIDE_MONOSPACE": float
static readonly "MONOSPACE": float

constructor(arg0: float, arg1: StringJS, arg2: boolean, arg3: boolean)

public "rightAligned"(): $FlapDisplaySection
public "wideFlaps"(): $FlapDisplaySection
public static "getFlapCycle"(arg0: StringJS): (StringJS)[]
public "tick"(arg0: boolean, arg1: $RandomSource$$Type): integer
public "setText"(arg0: $Component$$Type): void
public "refresh"(arg0: boolean): void
public "renderCharsIndividually"(): boolean
public "update"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public static "load"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $FlapDisplaySection
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getSize"(): float
public "getText"(): $Component
set "text"(value: $Component$$Type)
get "size"(): float
get "text"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlapDisplaySection$$Type = ($FlapDisplaySection);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlapDisplaySection$$Original = $FlapDisplaySection;}
declare module "com.simibubi.create.content.fluids.potion.PotionFluid$BottleType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $PotionFluid$BottleType extends $Enum<($PotionFluid$BottleType)> implements $StringRepresentable$$Interface {
static readonly "REGULAR": $PotionFluid$BottleType
static readonly "CODEC": $Codec<($PotionFluid$BottleType)>
static readonly "LINGERING": $PotionFluid$BottleType
static readonly "SPLASH": $PotionFluid$BottleType
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($PotionFluid$BottleType)>

public static "values"(): ($PotionFluid$BottleType)[]
public static "valueOf"(arg0: StringJS): $PotionFluid$BottleType
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionFluid$BottleType$$Type = (("regular") | ("splash") | ("lingering"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotionFluid$BottleType$$Original = $PotionFluid$BottleType;}
declare module "com.simibubi.create.content.kinetics.gantry.GantryShaftBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DirectionalKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalKineticBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$GantryShaftBlock$Part} from "com.simibubi.create.content.kinetics.gantry.GantryShaftBlock$Part"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$GantryShaftBlockEntity, $GantryShaftBlockEntity$$Type} from "com.simibubi.create.content.kinetics.gantry.GantryShaftBlockEntity"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $GantryShaftBlock extends $DirectionalKineticBlock implements $IBE$$Interface<($GantryShaftBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "PART": $Property<($GantryShaftBlock$Part)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($GantryShaftBlockEntity)>
public "getBlockEntityClass"(): $Class<($GantryShaftBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($GantryShaftBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($GantryShaftBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($GantryShaftBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($GantryShaftBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $GantryShaftBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
get "blockEntityType"(): $BlockEntityType<($GantryShaftBlockEntity)>
get "blockEntityClass"(): $Class<($GantryShaftBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GantryShaftBlock$$Type = ($GantryShaftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GantryShaftBlock$$Original = $GantryShaftBlock;}
declare module "com.simibubi.create.content.kinetics.base.DirectionalShaftHalvesBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Direction} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $DirectionalShaftHalvesBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getSourceFacing"(): $Direction
get "sourceFacing"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionalShaftHalvesBlockEntity$$Type = ($DirectionalShaftHalvesBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectionalShaftHalvesBlockEntity$$Original = $DirectionalShaftHalvesBlockEntity;}
declare module "com.simibubi.create.content.kinetics.crusher.CrushingWheelControllerBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$Optional} from "java.util.Optional"
import {$ProcessingInventory} from "com.simibubi.create.content.processing.recipe.ProcessingInventory"
import {$List$$Type} from "java.util.List"
import {$RecipeWrapper} from "net.neoforged.neoforge.items.wrapper.RecipeWrapper"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$RecipeHolder} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$StandardProcessingRecipe} from "com.simibubi.create.content.processing.recipe.StandardProcessingRecipe"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CrushingWheelControllerBlockEntity extends $SmartBlockEntity implements $Clearable$$Interface {
 "processingEntity": $Entity
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventory": $ProcessingInventory
 "crushingspeed": float

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "tickAudio"(): void
public "hasEntity"(): boolean
public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "isOccupied"(): boolean
public "startCrushing"(arg0: $Entity$$Type): void
public "findRecipe"(): $Optional<($RecipeHolder<($StandardProcessingRecipe<($RecipeWrapper)>)>)>
public "tick"(): void
public "clear"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
get "occupied"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrushingWheelControllerBlockEntity$$Type = ($CrushingWheelControllerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CrushingWheelControllerBlockEntity$$Original = $CrushingWheelControllerBlockEntity;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$BasinType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$BasinType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$BasinType$$Type = ($AllArmInteractionPointTypes$BasinType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$BasinType$$Original = $AllArmInteractionPointTypes$BasinType;}
declare module "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBlockItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$LogisticallyLinkedBlockItem} from "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBlockItem"

export class $FactoryPanelBlockItem extends $LogisticallyLinkedBlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public static "fixCtrlCopiedStack"(arg0: $ItemStack$$Type): $ItemStack
public "place"(arg0: $BlockPlaceContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryPanelBlockItem$$Type = ($FactoryPanelBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FactoryPanelBlockItem$$Original = $FactoryPanelBlockItem;}
declare module "com.simibubi.create.content.processing.burner.LitBlazeBurnerBlock$FlameType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $LitBlazeBurnerBlock$FlameType extends $Enum<($LitBlazeBurnerBlock$FlameType)> implements $StringRepresentable$$Interface {
static readonly "REGULAR": $LitBlazeBurnerBlock$FlameType
static readonly "SOUL": $LitBlazeBurnerBlock$FlameType

public static "values"(): ($LitBlazeBurnerBlock$FlameType)[]
public static "valueOf"(arg0: StringJS): $LitBlazeBurnerBlock$FlameType
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LitBlazeBurnerBlock$FlameType$$Type = (("regular") | ("soul"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LitBlazeBurnerBlock$FlameType$$Original = $LitBlazeBurnerBlock$FlameType;}
declare module "com.simibubi.create.content.logistics.crate.CreativeCrateBlockEntity" {
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$FilteringBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.filtering.FilteringBehaviour"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CrateBlockEntity} from "com.simibubi.create.content.logistics.crate.CrateBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CreativeCrateBlockEntity extends $CrateBlockEntity implements $Clearable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "invalidate"(): void
public "createFilter"(): $FilteringBehaviour
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeCrateBlockEntity$$Type = ($CreativeCrateBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeCrateBlockEntity$$Original = $CreativeCrateBlockEntity;}
declare module "com.simibubi.create.content.logistics.stockTicker.StockTickerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$PartialModel} from "dev.engine_room.flywheel.lib.model.baked.PartialModel"
import {$StockTickerBlockEntity, $StockTickerBlockEntity$$Type} from "com.simibubi.create.content.logistics.stockTicker.StockTickerBlockEntity"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $StockTickerBlock extends $HorizontalDirectionalBlock implements $IBE$$Interface<($StockTickerBlockEntity)>, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($StockTickerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($StockTickerBlockEntity)>
public "getBlockEntityClass"(): $Class<($StockTickerBlockEntity)>
public "getHat"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $LivingEntity$$Type): $PartialModel
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($StockTickerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($StockTickerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($StockTickerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($StockTickerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $StockTickerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($StockTickerBlockEntity)>
get "blockEntityClass"(): $Class<($StockTickerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StockTickerBlock$$Type = ($StockTickerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StockTickerBlock$$Original = $StockTickerBlock;}
declare module "com.simibubi.create.content.legacy.RefinedRadianceItem" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$NoGravMagicalDohickyItem} from "com.simibubi.create.content.legacy.NoGravMagicalDohickyItem"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"

export class $RefinedRadianceItem extends $NoGravMagicalDohickyItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "isFoil"(arg0: $ItemStack$$Type): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RefinedRadianceItem$$Type = ($RefinedRadianceItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RefinedRadianceItem$$Original = $RefinedRadianceItem;}
declare module "com.simibubi.create.content.decoration.steamWhistle.WhistleBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$WhistleBlock$WhistleSize} from "com.simibubi.create.content.decoration.steamWhistle.WhistleBlock$WhistleSize"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$WhistleBlockEntity, $WhistleBlockEntity$$Type} from "com.simibubi.create.content.decoration.steamWhistle.WhistleBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $WhistleBlock extends $Block implements $IBE$$Interface<($WhistleBlockEntity)>, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "WALL": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "SIZE": $EnumProperty<($WhistleBlock$WhistleSize)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getBlockEntityType"(): $BlockEntityType<($WhistleBlockEntity)>
public "getBlockEntityClass"(): $Class<($WhistleBlockEntity)>
public static "getAttachedDirection"(arg0: $BlockState$$Type): $Direction
public static "incrementSize"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): void
public static "queuePitchUpdate"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($WhistleBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($WhistleBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($WhistleBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($WhistleBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $WhistleBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($WhistleBlockEntity)>
get "blockEntityClass"(): $Class<($WhistleBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WhistleBlock$$Type = ($WhistleBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WhistleBlock$$Original = $WhistleBlock;}
declare module "com.simibubi.create.content.logistics.packagePort.postbox.PostboxBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$PostboxBlockEntity, $PostboxBlockEntity$$Type} from "com.simibubi.create.content.logistics.packagePort.postbox.PostboxBlockEntity"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $PostboxBlock extends $HorizontalDirectionalBlock implements $IBE$$Interface<($PostboxBlockEntity)>, $IWrenchable$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static "CODEC": $MapCodec<($PostboxBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $DyeColor$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "getBlockEntityType"(): $BlockEntityType<($PostboxBlockEntity)>
public "getBlockEntityClass"(): $Class<($PostboxBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getColor"(): $DyeColor
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($PostboxBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($PostboxBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PostboxBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PostboxBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $PostboxBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($PostboxBlockEntity)>
get "blockEntityClass"(): $Class<($PostboxBlockEntity)>
get "color"(): $DyeColor
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PostboxBlock$$Type = ($PostboxBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PostboxBlock$$Original = $PostboxBlock;}
declare module "com.simibubi.create.content.logistics.stockTicker.PackageOrder" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$BigItemStack, $BigItemStack$$Type} from "com.simibubi.create.content.logistics.BigItemStack"
import {$Record} from "java.lang.Record"

export class $PackageOrder extends $Record {
static readonly "CODEC": $Codec<($PackageOrder)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($PackageOrder)>

constructor(stacks: $List$$Type<($BigItemStack$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "empty"(): $PackageOrder
public "stacks"(): $List<($BigItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackageOrder$$Type = ({"stacks"?: $List$$Type<($BigItemStack$$Type)>}) | ([stacks?: $List$$Type<($BigItemStack$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackageOrder$$Original = $PackageOrder;}
declare module "com.simibubi.create.content.redstone.link.RedstoneLinkBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$FactoryPanelSupportBehaviour} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelSupportBehaviour"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RedstoneLinkBlockEntity extends $SmartBlockEntity {
 "panelSupport": $FactoryPanelSupportBehaviour
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "updateSelfAndAttached"(arg0: $BlockState$$Type): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "addBehavioursDeferred"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "setSignal"(arg0: integer): void
public "transmit"(arg0: integer): void
public "getReceivedSignal"(): integer
public "tick"(): void
public "remove"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "getSignal"(): integer
set "signal"(value: integer)
get "receivedSignal"(): integer
get "signal"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneLinkBlockEntity$$Type = ($RedstoneLinkBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneLinkBlockEntity$$Original = $RedstoneLinkBlockEntity;}
declare module "com.simibubi.create.content.kinetics.gauge.SpeedGaugeBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GaugeBlockEntity} from "com.simibubi.create.content.kinetics.gauge.GaugeBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $SpeedGaugeBlockEntity extends $GaugeBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "color": integer
 "prevDialState": float
 "dialState": float
 "updateSpeed": boolean
 "dialTarget": float
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "computerBehaviour": $AbstractComputerBehaviour
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public static "getDialTarget"(arg0: float): float
public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onSpeedChanged"(arg0: float): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpeedGaugeBlockEntity$$Type = ($SpeedGaugeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpeedGaugeBlockEntity$$Original = $SpeedGaugeBlockEntity;}
declare module "com.simibubi.create.content.kinetics.crank.HandCrankBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DirectionalKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalKineticBlock"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$HandCrankBlockEntity, $HandCrankBlockEntity$$Type} from "com.simibubi.create.content.kinetics.crank.HandCrankBlockEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $HandCrankBlock extends $DirectionalKineticBlock implements $IBE$$Interface<($HandCrankBlockEntity)>, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($HandCrankBlockEntity)>
public "getRotationSpeed"(): integer
public "getBlockEntityClass"(): $Class<($HandCrankBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($HandCrankBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($HandCrankBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($HandCrankBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($HandCrankBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $HandCrankBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($HandCrankBlockEntity)>
get "rotationSpeed"(): integer
get "blockEntityClass"(): $Class<($HandCrankBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandCrankBlock$$Type = ($HandCrankBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HandCrankBlock$$Original = $HandCrankBlock;}
declare module "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelPosition" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$FactoryPanelBlock$PanelSlot, $FactoryPanelBlock$PanelSlot$$Type} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBlock$PanelSlot"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Record} from "java.lang.Record"

export class $FactoryPanelPosition extends $Record {
static readonly "CODEC": $Codec<($FactoryPanelPosition)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($FactoryPanelPosition)>

constructor(pos: $BlockPos$$Type, slot: $FactoryPanelBlock$PanelSlot$$Type)

public "slot"(): $FactoryPanelBlock$PanelSlot
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryPanelPosition$$Type = ({"pos"?: $BlockPos$$Type, "slot"?: $FactoryPanelBlock$PanelSlot$$Type}) | ([pos?: $BlockPos$$Type, slot?: $FactoryPanelBlock$PanelSlot$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FactoryPanelPosition$$Original = $FactoryPanelPosition;}
declare module "com.simibubi.create.content.equipment.armor.BacktankItem$Layered" {
import {$ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BacktankItem$BacktankBlockItem$$Type} from "com.simibubi.create.content.equipment.armor.BacktankItem$BacktankBlockItem"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$LayeredArmorItem$$Interface} from "com.simibubi.create.foundation.item.LayeredArmorItem"
import {$HumanoidModel$$Type} from "net.minecraft.client.model.HumanoidModel"
import {$BacktankItem} from "com.simibubi.create.content.equipment.armor.BacktankItem"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MultiBufferSource$$Type} from "net.minecraft.client.renderer.MultiBufferSource"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$EquipmentSlot, $EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$HumanoidArmorLayer$$Type} from "net.minecraft.client.renderer.entity.layers.HumanoidArmorLayer"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$DispenseItemBehavior} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $BacktankItem$Layered extends $BacktankItem implements $LayeredArmorItem$$Interface {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BAR_COLOR": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "SLOT": $EquipmentSlot
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
static readonly "TYPE": $ArmorItem$Type
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Holder$$Type<($ArmorMaterial)>, arg1: $Item$Properties$$Type, arg2: $ResourceLocation$$Type, arg3: $Supplier$$Type<($BacktankItem$BacktankBlockItem$$Type)>)

public "getArmorTextureLocation"(arg0: $LivingEntity$$Type, arg1: $EquipmentSlot$$Type, arg2: $ItemStack$$Type, arg3: integer): StringJS
public "renderArmorPiece"(arg0: $HumanoidArmorLayer$$Type<(never), (never), (never)>, arg1: $PoseStack$$Type, arg2: $MultiBufferSource$$Type, arg3: $LivingEntity$$Type, arg4: $EquipmentSlot$$Type, arg5: integer, arg6: $HumanoidModel$$Type<(never)>, arg7: $ItemStack$$Type): void
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BacktankItem$Layered$$Type = ($BacktankItem$Layered);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BacktankItem$Layered$$Original = $BacktankItem$Layered;}
declare module "com.simibubi.create.content.logistics.packagePort.PackagePortTarget$ChainConveyorFrogportTarget$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PackagePortTarget$ChainConveyorFrogportTarget} from "com.simibubi.create.content.logistics.packagePort.PackagePortTarget$ChainConveyorFrogportTarget"
import {$PackagePortTargetType$$Interface} from "com.simibubi.create.content.logistics.packagePort.PackagePortTargetType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $PackagePortTarget$ChainConveyorFrogportTarget$Type implements $PackagePortTargetType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($ByteBuf), ($PackagePortTarget$ChainConveyorFrogportTarget)>
public "codec"(): $MapCodec<($PackagePortTarget$ChainConveyorFrogportTarget)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagePortTarget$ChainConveyorFrogportTarget$Type$$Type = ($PackagePortTarget$ChainConveyorFrogportTarget$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagePortTarget$ChainConveyorFrogportTarget$Type$$Original = $PackagePortTarget$ChainConveyorFrogportTarget$Type;}
declare module "com.simibubi.create.content.kinetics.crafter.ConnectedInputHandler$ConnectedInput" {
import {$MechanicalCrafterBlockEntity$Inventory} from "com.simibubi.create.content.kinetics.crafter.MechanicalCrafterBlockEntity$Inventory"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IItemHandler} from "net.neoforged.neoforge.items.IItemHandler"

export class $ConnectedInputHandler$ConnectedInput {
constructor()

public "attachTo"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): void
public "getItemHandler"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $IItemHandler
public "write"(arg0: $CompoundTag$$Type): void
public "read"(arg0: $CompoundTag$$Type): void
public "getInventories"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $List<($MechanicalCrafterBlockEntity$Inventory)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectedInputHandler$ConnectedInput$$Type = ($ConnectedInputHandler$ConnectedInput);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConnectedInputHandler$ConnectedInput$$Original = $ConnectedInputHandler$ConnectedInput;}
declare module "com.simibubi.create.content.logistics.funnel.AndesiteFunnelBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$FunnelBlock} from "com.simibubi.create.content.logistics.funnel.FunnelBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AndesiteFunnelBlock extends $FunnelBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "EXTRACTING": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getEquivalentBeltFunnel"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AndesiteFunnelBlock$$Type = ($AndesiteFunnelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AndesiteFunnelBlock$$Original = $AndesiteFunnelBlock;}
declare module "com.simibubi.create.content.logistics.chute.ChuteBlock$Shape" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $ChuteBlock$Shape extends $Enum<($ChuteBlock$Shape)> implements $StringRepresentable$$Interface {
static readonly "INTERSECTION": $ChuteBlock$Shape
static readonly "ENCASED": $ChuteBlock$Shape
static readonly "WINDOW": $ChuteBlock$Shape
static readonly "NORMAL": $ChuteBlock$Shape

public static "values"(): ($ChuteBlock$Shape)[]
public static "valueOf"(arg0: StringJS): $ChuteBlock$Shape
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChuteBlock$Shape$$Type = (("intersection") | ("window") | ("normal") | ("encased"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChuteBlock$Shape$$Original = $ChuteBlock$Shape;}
declare module "com.simibubi.create.content.logistics.box.PackageItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$PackageStyles$PackageStyle, $PackageStyles$PackageStyle$$Type} from "com.simibubi.create.content.logistics.box.PackageStyles$PackageStyle"
import {$List$$Type} from "java.util.List"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$UseAnim} from "net.minecraft.world.item.UseAnim"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$PackageOrderWithCrafts, $PackageOrderWithCrafts$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ItemStackHandler, $ItemStackHandler$$Type} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $PackageItem extends $Item {
static readonly "SLOTS": integer
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
 "style": $PackageStyles$PackageStyle
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type, arg1: $PackageStyles$PackageStyle$$Type)

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "canFitInsideContainerItems"(): boolean
public "hasCustomEntity"(arg0: $ItemStack$$Type): boolean
public static "isFinalLink"(arg0: $ItemStack$$Type): boolean
public static "matchAddress"(arg0: StringJS, arg1: StringJS): boolean
public static "matchAddress"(arg0: $ItemStack$$Type, arg1: StringJS): boolean
public static "getPackageVelocity"(arg0: integer): float
public static "clearAddress"(arg0: $ItemStack$$Type): void
public static "addAddress"(arg0: $ItemStack$$Type, arg1: StringJS): void
public static "setOrder"(arg0: $ItemStack$$Type, arg1: integer, arg2: integer, arg3: boolean, arg4: integer, arg5: boolean, arg6: $PackageOrderWithCrafts$$Type): void
public static "getOrderId"(arg0: $ItemStack$$Type): integer
public static "hasOrderData"(arg0: $ItemStack$$Type): boolean
public static "getLinkIndex"(arg0: $ItemStack$$Type): integer
public static "getOrderContext"(arg0: $ItemStack$$Type): $PackageOrderWithCrafts
public static "addOrderContext"(arg0: $ItemStack$$Type, arg1: $PackageOrderWithCrafts$$Type): void
public static "getHookDistance"(arg0: $ItemStack$$Type): float
public static "getWidth"(arg0: $ItemStack$$Type): float
public static "getHeight"(arg0: $ItemStack$$Type): float
public static "getContents"(arg0: $ItemStack$$Type): $ItemStackHandler
public "createEntity"(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: $ItemStack$$Type): $Entity
public static "isFinal"(arg0: $ItemStack$$Type): boolean
public "open"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "isPackage"(arg0: $ItemStack$$Type): boolean
public static "getAddress"(arg0: $ItemStack$$Type): StringJS
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "getIndex"(arg0: $ItemStack$$Type): integer
public "getDescriptionId"(): StringJS
public "getUseDuration"(arg0: $ItemStack$$Type, arg1: $LivingEntity$$Type): integer
public "getUseAnimation"(arg0: $ItemStack$$Type): $UseAnim
public "releaseUsing"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $LivingEntity$$Type, arg3: integer): void
public static "containing"(arg0: $List$$Type<($ItemStack$$Type)>): $ItemStack
public static "containing"(arg0: $ItemStackHandler$$Type): $ItemStack
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackageItem$$Type = ($PackageItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackageItem$$Original = $PackageItem;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.DirectBeltInputBehaviour$OccupiedPredicate" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"

export interface $DirectBeltInputBehaviour$OccupiedPredicate$$Interface {

(arg0: $Direction): boolean
}

export class $DirectBeltInputBehaviour$OccupiedPredicate implements $DirectBeltInputBehaviour$OccupiedPredicate$$Interface {
 "test"(arg0: $Direction$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectBeltInputBehaviour$OccupiedPredicate$$Type = ((arg0: $Direction) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectBeltInputBehaviour$OccupiedPredicate$$Original = $DirectBeltInputBehaviour$OccupiedPredicate;}
declare module "com.simibubi.create.content.logistics.filter.ListFilterItem" {
import {$FilterItemStack} from "com.simibubi.create.content.logistics.filter.FilterItemStack"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$List} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$FilterItem} from "com.simibubi.create.content.logistics.filter.FilterItem"
import {$Component} from "net.minecraft.network.chat.Component"
import {$DataComponentType} from "net.minecraft.core.component.DataComponentType"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$Item} from "net.minecraft.world.item.Item"
import {$ItemStackHandler} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $ListFilterItem extends $FilterItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "getFilterItemHandler"(arg0: $ItemStack$$Type): $ItemStackHandler
public "makeSummary"(arg0: $ItemStack$$Type): $List<($Component)>
public "makeStackWrapper"(arg0: $ItemStack$$Type): $FilterItemStack
public "getFilterItems"(arg0: $ItemStack$$Type): ($ItemStack)[]
public "getComponentType"(): $DataComponentType<(never)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "componentType"(): $DataComponentType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListFilterItem$$Type = ($ListFilterItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ListFilterItem$$Original = $ListFilterItem;}
declare module "com.simibubi.create.content.contraptions.bearing.BlankSailBlockItem" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $BlankSailBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "registerBlocks"(arg0: $Map$$Type<($Block$$Type), ($Item$$Type)>, arg1: $Item$$Type): void
public "removeFromBlockToItemMap"(arg0: $Map$$Type<($Block$$Type), ($Item$$Type)>, arg1: $Item$$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlankSailBlockItem$$Type = ($BlankSailBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlankSailBlockItem$$Original = $BlankSailBlockItem;}
declare module "com.simibubi.create.content.kinetics.waterwheel.WaterWheelBlockEntity" {
import {$GeneratingKineticBlockEntity} from "com.simibubi.create.content.kinetics.base.GeneratingKineticBlockEntity"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$List$$Type} from "java.util.List"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$Set} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WaterWheelBlockEntity extends $GeneratingKineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
static readonly "SMALL_OFFSETS": $Map<($Direction$Axis), ($Set<($BlockPos)>)>
 "flowScore": integer
 "material": $BlockState
 "updateSpeed": boolean
 "reActivateSource": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
static readonly "LARGE_OFFSETS": $Map<($Direction$Axis), ($Set<($BlockPos)>)>
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getFlowVectorAtPosition"(arg0: $BlockPos$$Type): $Vec3
public "setFlowScoreAndUpdate"(arg0: integer): void
public "getGeneratedSpeed"(): float
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "applyMaterialIfValid"(arg0: $ItemStack$$Type): $ItemInteractionResult
public "determineAndApplyFlowScore"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
set "flowScoreAndUpdate"(value: integer)
get "generatedSpeed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterWheelBlockEntity$$Type = ($WaterWheelBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WaterWheelBlockEntity$$Original = $WaterWheelBlockEntity;}
declare module "com.simibubi.create.content.contraptions.actors.AttachedActorBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $AttachedActorBlock extends $HorizontalDirectionalBlock implements $IWrenchable$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedActorBlock$$Type = ($AttachedActorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttachedActorBlock$$Original = $AttachedActorBlock;}
declare module "com.simibubi.create.content.contraptions.render.ClientContraption" {
import {$BitSet} from "java.util.BitSet"
import {$ClientContraption$RenderedBlocks} from "com.simibubi.create.content.contraptions.render.ClientContraption$RenderedBlocks"
import {$List} from "java.util.List"
import {$VirtualRenderWorld} from "com.simibubi.create.foundation.virtualWorld.VirtualRenderWorld"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$ContraptionMatrices} from "com.simibubi.create.content.contraptions.render.ContraptionMatrices"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $ClientContraption {
readonly "shouldRenderBlockEntities": $BitSet
readonly "renderedBlockEntityView": $List<($BlockEntity)>
readonly "scratchErroredBlockEntities": $BitSet

constructor(arg0: $Contraption$$Type)

public "resetRenderLevel"(): void
public "invalidateStructure"(): void
public "invalidateChildren"(): void
public "structureVersion"(): integer
public "childrenVersion"(): integer
public "readBlockEntity"(arg0: $Level$$Type, arg1: $StructureTemplate$StructureBlockInfo$$Type, arg2: boolean): $BlockEntity
public "getRenderLevel"(): $VirtualRenderWorld
public "getMatrices"(): $ContraptionMatrices
public "getAndAdjustShouldRenderBlockEntities"(): $BitSet
public "getRenderedBlocks"(): $ClientContraption$RenderedBlocks
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
get "renderLevel"(): $VirtualRenderWorld
get "matrices"(): $ContraptionMatrices
get "andAdjustShouldRenderBlockEntities"(): $BitSet
get "renderedBlocks"(): $ClientContraption$RenderedBlocks
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientContraption$$Type = ($ClientContraption);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientContraption$$Original = $ClientContraption;}
declare module "com.simibubi.create.content.trains.entity.Navigation" {
import {$ArrayList$$Type} from "java.util.ArrayList"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$UUID} from "java.util.UUID"
import {$IGenerallySearchableNavigation$PointTest$$Type} from "com.railwayteam.railways.mixin_interfaces.IGenerallySearchableNavigation$PointTest"
import {$List} from "java.util.List"
import {$Train, $Train$$Type} from "com.simibubi.create.content.trains.entity.Train"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$DiscoveredPath, $DiscoveredPath$$Type} from "com.simibubi.create.content.trains.graph.DiscoveredPath"
import {$TravellingPoint$$Type} from "com.simibubi.create.content.trains.entity.TravellingPoint"
import {$IWaypointableNavigation$$Interface} from "com.railwayteam.railways.mixin_interfaces.IWaypointableNavigation"
import {$IGenerallySearchableNavigation$$Interface} from "com.railwayteam.railways.mixin_interfaces.IGenerallySearchableNavigation"
import {$Navigation$StationTest$$Type} from "com.simibubi.create.content.trains.entity.Navigation$StationTest"
import {$TravellingPoint$ITrackSelector} from "com.simibubi.create.content.trains.entity.TravellingPoint$ITrackSelector"
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$AccessorNavigation$$Interface} from "com.railwayteam.railways.mixin.AccessorNavigation"
import {$IBufferBlockCheckableNavigation$$Interface} from "com.railwayteam.railways.mixin_interfaces.IBufferBlockCheckableNavigation"
import {$GlobalStation, $GlobalStation$$Type} from "com.simibubi.create.content.trains.station.GlobalStation"

export class $Navigation implements $AccessorNavigation$$Interface, $IGenerallySearchableNavigation$$Interface, $IBufferBlockCheckableNavigation$$Interface, $IWaypointableNavigation$$Interface {
 "distanceToDestination": double
 "destination": $GlobalStation
 "announceArrival": boolean
 "ticksWaitingForSignal": integer
 "waitingForSignal": $Pair<($UUID), (boolean)>
 "distanceStartedAt": double
 "destinationBehindTrain": boolean
 "distanceToSignal": double
 "train": $Train

constructor(arg0: $Train$$Type)

public "railways$isWaypointMode"(): boolean
public "getCurrentPath"(): $List
public "cancelNavigation"(): void
public "findNearestApproachable"(arg0: boolean): $GlobalStation
public "findPathTo"(arg0: $GlobalStation$$Type, arg1: double): $DiscoveredPath
public "findPathTo"(arg0: $ArrayList$$Type<($GlobalStation$$Type)>, arg1: double): $DiscoveredPath
public "startNavigation"(arg0: $DiscoveredPath$$Type): double
public "railways$findNearestApproachableSwitch"(arg0: boolean): $Pair
public "railways$updateControlsBlock"(arg0: boolean): void
public "controlSignalScout"(): $TravellingPoint$ITrackSelector
public "railways$searchGeneral"(arg0: double, arg1: boolean, arg2: $IGenerallySearchableNavigation$PointTest$$Type): void
public "railways$searchGeneral"(arg0: double, arg1: double, arg2: boolean, arg3: $IGenerallySearchableNavigation$PointTest$$Type): void
public "tick"(arg0: $Level$$Type): void
public "control"(arg0: $TravellingPoint$$Type): $TravellingPoint$ITrackSelector
public "write"(arg0: $DimensionPalette$$Type): $CompoundTag
public "read"(arg0: $CompoundTag$$Type, arg1: $TrackGraph$$Type, arg2: $DimensionPalette$$Type): void
public "isActive"(): boolean
public "search"(arg0: double, arg1: boolean, arg2: $ArrayList$$Type<($GlobalStation$$Type)>, arg3: $Navigation$StationTest$$Type): void
public "search"(arg0: double, arg1: double, arg2: boolean, arg3: $ArrayList$$Type<($GlobalStation$$Type)>, arg4: $Navigation$StationTest$$Type): void
get "currentPath"(): $List
get "active"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Navigation$$Type = ($Navigation);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Navigation$$Original = $Navigation;}
declare module "com.simibubi.create.content.legacy.NoGravMagicalDohickyItem" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"

export class $NoGravMagicalDohickyItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "onEntityItemUpdate"(arg0: $ItemStack$$Type, arg1: $ItemEntity$$Type): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoGravMagicalDohickyItem$$Type = ($NoGravMagicalDohickyItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoGravMagicalDohickyItem$$Original = $NoGravMagicalDohickyItem;}
declare module "com.simibubi.create.content.kinetics.crafter.MechanicalCrafterBlock" {
import {$MechanicalCrafterBlockEntity, $MechanicalCrafterBlockEntity$$Type} from "com.simibubi.create.content.kinetics.crafter.MechanicalCrafterBlockEntity"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Pointing} from "net.createmod.catnip.math.Pointing"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$HorizontalKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalKineticBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ICogWheel$$Interface} from "com.simibubi.create.content.kinetics.simpleRelays.ICogWheel"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $MechanicalCrafterBlock extends $HorizontalKineticBlock implements $IBE$$Interface<($MechanicalCrafterBlockEntity)>, $ICogWheel$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "POINTING": $EnumProperty<($Pointing)>
static readonly "HORIZONTAL_FACING": $Property<($Direction)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public static "isValidTarget"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "getBlockEntityType"(): $BlockEntityType<($MechanicalCrafterBlockEntity)>
public "getBlockEntityClass"(): $Class<($MechanicalCrafterBlockEntity)>
public static "getTargetDirection"(arg0: $BlockState$$Type): $Direction
public static "pointingFromFacing"(arg0: $Direction$$Type, arg1: $Direction$$Type): $Pointing
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($MechanicalCrafterBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($MechanicalCrafterBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MechanicalCrafterBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MechanicalCrafterBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $MechanicalCrafterBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "isSmallCog"(): boolean
public static "isSmallCog"(arg0: $Block$$Type): boolean
public static "isSmallCog"(arg0: $BlockState$$Type): boolean
public "isLargeCog"(): boolean
public static "isLargeCog"(arg0: $Block$$Type): boolean
public static "isLargeCog"(arg0: $BlockState$$Type): boolean
public "isDedicatedCogWheel"(): boolean
public static "isDedicatedCogWheel"(arg0: $Block$$Type): boolean
public static "isDedicatedCogItem"(arg0: $ItemStack$$Type): boolean
public static "isSmallCogItem"(arg0: $ItemStack$$Type): boolean
public static "isLargeCogItem"(arg0: $ItemStack$$Type): boolean
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
get "blockEntityType"(): $BlockEntityType<($MechanicalCrafterBlockEntity)>
get "blockEntityClass"(): $Class<($MechanicalCrafterBlockEntity)>
get "smallCog"(): boolean
get "largeCog"(): boolean
get "dedicatedCogWheel"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalCrafterBlock$$Type = ($MechanicalCrafterBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalCrafterBlock$$Original = $MechanicalCrafterBlock;}
declare module "com.simibubi.create.content.kinetics.simpleRelays.CogWheelBlock" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$EncasableBlock$$Interface} from "com.simibubi.create.content.decoration.encasing.EncasableBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ICogWheel$$Interface} from "com.simibubi.create.content.kinetics.simpleRelays.ICogWheel"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis, $Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$AbstractSimpleShaftBlock} from "com.simibubi.create.content.kinetics.simpleRelays.AbstractSimpleShaftBlock"

export class $CogWheelBlock extends $AbstractSimpleShaftBlock implements $ICogWheel$$Interface, $EncasableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "isSmallCog"(): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public static "large"(arg0: $BlockBehaviour$Properties$$Type): $CogWheelBlock
public "isLargeCog"(): boolean
public static "isValidCogwheelPosition"(arg0: boolean, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Direction$Axis$$Type): boolean
public "isDedicatedCogWheel"(): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public static "small"(arg0: $BlockBehaviour$Properties$$Type): $CogWheelBlock
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public static "isSmallCog"(arg0: $Block$$Type): boolean
public static "isSmallCog"(arg0: $BlockState$$Type): boolean
public static "isLargeCog"(arg0: $Block$$Type): boolean
public static "isLargeCog"(arg0: $BlockState$$Type): boolean
public static "isDedicatedCogWheel"(arg0: $Block$$Type): boolean
public static "isDedicatedCogItem"(arg0: $ItemStack$$Type): boolean
public static "isSmallCogItem"(arg0: $ItemStack$$Type): boolean
public static "isLargeCogItem"(arg0: $ItemStack$$Type): boolean
public "playEncaseSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "tryEncase"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): $ItemInteractionResult
public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
get "smallCog"(): boolean
get "largeCog"(): boolean
get "dedicatedCogWheel"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CogWheelBlock$$Type = ($CogWheelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CogWheelBlock$$Original = $CogWheelBlock;}
declare module "com.simibubi.create.content.kinetics.belt.transport.BeltMovementHandler$TransportedEntityInfo" {
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BeltMovementHandler$TransportedEntityInfo {
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getTicksSinceLastCollision"(): integer
public "tick"(): $BeltMovementHandler$TransportedEntityInfo
public "refresh"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): void
get "ticksSinceLastCollision"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltMovementHandler$TransportedEntityInfo$$Type = ($BeltMovementHandler$TransportedEntityInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltMovementHandler$TransportedEntityInfo$$Original = $BeltMovementHandler$TransportedEntityInfo;}
declare module "com.simibubi.create.content.trains.schedule.ScheduleEntry" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ScheduleWaitCondition, $ScheduleWaitCondition$$Type} from "com.simibubi.create.content.trains.schedule.condition.ScheduleWaitCondition"
import {$List, $List$$Type} from "java.util.List"
import {$ScheduleInstruction, $ScheduleInstruction$$Type} from "com.simibubi.create.content.trains.schedule.destination.ScheduleInstruction"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $ScheduleEntry {
 "instruction": $ScheduleInstruction
 "conditions": $List<($List<($ScheduleWaitCondition)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ScheduleEntry)>

constructor()
constructor(arg0: $ScheduleInstruction$$Type, arg1: $List$$Type<($List$$Type<($ScheduleWaitCondition$$Type)>)>)

public "clone"(arg0: $HolderLookup$Provider$$Type): $ScheduleEntry
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "fromTag"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): $ScheduleEntry
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduleEntry$$Type = ($ScheduleEntry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduleEntry$$Original = $ScheduleEntry;}
declare module "com.simibubi.create.content.equipment.armor.BacktankBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$LootParams$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootParams$Builder"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$HorizontalKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalKineticBlock"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BacktankBlockEntity, $BacktankBlockEntity$$Type} from "com.simibubi.create.content.equipment.armor.BacktankBlockEntity"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $BacktankBlock extends $HorizontalKineticBlock implements $IBE$$Interface<($BacktankBlockEntity)>, $SimpleWaterloggedBlock$$Interface, $SpecialBlockItemRequirement$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "HORIZONTAL_FACING": $Property<($Direction)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "getDrops"(arg0: $BlockState$$Type, arg1: $LootParams$Builder$$Type): $List<($ItemStack)>
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($BacktankBlockEntity)>
public "getBlockEntityClass"(): $Class<($BacktankBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($BacktankBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($BacktankBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BacktankBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($BacktankBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $BacktankBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($BacktankBlockEntity)>
get "blockEntityClass"(): $Class<($BacktankBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BacktankBlock$$Type = ($BacktankBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BacktankBlock$$Original = $BacktankBlock;}
declare module "com.simibubi.create.content.equipment.clipboard.ClipboardBlockEntity" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ClipboardBlockEntity extends $SmartBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "setComponents"(arg0: $DataComponentMap$$Type): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "updateWrittenState"(): void
public "onEditedBy"(arg0: $Player$$Type): void
public "initialize"(): void
set "components"(value: $DataComponentMap$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipboardBlockEntity$$Type = ($ClipboardBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipboardBlockEntity$$Original = $ClipboardBlockEntity;}
declare module "com.simibubi.create.content.kinetics.mixer.MechanicalMixerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$KineticBlock} from "com.simibubi.create.content.kinetics.base.KineticBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$IRotate$SpeedLevel} from "com.simibubi.create.content.kinetics.base.IRotate$SpeedLevel"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$MechanicalMixerBlockEntity, $MechanicalMixerBlockEntity$$Type} from "com.simibubi.create.content.kinetics.mixer.MechanicalMixerBlockEntity"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ICogWheel$$Interface} from "com.simibubi.create.content.kinetics.simpleRelays.ICogWheel"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $MechanicalMixerBlock extends $KineticBlock implements $IBE$$Interface<($MechanicalMixerBlockEntity)>, $ICogWheel$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "getMinimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($MechanicalMixerBlockEntity)>
public "getBlockEntityClass"(): $Class<($MechanicalMixerBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($MechanicalMixerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($MechanicalMixerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MechanicalMixerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MechanicalMixerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $MechanicalMixerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "isSmallCog"(): boolean
public static "isSmallCog"(arg0: $Block$$Type): boolean
public static "isSmallCog"(arg0: $BlockState$$Type): boolean
public "isLargeCog"(): boolean
public static "isLargeCog"(arg0: $Block$$Type): boolean
public static "isLargeCog"(arg0: $BlockState$$Type): boolean
public "isDedicatedCogWheel"(): boolean
public static "isDedicatedCogWheel"(arg0: $Block$$Type): boolean
public static "isDedicatedCogItem"(arg0: $ItemStack$$Type): boolean
public static "isSmallCogItem"(arg0: $ItemStack$$Type): boolean
public static "isLargeCogItem"(arg0: $ItemStack$$Type): boolean
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
get "minimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
get "blockEntityType"(): $BlockEntityType<($MechanicalMixerBlockEntity)>
get "blockEntityClass"(): $Class<($MechanicalMixerBlockEntity)>
get "smallCog"(): boolean
get "largeCog"(): boolean
get "dedicatedCogWheel"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalMixerBlock$$Type = ($MechanicalMixerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalMixerBlock$$Original = $MechanicalMixerBlock;}
declare module "com.simibubi.create.content.trains.signal.SignalBoundary" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$SignalBlockEntity$$Type} from "com.simibubi.create.content.trains.signal.SignalBlockEntity"
import {$EdgePointType$$Type} from "com.simibubi.create.content.trains.graph.EdgePointType"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SignalBlock$SignalType} from "com.simibubi.create.content.trains.signal.SignalBlock$SignalType"
import {$TrackNodeLocation} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$TrackEdgePoint} from "com.simibubi.create.content.trains.signal.TrackEdgePoint"
import {$TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$SignalBlockEntity$SignalState} from "com.simibubi.create.content.trains.signal.SignalBlockEntity$SignalState"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SignalBlockEntity$OverlayState} from "com.simibubi.create.content.trains.signal.SignalBlockEntity$OverlayState"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $SignalBoundary extends $TrackEdgePoint {
 "edgeLocation": $Couple<($TrackNodeLocation)>
 "sidesToUpdate": $Couple<(boolean)>
 "types": $Couple<($SignalBlock$SignalType)>
 "cachedStates": $Couple<($SignalBlockEntity$SignalState)>
 "groups": $Couple<($UUID)>
 "id": $UUID
 "position": double
 "blockEntities": $Couple<($Map<($BlockPos), (boolean)>)>

constructor()

public "canMerge"(): boolean
public "onRemoved"(arg0: $TrackGraph$$Type): void
public "setGroupAndUpdate"(arg0: $TrackNode$$Type, arg1: $UUID$$Type): void
public "canCoexistWith"(arg0: $EdgePointType$$Type<(never)>, arg1: boolean): boolean
public "blockEntityAdded"(arg0: $BlockEntity$$Type, arg1: boolean): void
public "updateBlockEntityPower"(arg0: $SignalBlockEntity$$Type): void
public "blockEntityRemoved"(arg0: $BlockPos$$Type, arg1: boolean): void
public "canNavigateVia"(arg0: $TrackNode$$Type): boolean
public "getOverlayFor"(arg0: $BlockPos$$Type): $SignalBlockEntity$OverlayState
public "getStateFor"(arg0: $BlockPos$$Type): $SignalBlockEntity$SignalState
public "isForcedRed"(arg0: $TrackNode$$Type): boolean
public "isForcedRed"(arg0: boolean): boolean
public "cycleSignalType"(arg0: $BlockPos$$Type): void
public "tick"(arg0: $TrackGraph$$Type, arg1: boolean): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $DimensionPalette$$Type): void
public "write"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean, arg3: $DimensionPalette$$Type): void
public "read"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): void
public "invalidate"(arg0: $LevelAccessor$$Type): void
public "queueUpdate"(arg0: $TrackNode$$Type): void
public "setGroup"(arg0: boolean, arg1: $UUID$$Type): void
public "getGroup"(arg0: $TrackNode$$Type): $UUID
public "getTypeFor"(arg0: $BlockPos$$Type): $SignalBlock$SignalType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignalBoundary$$Type = ($SignalBoundary);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignalBoundary$$Original = $SignalBoundary;}
declare module "com.simibubi.create.content.redstone.smartObserver.SmartObserverBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SmartObserverBlockEntity extends $SmartBlockEntity implements $Clearable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "turnOffTicks": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "activate"(): void
public "activate"(arg0: integer): void
public static "tryClear"(arg0: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmartObserverBlockEntity$$Type = ($SmartObserverBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmartObserverBlockEntity$$Original = $SmartObserverBlockEntity;}
declare module "com.simibubi.create.content.logistics.packagerLink.RequestPromise" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Comparator} from "java.util.Comparator"
import {$BigItemStack, $BigItemStack$$Type} from "com.simibubi.create.content.logistics.BigItemStack"

export class $RequestPromise {
static readonly "CODEC": $Codec<($RequestPromise)>
 "ticksExisted": integer
 "promisedStack": $BigItemStack

constructor(arg0: $BigItemStack$$Type)
constructor(arg0: integer, arg1: $BigItemStack$$Type)

public static "ageComparator"(): $Comparator<($RequestPromise)>
public "tick"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RequestPromise$$Type = ($RequestPromise);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RequestPromise$$Original = $RequestPromise;}
declare module "com.simibubi.create.content.redstone.displayLink.target.DisplayBoardTarget" {
import {$DisplayTargetStats} from "com.simibubi.create.content.redstone.displayLink.target.DisplayTargetStats"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List$$Type} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$DisplayTarget} from "com.simibubi.create.api.behaviour.display.DisplayTarget"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $DisplayBoardTarget extends $DisplayTarget {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry<($BlockEntityType<(never)>), ($DisplayTarget)>
static readonly "BY_BLOCK": $SimpleRegistry<($Block), ($DisplayTarget)>

constructor()

public "isReserved"(arg0: integer, arg1: $BlockEntity$$Type, arg2: $DisplayLinkContext$$Type): boolean
public "getMultiblockBounds"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): $AABB
public "provideStats"(arg0: $DisplayLinkContext$$Type): $DisplayTargetStats
public "acceptFlapText"(arg0: integer, arg1: $List$$Type<($List$$Type<($MutableComponent$$Type)>)>, arg2: $DisplayLinkContext$$Type): void
public "acceptText"(arg0: integer, arg1: $List$$Type<($MutableComponent$$Type)>, arg2: $DisplayLinkContext$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayBoardTarget$$Type = ($DisplayBoardTarget);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DisplayBoardTarget$$Original = $DisplayBoardTarget;}
declare module "com.simibubi.create.content.decoration.copycat.CopycatBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$HolderGetter} from "net.minecraft.core.HolderGetter"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$ICopycatBlockEntity$$Type, $ICopycatBlockEntity$$Interface} from "com.copycatsplus.copycats.foundation.copycat.ICopycatBlockEntity"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SpecialBlockEntityItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockEntityItemRequirement"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$ICopycatBlock} from "com.copycatsplus.copycats.foundation.copycat.ICopycatBlock"
import {$PartialSafeNBT$$Interface} from "com.simibubi.create.api.schematic.nbt.PartialSafeNBT"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CopycatBlockEntity extends $SmartBlockEntity implements $SpecialBlockEntityItemRequirement$$Interface, $TransformableBlockEntity$$Interface, $PartialSafeNBT$$Interface, $Clearable$$Interface, $ICopycatBlockEntity$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "clearContent"(): void
public "getRequiredItems"(arg0: $BlockState$$Type): $ItemRequirement
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "setConsumedItem"(arg0: $ItemStack$$Type): void
public "getConsumedItem"(): $ItemStack
public "hasCustomMaterial"(): boolean
public "setMaterial"(arg0: $BlockState$$Type): void
public "cycleMaterial"(): boolean
public "isCTEnabled"(): boolean
public "setMaterialInternal"(material: $BlockState$$Type): void
public "setConsumedItemInternal"(consumedItem: $ItemStack$$Type): void
public "setCTEnabledInternal"(value: boolean): void
public "setLevel"(arg0: $Level$$Type): void
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "onLoad"(): void
public "getMaterial"(): $BlockState
public "getModelData"(): $ModelData
public static "tryClear"(arg0: any): void
public "notifyUpdate"(): void
public "blockHolderGetter"(): $HolderGetter<($Block)>
public static "writeSafe"(self: $ICopycatBlockEntity$$Type, tag: $CompoundTag$$Type, registries: $HolderLookup$Provider$$Type): void
public "setCTEnabled"(value: boolean): void
public "getBlock"(): $ICopycatBlock
public "getLevel"(): $Level
public "init"(): void
public static "write"(self: $ICopycatBlockEntity$$Type, tag: $CompoundTag$$Type, registries: $HolderLookup$Provider$$Type, clientPacket: boolean): void
public static "write"(tag: $CompoundTag$$Type, stack: $ItemStack$$Type, material: $BlockState$$Type, registries: $HolderLookup$Provider$$Type, enableCT: boolean): void
public static "read"(self: $ICopycatBlockEntity$$Type, tag: $CompoundTag$$Type, registries: $HolderLookup$Provider$$Type, clientPacket: boolean): void
public "accept"(other: $BlockEntity$$Type): void
public "getBlockPos"(): $BlockPos
public "getBlockState"(): $BlockState
public "setBlockState"(arg0: $BlockState$$Type): void
set "consumedItem"(value: $ItemStack$$Type)
get "consumedItem"(): $ItemStack
set "material"(value: $BlockState$$Type)
get "CTEnabled"(): boolean
set "materialInternal"(value: $BlockState$$Type)
set "consumedItemInternal"(value: $ItemStack$$Type)
set "CTEnabledInternal"(value: boolean)
set "level"(value: $Level$$Type)
get "material"(): $BlockState
get "modelData"(): $ModelData
set "CTEnabled"(value: boolean)
get "block"(): $ICopycatBlock
get "level"(): $Level
get "blockPos"(): $BlockPos
get "blockState"(): $BlockState
set "blockState"(value: $BlockState$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopycatBlockEntity$$Type = ($CopycatBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CopycatBlockEntity$$Original = $CopycatBlockEntity;}
declare module "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType" {
import {$FanProcessingType$AirFlowParticleAccess$$Type} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType$AirFlowParticleAccess"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"

export interface $FanProcessingType$$Interface {
get "priority"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.CreateFanProcessingType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.CreateFanProcessingTypeTag
}

export class $FanProcessingType implements $FanProcessingType$$Interface {
 "spawnProcessingParticles"(arg0: $Level$$Type, arg1: $Vec3$$Type): void
 "morphAirFlow"(arg0: $FanProcessingType$AirFlowParticleAccess$$Type, arg1: $RandomSource$$Type): void
 "affectEntity"(arg0: $Entity$$Type, arg1: $Level$$Type): void
 "isValidAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
 "canProcess"(arg0: $ItemStack$$Type, arg1: $Level$$Type): boolean
 "process"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemStack)>
 "getPriority"(): integer
static "parse"(arg0: StringJS): $FanProcessingType
static "getAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $FanProcessingType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FanProcessingType$$Type = (Special.CreateFanProcessingType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FanProcessingType$$Original = $FanProcessingType;}
declare module "com.simibubi.create.content.equipment.toolbox.ToolboxBlockEntity" {
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$Map} from "java.util.Map"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$AccessorToolboxBlockEntity$$Interface} from "com.railwayteam.railways.mixin.AccessorToolboxBlockEntity"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$ToolboxInventory, $ToolboxInventory$$Type} from "com.simibubi.create.content.equipment.toolbox.ToolboxInventory"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Nameable$$Interface} from "net.minecraft.world.Nameable"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$DyeColor} from "net.minecraft.world.item.DyeColor"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ToolboxBlockEntity extends $SmartBlockEntity implements $MenuProvider$$Interface, $Nameable$$Interface, $AccessorToolboxBlockEntity$$Interface {
 "drawers": $LerpedFloat
 "lid": $LerpedFloat
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "unequip"(arg0: integer, arg1: $Player$$Type, arg2: integer, arg3: boolean): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "getConnectedPlayers"(): $Map
public "getUniqueId"(): $UUID
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "readInventory"(arg0: $ToolboxInventory$$Type): void
public "setUniqueId"(arg0: $UUID$$Type): void
public "unequipTracked"(): void
public "connectPlayer"(arg0: integer, arg1: $Player$$Type, arg2: integer): void
public "isFullyInitialized"(): boolean
public "tick"(): void
public "getDisplayName"(): $Component
public "getName"(): $Component
public "initialize"(): void
public "invalidate"(): void
public "getColor"(): $DyeColor
public "getInventory"(): $ToolboxInventory
public "hasCustomName"(): boolean
public "getCustomName"(): $Component
public "setCustomName"(arg0: $Component$$Type): void
public "setBlockState"(arg0: $BlockState$$Type): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
get "connectedPlayers"(): $Map
get "uniqueId"(): $UUID
set "uniqueId"(value: $UUID$$Type)
get "fullyInitialized"(): boolean
get "displayName"(): $Component
get "name"(): $Component
get "color"(): $DyeColor
get "inventory"(): $ToolboxInventory
get "customName"(): $Component
set "customName"(value: $Component$$Type)
set "blockState"(value: $BlockState$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolboxBlockEntity$$Type = ($ToolboxBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ToolboxBlockEntity$$Original = $ToolboxBlockEntity;}
declare module "com.simibubi.create.content.contraptions.pulley.PulleyBlock$RopeBlockBase" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PulleyBlock$RopeBlockBase extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PulleyBlock$RopeBlockBase$$Type = ($PulleyBlock$RopeBlockBase);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PulleyBlock$RopeBlockBase$$Original = $PulleyBlock$RopeBlockBase;}
declare module "com.simibubi.create.content.kinetics.saw.SawBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$SawBlockEntity, $SawBlockEntity$$Type} from "com.simibubi.create.content.kinetics.saw.SawBlockEntity"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$DirectionalAxisKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalAxisKineticBlock"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $SawBlock extends $DirectionalAxisKineticBlock implements $IBE$$Interface<($SawBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "FLIPPED": $BooleanProperty
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "AXIS_ALONG_FIRST_COORDINATE": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "isHorizontal"(arg0: $BlockState$$Type): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($SawBlockEntity)>
public "getBlockEntityClass"(): $Class<($SawBlockEntity)>
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "entityInside"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): void
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SawBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SawBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SawBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SawBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SawBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SawBlockEntity)>
get "blockEntityClass"(): $Class<($SawBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SawBlock$$Type = ($SawBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SawBlock$$Original = $SawBlock;}
declare module "com.simibubi.create.content.contraptions.behaviour.dispenser.storage.DispenserMountedStorageType" {
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$SimpleMountedStorageType} from "com.simibubi.create.api.contraption.storage.item.simple.SimpleMountedStorageType"
import {$MountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorage"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DispenserMountedStorage} from "com.simibubi.create.content.contraptions.behaviour.dispenser.storage.DispenserMountedStorage"
import {$MountedItemStorageType} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageType"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DispenserMountedStorageType extends $SimpleMountedStorageType<($DispenserMountedStorage)> {
readonly "codec": $MapCodec<(T)>
static readonly "CODEC": $Codec<($MountedItemStorageType<(never)>)>
readonly "holder": $Holder$Reference<($MountedItemStorageType<(never)>)>
static readonly "REGISTRY": $SimpleRegistry<($Block), ($MountedItemStorageType<(never)>)>

constructor()

public "mount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): $MountedItemStorage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DispenserMountedStorageType$$Type = ($DispenserMountedStorageType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DispenserMountedStorageType$$Original = $DispenserMountedStorageType;}
declare module "com.simibubi.create.content.redstone.displayLink.target.LecternDisplayTarget" {
import {$DisplayTargetStats} from "com.simibubi.create.content.redstone.displayLink.target.DisplayTargetStats"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List$$Type} from "java.util.List"
import {$MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$Component} from "net.minecraft.network.chat.Component"
import {$DisplayTarget} from "com.simibubi.create.api.behaviour.display.DisplayTarget"

export class $LecternDisplayTarget extends $DisplayTarget {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry<($BlockEntityType<(never)>), ($DisplayTarget)>
static readonly "BY_BLOCK": $SimpleRegistry<($Block), ($DisplayTarget)>

constructor()

public "getLineOptionText"(arg0: integer): $Component
public "provideStats"(arg0: $DisplayLinkContext$$Type): $DisplayTargetStats
public "requiresComponentSanitization"(): boolean
public "acceptText"(arg0: integer, arg1: $List$$Type<($MutableComponent$$Type)>, arg2: $DisplayLinkContext$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LecternDisplayTarget$$Type = ($LecternDisplayTarget);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LecternDisplayTarget$$Original = $LecternDisplayTarget;}
declare module "com.simibubi.create.content.kinetics.gearbox.VerticalGearboxItem" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $VerticalGearboxItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "registerBlocks"(arg0: $Map$$Type<($Block$$Type), ($Item$$Type)>, arg1: $Item$$Type): void
public "getDescriptionId"(): StringJS
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VerticalGearboxItem$$Type = ($VerticalGearboxItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VerticalGearboxItem$$Original = $VerticalGearboxItem;}
declare module "com.simibubi.create.content.kinetics.transmission.ClutchBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$GearshiftBlock} from "com.simibubi.create.content.kinetics.transmission.GearshiftBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SplitShaftBlockEntity} from "com.simibubi.create.content.kinetics.transmission.SplitShaftBlockEntity"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ClutchBlock extends $GearshiftBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($SplitShaftBlockEntity)>
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SplitShaftBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClutchBlock$$Type = ($ClutchBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClutchBlock$$Original = $ClutchBlock;}
declare module "com.simibubi.create.content.fluids.pipes.FluidPipeBlock" {
import {$PipeBlock} from "net.minecraft.world.level.block.PipeBlock"
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$EncasableBlock$$Interface} from "com.simibubi.create.content.decoration.encasing.EncasableBlock"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IWrenchableWithBracket$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchableWithBracket"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Map} from "java.util.Map"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$FluidPipeBlockEntity, $FluidPipeBlockEntity$$Type} from "com.simibubi.create.content.fluids.pipes.FluidPipeBlockEntity"
import {$TransformableBlock$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlock"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $FluidPipeBlock extends $PipeBlock implements $SimpleWaterloggedBlock$$Interface, $IWrenchableWithBracket$$Interface, $IBE$$Interface<($FluidPipeBlockEntity)>, $EncasableBlock$$Interface, $TransformableBlock$$Interface {
static readonly "DOWN": $BooleanProperty
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "SOUTH": $BooleanProperty
static readonly "UP": $BooleanProperty
static readonly "EAST": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FluidPipeBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($BooleanProperty)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "supportsExternalFaceHiding"(arg0: $BlockState$$Type): boolean
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "updateBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $Direction$$Type, arg3: $BlockAndTintGetter$$Type, arg4: $BlockPos$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($FluidPipeBlockEntity)>
public static "canConnectTo"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getBlockEntityClass"(): $Class<($FluidPipeBlockEntity)>
public "getAxisState"(arg0: $Direction$Axis$$Type): $BlockState
public static "isPipe"(arg0: $BlockState$$Type): boolean
public static "shouldDrawRim"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public static "isCornerOrEndPipe"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public static "shouldDrawCasing"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "removeBracket"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: boolean): $Optional<($ItemStack)>
public static "isOpenAt"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "transform"(arg0: $BlockState$$Type, arg1: $StructureTransform$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "tryRemoveBracket"(arg0: $UseOnContext$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($FluidPipeBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($FluidPipeBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FluidPipeBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FluidPipeBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $FluidPipeBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "playEncaseSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "tryEncase"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): $ItemInteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($FluidPipeBlockEntity)>
get "blockEntityClass"(): $Class<($FluidPipeBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidPipeBlock$$Type = ($FluidPipeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidPipeBlock$$Original = $FluidPipeBlock;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.ArmItem" {
import {$Map} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ArmItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "canAttackBlock"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): boolean
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmItem$$Type = ($ArmItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmItem$$Original = $ArmItem;}
declare module "com.simibubi.create.content.redstone.thresholdSwitch.ThresholdSwitchBlockEntity$ThresholdType" {
import {$Enum} from "java.lang.Enum"

export class $ThresholdSwitchBlockEntity$ThresholdType extends $Enum<($ThresholdSwitchBlockEntity$ThresholdType)> {
static readonly "ITEM": $ThresholdSwitchBlockEntity$ThresholdType
static readonly "FLUID": $ThresholdSwitchBlockEntity$ThresholdType
static readonly "CUSTOM": $ThresholdSwitchBlockEntity$ThresholdType
static readonly "UNSUPPORTED": $ThresholdSwitchBlockEntity$ThresholdType

public static "values"(): ($ThresholdSwitchBlockEntity$ThresholdType)[]
public static "valueOf"(arg0: StringJS): $ThresholdSwitchBlockEntity$ThresholdType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThresholdSwitchBlockEntity$ThresholdType$$Type = (("unsupported") | ("item") | ("fluid") | ("custom"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThresholdSwitchBlockEntity$ThresholdType$$Original = $ThresholdSwitchBlockEntity$ThresholdType;}
declare module "com.simibubi.create.content.trains.schedule.ScheduleRuntime$State" {
import {$Enum} from "java.lang.Enum"

export class $ScheduleRuntime$State extends $Enum<($ScheduleRuntime$State)> {
static readonly "IN_TRANSIT": $ScheduleRuntime$State
static readonly "PRE_TRANSIT": $ScheduleRuntime$State
static readonly "POST_TRANSIT": $ScheduleRuntime$State

public static "values"(): ($ScheduleRuntime$State)[]
public static "valueOf"(arg0: StringJS): $ScheduleRuntime$State
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduleRuntime$State$$Type = (("pre_transit") | ("in_transit") | ("post_transit"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduleRuntime$State$$Original = $ScheduleRuntime$State;}
declare module "com.simibubi.create.content.redstone.displayLink.source.TimeOfDayDisplaySource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $TimeOfDayDisplaySource extends $SingleLineDisplaySource {
static readonly "EMPTY_TIME": $MutableComponent
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimeOfDayDisplaySource$$Type = ($TimeOfDayDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TimeOfDayDisplaySource$$Original = $TimeOfDayDisplaySource;}
declare module "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$KineticBlock} from "com.simibubi.create.content.kinetics.base.KineticBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IHaveBigOutline$$Interface} from "com.simibubi.create.foundation.block.IHaveBigOutline"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$ChainConveyorBlockEntity, $ChainConveyorBlockEntity$$Type} from "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorBlockEntity"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $ChainConveyorBlock extends $KineticBlock implements $IBE$$Interface<($ChainConveyorBlockEntity)>, $IHaveBigOutline$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "playerDestroy"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockEntity$$Type, arg5: $ItemStack$$Type): void
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($ChainConveyorBlockEntity)>
public "getBlockEntityClass"(): $Class<($ChainConveyorBlockEntity)>
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getInteractionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ChainConveyorBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ChainConveyorBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ChainConveyorBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ChainConveyorBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ChainConveyorBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ChainConveyorBlockEntity)>
get "blockEntityClass"(): $Class<($ChainConveyorBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainConveyorBlock$$Type = ($ChainConveyorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainConveyorBlock$$Original = $ChainConveyorBlock;}
declare module "com.simibubi.create.content.decoration.bracket.BracketBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BracketBlock$BracketType} from "com.simibubi.create.content.decoration.bracket.BracketBlock$BracketType"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BracketBlock extends $WrenchableDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "AXIS_ALONG_FIRST_COORDINATE": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "TYPE": $EnumProperty<($BracketBlock$BracketType)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getSuitableBracket"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $Optional<($BlockState)>
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BracketBlock$$Type = ($BracketBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BracketBlock$$Original = $BracketBlock;}
declare module "com.simibubi.create.content.fluids.potion.PotionFluid$PotionFluidType" {
import {$FluidType$Properties$$Type} from "net.neoforged.neoforge.fluids.FluidType$Properties"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$AllFluids$TintedFluidType} from "com.simibubi.create.AllFluids$TintedFluidType"
import {$Lazy} from "net.neoforged.neoforge.common.util.Lazy"

export class $PotionFluid$PotionFluidType extends $AllFluids$TintedFluidType {
static readonly "SIZE": $Lazy<(integer)>
static readonly "BUCKET_VOLUME": integer

constructor(arg0: $FluidType$Properties$$Type, arg1: $ResourceLocation$$Type, arg2: $ResourceLocation$$Type)

public "getTintColor"(arg0: $FluidStack$$Type): integer
public "getDescriptionId"(arg0: $FluidStack$$Type): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionFluid$PotionFluidType$$Type = ($PotionFluid$PotionFluidType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotionFluid$PotionFluidType$$Original = $PotionFluid$PotionFluidType;}
declare module "com.simibubi.create.content.contraptions.piston.LinearActuatorBlockEntity" {
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$AbstractContraptionEntity, $AbstractContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$ControlledContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.ControlledContraptionEntity"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$IDisplayAssemblyExceptions$$Interface} from "com.simibubi.create.content.contraptions.IDisplayAssemblyExceptions"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IControlContraption$$Interface} from "com.simibubi.create.content.contraptions.IControlContraption"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AssemblyException} from "com.simibubi.create.content.contraptions.AssemblyException"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LinearActuatorBlockEntity extends $KineticBlockEntity implements $IControlContraption$$Interface, $IDisplayAssemblyExceptions$$Interface {
 "running": boolean
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "offset": float
 "assembleNextTick": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "needsContraption": boolean
 "preventSpeedUpdate": integer
 "movedContraption": $AbstractContraptionEntity
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isAttachedTo"(arg0: $AbstractContraptionEntity$$Type): boolean
public "onStall"(): void
public "getLastAssemblyException"(): $AssemblyException
public "getMovementSpeed"(): float
public "getInterpolatedOffset"(arg0: float): float
public "getMotionVector"(): $Vec3
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "onSpeedChanged"(arg0: float): void
public "onLengthBroken"(): void
public "tick"(): void
public "remove"(): void
public "attach"(arg0: $ControlledContraptionEntity$$Type): void
public "isValid"(): boolean
public "getBlockPosition"(): $BlockPos
public "disassemble"(): void
public "addExceptionToTooltip"(arg0: $List$$Type<($Component$$Type)>): boolean
get "lastAssemblyException"(): $AssemblyException
get "movementSpeed"(): float
get "motionVector"(): $Vec3
get "valid"(): boolean
get "blockPosition"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LinearActuatorBlockEntity$$Type = ($LinearActuatorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LinearActuatorBlockEntity$$Original = $LinearActuatorBlockEntity;}
declare module "com.simibubi.create.content.kinetics.press.MechanicalPressBlockEntity" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$List$$Type} from "java.util.List"
import {$ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$BasinOperatingBlockEntity} from "com.simibubi.create.content.processing.basin.BasinOperatingBlockEntity"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$DeferralBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.simple.DeferralBehaviour"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$RecipeHolder} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$PressingRecipe} from "com.simibubi.create.content.kinetics.press.PressingRecipe"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$PressingBehaviour} from "com.simibubi.create.content.kinetics.press.PressingBehaviour"
import {$TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"
import {$PressingBehaviour$PressingBehaviourSpecifics$$Interface} from "com.simibubi.create.content.kinetics.press.PressingBehaviour$PressingBehaviourSpecifics"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MechanicalPressBlockEntity extends $BasinOperatingBlockEntity implements $PressingBehaviour$PressingBehaviourSpecifics$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "basinRemoved": boolean
 "networkDirty": boolean
 "pressingBehaviour": $PressingBehaviour
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "basinChecker": $DeferralBehaviour
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "canProcessInBulk"(): boolean
public "onItemPressed"(arg0: $ItemStack$$Type): void
public "startProcessingBasin"(): void
public "getPressingBehaviour"(): $PressingBehaviour
public "tryProcessInBasin"(arg0: boolean): boolean
public "tryProcessInWorld"(arg0: $ItemEntity$$Type, arg1: boolean): boolean
public "tryProcessOnBelt"(arg0: $TransportedItemStack$$Type, arg1: $List$$Type<($ItemStack$$Type)>, arg2: boolean): boolean
public "onPressingCompleted"(): void
public "getKineticSpeed"(): float
public static "canCompress"(arg0: $Recipe$$Type<(never)>): boolean
public "getParticleAmount"(): integer
public "getRecipe"(arg0: $ItemStack$$Type): $Optional<($RecipeHolder<($PressingRecipe)>)>
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
get "kineticSpeed"(): float
get "particleAmount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPressBlockEntity$$Type = ($MechanicalPressBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalPressBlockEntity$$Original = $MechanicalPressBlockEntity;}
declare module "com.simibubi.create.content.logistics.packager.PackagerItemHandler" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container} from "net.minecraft.world.Container"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$List} from "java.util.List"
import {$IItemHandlerModifiable$$Interface} from "net.neoforged.neoforge.items.IItemHandlerModifiable"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$IItemHandler} from "net.neoforged.neoforge.items.IItemHandler"
import {$PackagerBlockEntity$$Type} from "com.simibubi.create.content.logistics.packager.PackagerBlockEntity"

export class $PackagerItemHandler implements $IItemHandlerModifiable$$Interface {
constructor(arg0: $PackagerBlockEntity$$Type)

public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "kjs$self"(): $IItemHandler
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getStackInSlot"(arg0: integer): $ItemStack
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "extractItem"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public "getSlotLimit"(arg0: integer): integer
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getBlock"(level: $Level$$Type): $LevelBlock
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "clear"(): void
public "clear"(match: $ItemPredicate$$Type): void
public "find"(match: $ItemPredicate$$Type): integer
public "find"(): integer
public "count"(match: $ItemPredicate$$Type): integer
public "count"(): integer
public "countNonEmpty"(): integer
public "countNonEmpty"(match: $ItemPredicate$$Type): integer
public "getWidth"(): integer
public "getHeight"(): integer
public "setChanged"(): void
public "getAllItems"(): $List<($ItemStack)>
public "asContainer"(): $Container
get "slots"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "empty"(): boolean
get "width"(): integer
get "height"(): integer
get "changed"(): void
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagerItemHandler$$Type = ($PackagerItemHandler);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagerItemHandler$$Original = $PackagerItemHandler;}
declare module "com.simibubi.create.content.logistics.tableCloth.TableClothBlockItem" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $TableClothBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "isFoil"(arg0: $ItemStack$$Type): boolean
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TableClothBlockItem$$Type = ($TableClothBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TableClothBlockItem$$Original = $TableClothBlockItem;}
declare module "com.simibubi.create.content.logistics.redstoneRequester.AutoRequestData" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$PackageOrderWithCrafts, $PackageOrderWithCrafts$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"

export class $AutoRequestData extends $Record {
static readonly "CODEC": $Codec<($AutoRequestData)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($AutoRequestData)>

constructor()
constructor(encodedRequest: $PackageOrderWithCrafts$$Type, encodedTargetAddress: StringJS, targetOffset: $BlockPos$$Type, targetDim: StringJS, isValid: boolean)

public static "readFromItem"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type): $AutoRequestData
public "encodedRequest"(): $PackageOrderWithCrafts
public "encodedTargetAddress"(): StringJS
public "targetOffset"(): $BlockPos
public "targetDim"(): StringJS
public "writeToItem"(arg0: $BlockPos$$Type, arg1: $ItemStack$$Type): void
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isValid"(): boolean
get "valid"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AutoRequestData$$Type = ({"targetOffset"?: $BlockPos$$Type, "encodedTargetAddress"?: StringJS, "encodedRequest"?: $PackageOrderWithCrafts$$Type, "targetDim"?: StringJS, "isValid"?: boolean}) | ([targetOffset?: $BlockPos$$Type, encodedTargetAddress?: StringJS, encodedRequest?: $PackageOrderWithCrafts$$Type, targetDim?: StringJS, isValid?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AutoRequestData$$Original = $AutoRequestData;}
declare module "com.simibubi.create.content.equipment.TreeFertilizerItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"

export class $TreeFertilizerItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeFertilizerItem$$Type = ($TreeFertilizerItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeFertilizerItem$$Original = $TreeFertilizerItem;}
declare module "com.simibubi.create.content.trains.graph.TrackEdgeIntersection" {
import {$TrackNodeLocation, $TrackNodeLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$UUID} from "java.util.UUID"
import {$Couple} from "net.createmod.catnip.data.Couple"

export class $TrackEdgeIntersection {
 "groupId": $UUID
 "location": double
 "id": $UUID
 "targetLocation": double
 "target": $Couple<($TrackNodeLocation)>

constructor()

public "isNear"(arg0: double): boolean
public "write"(arg0: $DimensionPalette$$Type): $CompoundTag
public static "read"(arg0: $CompoundTag$$Type, arg1: $DimensionPalette$$Type): $TrackEdgeIntersection
public "targets"(arg0: $TrackNodeLocation$$Type, arg1: $TrackNodeLocation$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackEdgeIntersection$$Type = ($TrackEdgeIntersection);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackEdgeIntersection$$Original = $TrackEdgeIntersection;}
declare module "com.simibubi.create.content.decoration.bracket.BracketBlockItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $BracketBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BracketBlockItem$$Type = ($BracketBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BracketBlockItem$$Original = $BracketBlockItem;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$DeployerType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$DeployerType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$DeployerType$$Type = ($AllArmInteractionPointTypes$DeployerType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$DeployerType$$Original = $AllArmInteractionPointTypes$DeployerType;}
declare module "com.simibubi.create.content.logistics.depot.storage.DepotMountedStorage$Handler" {
import {$ItemStackHandler} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $DepotMountedStorage$Handler extends $ItemStackHandler {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DepotMountedStorage$Handler$$Type = ($DepotMountedStorage$Handler);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DepotMountedStorage$Handler$$Original = $DepotMountedStorage$Handler;}
declare module "com.simibubi.create.content.kinetics.press.PressingBehaviour$PressingBehaviourSpecifics" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"

export interface $PressingBehaviour$PressingBehaviourSpecifics$$Interface {
get "kineticSpeed"(): float
get "particleAmount"(): integer
}

export class $PressingBehaviour$PressingBehaviourSpecifics implements $PressingBehaviour$PressingBehaviourSpecifics$$Interface {
 "canProcessInBulk"(): boolean
 "tryProcessInBasin"(arg0: boolean): boolean
 "tryProcessInWorld"(arg0: $ItemEntity$$Type, arg1: boolean): boolean
 "tryProcessOnBelt"(arg0: $TransportedItemStack$$Type, arg1: $List$$Type<($ItemStack$$Type)>, arg2: boolean): boolean
 "onPressingCompleted"(): void
 "getKineticSpeed"(): float
 "getParticleAmount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressingBehaviour$PressingBehaviourSpecifics$$Type = ($PressingBehaviour$PressingBehaviourSpecifics);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PressingBehaviour$PressingBehaviourSpecifics$$Original = $PressingBehaviour$PressingBehaviourSpecifics;}
declare module "com.simibubi.create.content.equipment.zapper.terrainzapper.Brush" {
import {$PlacementOptions$$Type} from "com.simibubi.create.content.equipment.zapper.terrainzapper.PlacementOptions"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$TerrainTools, $TerrainTools$$Type} from "com.simibubi.create.content.equipment.zapper.terrainzapper.TerrainTools"

export class $Brush {
constructor(arg0: integer)

public "getSupportedTools"(): ($TerrainTools)[]
public "redirectTool"(arg0: $TerrainTools$$Type): $TerrainTools
public "hasPlacementOptions"(): boolean
public "hasConnectivityOptions"(): boolean
public "addToGlobalPositions"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $Collection$$Type<($BlockPos$$Type)>, arg4: $TerrainTools$$Type): $Collection<($BlockPos)>
public "get"(arg0: integer): integer
public "set"(arg0: integer, arg1: integer, arg2: integer): void
public "getOffset"(arg0: $Vec3$$Type, arg1: $Direction$$Type, arg2: $PlacementOptions$$Type): $BlockPos
get "supportedTools"(): ($TerrainTools)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Brush$$Type = ($Brush);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Brush$$Original = $Brush;}
declare module "com.simibubi.create.content.trains.entity.CarriageBogey" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CarriageContraptionEntity$$Type} from "com.simibubi.create.content.trains.entity.CarriageContraptionEntity"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Carriage} from "com.simibubi.create.content.trains.entity.Carriage"
import {$Level} from "net.minecraft.world.level.Level"
import {$TravellingPoint, $TravellingPoint$$Type} from "com.simibubi.create.content.trains.entity.TravellingPoint"
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BogeyStyle} from "com.simibubi.create.content.trains.bogey.BogeyStyle"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$AbstractBogeyBlock, $AbstractBogeyBlock$$Type} from "com.simibubi.create.content.trains.bogey.AbstractBogeyBlock"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$AccessorCarriageBogey$$Interface} from "com.railwayteam.railways.mixin.AccessorCarriageBogey"
import {$BogeySizes$BogeySize} from "com.simibubi.create.content.trains.bogey.BogeySizes$BogeySize"

export class $CarriageBogey implements $AccessorCarriageBogey$$Interface {
 "bogeyData": $CompoundTag
 "carriage": $Carriage
static readonly "UPSIDE_DOWN_KEY": StringJS
 "couplingAnchors": $Couple<($Vec3)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($CarriageBogey)>

constructor(arg0: $AbstractBogeyBlock$$Type<(never)>, arg1: boolean, arg2: $CompoundTag$$Type)
constructor(arg0: $AbstractBogeyBlock$$Type<(never)>, arg1: boolean, arg2: $CompoundTag$$Type, arg3: $TravellingPoint$$Type, arg4: $TravellingPoint$$Type)

public "updateCouplingAnchor"(arg0: $Vec3$$Type, arg1: float, arg2: float, arg3: integer, arg4: float, arg5: boolean): void
public "getAnchorPosition"(arg0: boolean): $Vec3
public "getAnchorPosition"(): $Vec3
public "getStress"(): double
public "isUpsideDown"(): boolean
public "updateAngles"(arg0: $CarriageContraptionEntity$$Type, arg1: double): void
public "getDimension"(): $ResourceKey<($Level)>
public "trailing"(): $TravellingPoint
public "write"(arg0: $DimensionPalette$$Type): $CompoundTag
public static "read"(arg0: $CompoundTag$$Type, arg1: $TrackGraph$$Type, arg2: $DimensionPalette$$Type): $CarriageBogey
public "getType"(): $AbstractBogeyBlock
public "getSize"(): $BogeySizes$BogeySize
public "leading"(): $TravellingPoint
public "getStyle"(): $BogeyStyle
get "anchorPosition"(): $Vec3
get "stress"(): double
get "upsideDown"(): boolean
get "dimension"(): $ResourceKey<($Level)>
get "type"(): $AbstractBogeyBlock
get "size"(): $BogeySizes$BogeySize
get "style"(): $BogeyStyle
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarriageBogey$$Type = ($CarriageBogey);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarriageBogey$$Original = $CarriageBogey;}
declare module "com.simibubi.create.content.contraptions.elevator.ElevatorColumn$ColumnCoords" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"

export class $ElevatorColumn$ColumnCoords extends $Record {
constructor(x: integer, z: integer, side: $Direction$$Type)

public "relative"(arg0: $BlockPos$$Type): $ElevatorColumn$ColumnCoords
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "x"(): integer
public "write"(): $CompoundTag
public static "read"(arg0: $CompoundTag$$Type): $ElevatorColumn$ColumnCoords
public "z"(): integer
public "side"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElevatorColumn$ColumnCoords$$Type = ({"x"?: integer, "side"?: $Direction$$Type, "z"?: integer}) | ([x?: integer, side?: $Direction$$Type, z?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ElevatorColumn$ColumnCoords$$Original = $ElevatorColumn$ColumnCoords;}
declare module "com.simibubi.create.content.logistics.packager.PackagingRequest" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$MutableInt, $MutableInt$$Type} from "org.apache.commons.lang3.mutable.MutableInt"
import {$PackageOrderWithCrafts, $PackageOrderWithCrafts$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts"
import {$MutableBoolean, $MutableBoolean$$Type} from "org.apache.commons.lang3.mutable.MutableBoolean"
import {$Record} from "java.lang.Record"

export class $PackagingRequest extends $Record {
constructor(item: $ItemStack$$Type, count: $MutableInt$$Type, address: StringJS, linkIndex: integer, finalLink: $MutableBoolean$$Type, packageCounter: $MutableInt$$Type, orderId: integer, context: $PackageOrderWithCrafts$$Type)

public "finalLink"(): $MutableBoolean
public "packageCounter"(): $MutableInt
public "orderId"(): integer
public "linkIndex"(): integer
public "item"(): $ItemStack
public "context"(): $PackageOrderWithCrafts
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public "count"(): $MutableInt
public "getCount"(): integer
public static "create"(arg0: $ItemStack$$Type, arg1: integer, arg2: StringJS, arg3: integer, arg4: $MutableBoolean$$Type, arg5: integer, arg6: integer, arg7: $PackageOrderWithCrafts$$Type): $PackagingRequest
public "address"(): StringJS
public "subtract"(arg0: integer): void
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagingRequest$$Type = ({"count"?: $MutableInt$$Type, "context"?: $PackageOrderWithCrafts$$Type, "finalLink"?: $MutableBoolean$$Type, "item"?: $ItemStack$$Type, "address"?: StringJS, "packageCounter"?: $MutableInt$$Type, "linkIndex"?: integer, "orderId"?: integer}) | ([count?: $MutableInt$$Type, context?: $PackageOrderWithCrafts$$Type, finalLink?: $MutableBoolean$$Type, item?: $ItemStack$$Type, address?: StringJS, packageCounter?: $MutableInt$$Type, linkIndex?: integer, orderId?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagingRequest$$Original = $PackagingRequest;}
declare module "com.simibubi.create.content.schematics.SchematicPrinter$BlockTargetHandler" {
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $SchematicPrinter$BlockTargetHandler$$Interface {

(arg0: $BlockPos, arg1: $BlockState, arg2: $BlockEntity): void
}

export class $SchematicPrinter$BlockTargetHandler implements $SchematicPrinter$BlockTargetHandler$$Interface {
 "handle"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockEntity$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicPrinter$BlockTargetHandler$$Type = ((arg0: $BlockPos, arg1: $BlockState, arg2: $BlockEntity) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicPrinter$BlockTargetHandler$$Original = $SchematicPrinter$BlockTargetHandler;}
declare module "com.simibubi.create.content.redstone.displayLink.ClickToLinkBlockItem" {
import {$PlayerInteractEvent$RightClickBlock$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$RightClickBlock"
import {$Map} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $ClickToLinkBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "isValidTarget"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): boolean
public "getMaxDistanceFromSelection"(): integer
public "getMessageTranslationKey"(): StringJS
public "placeWhenInvalid"(): boolean
public "getSelectionBounds"(arg0: $BlockPos$$Type): $AABB
public static "linkableItemAlwaysPlacesWhenUsed"(arg0: $PlayerInteractEvent$RightClickBlock$$Type): void
public static "clientTick"(): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "maxDistanceFromSelection"(): integer
get "messageTranslationKey"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClickToLinkBlockItem$$Type = ($ClickToLinkBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClickToLinkBlockItem$$Original = $ClickToLinkBlockItem;}
declare module "com.simibubi.create.content.redstone.analogLever.AnalogLeverBlockEntity" {
import {$AnalogLeverBlockEntityAccessor$$Interface} from "com.hlysine.create_connected.mixin.linkedtransmitter.AnalogLeverBlockEntityAccessor"
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveGoggleInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveGoggleInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AnalogLeverBlockEntity extends $SmartBlockEntity implements $IHaveGoggleInformation$$Interface, $AnalogLeverBlockEntityAccessor$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "changeState"(arg0: boolean): void
public "getLastChange"(): integer
public "getClientState"(): $LerpedFloat
public "tick"(): void
public "initialize"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "getState"(): integer
public "containedFluidTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean, arg2: $IFluidHandler$$Type): boolean
public "getIcon"(arg0: boolean): $ItemStack
get "lastChange"(): integer
get "clientState"(): $LerpedFloat
get "state"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnalogLeverBlockEntity$$Type = ($AnalogLeverBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AnalogLeverBlockEntity$$Original = $AnalogLeverBlockEntity;}
declare module "com.simibubi.create.content.redstone.nixieTube.DoubleFaceAttachedBlock$DoubleAttachFace" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $DoubleFaceAttachedBlock$DoubleAttachFace extends $Enum<($DoubleFaceAttachedBlock$DoubleAttachFace)> implements $StringRepresentable$$Interface {
static readonly "FLOOR": $DoubleFaceAttachedBlock$DoubleAttachFace
static readonly "WALL": $DoubleFaceAttachedBlock$DoubleAttachFace
static readonly "CEILING": $DoubleFaceAttachedBlock$DoubleAttachFace
static readonly "WALL_REVERSED": $DoubleFaceAttachedBlock$DoubleAttachFace

public static "values"(): ($DoubleFaceAttachedBlock$DoubleAttachFace)[]
public static "valueOf"(arg0: StringJS): $DoubleFaceAttachedBlock$DoubleAttachFace
public "getSerializedName"(): StringJS
public "xRot"(): integer
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleFaceAttachedBlock$DoubleAttachFace$$Type = (("floor") | ("wall") | ("wall_reversed") | ("ceiling"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoubleFaceAttachedBlock$DoubleAttachFace$$Original = $DoubleFaceAttachedBlock$DoubleAttachFace;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.DirectBeltInputBehaviour$AvailabilityPredicate" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"

export interface $DirectBeltInputBehaviour$AvailabilityPredicate$$Interface {

(arg0: $Direction): boolean
}

export class $DirectBeltInputBehaviour$AvailabilityPredicate implements $DirectBeltInputBehaviour$AvailabilityPredicate$$Interface {
 "test"(arg0: $Direction$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectBeltInputBehaviour$AvailabilityPredicate$$Type = ((arg0: $Direction) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectBeltInputBehaviour$AvailabilityPredicate$$Original = $DirectBeltInputBehaviour$AvailabilityPredicate;}
declare module "com.simibubi.create.content.equipment.armor.CardboardArmorItem" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Supplier} from "java.util.function.Supplier"
import {$BaseArmorItem} from "com.simibubi.create.content.equipment.armor.BaseArmorItem"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $CardboardArmorItem extends $BaseArmorItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $ArmorItem$Type$$Type, arg1: $Item$Properties$$Type)

public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CardboardArmorItem$$Type = ($CardboardArmorItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CardboardArmorItem$$Original = $CardboardArmorItem;}
declare module "com.simibubi.create.content.contraptions.pulley.PulleyBlock$RopeBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$PulleyBlock$RopeBlockBase} from "com.simibubi.create.content.contraptions.pulley.PulleyBlock$RopeBlockBase"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"

export class $PulleyBlock$RopeBlock extends $PulleyBlock$RopeBlockBase {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PulleyBlock$RopeBlock$$Type = ($PulleyBlock$RopeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PulleyBlock$RopeBlock$$Original = $PulleyBlock$RopeBlock;}
declare module "com.simibubi.create.content.fluids.pipes.IAxisPipe" {
import {$Direction$Axis, $Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $IAxisPipe$$Interface {

(arg0: $BlockState): $Direction$Axis$$Type
}

export class $IAxisPipe implements $IAxisPipe$$Interface {
static "getAxisOf"(arg0: $BlockState$$Type): $Direction$Axis
 "getAxis"(arg0: $BlockState$$Type): $Direction$Axis
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IAxisPipe$$Type = ((arg0: $BlockState) => $Direction$Axis$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IAxisPipe$$Original = $IAxisPipe;}
declare module "com.simibubi.create.content.contraptions.actors.psi.PortableStorageInterfaceBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$PortableStorageInterfaceBlockEntity, $PortableStorageInterfaceBlockEntity$$Type} from "com.simibubi.create.content.contraptions.actors.psi.PortableStorageInterfaceBlockEntity"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $PortableStorageInterfaceBlock extends $WrenchableDirectionalBlock implements $IBE$$Interface<($PortableStorageInterfaceBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($PortableStorageInterfaceBlockEntity)>
public "getBlockEntityClass"(): $Class<($PortableStorageInterfaceBlockEntity)>
public static "forFluids"(arg0: $BlockBehaviour$Properties$$Type): $PortableStorageInterfaceBlock
public static "forItems"(arg0: $BlockBehaviour$Properties$$Type): $PortableStorageInterfaceBlock
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($PortableStorageInterfaceBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($PortableStorageInterfaceBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PortableStorageInterfaceBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($PortableStorageInterfaceBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $PortableStorageInterfaceBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($PortableStorageInterfaceBlockEntity)>
get "blockEntityClass"(): $Class<($PortableStorageInterfaceBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PortableStorageInterfaceBlock$$Type = ($PortableStorageInterfaceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PortableStorageInterfaceBlock$$Original = $PortableStorageInterfaceBlock;}
declare module "com.simibubi.create.content.schematics.SchematicPrinter$PlacementPredicate" {
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $SchematicPrinter$PlacementPredicate$$Interface {

(arg0: $BlockPos, arg1: $BlockState, arg2: $BlockEntity, arg3: $BlockState, arg4: $BlockState, arg5: boolean): boolean
}

export class $SchematicPrinter$PlacementPredicate implements $SchematicPrinter$PlacementPredicate$$Interface {
 "shouldPlace"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockEntity$$Type, arg3: $BlockState$$Type, arg4: $BlockState$$Type, arg5: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicPrinter$PlacementPredicate$$Type = ((arg0: $BlockPos, arg1: $BlockState, arg2: $BlockEntity, arg3: $BlockState, arg4: $BlockState, arg5: boolean) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicPrinter$PlacementPredicate$$Original = $SchematicPrinter$PlacementPredicate;}
declare module "com.simibubi.create.content.trains.entity.TrainStatus" {
import {$Train$$Type} from "com.simibubi.create.content.trains.entity.Train"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$TrainStatus$StatusMessage$$Type} from "com.simibubi.create.content.trains.entity.TrainStatus$StatusMessage"

export class $TrainStatus {
 "navigation": boolean
 "track": boolean
 "conductor": boolean

constructor(arg0: $Train$$Type)

public "endOfTrack"(): void
public "highStress"(): void
public "trackOK"(): void
public "doublePortal"(): void
public "failedMigration"(): void
public "successfulMigration"(): void
public "manualControls"(): void
public "missingConductor"(): void
public "failedNavigation"(): void
public "failedNavigationNoTarget"(arg0: StringJS): void
public "foundConductor"(): void
public "failedPackageNoTarget"(arg0: StringJS): void
public "missingCorrectConductor"(): void
public "newSchedule"(): void
public "displayInformation"(arg0: StringJS, arg1: boolean, ...arg2: (any)[]): void
public "successfulNavigation"(): void
public "tick"(arg0: $Level$$Type): void
public "crash"(): void
public "addMessage"(arg0: $TrainStatus$StatusMessage$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrainStatus$$Type = ($TrainStatus);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrainStatus$$Original = $TrainStatus;}
declare module "com.simibubi.create.content.kinetics.gantry.GantryShaftBlock$Part" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $GantryShaftBlock$Part extends $Enum<($GantryShaftBlock$Part)> implements $StringRepresentable$$Interface {
static readonly "SINGLE": $GantryShaftBlock$Part
static readonly "START": $GantryShaftBlock$Part
static readonly "END": $GantryShaftBlock$Part
static readonly "MIDDLE": $GantryShaftBlock$Part

public static "values"(): ($GantryShaftBlock$Part)[]
public static "valueOf"(arg0: StringJS): $GantryShaftBlock$Part
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GantryShaftBlock$Part$$Type = (("start") | ("middle") | ("end") | ("single"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GantryShaftBlock$Part$$Original = $GantryShaftBlock$Part;}
declare module "com.simibubi.create.content.trains.schedule.ScheduleItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DataComponentType} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Map} from "java.util.Map"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ItemCopyingRecipe$SupportsItemCopying$$Interface} from "com.simibubi.create.foundation.recipe.ItemCopyingRecipe$SupportsItemCopying"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Schedule} from "com.simibubi.create.content.trains.schedule.Schedule"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ScheduleItem extends $Item implements $MenuProvider$$Interface, $ItemCopyingRecipe$SupportsItemCopying$$Interface {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "handScheduleTo"(arg0: $ItemStack$$Type, arg1: $Player$$Type, arg2: $LivingEntity$$Type, arg3: $InteractionHand$$Type): $InteractionResult
public "getDisplayName"(): $Component
public "getComponentType"(): $DataComponentType<(never)>
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "getSchedule"(arg0: $HolderLookup$Provider$$Type, arg1: $ItemStack$$Type): $Schedule
public "createCopy"(arg0: $ItemStack$$Type, arg1: integer): $ItemStack
public "canCopyFromItem"(arg0: $ItemStack$$Type): boolean
public "canCopyToItem"(arg0: $ItemStack$$Type): boolean
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "displayName"(): $Component
get "componentType"(): $DataComponentType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduleItem$$Type = ($ScheduleItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduleItem$$Original = $ScheduleItem;}
declare module "com.simibubi.create.content.kinetics.chainConveyor.ChainConveyorBlockEntity$ConnectedPort" {
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"

export class $ChainConveyorBlockEntity$ConnectedPort extends $Record {
constructor(chainPosition: float, connection: $BlockPos$$Type, filter: StringJS)

public "chainPosition"(): float
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): StringJS
public "connection"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainConveyorBlockEntity$ConnectedPort$$Type = ({"filter"?: StringJS, "chainPosition"?: float, "connection"?: $BlockPos$$Type}) | ([filter?: StringJS, chainPosition?: float, connection?: $BlockPos$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainConveyorBlockEntity$ConnectedPort$$Original = $ChainConveyorBlockEntity$ConnectedPort;}
declare module "com.simibubi.create.content.contraptions.mounted.CartAssemblerBlockItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $CartAssemblerBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "tryPlaceAssembler"(arg0: $UseOnContext$$Type): boolean
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CartAssemblerBlockItem$$Type = ($CartAssemblerBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CartAssemblerBlockItem$$Original = $CartAssemblerBlockItem;}
declare module "com.simibubi.create.content.processing.burner.LitBlazeBurnerBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$LitBlazeBurnerBlock$FlameType} from "com.simibubi.create.content.processing.burner.LitBlazeBurnerBlock$FlameType"
import {$ItemAbility} from "net.neoforged.neoforge.common.ItemAbility"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $LitBlazeBurnerBlock extends $Block implements $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "EXTINGUISH_FLAME_ACTION": $ItemAbility
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "FLAME_TYPE": $EnumProperty<($LitBlazeBurnerBlock$FlameType)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public static "getLight"(arg0: $BlockState$$Type): integer
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LitBlazeBurnerBlock$$Type = ($LitBlazeBurnerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LitBlazeBurnerBlock$$Original = $LitBlazeBurnerBlock;}
declare module "com.simibubi.create.content.kinetics.gantry.GantryShaftBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity, $KineticBlockEntity$$Type} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $GantryShaftBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getPinionMovementSpeed"(): float
public "canAssembleOn"(): boolean
public "propagateRotationTo"(arg0: $KineticBlockEntity$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: boolean, arg5: boolean): float
public "isCustomConnection"(arg0: $KineticBlockEntity$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type): boolean
public "onSpeedChanged"(arg0: float): void
public "checkAttachedCarriageBlocks"(): void
get "pinionMovementSpeed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GantryShaftBlockEntity$$Type = ($GantryShaftBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GantryShaftBlockEntity$$Original = $GantryShaftBlockEntity;}
declare module "com.simibubi.create.content.contraptions.bearing.ClockworkBearingBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List$$Type} from "java.util.List"
import {$IBearingBlockEntity$$Interface} from "com.simibubi.create.content.contraptions.bearing.IBearingBlockEntity"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$ValueBoxTransform} from "com.simibubi.create.foundation.blockEntity.behaviour.ValueBoxTransform"
import {$AbstractContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$ControlledContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.ControlledContraptionEntity"
import {$IDisplayAssemblyExceptions$$Interface} from "com.simibubi.create.content.contraptions.IDisplayAssemblyExceptions"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AssemblyException} from "com.simibubi.create.content.contraptions.AssemblyException"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ClockworkBearingBlockEntity extends $KineticBlockEntity implements $IBearingBlockEntity$$Interface, $IDisplayAssemblyExceptions$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isAttachedTo"(arg0: $AbstractContraptionEntity$$Type): boolean
public "onStall"(): void
public "setAngle"(arg0: float): void
public "getLastAssemblyException"(): $AssemblyException
public "isWoodenTop"(): boolean
public "getAngularSpeed"(): float
public "getInterpolatedAngle"(arg0: float): float
public "getHourArmSpeed"(): float
public "getMinuteArmSpeed"(): float
public "assemble"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "onSpeedChanged"(arg0: float): void
public "tick"(): void
public "remove"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "attach"(arg0: $ControlledContraptionEntity$$Type): void
public "isValid"(): boolean
public "isRunning"(): boolean
public "getBlockPosition"(): $BlockPos
public "disassemble"(): void
public "getMovementModeSlot"(): $ValueBoxTransform
public "addExceptionToTooltip"(arg0: $List$$Type<($Component$$Type)>): boolean
set "angle"(value: float)
get "lastAssemblyException"(): $AssemblyException
get "woodenTop"(): boolean
get "angularSpeed"(): float
get "hourArmSpeed"(): float
get "minuteArmSpeed"(): float
get "valid"(): boolean
get "running"(): boolean
get "blockPosition"(): $BlockPos
get "movementModeSlot"(): $ValueBoxTransform
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClockworkBearingBlockEntity$$Type = ($ClockworkBearingBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClockworkBearingBlockEntity$$Original = $ClockworkBearingBlockEntity;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.attributes.ColorAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $ColorAttribute$Type implements $ItemAttributeType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColorAttribute$Type$$Type = ($ColorAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ColorAttribute$Type$$Original = $ColorAttribute$Type;}
declare module "com.simibubi.create.content.trains.entity.Carriage$DimensionalCarriageEntity" {
import {$TrackNodeLocation} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$CarriageContraptionEntity, $CarriageContraptionEntity$$Type} from "com.simibubi.create.content.trains.entity.CarriageContraptionEntity"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Carriage$$Type} from "com.simibubi.create.content.trains.entity.Carriage"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$WeakReference} from "java.lang.ref.WeakReference"

export class $Carriage$DimensionalCarriageEntity {
 "pointsInitialised": boolean
 "pivot": $TrackNodeLocation
 "rotationAnchors": $Couple<($Vec3)>
 "cutoff": float
 "positionAnchor": $Vec3
 "entity": $WeakReference<($CarriageContraptionEntity)>

constructor(arg0: $Carriage$$Type)

public "leadingAnchor"(): $Vec3
public "trailingAnchor"(): $Vec3
public "discardPivot"(): void
public "minAllowedLocalCoord"(): integer
public "maxAllowedLocalCoord"(): integer
public "updateCutoff"(arg0: boolean): void
public "updatePassengerLoadout"(): void
public "findPivot"(arg0: $ResourceKey$$Type<($Level)>, arg1: boolean): $TrackNodeLocation
public "alignEntity"(arg0: $CarriageContraptionEntity$$Type): void
public "updateRenderedCutoff"(): void
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Carriage$DimensionalCarriageEntity$$Type = ($Carriage$DimensionalCarriageEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Carriage$DimensionalCarriageEntity$$Original = $Carriage$DimensionalCarriageEntity;}
declare module "com.simibubi.create.content.fluids.tank.storage.FluidTankMountedStorage$Handler" {
import {$FluidTank} from "net.neoforged.neoforge.fluids.capability.templates.FluidTank"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"

export class $FluidTankMountedStorage$Handler extends $FluidTank {
constructor(arg0: integer, arg1: $FluidStack$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankMountedStorage$Handler$$Type = ($FluidTankMountedStorage$Handler);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTankMountedStorage$Handler$$Original = $FluidTankMountedStorage$Handler;}
declare module "com.simibubi.create.content.kinetics.speedController.SpeedControllerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$SpeedControllerBlockEntity, $SpeedControllerBlockEntity$$Type} from "com.simibubi.create.content.kinetics.speedController.SpeedControllerBlockEntity"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$HorizontalAxisKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalAxisKineticBlock"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $SpeedControllerBlock extends $HorizontalAxisKineticBlock implements $IBE$$Interface<($SpeedControllerBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "HORIZONTAL_AXIS": $Property<($Direction$Axis)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($SpeedControllerBlockEntity)>
public "getBlockEntityClass"(): $Class<($SpeedControllerBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SpeedControllerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SpeedControllerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SpeedControllerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SpeedControllerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SpeedControllerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SpeedControllerBlockEntity)>
get "blockEntityClass"(): $Class<($SpeedControllerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpeedControllerBlock$$Type = ($SpeedControllerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpeedControllerBlock$$Original = $SpeedControllerBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.ItemListDisplaySource" {
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ValueListDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.ValueListDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $ItemListDisplaySource extends $ValueListDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemListDisplaySource$$Type = ($ItemListDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemListDisplaySource$$Original = $ItemListDisplaySource;}
declare module "com.simibubi.create.content.trains.entity.TravellingPoint$ITurnListener" {
import {$BiConsumer, $BiConsumer$$Type, $BiConsumer$$Interface} from "java.util.function.BiConsumer"
import {$TrackEdge, $TrackEdge$$Type} from "com.simibubi.create.content.trains.graph.TrackEdge"

export interface $TravellingPoint$ITurnListener$$Interface extends $BiConsumer$$Interface<(double), ($TrackEdge)> {

(arg0: double, arg1: $TrackEdge): void
}

export class $TravellingPoint$ITurnListener implements $TravellingPoint$ITurnListener$$Interface {
 "accept"(arg0: double, arg1: $TrackEdge$$Type): void
 "andThen"(arg0: $BiConsumer$$Type<(double), ($TrackEdge)>): $BiConsumer<(double), ($TrackEdge)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TravellingPoint$ITurnListener$$Type = ((arg0: double, arg1: $TrackEdge) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TravellingPoint$ITurnListener$$Original = $TravellingPoint$ITurnListener;}
declare module "com.simibubi.create.content.contraptions.bearing.ClockworkBearingBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BearingBlock} from "com.simibubi.create.content.contraptions.bearing.BearingBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ClockworkBearingBlockEntity, $ClockworkBearingBlockEntity$$Type} from "com.simibubi.create.content.contraptions.bearing.ClockworkBearingBlockEntity"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $ClockworkBearingBlock extends $BearingBlock implements $IBE$$Interface<($ClockworkBearingBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($ClockworkBearingBlockEntity)>
public "getBlockEntityClass"(): $Class<($ClockworkBearingBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ClockworkBearingBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ClockworkBearingBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ClockworkBearingBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ClockworkBearingBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ClockworkBearingBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ClockworkBearingBlockEntity)>
get "blockEntityClass"(): $Class<($ClockworkBearingBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClockworkBearingBlock$$Type = ($ClockworkBearingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClockworkBearingBlock$$Original = $ClockworkBearingBlock;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint" {
import {$ArmInteractionPoint$Mode} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint$Mode"
import {$ArmInteractionPointType, $ArmInteractionPointType$$Type} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ArmBlockEntity$$Type} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmBlockEntity"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ArmAngleTarget} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmAngleTarget"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ArmInteractionPoint {
constructor(arg0: $ArmInteractionPointType$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type)

public "updateCachedState"(): void
public "cycleMode"(): void
public "getTargetAngles"(arg0: $BlockPos$$Type, arg1: boolean): $ArmAngleTarget
public "getSlotCount"(arg0: $ArmBlockEntity$$Type): integer
public static "transformPos"(arg0: $CompoundTag$$Type, arg1: $StructureTransform$$Type): void
public static "isInteractable"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "keepAlive"(): void
public "getLevel"(): $Level
public "setLevel"(arg0: $Level$$Type): void
public "getMode"(): $ArmInteractionPoint$Mode
public "extract"(arg0: $ArmBlockEntity$$Type, arg1: integer, arg2: boolean): $ItemStack
public "extract"(arg0: $ArmBlockEntity$$Type, arg1: integer, arg2: integer, arg3: boolean): $ItemStack
public "insert"(arg0: $ArmBlockEntity$$Type, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "getType"(): $ArmInteractionPointType
public static "create"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
public static "deserialize"(arg0: $CompoundTag$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): $ArmInteractionPoint
public "serialize"(arg0: $BlockPos$$Type): $CompoundTag
public "isValid"(): boolean
public "getPos"(): $BlockPos
get "level"(): $Level
set "level"(value: $Level$$Type)
get "mode"(): $ArmInteractionPoint$Mode
get "type"(): $ArmInteractionPointType
get "valid"(): boolean
get "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmInteractionPoint$$Type = ($ArmInteractionPoint);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmInteractionPoint$$Original = $ArmInteractionPoint;}
declare module "com.simibubi.create.content.contraptions.StructureTransform" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Direction$Axis, $Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StructureTransform {
 "mirror": $Mirror
 "offset": $BlockPos
 "rotationAxis": $Direction$Axis
 "rotation": $Rotation
 "angle": integer
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($StructureTransform)>

constructor(arg0: $BlockPos$$Type, arg1: float, arg2: float, arg3: float)
constructor(arg0: $BlockPos$$Type, arg1: $Direction$Axis$$Type, arg2: $Rotation$$Type, arg3: $Mirror$$Type)

public "unapplyWithoutOffset"(arg0: $BlockPos$$Type): $BlockPos
public "unapplyWithoutOffset"(arg0: $Vec3$$Type): $Vec3
public "unapply"(arg0: $BlockPos$$Type): $BlockPos
public "mirrorFacing"(arg0: $Direction$$Type): $Direction
public "rotateFacing"(arg0: $Direction$$Type): $Direction
public "applyWithoutOffset"(arg0: $Vec3$$Type): $Vec3
public "applyWithoutOffset"(arg0: $BlockPos$$Type): $BlockPos
public "applyWithoutOffsetUncentered"(arg0: $Vec3$$Type): $Vec3
public "apply"(arg0: $BlockState$$Type): $BlockState
public "apply"(arg0: $Vec3$$Type): $Vec3
public "apply"(arg0: $BlockEntity$$Type): void
public "apply"(arg0: $BlockPos$$Type): $BlockPos
public "rotateAxis"(arg0: $Direction$Axis$$Type): $Direction$Axis
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTransform$$Type = ($StructureTransform);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTransform$$Original = $StructureTransform;}
declare module "com.simibubi.create.content.logistics.tunnel.BeltTunnelItem" {
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $BeltTunnelItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltTunnelItem$$Type = ($BeltTunnelItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltTunnelItem$$Original = $BeltTunnelItem;}
declare module "com.simibubi.create.content.equipment.potatoCannon.PotatoProjectileEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$EntityType$Builder, $EntityType$Builder$$Type} from "net.minecraft.world.entity.EntityType$Builder"
import {$Optional} from "java.util.Optional"
import {$UUID} from "java.util.UUID"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity$RemovalReason} from "net.minecraft.world.entity.Entity$RemovalReason"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$PotatoCannonProjectileType} from "com.simibubi.create.api.equipment.potatoCannon.PotatoCannonProjectileType"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ScoreHolder} from "net.minecraft.world.scores.ScoreHolder"
import {$EntityInLevelCallback} from "net.minecraft.world.level.entity.EntityInLevelCallback"
import {$AbstractHurtingProjectile, $AbstractHurtingProjectile$$Type} from "net.minecraft.world.entity.projectile.AbstractHurtingProjectile"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$PortalProcessor} from "net.minecraft.world.entity.PortalProcessor"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$IEntityWithComplexSpawn$$Interface} from "net.neoforged.neoforge.entity.IEntityWithComplexSpawn"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$PotatoProjectileRenderMode} from "com.simibubi.create.api.equipment.potatoCannon.PotatoProjectileRenderMode"

export class $PotatoProjectileEntity extends $AbstractHurtingProjectile implements $IEntityWithComplexSpawn$$Interface {
 "hasImpulse": boolean
 "tickCount": integer
 "noPhysics": boolean
 "yo": double
 "leftOwner": boolean
static readonly "BOARDING_COOLDOWN": integer
 "removalReason": $Entity$RemovalReason
 "yRotO": float
static readonly "CONTENTS_SLOT_INDEX": integer
 "level": $Level
 "moveDist": float
static readonly "ID_TAG": StringJS
 "mainSupportingBlockPos": $Optional<($BlockPos)>
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
 "xRotO": float
 "zo": double
 "walkDist": float
 "xOld": double
 "noCulling": boolean
 "wasInPowderSnow": boolean
 "hurtMarked": boolean
 "invulnerableTime": integer
static readonly "UUID_TAG": StringJS
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
 "fallDistance": float
 "portalProcess": $PortalProcessor
 "verticalCollision": boolean
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
 "accelerationPower": double
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
 "verticalCollisionBelow": boolean
static readonly "INITAL_ACCELERATION_POWER": double
static readonly "DEFLECTION_SCALE": double
 "yOld": double
static readonly "DEFAULT_BB_WIDTH": float
 "minorHorizontalCollision": boolean
static readonly "DEFAULT_BB_HEIGHT": float
 "levelCallback": $EntityInLevelCallback
 "ownerUUID": $UUID
 "walkDistO": float
static readonly "FREEZE_HURT_FREQUENCY": integer
 "flyDist": float
 "isInPowderSnow": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasBeenShot": boolean
 "cachedOwner": $Entity
static readonly "PASSENGERS_TAG": StringJS
 "blocksBuilding": boolean
 "wasOnFire": boolean
 "zOld": double
static readonly "TOTAL_AIR_SUPPLY": integer
 "xo": double
static readonly "BASE_SAFE_FALL_DISTANCE": integer
 "wasTouchingWater": boolean
 "horizontalCollision": boolean

constructor(arg0: $EntityType$$Type<($AbstractHurtingProjectile$$Type)>, arg1: $Level$$Type)

public "setItem"(arg0: $ItemStack$$Type): void
public "writeSpawnData"(arg0: $RegistryFriendlyByteBuf$$Type): void
public "readSpawnData"(arg0: $RegistryFriendlyByteBuf$$Type): void
public "setEnchantmentEffectsFromCannon"(arg0: $ItemStack$$Type): void
public "getStuckEntity"(): $Entity
public "getProjectileType"(): $PotatoCannonProjectileType
public static "playHitSound"(arg0: $Level$$Type, arg1: $Vec3$$Type): void
public "setStuckEntity"(arg0: $Entity$$Type): void
public "getRenderMode"(): $PotatoProjectileRenderMode
public static "playLaunchSound"(arg0: $Level$$Type, arg1: $Vec3$$Type, arg2: float): void
public "tick"(): void
public "getItem"(): $ItemStack
public static "build"(arg0: $EntityType$Builder$$Type<(never)>): $EntityType$Builder<(never)>
public "attack"(arg0: $DamageSource$$Type, arg1: float): boolean
public "addAdditionalSaveData"(arg0: $CompoundTag$$Type): void
public "readAdditionalSaveData"(arg0: $CompoundTag$$Type): void
public static "forNameOnly"(arg0: StringJS): $ScoreHolder
public static "fromGameProfile"(arg0: $GameProfile$$Type): $ScoreHolder
/**
 * 
 * @deprecated
 */
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
set "item"(value: $ItemStack$$Type)
set "enchantmentEffectsFromCannon"(value: $ItemStack$$Type)
get "stuckEntity"(): $Entity
get "projectileType"(): $PotatoCannonProjectileType
set "stuckEntity"(value: $Entity$$Type)
get "renderMode"(): $PotatoProjectileRenderMode
get "item"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotatoProjectileEntity$$Type = ($PotatoProjectileEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotatoProjectileEntity$$Original = $PotatoProjectileEntity;}
declare module "com.simibubi.create.content.logistics.redstoneRequester.RedstoneRequesterBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$RedstoneRequesterBlockEntity, $RedstoneRequesterBlockEntity$$Type} from "com.simibubi.create.content.logistics.redstoneRequester.RedstoneRequesterBlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$StockTickerBlockEntity$$Type} from "com.simibubi.create.content.logistics.stockTicker.StockTickerBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$PackageOrderWithCrafts$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $RedstoneRequesterBlock extends $Block implements $IBE$$Interface<($RedstoneRequesterBlockEntity)>, $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($RedstoneRequesterBlockEntity)>
public "getBlockEntityClass"(): $Class<($RedstoneRequesterBlockEntity)>
public static "programRequester"(arg0: $ServerPlayer$$Type, arg1: $StockTickerBlockEntity$$Type, arg2: $PackageOrderWithCrafts$$Type, arg3: StringJS): void
public static "appendRequesterTooltip"(arg0: $ItemStack$$Type, arg1: $List$$Type<($Component$$Type)>): void
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($RedstoneRequesterBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($RedstoneRequesterBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($RedstoneRequesterBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($RedstoneRequesterBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $RedstoneRequesterBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($RedstoneRequesterBlockEntity)>
get "blockEntityClass"(): $Class<($RedstoneRequesterBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneRequesterBlock$$Type = ($RedstoneRequesterBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneRequesterBlock$$Original = $RedstoneRequesterBlock;}
declare module "com.simibubi.create.content.kinetics.base.KineticBlockEntity" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveGoggleInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveGoggleInformation"
import {$KineticNetwork} from "com.simibubi.create.content.kinetics.KineticNetwork"
import {$IHaveHoveringInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveHoveringInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IRotate$$Type} from "com.simibubi.create.content.kinetics.base.IRotate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $KineticBlockEntity extends $SmartBlockEntity implements $IHaveGoggleInformation$$Interface, $IHaveHoveringInformation$$Interface {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "warnOfMovement"(): void
public "clearKineticInformation"(): void
public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "hasNetwork"(): boolean
public "calculateStressApplied"(): float
public "getOrCreateNetwork"(): $KineticNetwork
public "needsSpeedUpdate"(): boolean
public "attachKinetics"(): void
public "getFlickerScore"(): integer
public "hasSource"(): boolean
public "removeSource"(): void
public "detachKinetics"(): void
public "getGeneratedSpeed"(): float
public "setNetwork"(arg0: long): void
public "isSpeedRequirementFulfilled"(): boolean
public "tickAudio"(): void
public "updateFromNetwork"(arg0: float, arg1: float, arg2: integer): void
public "calculateAddedStressCapacity"(): float
public static "convertToLinear"(arg0: float): float
public static "convertToAngular"(arg0: float): float
public "isOverStressed"(): boolean
public "propagateRotationTo"(arg0: $KineticBlockEntity$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: boolean, arg5: boolean): float
public "addPropagationLocations"(arg0: $IRotate$$Type, arg1: $BlockState$$Type, arg2: $List$$Type<($BlockPos$$Type)>): $List<($BlockPos)>
public "isCustomConnection"(arg0: $KineticBlockEntity$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type): boolean
public "getRotationAngleOffset"(arg0: $Direction$Axis$$Type): integer
public "isSource"(): boolean
public static "convertToDirection"(arg0: float, arg1: $Direction$$Type): float
public "requestModelDataUpdate"(): void
public "addToTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "onSpeedChanged"(arg0: float): void
public static "switchToBlockState"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "getTheoreticalSpeed"(): float
public "tick"(): void
public "remove"(): void
public "initialize"(): void
public "setSource"(arg0: $BlockPos$$Type): void
public "setSpeed"(arg0: float): void
public "getSpeed"(): float
public "containedFluidTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean, arg2: $IFluidHandler$$Type): boolean
public "getIcon"(arg0: boolean): $ItemStack
get "orCreateNetwork"(): $KineticNetwork
get "flickerScore"(): integer
get "generatedSpeed"(): float
get "speedRequirementFulfilled"(): boolean
get "overStressed"(): boolean
get "theoreticalSpeed"(): float
set "speed"(value: float)
get "speed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KineticBlockEntity$$Type = ($KineticBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KineticBlockEntity$$Original = $KineticBlockEntity;}
declare module "com.simibubi.create.content.kinetics.transmission.sequencer.SequencerInstructions" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Enum} from "java.lang.Enum"
import {$AllGuiTextures, $AllGuiTextures$$Type} from "com.simibubi.create.foundation.gui.AllGuiTextures"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $SequencerInstructions extends $Enum<($SequencerInstructions)> {
readonly "translationKey": StringJS
readonly "maxValue": integer
readonly "defaultValue": integer
static readonly "AWAIT": $SequencerInstructions
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($SequencerInstructions)>
static readonly "TURN_DISTANCE": $SequencerInstructions
readonly "shiftStep": integer
readonly "descriptiveTranslationKey": StringJS
readonly "hasValueParameter": boolean
readonly "background": $AllGuiTextures
readonly "parameterKey": StringJS
readonly "hasSpeedParameter": boolean
static readonly "END": $SequencerInstructions
static readonly "TURN_ANGLE": $SequencerInstructions
static readonly "DELAY": $SequencerInstructions

public "needsPropagation"(): boolean
public static "invokeInit$create_connected_$md$b00d76$0"(arg0: StringJS, arg1: integer, arg2: StringJS, arg3: $AllGuiTextures$$Type): $SequencerInstructions
public static "invokeInit$create_connected_$md$b00d76$1"(arg0: StringJS, arg1: integer, arg2: StringJS, arg3: $AllGuiTextures$$Type, arg4: boolean, arg5: boolean, arg6: integer, arg7: integer, arg8: integer): $SequencerInstructions
public static "values"(): ($SequencerInstructions)[]
public static "valueOf"(arg0: StringJS): $SequencerInstructions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencerInstructions$$Type = (("turn_angle") | ("turn_distance") | ("delay") | ("await") | ("end") | ("turn_await") | ("turn_time") | ("loop"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SequencerInstructions$$Original = $SequencerInstructions;}
declare module "com.simibubi.create.content.contraptions.gantry.GantryCarriageBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$GantryCarriageBlockEntity, $GantryCarriageBlockEntity$$Type} from "com.simibubi.create.content.contraptions.gantry.GantryCarriageBlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Direction$Axis, $Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$DirectionalAxisKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalAxisKineticBlock"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $GantryCarriageBlock extends $DirectionalAxisKineticBlock implements $IBE$$Interface<($GantryCarriageBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "AXIS_ALONG_FIRST_COORDINATE": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getBlockEntityType"(): $BlockEntityType<($GantryCarriageBlockEntity)>
public "getBlockEntityClass"(): $Class<($GantryCarriageBlockEntity)>
public static "isValidGantryShaftAxis"(arg0: $BlockState$$Type, arg1: $BlockState$$Type): boolean
public static "getValidGantryShaftAxis"(arg0: $BlockState$$Type): $Direction$Axis
public static "getValidGantryPinionAxis"(arg0: $BlockState$$Type, arg1: $Direction$Axis$$Type): $Direction$Axis
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "updateIndirectNeighbourShapes"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: integer, arg4: integer): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($GantryCarriageBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($GantryCarriageBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($GantryCarriageBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($GantryCarriageBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $GantryCarriageBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($GantryCarriageBlockEntity)>
get "blockEntityClass"(): $Class<($GantryCarriageBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GantryCarriageBlock$$Type = ($GantryCarriageBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GantryCarriageBlock$$Original = $GantryCarriageBlock;}
declare module "com.simibubi.create.content.logistics.depot.DepotBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DepotBlockEntity extends $SmartBlockEntity implements $Clearable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "setHeldItem"(arg0: $ItemStack$$Type): void
public "getHeldItem"(): $ItemStack
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
set "heldItem"(value: $ItemStack$$Type)
get "heldItem"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DepotBlockEntity$$Type = ($DepotBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DepotBlockEntity$$Original = $DepotBlockEntity;}
declare module "com.simibubi.create.content.kinetics.crafter.MechanicalCraftingRecipe$Serializer" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$MechanicalCraftingRecipe} from "com.simibubi.create.content.kinetics.crafter.MechanicalCraftingRecipe"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$RecipeSerializer, $RecipeSerializer$$Type, $RecipeSerializer$$Interface} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $MechanicalCraftingRecipe$Serializer implements $RecipeSerializer$$Interface<($MechanicalCraftingRecipe)> {
static readonly "CODEC": $MapCodec<($MechanicalCraftingRecipe)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MechanicalCraftingRecipe)>

constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($MechanicalCraftingRecipe)>
public "codec"(): $MapCodec<($MechanicalCraftingRecipe)>
public static "register"<S extends $RecipeSerializer<(object)>, T extends $Recipe<(object)>>(arg0: StringJS, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalCraftingRecipe$Serializer$$Type = ($MechanicalCraftingRecipe$Serializer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalCraftingRecipe$Serializer$$Original = $MechanicalCraftingRecipe$Serializer;}
declare module "com.simibubi.create.content.kinetics.millstone.MillstoneBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$KineticBlock} from "com.simibubi.create.content.kinetics.base.KineticBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MillstoneBlockEntity, $MillstoneBlockEntity$$Type} from "com.simibubi.create.content.kinetics.millstone.MillstoneBlockEntity"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ICogWheel$$Interface} from "com.simibubi.create.content.kinetics.simpleRelays.ICogWheel"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $MillstoneBlock extends $KineticBlock implements $IBE$$Interface<($MillstoneBlockEntity)>, $ICogWheel$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($MillstoneBlockEntity)>
public "getBlockEntityClass"(): $Class<($MillstoneBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($MillstoneBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($MillstoneBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MillstoneBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MillstoneBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $MillstoneBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "isSmallCog"(): boolean
public static "isSmallCog"(arg0: $Block$$Type): boolean
public static "isSmallCog"(arg0: $BlockState$$Type): boolean
public "isLargeCog"(): boolean
public static "isLargeCog"(arg0: $Block$$Type): boolean
public static "isLargeCog"(arg0: $BlockState$$Type): boolean
public "isDedicatedCogWheel"(): boolean
public static "isDedicatedCogWheel"(arg0: $Block$$Type): boolean
public static "isDedicatedCogItem"(arg0: $ItemStack$$Type): boolean
public static "isSmallCogItem"(arg0: $ItemStack$$Type): boolean
public static "isLargeCogItem"(arg0: $ItemStack$$Type): boolean
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($MillstoneBlockEntity)>
get "blockEntityClass"(): $Class<($MillstoneBlockEntity)>
get "smallCog"(): boolean
get "largeCog"(): boolean
get "dedicatedCogWheel"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MillstoneBlock$$Type = ($MillstoneBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MillstoneBlock$$Original = $MillstoneBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.FluidAmountDisplaySource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $FluidAmountDisplaySource extends $SingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidAmountDisplaySource$$Type = ($FluidAmountDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidAmountDisplaySource$$Original = $FluidAmountDisplaySource;}
declare module "com.simibubi.create.content.decoration.slidingDoor.DoorControlBehaviour" {
import {$SmartBlockEntity, $SmartBlockEntity$$Type} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$DoorControl, $DoorControl$$Type} from "com.simibubi.create.content.decoration.slidingDoor.DoorControl"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BehaviourType} from "com.simibubi.create.foundation.blockEntity.behaviour.BehaviourType"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $DoorControlBehaviour extends $BlockEntityBehaviour {
 "mode": $DoorControl
 "blockEntity": $SmartBlockEntity
static readonly "TYPE": $BehaviourType<($DoorControlBehaviour)>

constructor(arg0: $SmartBlockEntity$$Type)

public "set"(arg0: $DoorControl$$Type): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "getType"(): $BehaviourType<(never)>
get "type"(): $BehaviourType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoorControlBehaviour$$Type = ($DoorControlBehaviour);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoorControlBehaviour$$Original = $DoorControlBehaviour;}
declare module "com.simibubi.create.content.contraptions.actors.trainControls.ControlsBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $ControlsBlock extends $HorizontalDirectionalBlock implements $IWrenchable$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ControlsBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "VIRTUAL": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ControlsBlock$$Type = ($ControlsBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ControlsBlock$$Original = $ControlsBlock;}
declare module "com.simibubi.create.content.contraptions.actors.contraptionControls.ContraptionControlsBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$ContraptionControlsBlockEntity, $ContraptionControlsBlockEntity$$Type} from "com.simibubi.create.content.contraptions.actors.contraptionControls.ContraptionControlsBlockEntity"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ControlsBlock} from "com.simibubi.create.content.contraptions.actors.trainControls.ControlsBlock"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $ContraptionControlsBlock extends $ControlsBlock implements $IBE$$Interface<($ContraptionControlsBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ContraptionControlsBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "VIRTUAL": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($ContraptionControlsBlockEntity)>
public "getBlockEntityClass"(): $Class<($ContraptionControlsBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ContraptionControlsBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ContraptionControlsBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ContraptionControlsBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ContraptionControlsBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ContraptionControlsBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ContraptionControlsBlockEntity)>
get "blockEntityClass"(): $Class<($ContraptionControlsBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContraptionControlsBlock$$Type = ($ContraptionControlsBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ContraptionControlsBlock$$Original = $ContraptionControlsBlock;}
declare module "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBlockEntity" {
import {$UUID$$Type} from "java.util.UUID"
import {$FactoryPanelBlock$PanelSlot, $FactoryPanelBlock$PanelSlot$$Type} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBlock$PanelSlot"
import {$List$$Type} from "java.util.List"
import {$EnumMap} from "java.util.EnumMap"
import {$AdvancementBehaviour} from "com.simibubi.create.foundation.advancement.AdvancementBehaviour"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$FactoryPanelBehaviour} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBehaviour"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PackagerBlockEntity} from "com.simibubi.create.content.logistics.packager.PackagerBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FactoryPanelBlockEntity extends $SmartBlockEntity {
 "redraw": boolean
 "advancements": $AdvancementBehaviour
 "panels": $EnumMap<($FactoryPanelBlock$PanelSlot), ($FactoryPanelBehaviour)>
 "restocker": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lastShape": $VoxelShape

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getRestockedPackager"(): $PackagerBlockEntity
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "addPanel"(arg0: $FactoryPanelBlock$PanelSlot$$Type, arg1: $UUID$$Type): boolean
public "activePanels"(): integer
public "removePanel"(arg0: $FactoryPanelBlock$PanelSlot$$Type): boolean
public "getShape"(): $VoxelShape
public "remove"(): void
public "destroy"(): void
get "restockedPackager"(): $PackagerBlockEntity
get "shape"(): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryPanelBlockEntity$$Type = ($FactoryPanelBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FactoryPanelBlockEntity$$Original = $FactoryPanelBlockEntity;}
declare module "com.simibubi.create.content.logistics.stockTicker.StockCheckingBlockEntity" {
import {$LogisticallyLinkedBehaviour$RequestType$$Type} from "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBehaviour$RequestType"
import {$IdentifiedInventory$$Type} from "com.simibubi.create.content.logistics.packager.IdentifiedInventory"
import {$List$$Type} from "java.util.List"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$LogisticallyLinkedBehaviour} from "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBehaviour"
import {$PackageOrder$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrder"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PackageOrderWithCrafts$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts"
import {$InventorySummary} from "com.simibubi.create.content.logistics.packager.InventorySummary"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StockCheckingBlockEntity extends $SmartBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "behaviour": $LogisticallyLinkedBehaviour

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getRecentSummary"(): $InventorySummary
public "broadcastPackageRequest"(arg0: $LogisticallyLinkedBehaviour$RequestType$$Type, arg1: $PackageOrderWithCrafts$$Type, arg2: $IdentifiedInventory$$Type, arg3: StringJS): boolean
public "broadcastPackageRequest"(arg0: $LogisticallyLinkedBehaviour$RequestType$$Type, arg1: $PackageOrder$$Type, arg2: $IdentifiedInventory$$Type, arg3: StringJS): boolean
public "getAccurateSummary"(): $InventorySummary
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
get "recentSummary"(): $InventorySummary
get "accurateSummary"(): $InventorySummary
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StockCheckingBlockEntity$$Type = ($StockCheckingBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StockCheckingBlockEntity$$Original = $StockCheckingBlockEntity;}
declare module "com.simibubi.create.content.trains.schedule.ScheduleDataEntry" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$GuiGraphics$$Type} from "net.minecraft.client.gui.GuiGraphics"
import {$IScheduleInput$$Interface} from "com.simibubi.create.content.trains.schedule.IScheduleInput"
import {$List} from "java.util.List"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$Component} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $ScheduleDataEntry implements $IScheduleInput$$Interface {
constructor()

public "setData"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
public "getData"(): $CompoundTag
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "initConfigurationWidgets"(arg0: $ModularGuiLineBuilder$$Type): void
public "slotsTargeted"(): integer
public "getTitleAs"(arg0: StringJS): $List<($Component)>
public "getSecondLineIcon"(): $ItemStack
public "getSecondLineTooltip"(arg0: integer): $List<($Component)>
public "renderSpecialIcon"(arg0: $GuiGraphics$$Type, arg1: integer, arg2: integer): boolean
public "getItem"(arg0: integer): $ItemStack
public "getId"(): $ResourceLocation
public "getSummary"(): $Pair<($ItemStack), ($Component)>
get "data"(): $CompoundTag
get "secondLineIcon"(): $ItemStack
get "id"(): $ResourceLocation
get "summary"(): $Pair<($ItemStack), ($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduleDataEntry$$Type = ($ScheduleDataEntry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduleDataEntry$$Original = $ScheduleDataEntry;}
declare module "com.simibubi.create.content.fluids.pipes.StraightPipeBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StraightPipeBlockEntity extends $SmartBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StraightPipeBlockEntity$$Type = ($StraightPipeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StraightPipeBlockEntity$$Original = $StraightPipeBlockEntity;}
declare module "com.simibubi.create.content.materials.ExperienceBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ExperienceBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceBlock$$Type = ($ExperienceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExperienceBlock$$Original = $ExperienceBlock;}
declare module "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PackageOrderWithCrafts$CraftingEntry, $PackageOrderWithCrafts$CraftingEntry$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts$CraftingEntry"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$BigItemStack, $BigItemStack$$Type} from "com.simibubi.create.content.logistics.BigItemStack"
import {$PackageOrder, $PackageOrder$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrder"
import {$Record} from "java.lang.Record"

export class $PackageOrderWithCrafts extends $Record {
static readonly "CODEC": $Codec<($PackageOrderWithCrafts)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($PackageOrderWithCrafts)>

constructor(orderedStacks: $PackageOrder$$Type, orderedCrafts: $List$$Type<($PackageOrderWithCrafts$CraftingEntry$$Type)>)

public "orderedStacksMatchOrderedRecipes"(): boolean
public static "singleRecipe"(arg0: $List$$Type<($BigItemStack$$Type)>): $PackageOrderWithCrafts
public static "hasCraftingInformation"(arg0: $PackageOrderWithCrafts$$Type): boolean
public "getCraftingInformation"(): $List<($BigItemStack)>
public "orderedCrafts"(): $List<($PackageOrderWithCrafts$CraftingEntry)>
public "orderedStacks"(): $PackageOrder
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "empty"(): $PackageOrderWithCrafts
public static "simple"(arg0: $List$$Type<($BigItemStack$$Type)>): $PackageOrderWithCrafts
public "stacks"(): $List<($BigItemStack)>
get "craftingInformation"(): $List<($BigItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackageOrderWithCrafts$$Type = ({"orderedCrafts"?: $List$$Type<($PackageOrderWithCrafts$CraftingEntry$$Type)>, "orderedStacks"?: $PackageOrder$$Type}) | ([orderedCrafts?: $List$$Type<($PackageOrderWithCrafts$CraftingEntry$$Type)>, orderedStacks?: $PackageOrder$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackageOrderWithCrafts$$Original = $PackageOrderWithCrafts;}
declare module "com.simibubi.create.content.kinetics.deployer.DeployerRecipeSearchEvent" {
import {$Optional$$Type} from "java.util.Optional"
import {$DeployerBlockEntity, $DeployerBlockEntity$$Type} from "com.simibubi.create.content.kinetics.deployer.DeployerBlockEntity"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$Recipe, $Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$ICancellableEvent$$Interface} from "net.neoforged.bus.api.ICancellableEvent"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Event} from "net.neoforged.bus.api.Event"
import {$RecipeWrapper, $RecipeWrapper$$Type} from "net.neoforged.neoforge.items.wrapper.RecipeWrapper"

export class $DeployerRecipeSearchEvent extends $Event implements $ICancellableEvent$$Interface {
constructor(arg0: $DeployerBlockEntity$$Type, arg1: $RecipeWrapper$$Type)

public "shouldAddRecipeWithPriority"(arg0: integer): boolean
public "addRecipe"(arg0: $Supplier$$Type<(($RecipeHolder$$Type<($Recipe$$Type<($RecipeInput$$Type)>)>)?)>, arg1: integer): void
public "getRecipe"(): $RecipeHolder<($Recipe<($RecipeInput)>)>
public "getInventory"(): $RecipeWrapper
public "getBlockEntity"(): $DeployerBlockEntity
public "setCanceled"(arg0: boolean): void
public "isCanceled"(): boolean
get "recipe"(): $RecipeHolder<($Recipe<($RecipeInput)>)>
get "inventory"(): $RecipeWrapper
get "blockEntity"(): $DeployerBlockEntity
set "canceled"(value: boolean)
get "canceled"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeployerRecipeSearchEvent$$Type = ($DeployerRecipeSearchEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeployerRecipeSearchEvent$$Original = $DeployerRecipeSearchEvent;}
declare module "com.simibubi.create.content.trains.signal.SignalBlock$SignalType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $SignalBlock$SignalType extends $Enum<($SignalBlock$SignalType)> implements $StringRepresentable$$Interface {
static readonly "ENTRY_SIGNAL": $SignalBlock$SignalType
static readonly "CROSS_SIGNAL": $SignalBlock$SignalType

public static "values"(): ($SignalBlock$SignalType)[]
public static "valueOf"(arg0: StringJS): $SignalBlock$SignalType
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignalBlock$SignalType$$Type = (("entry_signal") | ("cross_signal"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignalBlock$SignalType$$Original = $SignalBlock$SignalType;}
declare module "com.simibubi.create.content.equipment.zapper.terrainzapper.TerrainTools" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AllIcons} from "com.simibubi.create.foundation.gui.AllIcons"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TerrainTools extends $Enum<($TerrainTools)> implements $StringRepresentable$$Interface {
static readonly "Replace": $TerrainTools
static readonly "Fill": $TerrainTools
static readonly "CODEC": $Codec<($TerrainTools)>
 "translationKey": StringJS
static readonly "Flatten": $TerrainTools
 "icon": $AllIcons
static readonly "Overlay": $TerrainTools
static readonly "Place": $TerrainTools
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($TerrainTools)>
static readonly "Clear": $TerrainTools

public static "isReplaceable"(arg0: $BlockState$$Type): boolean
public "requiresSelectedBlock"(): boolean
public "run"(arg0: $Level$$Type, arg1: $List$$Type<($BlockPos$$Type)>, arg2: $Direction$$Type, arg3: $BlockState$$Type, arg4: $CompoundTag$$Type, arg5: $Player$$Type): void
public static "values"(): ($TerrainTools)[]
public static "valueOf"(arg0: StringJS): $TerrainTools
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TerrainTools$$Type = (("fill") | ("place") | ("replace") | ("clear") | ("overlay") | ("flatten"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TerrainTools$$Original = $TerrainTools;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.SingletonItemAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Function$$Type} from "java.util.function.Function"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$SingletonItemAttribute$$Type} from "com.simibubi.create.content.logistics.item.filter.attribute.SingletonItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $SingletonItemAttribute$Type implements $ItemAttributeType$$Interface {
constructor(arg0: $Function$$Type<($SingletonItemAttribute$Type), ($SingletonItemAttribute$$Type)>)

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingletonItemAttribute$Type$$Type = ($SingletonItemAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SingletonItemAttribute$Type$$Original = $SingletonItemAttribute$Type;}
declare module "com.simibubi.create.content.redstone.displayLink.source.DeathCounterDisplaySource" {
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$StatTrackingDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.StatTrackingDisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $DeathCounterDisplaySource extends $StatTrackingDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeathCounterDisplaySource$$Type = ($DeathCounterDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeathCounterDisplaySource$$Original = $DeathCounterDisplaySource;}
declare module "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$FlapDisplayBlockEntity$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayBlockEntity"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$DisplayTargetStats$$Type} from "com.simibubi.create.content.redstone.displayLink.target.DisplayTargetStats"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$FlapDisplayLayout$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayLayout"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $SingleLineDisplaySource extends $DisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
public "provideText"(arg0: $DisplayLinkContext$$Type, arg1: $DisplayTargetStats$$Type): $List<($MutableComponent)>
public "provideFlapDisplayText"(arg0: $DisplayLinkContext$$Type, arg1: $DisplayTargetStats$$Type): $List<($List<($MutableComponent)>)>
public "loadFlapDisplayLayout"(arg0: $DisplayLinkContext$$Type, arg1: $FlapDisplayBlockEntity$$Type, arg2: $FlapDisplayLayout$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingleLineDisplaySource$$Type = ($SingleLineDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SingleLineDisplaySource$$Original = $SingleLineDisplaySource;}
declare module "com.simibubi.create.content.trains.graph.EdgePointType" {
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$Map} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$TrackEdgePoint} from "com.simibubi.create.content.trains.signal.TrackEdgePoint"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$TrackObserver} from "com.simibubi.create.content.trains.observer.TrackObserver"
import {$GlobalStation} from "com.simibubi.create.content.trains.station.GlobalStation"
import {$SignalBoundary} from "com.simibubi.create.content.trains.signal.SignalBoundary"

export class $EdgePointType<T extends $TrackEdgePoint> {
static readonly "TYPES": $Map<($ResourceLocation), ($EdgePointType<(never)>)>
static readonly "SIGNAL": $EdgePointType<($SignalBoundary)>
static readonly "STATION": $EdgePointType<($GlobalStation)>
static readonly "OBSERVER": $EdgePointType<($TrackObserver)>

constructor(arg0: $ResourceLocation$$Type, arg1: $Supplier$$Type<(T)>)

public static "register"<T extends $TrackEdgePoint>(arg0: $ResourceLocation$$Type, arg1: $Supplier$$Type<(T)>): $EdgePointType<(T)>
public static "read"(arg0: $FriendlyByteBuf$$Type, arg1: $DimensionPalette$$Type): $TrackEdgePoint
public "getId"(): $ResourceLocation
public "create"(): T
get "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EdgePointType$$Type<T> = ($EdgePointType<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EdgePointType$$Original<T> = $EdgePointType<(T)>;}
declare module "com.simibubi.create.content.redstone.displayLink.DisplayLinkBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$FactoryPanelSupportBehaviour} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelSupportBehaviour"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$List$$Type} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$LinkWithBulbBlockEntity} from "com.simibubi.create.content.redstone.displayLink.LinkWithBulbBlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$DisplayTarget} from "com.simibubi.create.api.behaviour.display.DisplayTarget"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DisplayLinkBlockEntity extends $LinkWithBulbBlockEntity implements $TransformableBlockEntity$$Interface {
 "refreshTicks": integer
 "targetLine": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "activeTarget": $DisplayTarget
 "computerBehaviour": $AbstractComputerBehaviour
 "factoryPanelSupport": $FactoryPanelSupportBehaviour
 "activeSource": $DisplaySource

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getBulbOffset"(arg0: $BlockState$$Type): $Vec3
public "setSourceConfig"(arg0: $CompoundTag$$Type): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getSourceConfig"(): $CompoundTag
public "updateGatheredData"(): void
public "tickSource"(): void
public "onNoLongerPowered"(): void
public "getTargetPosition"(): $BlockPos
public "tick"(): void
public "target"(arg0: $BlockPos$$Type): void
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "invalidate"(): void
public "getDirection"(): $Direction
public "getSourcePosition"(): $BlockPos
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
set "sourceConfig"(value: $CompoundTag$$Type)
get "sourceConfig"(): $CompoundTag
get "targetPosition"(): $BlockPos
get "direction"(): $Direction
get "sourcePosition"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayLinkBlockEntity$$Type = ($DisplayLinkBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DisplayLinkBlockEntity$$Original = $DisplayLinkBlockEntity;}
declare module "com.simibubi.create.content.trains.entity.Train" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$TravellingPoint$SteerDirection} from "com.simibubi.create.content.trains.entity.TravellingPoint$SteerDirection"
import {$TravellingPoint$IEdgePointListener} from "com.simibubi.create.content.trains.entity.TravellingPoint$IEdgePointListener"
import {$Optional} from "java.util.Optional"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$AccessorTrain$$Interface} from "com.railwayteam.railways.mixin.AccessorTrain"
import {$TrainIconType, $TrainIconType$$Type} from "com.simibubi.create.content.trains.entity.TrainIconType"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$TravellingPoint$$Type} from "com.simibubi.create.content.trains.entity.TravellingPoint"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$IBufferBlockedTrain$$Interface} from "com.railwayteam.railways.mixin_interfaces.IBufferBlockedTrain"
import {$IStrictSignalTrain$$Interface} from "com.railwayteam.railways.mixin_interfaces.IStrictSignalTrain"
import {$ScheduleRuntime} from "com.simibubi.create.content.trains.schedule.ScheduleRuntime"
import {$ICrashAdvancement$$Interface} from "com.railwayteam.railways.mixin_interfaces.ICrashAdvancement"
import {$Set} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IIndexedSchedule$$Interface} from "com.railwayteam.railways.mixin_interfaces.IIndexedSchedule"
import {$IHandcarTrain$$Interface} from "com.railwayteam.railways.mixin_interfaces.IHandcarTrain"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Carriage, $Carriage$$Type} from "com.simibubi.create.content.trains.entity.Carriage"
import {$CPLTrain$$Interface} from "com.hlysine.create_power_loader.content.trains.CPLTrain"
import {$TrainStatus} from "com.simibubi.create.content.trains.entity.TrainStatus"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TrackGraph, $TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$TrackNode, $TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Navigation} from "com.simibubi.create.content.trains.entity.Navigation"
import {$IOccupiedCouplers$$Interface} from "com.railwayteam.railways.mixin_interfaces.IOccupiedCouplers"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$TrainChunkLoader, $TrainChunkLoader$$Type} from "com.hlysine.create_power_loader.content.trains.TrainChunkLoader"
import {$GlobalStation, $GlobalStation$$Type} from "com.simibubi.create.content.trains.station.GlobalStation"

export class $Train implements $AccessorTrain$$Interface, $IStrictSignalTrain$$Interface, $IIndexedSchedule$$Interface, $IBufferBlockedTrain$$Interface, $ICrashAdvancement$$Interface, $IHandcarTrain$$Interface, $IOccupiedCouplers$$Interface, $CPLTrain$$Interface {
 "throttle": double
 "lowHonk": boolean
 "speedBeforeStall": double
 "icon": $TrainIconType
 "doubleEnded": boolean
 "backwardsDriver": $Player
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Train)>
 "speed": double
 "manualTick": boolean
 "currentlyBackwards": boolean
 "honkPitch": integer
 "railways$occupiedCouplers": $Set
 "navigation": $Navigation
 "carriages": $List<($Carriage)>
 "currentStation": $UUID
 "honkTicks": integer
 "id": $UUID
 "owner": $UUID
 "targetSpeed": double
 "occupiedSignalBlocks": $Map<($UUID), ($UUID)>
 "carriageWaitingForChunks": integer
 "accumulatedSteamRelease": float
 "reservedSignalBlocks": $Set<($UUID)>
 "updateSignalBlocks": boolean
 "migrationCooldown": integer
 "runtime": $ScheduleRuntime
 "occupiedObservers": $Set<($UUID)>
 "derailed": boolean
 "carriageSpacing": $List<(integer)>
 "graph": $TrackGraph
 "cachedObserverFiltering": $Map<($UUID), ($Pair<(integer), (boolean)>)>
 "cpl$chunkLoader": $TrainChunkLoader
 "honk": boolean
 "mapColorIndex": integer
 "name": $Component
 "invalid": boolean
 "status": $TrainStatus
 "manualSteer": $TravellingPoint$SteerDirection
 "fuelTicks": integer

constructor(arg0: $UUID$$Type, arg1: $UUID$$Type, arg2: $TrackGraph$$Type, arg3: $List$$Type<($Carriage$$Type)>, arg4: $List$$Type<(integer)>, arg5: boolean, arg6: $Component$$Type, arg7: $TrainIconType$$Type, arg8: integer)
constructor(arg0: $UUID$$Type, arg1: $UUID$$Type, arg2: $TrackGraph$$Type, arg3: $List$$Type<($Carriage$$Type)>, arg4: $List$$Type<(integer)>, arg5: boolean, arg6: integer)

public "setCurrentStation"(arg0: $GlobalStation$$Type): void
public "canDisassemble"(): boolean
public "reattachToTracks"(arg0: $Level$$Type): void
public "frontSignalListener"(): $TravellingPoint$IEdgePointListener
public "backSignalListener"(): $TravellingPoint$IEdgePointListener
public "findCollidingTrain"(arg0: $Level$$Type, arg1: $Vec3$$Type, arg2: $Vec3$$Type, arg3: $ResourceKey$$Type<($Level)>): $Pair<($Train), ($Vec3)>
public "isTravellingOn"(arg0: $TrackNode$$Type): boolean
public "forEachTravellingPoint"(arg0: $Consumer$$Type<($TravellingPoint)>): void
public "detachFromTracks"(): void
public "forEachTravellingPointBackwards"(arg0: $BiConsumer$$Type<($TravellingPoint), (double)>): void
public "leaveStation"(): void
public "arriveAt"(arg0: $GlobalStation$$Type): void
public "getEndpointEdges"(): $Couple<($Couple<($TrackNode)>)>
public "getNavigationPenalty"(): integer
public "handler$zkc000$railways$maxSpeed"(arg0: $CallbackInfoReturnable$$Type): void
public "handler$zkc000$railways$maxTurnSpeed"(arg0: $CallbackInfoReturnable$$Type): void
public "handler$zkc000$railways$acceleration"(arg0: $CallbackInfoReturnable$$Type): void
public "distanceToLocationSqr"(arg0: $Level$$Type, arg1: $Vec3$$Type): float
public "getPresentDimensions"(): $List<($ResourceKey<($Level)>)>
public "getPositionInDimension"(arg0: $ResourceKey$$Type<($Level)>): $Optional<($BlockPos)>
public "railways$setControlBlocked"(arg0: boolean, arg1: boolean): void
public "railways$setStrictSignals"(arg0: boolean): void
public "railways$getIndex"(): integer
public "railways$awardCrashAdvancements"(): void
public "earlyTick"(arg0: $Level$$Type): void
public "setLoader"(arg0: $TrainChunkLoader$$Type): void
public "cancelStall"(): void
public "railways$setIndex"(arg0: integer): void
public "shouldCarriageSyncThisTick"(arg0: long, arg1: integer): boolean
public "burnFuel"(): void
public "getCurrentStation"(): $GlobalStation
public "maxSpeed"(): float
public "maxTurnSpeed"(): float
public "approachTargetSpeed"(arg0: float): void
public "railways$isHandcar"(): boolean
public "railways$isControlBlocked"(): boolean
public "railways$getBlockedSign"(): integer
public "hasForwardConductor"(): boolean
public "hasBackwardConductor"(): boolean
public "railways$setHandcar"(arg0: boolean): void
public "collectInitiallyOccupiedSignalBlocks"(): void
public "railways$getOccupiedCouplers"(): $Set
public "determineHonk"(arg0: $Level$$Type): void
public "railways$getStress"(): (double)[]
public "railways$setStress"(arg0: (double)[]): void
public "acceleration"(): float
public "tick"(arg0: $Level$$Type): void
public "getLoader"(): $TrainChunkLoader
public "write"(arg0: $DimensionPalette$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public static "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $Map$$Type<($UUID$$Type), ($TrackGraph$$Type)>, arg3: $DimensionPalette$$Type): $Train
public "getOwner"(arg0: $Level$$Type): $LivingEntity
public "crash"(): void
public "disassemble"(arg0: $Direction$$Type, arg1: $BlockPos$$Type): boolean
public "getTotalLength"(): integer
public "countPlayerPassengers"(): integer
get "endpointEdges"(): $Couple<($Couple<($TrackNode)>)>
get "navigationPenalty"(): integer
get "presentDimensions"(): $List<($ResourceKey<($Level)>)>
set "loader"(value: $TrainChunkLoader$$Type)
get "loader"(): $TrainChunkLoader
get "totalLength"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Train$$Type = ($Train);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Train$$Original = $Train;}
declare module "com.simibubi.create.content.kinetics.gauge.GaugeBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$GaugeBlockEntity, $GaugeBlockEntity$$Type} from "com.simibubi.create.content.kinetics.gauge.GaugeBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$DirectionalAxisKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalAxisKineticBlock"
import {$GaugeShaper} from "com.simibubi.create.content.kinetics.gauge.GaugeShaper"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $GaugeBlock extends $DirectionalAxisKineticBlock implements $IBE$$Interface<($GaugeBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "AXIS_ALONG_FIRST_COORDINATE": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "GAUGE": $GaugeShaper

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "getBlockEntityType"(): $BlockEntityType<($GaugeBlockEntity)>
public "getBlockEntityClass"(): $Class<($GaugeBlockEntity)>
public static "stress"(arg0: $BlockBehaviour$Properties$$Type): $GaugeBlock
public "shouldRenderHeadOnFace"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "speed"(arg0: $BlockBehaviour$Properties$$Type): $GaugeBlock
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($GaugeBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($GaugeBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($GaugeBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($GaugeBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $GaugeBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($GaugeBlockEntity)>
get "blockEntityClass"(): $Class<($GaugeBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GaugeBlock$$Type = ($GaugeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GaugeBlock$$Original = $GaugeBlock;}
declare module "com.simibubi.create.content.trains.graph.TrackEdge" {
import {$BezierConnection, $BezierConnection$$Type} from "com.simibubi.create.content.trains.track.BezierConnection"
import {$TrackGraph$$Type} from "com.simibubi.create.content.trains.graph.TrackGraph"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$EdgeData} from "com.simibubi.create.content.trains.graph.EdgeData"
import {$Collection} from "java.util.Collection"
import {$TrackNode, $TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$TrackMaterial, $TrackMaterial$$Type} from "com.simibubi.create.content.trains.track.TrackMaterial"

export class $TrackEdge {
 "node2": $TrackNode
 "node1": $TrackNode

constructor(arg0: $TrackNode$$Type, arg1: $TrackNode$$Type, arg2: $BezierConnection$$Type, arg3: $TrackMaterial$$Type)

public "getTrackMaterial"(): $TrackMaterial
public "getTurn"(): $BezierConnection
public "isTurn"(): boolean
public "isInterDimensional"(): boolean
public "incrementT"(arg0: double, arg1: double): double
public "canTravelTo"(arg0: $TrackEdge$$Type): boolean
public "getEdgeData"(): $EdgeData
public "getDirectionAt"(arg0: double): $Vec3
public "getPositionSmoothed"(arg0: $TrackGraph$$Type, arg1: double): $Vec3
public "getNormalSmoothed"(arg0: $TrackGraph$$Type, arg1: double): $Vec3
public "getIntersection"(arg0: $TrackNode$$Type, arg1: $TrackNode$$Type, arg2: $TrackEdge$$Type, arg3: $TrackNode$$Type, arg4: $TrackNode$$Type): $Collection<((double)[])>
public "getLength"(): double
public "write"(arg0: $DimensionPalette$$Type): $CompoundTag
public static "read"(arg0: $TrackNode$$Type, arg1: $TrackNode$$Type, arg2: $CompoundTag$$Type, arg3: $TrackGraph$$Type, arg4: $DimensionPalette$$Type): $TrackEdge
public "getPosition"(arg0: $TrackGraph$$Type, arg1: double): $Vec3
public "getDirection"(arg0: boolean): $Vec3
public "getNormal"(arg0: $TrackGraph$$Type, arg1: double): $Vec3
get "trackMaterial"(): $TrackMaterial
get "turn"(): $BezierConnection
get "turn"(): boolean
get "interDimensional"(): boolean
get "edgeData"(): $EdgeData
get "length"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackEdge$$Type = ($TrackEdge);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackEdge$$Original = $TrackEdge;}
declare module "com.simibubi.create.content.contraptions.bearing.MechanicalBearingBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$MechanicalBearingBlockEntity, $MechanicalBearingBlockEntity$$Type} from "com.simibubi.create.content.contraptions.bearing.MechanicalBearingBlockEntity"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BearingBlock} from "com.simibubi.create.content.contraptions.bearing.BearingBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $MechanicalBearingBlock extends $BearingBlock implements $IBE$$Interface<($MechanicalBearingBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($MechanicalBearingBlockEntity)>
public "getBlockEntityClass"(): $Class<($MechanicalBearingBlockEntity)>
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($MechanicalBearingBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($MechanicalBearingBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MechanicalBearingBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($MechanicalBearingBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $MechanicalBearingBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($MechanicalBearingBlockEntity)>
get "blockEntityClass"(): $Class<($MechanicalBearingBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalBearingBlock$$Type = ($MechanicalBearingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalBearingBlock$$Original = $MechanicalBearingBlock;}
declare module "com.simibubi.create.content.equipment.potatoCannon.PotatoCannonItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$PotatoCannonItem$Ammo} from "com.simibubi.create.content.equipment.potatoCannon.PotatoCannonItem$Ammo"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$AbstractClientPlayer$$Type} from "net.minecraft.client.player.AbstractClientPlayer"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$CustomArmPoseItem$$Interface} from "com.simibubi.create.foundation.item.CustomArmPoseItem"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$HumanoidModel$ArmPose} from "net.minecraft.client.model.HumanoidModel$ArmPose"
import {$Map} from "java.util.Map"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate} from "java.util.function.Predicate"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ProjectileWeaponItem} from "net.minecraft.world.item.ProjectileWeaponItem"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$IClientItemExtensions$$Type} from "net.neoforged.neoforge.client.extensions.common.IClientItemExtensions"
import {$UseAnim} from "net.minecraft.world.item.UseAnim"
import {$Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $PotatoCannonItem extends $ProjectileWeaponItem implements $CustomArmPoseItem$$Interface {
static readonly "ARROW_ONLY": $Predicate<($ItemStack)>
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "ARROW_OR_FIREWORK": $Predicate<($ItemStack)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "initializeClient"(arg0: $Consumer$$Type<($IClientItemExtensions)>): void
public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "canAttackBlock"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): boolean
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "supportsEnchantment"(arg0: $ItemStack$$Type, arg1: $Holder$$Type<($Enchantment)>): boolean
public "shouldCauseReequipAnimation"(arg0: $ItemStack$$Type, arg1: $ItemStack$$Type, arg2: boolean): boolean
public "getDefaultProjectileRange"(): integer
public static "getAmmo"(arg0: $Player$$Type, arg1: $ItemStack$$Type): $PotatoCannonItem$Ammo
public "getArmPose"(arg0: $ItemStack$$Type, arg1: $AbstractClientPlayer$$Type, arg2: $InteractionHand$$Type): $HumanoidModel$ArmPose
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "isBarVisible"(arg0: $ItemStack$$Type): boolean
public "getBarWidth"(arg0: $ItemStack$$Type): integer
public "getBarColor"(arg0: $ItemStack$$Type): integer
public "onEntitySwing"(arg0: $ItemStack$$Type, arg1: $LivingEntity$$Type, arg2: $InteractionHand$$Type): boolean
public "getUseAnimation"(arg0: $ItemStack$$Type): $UseAnim
public "getAllSupportedProjectiles"(): $Predicate<($ItemStack)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "defaultProjectileRange"(): integer
get "allSupportedProjectiles"(): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotatoCannonItem$$Type = ($PotatoCannonItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotatoCannonItem$$Original = $PotatoCannonItem;}
declare module "com.simibubi.create.content.trains.station.GlobalPackagePort" {
import {$IItemHandlerModifiable$$Type} from "net.neoforged.neoforge.items.IItemHandlerModifiable"
import {$ItemStackHandler} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $GlobalPackagePort {
 "address": StringJS
 "primed": boolean
 "offlineBuffer": $ItemStackHandler

constructor()

public "restoreOfflineBuffer"(arg0: $IItemHandlerModifiable$$Type): void
public "saveOfflineBuffer"(arg0: $IItemHandlerModifiable$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlobalPackagePort$$Type = ($GlobalPackagePort);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GlobalPackagePort$$Original = $GlobalPackagePort;}
declare module "com.simibubi.create.content.redstone.displayLink.source.TrainStatusDisplaySource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $TrainStatusDisplaySource extends $SingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrainStatusDisplaySource$$Type = ($TrainStatusDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrainStatusDisplaySource$$Original = $TrainStatusDisplaySource;}
declare module "com.simibubi.create.content.kinetics.chainDrive.ChainGearshiftBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$ChainDriveBlock$Part} from "com.simibubi.create.content.kinetics.chainDrive.ChainDriveBlock$Part"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ChainDriveBlock} from "com.simibubi.create.content.kinetics.chainDrive.ChainDriveBlock"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $ChainGearshiftBlock extends $ChainDriveBlock {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "CONNECTED_ALONG_FIRST_COORDINATE": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "PART": $Property<($ChainDriveBlock$Part)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getBlockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($KineticBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainGearshiftBlock$$Type = ($ChainGearshiftBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainGearshiftBlock$$Original = $ChainGearshiftBlock;}
declare module "com.simibubi.create.content.decoration.slidingDoor.SlidingDoorBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$DoubleBlockHalf} from "net.minecraft.world.level.block.state.properties.DoubleBlockHalf"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DoorHingeSide, $DoorHingeSide$$Type} from "net.minecraft.world.level.block.state.properties.DoorHingeSide"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IHaveBigOutline$$Interface} from "com.simibubi.create.foundation.block.IHaveBigOutline"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Supplier} from "java.util.function.Supplier"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$DoorBlock} from "net.minecraft.world.level.block.DoorBlock"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$SlidingDoorBlockEntity, $SlidingDoorBlockEntity$$Type} from "com.simibubi.create.content.decoration.slidingDoor.SlidingDoorBlockEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $SlidingDoorBlock extends $DoorBlock implements $IWrenchable$$Interface, $IBE$$Interface<($SlidingDoorBlockEntity)>, $IHaveBigOutline$$Interface {
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "VISIBLE": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "TRAIN_SET_TYPE": $Supplier<($BlockSetType)>
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($DoubleBlockHalf)>
static readonly "UPDATE_ALL": integer
static readonly "HINGE": $EnumProperty<($DoorHingeSide)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DoorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OPEN": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "STONE_SET_TYPE": $Supplier<($BlockSetType)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "GLASS_SET_TYPE": $Supplier<($BlockSetType)>

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $BlockSetType$$Type, arg2: boolean)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public static "stone"(arg0: $BlockBehaviour$Properties$$Type, arg1: boolean): $SlidingDoorBlock
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "glass"(arg0: $BlockBehaviour$Properties$$Type, arg1: boolean): $SlidingDoorBlock
public "setOpen"(arg0: $Entity$$Type, arg1: $Level$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: boolean): void
public static "metal"(arg0: $BlockBehaviour$Properties$$Type, arg1: boolean): $SlidingDoorBlock
public "getBlockEntityType"(): $BlockEntityType<($SlidingDoorBlockEntity)>
public "getBlockEntityClass"(): $Class<($SlidingDoorBlockEntity)>
public static "isDoubleDoor"(arg0: $BlockState$$Type, arg1: $DoorHingeSide$$Type, arg2: $Direction$$Type, arg3: $BlockState$$Type): boolean
public "isFoldingDoor"(): boolean
public "deferUpdate"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): void
public static "isDoorPowered"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getInteractionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($SlidingDoorBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($SlidingDoorBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SlidingDoorBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($SlidingDoorBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $SlidingDoorBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($SlidingDoorBlockEntity)>
get "blockEntityClass"(): $Class<($SlidingDoorBlockEntity)>
get "foldingDoor"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlidingDoorBlock$$Type = ($SlidingDoorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlidingDoorBlock$$Original = $SlidingDoorBlock;}
declare module "com.simibubi.create.content.trains.entity.TravellingPoint$IEdgePointListener" {
import {$BiPredicate, $BiPredicate$$Type, $BiPredicate$$Interface} from "java.util.function.BiPredicate"
import {$TrackEdgePoint, $TrackEdgePoint$$Type} from "com.simibubi.create.content.trains.signal.TrackEdgePoint"
import {$TrackNode, $TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$Pair, $Pair$$Type} from "net.createmod.catnip.data.Pair"
import {$Couple, $Couple$$Type} from "net.createmod.catnip.data.Couple"

export interface $TravellingPoint$IEdgePointListener$$Interface extends $BiPredicate$$Interface<(double), ($Pair<($TrackEdgePoint), ($Couple<($TrackNode)>)>)> {

(arg0: double, arg1: $Pair<($TrackEdgePoint), ($Couple<($TrackNode)>)>): boolean
}

export class $TravellingPoint$IEdgePointListener implements $TravellingPoint$IEdgePointListener$$Interface {
 "negate"(): $BiPredicate<(double), ($Pair<($TrackEdgePoint), ($Couple<($TrackNode)>)>)>
 "and"(arg0: $BiPredicate$$Type<(double), ($Pair<($TrackEdgePoint), ($Couple<($TrackNode)>)>)>): $BiPredicate<(double), ($Pair<($TrackEdgePoint), ($Couple<($TrackNode)>)>)>
 "test"(arg0: double, arg1: $Pair$$Type<($TrackEdgePoint$$Type), ($Couple$$Type<($TrackNode$$Type)>)>): boolean
 "or"(arg0: $BiPredicate$$Type<(double), ($Pair<($TrackEdgePoint), ($Couple<($TrackNode)>)>)>): $BiPredicate<(double), ($Pair<($TrackEdgePoint), ($Couple<($TrackNode)>)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TravellingPoint$IEdgePointListener$$Type = ((arg0: double, arg1: $Pair<($TrackEdgePoint), ($Couple<($TrackNode)>)>) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TravellingPoint$IEdgePointListener$$Original = $TravellingPoint$IEdgePointListener;}
declare module "com.simibubi.create.content.contraptions.piston.MechanicalPistonHeadBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$PistonType} from "net.minecraft.world.level.block.state.properties.PistonType"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $MechanicalPistonHeadBlock extends $WrenchableDirectionalBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "TYPE": $EnumProperty<($PistonType)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPistonHeadBlock$$Type = ($MechanicalPistonHeadBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalPistonHeadBlock$$Original = $MechanicalPistonHeadBlock;}
declare module "com.simibubi.create.content.redstone.link.RedstoneLinkBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$RedstoneLinkBlockEntity, $RedstoneLinkBlockEntity$$Type} from "com.simibubi.create.content.redstone.link.RedstoneLinkBlockEntity"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $RedstoneLinkBlock extends $WrenchableDirectionalBlock implements $IBE$$Interface<($RedstoneLinkBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "RECEIVER": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "toggleMode"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): $InteractionResult
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getBlockEntityType"(): $BlockEntityType<($RedstoneLinkBlockEntity)>
public "updateTransmittedSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): void
public "getBlockEntityClass"(): $Class<($RedstoneLinkBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getDirectSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($RedstoneLinkBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($RedstoneLinkBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($RedstoneLinkBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($RedstoneLinkBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $RedstoneLinkBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($RedstoneLinkBlockEntity)>
get "blockEntityClass"(): $Class<($RedstoneLinkBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneLinkBlock$$Type = ($RedstoneLinkBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneLinkBlock$$Original = $RedstoneLinkBlock;}
declare module "com.simibubi.create.content.logistics.vault.ItemVaultBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ItemVaultBlockEntity, $ItemVaultBlockEntity$$Type} from "com.simibubi.create.content.logistics.vault.ItemVaultBlockEntity"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $ItemVaultBlock extends $Block implements $IWrenchable$$Interface, $IBE$$Interface<($ItemVaultBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "SILENCED_METAL": $SoundType
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "HORIZONTAL_AXIS": $Property<($Direction$Axis)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LARGE": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getBlockEntityType"(): $BlockEntityType<($ItemVaultBlockEntity)>
public static "isLarge"(arg0: $BlockState$$Type): boolean
public "getBlockEntityClass"(): $Class<($ItemVaultBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "isVault"(arg0: $BlockState$$Type): boolean
public static "getVaultBlockAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "getSoundType"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): $SoundType
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ItemVaultBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ItemVaultBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ItemVaultBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ItemVaultBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ItemVaultBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ItemVaultBlockEntity)>
get "blockEntityClass"(): $Class<($ItemVaultBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemVaultBlock$$Type = ($ItemVaultBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemVaultBlock$$Original = $ItemVaultBlock;}
declare module "com.simibubi.create.content.logistics.vault.ItemVaultMountedStorageType" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ItemVaultMountedStorage} from "com.simibubi.create.content.logistics.vault.ItemVaultMountedStorage"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MountedItemStorageType} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageType"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ItemVaultMountedStorageType extends $MountedItemStorageType<($ItemVaultMountedStorage)> {
readonly "codec": $MapCodec<(T)>
static readonly "CODEC": $Codec<($MountedItemStorageType<(never)>)>
readonly "holder": $Holder$Reference<($MountedItemStorageType<(never)>)>
static readonly "REGISTRY": $SimpleRegistry<($Block), ($MountedItemStorageType<(never)>)>

constructor()

public "mount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): $ItemVaultMountedStorage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemVaultMountedStorageType$$Type = ($ItemVaultMountedStorageType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemVaultMountedStorageType$$Original = $ItemVaultMountedStorageType;}
declare module "com.simibubi.create.content.contraptions.piston.MechanicalPistonBlockEntity" {
import {$AbstractContraptionEntity} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$LinearActuatorBlockEntity} from "com.simibubi.create.content.contraptions.piston.LinearActuatorBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $MechanicalPistonBlockEntity extends $LinearActuatorBlockEntity {
 "running": boolean
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "offset": float
 "assembleNextTick": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "needsContraption": boolean
 "preventSpeedUpdate": integer
 "movedContraption": $AbstractContraptionEntity
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getMovementSpeed"(): float
public "assemble"(): void
public "disassemble"(): void
get "movementSpeed"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPistonBlockEntity$$Type = ($MechanicalPistonBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalPistonBlockEntity$$Original = $MechanicalPistonBlockEntity;}
declare module "com.simibubi.create.content.trains.track.TrackBlockEntity" {
import {$BezierConnection, $BezierConnection$$Type} from "com.simibubi.create.content.trains.track.BezierConnection"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$SlabBlock, $SlabBlock$$Type} from "net.minecraft.world.level.block.SlabBlock"
import {$Map} from "java.util.Map"
import {$List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$IHasTrackCasing$$Interface} from "com.railwayteam.railways.mixin_interfaces.IHasTrackCasing"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$IMergeableBE$$Interface} from "com.simibubi.create.foundation.blockEntity.IMergeableBE"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$TrackBlockEntityTilt} from "com.simibubi.create.content.trains.track.TrackBlockEntityTilt"
import {$AABB} from "net.minecraft.world.phys.AABB"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TrackBlockEntity extends $SmartBlockEntity implements $TransformableBlockEntity$$Interface, $IMergeableBE$$Interface, $IHasTrackCasing$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "boundLocation": $Pair<($ResourceKey<($Level)>), ($BlockPos)>
 "tilt": $TrackBlockEntityTilt

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "hasInteractableConnections"(): boolean
public "manageFakeTracksAlong"(arg0: $BezierConnection$$Type, arg1: boolean): void
public "getTrackCasing"(): $SlabBlock
public "isTilted"(): boolean
public "addConnection"(arg0: $BezierConnection$$Type): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public "getRenderBoundingBox"(): $AABB
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "removeConnection"(arg0: $BlockPos$$Type): void
public "validateConnections"(): void
public "removeInboundConnections"(arg0: boolean): void
public "isAlternate"(): boolean
public "setAlternate"(arg0: boolean): void
public "setTrackCasing"(arg0: $SlabBlock$$Type): void
public "tick"(): void
public "bind"(arg0: $ResourceKey$$Type<($Level)>, arg1: $BlockPos$$Type): void
public "remove"(): void
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "initialize"(): void
public "accept"(arg0: $BlockEntity$$Type): void
public "invalidate"(): void
public "getConnections"(): $Map<($BlockPos), ($BezierConnection)>
public "getModelData"(): $ModelData
public static "setAlternateModel"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: boolean): boolean
public static "getTrackCasing"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $SlabBlock
public static "isAlternate"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public static "setTrackCasing"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $SlabBlock$$Type): void
get "trackCasing"(): $SlabBlock
get "tilted"(): boolean
get "renderBoundingBox"(): $AABB
get "alternate"(): boolean
set "alternate"(value: boolean)
set "trackCasing"(value: $SlabBlock$$Type)
get "connections"(): $Map<($BlockPos), ($BezierConnection)>
get "modelData"(): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackBlockEntity$$Type = ($TrackBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackBlockEntity$$Original = $TrackBlockEntity;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$ChuteType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$ChuteType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$ChuteType$$Type = ($AllArmInteractionPointTypes$ChuteType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$ChuteType$$Original = $AllArmInteractionPointTypes$ChuteType;}
declare module "com.simibubi.create.content.equipment.zapper.terrainzapper.TerrainBrushes" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$Brush} from "com.simibubi.create.content.equipment.zapper.terrainzapper.Brush"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $TerrainBrushes extends $Enum<($TerrainBrushes)> implements $StringRepresentable$$Interface {
static readonly "Sphere": $TerrainBrushes
static readonly "Cylinder": $TerrainBrushes
static readonly "CODEC": $Codec<($TerrainBrushes)>
static readonly "Cuboid": $TerrainBrushes
static readonly "Cluster": $TerrainBrushes
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($TerrainBrushes)>
static readonly "Surface": $TerrainBrushes

public "get"(): $Brush
public static "values"(): ($TerrainBrushes)[]
public static "valueOf"(arg0: StringJS): $TerrainBrushes
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TerrainBrushes$$Type = (("cuboid") | ("sphere") | ("cylinder") | ("surface") | ("cluster"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TerrainBrushes$$Original = $TerrainBrushes;}
declare module "com.simibubi.create.content.kinetics.base.KineticBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IRotate$SpeedLevel} from "com.simibubi.create.content.kinetics.base.IRotate$SpeedLevel"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$IRotate$$Interface} from "com.simibubi.create.content.kinetics.base.IRotate"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $KineticBlock extends $Block implements $IRotate$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "updateIndirectNeighbourShapes"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: integer, arg4: integer): void
public "getMinimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
public "hideStressImpact"(): boolean
public "showCapacityWithAnnotation"(): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
get "minimumRequiredSpeedLevel"(): $IRotate$SpeedLevel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KineticBlock$$Type = ($KineticBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KineticBlock$$Original = $KineticBlock;}
declare module "com.simibubi.create.content.equipment.toolbox.ToolboxMountedStorage" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ToolboxBlockEntity$$Type} from "com.simibubi.create.content.equipment.toolbox.ToolboxBlockEntity"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ToolboxInventory} from "com.simibubi.create.content.equipment.toolbox.ToolboxInventory"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$WrapperMountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.WrapperMountedItemStorage"
import {$MountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorage"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MountedItemStorageType} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageType"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ToolboxMountedStorage extends $WrapperMountedItemStorage<($ToolboxInventory)> {
static readonly "CODEC": $MapCodec<($ToolboxMountedStorage)>
readonly "type": $MountedItemStorageType<($MountedItemStorage)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MountedItemStorage)>

public "handleInteraction"(arg0: $ServerPlayer$$Type, arg1: $Contraption$$Type, arg2: $StructureTemplate$StructureBlockInfo$$Type): boolean
public static "fromLegacy"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): $ToolboxMountedStorage
public static "fromToolbox"(arg0: $ToolboxBlockEntity$$Type): $ToolboxMountedStorage
public "unmount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolboxMountedStorage$$Type = ($ToolboxMountedStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ToolboxMountedStorage$$Original = $ToolboxMountedStorage;}
declare module "com.simibubi.create.content.kinetics.waterwheel.WaterWheelBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$WaterWheelBlockEntity, $WaterWheelBlockEntity$$Type} from "com.simibubi.create.content.kinetics.waterwheel.WaterWheelBlockEntity"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DirectionalKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalKineticBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $WaterWheelBlock extends $DirectionalKineticBlock implements $IBE$$Interface<($WaterWheelBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getParticleTargetRadius"(): float
public "getParticleInitialRadius"(): float
public "hideStressImpact"(): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "isFlammable"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($WaterWheelBlockEntity)>
public "getBlockEntityClass"(): $Class<($WaterWheelBlockEntity)>
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($WaterWheelBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($WaterWheelBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($WaterWheelBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($WaterWheelBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $WaterWheelBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "particleTargetRadius"(): float
get "particleInitialRadius"(): float
get "blockEntityType"(): $BlockEntityType<($WaterWheelBlockEntity)>
get "blockEntityClass"(): $Class<($WaterWheelBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterWheelBlock$$Type = ($WaterWheelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WaterWheelBlock$$Original = $WaterWheelBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.NixieTubeDisplaySource" {
import {$SingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.SingleLineDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $NixieTubeDisplaySource extends $SingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NixieTubeDisplaySource$$Type = ($NixieTubeDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NixieTubeDisplaySource$$Original = $NixieTubeDisplaySource;}
declare module "com.simibubi.create.content.decoration.steamWhistle.WhistleBlockEntity" {
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidTankBlockEntity} from "com.simibubi.create.content.fluids.tank.FluidTankBlockEntity"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$IHaveGoggleInformation$$Interface} from "com.simibubi.create.api.equipment.goggles.IHaveGoggleInformation"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$IFluidHandler$$Type} from "net.neoforged.neoforge.fluids.capability.IFluidHandler"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WhistleBlockEntity extends $SmartBlockEntity implements $IHaveGoggleInformation$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $WeakReference<($FluidTankBlockEntity)>
 "animation": $LerpedFloat

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addToGoggleTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getPitchId"(): integer
public "updatePitch"(): void
public "tick"(): void
public "getTank"(): $FluidTankBlockEntity
public "containedFluidTooltip"(arg0: $List$$Type<($Component$$Type)>, arg1: boolean, arg2: $IFluidHandler$$Type): boolean
public "getIcon"(arg0: boolean): $ItemStack
get "pitchId"(): integer
get "tank"(): $FluidTankBlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WhistleBlockEntity$$Type = ($WhistleBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WhistleBlockEntity$$Original = $WhistleBlockEntity;}
declare module "com.simibubi.create.content.trains.observer.TrackObserverBlockEntity" {
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$UUID} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$TrackTargetingBehaviour} from "com.simibubi.create.content.trains.track.TrackTargetingBehaviour"
import {$TransformableBlockEntity$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlockEntity"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$FilteringBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.filtering.FilteringBehaviour"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$TrackObserver} from "com.simibubi.create.content.trains.observer.TrackObserver"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TrackObserverBlockEntity extends $SmartBlockEntity implements $TransformableBlockEntity$$Interface, $Clearable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "passingTrainUUID": $UUID
 "computerBehaviour": $AbstractComputerBehaviour
 "edgePoint": $TrackTargetingBehaviour<($TrackObserver)>

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "clearContent"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getObserver"(): $TrackObserver
public "isBlockPowered"(): boolean
public "tick"(): void
public "getFilter"(): $ItemStack
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "invalidate"(): void
public "createFilter"(): $FilteringBehaviour
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public static "tryClear"(arg0: any): void
get "observer"(): $TrackObserver
get "blockPowered"(): boolean
get "filter"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackObserverBlockEntity$$Type = ($TrackObserverBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackObserverBlockEntity$$Original = $TrackObserverBlockEntity;}
declare module "com.simibubi.create.content.trains.bogey.AbstractBogeyBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BogeyStyle, $BogeyStyle$$Type} from "com.simibubi.create.content.trains.bogey.BogeyStyle"
import {$CachedRenderBBBlockEntity} from "com.simibubi.create.foundation.blockEntity.CachedRenderBBBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractBogeyBlockEntity extends $CachedRenderBBBlockEntity {
static readonly "BOGEY_STYLE_KEY": StringJS
static readonly "BOGEY_DATA_KEY": StringJS
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "animate"(arg0: float): void
public "setBogeyStyle"(arg0: $BogeyStyle$$Type): void
public "getBogeyData"(): $CompoundTag
public "setBogeyData"(arg0: $CompoundTag$$Type): void
public "getVirtualAngle"(arg0: float): float
public "getDefaultStyle"(): $BogeyStyle
public "getStyle"(): $BogeyStyle
set "bogeyStyle"(value: $BogeyStyle$$Type)
get "bogeyData"(): $CompoundTag
set "bogeyData"(value: $CompoundTag$$Type)
get "defaultStyle"(): $BogeyStyle
get "style"(): $BogeyStyle
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractBogeyBlockEntity$$Type = ($AbstractBogeyBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractBogeyBlockEntity$$Original = $AbstractBogeyBlockEntity;}
declare module "com.simibubi.create.content.logistics.funnel.FunnelItem" {
import {$PlayerInteractEvent$RightClickBlock$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$RightClickBlock"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $FunnelItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public static "funnelItemAlwaysPlacesWhenUsed"(arg0: $PlayerInteractEvent$RightClickBlock$$Type): void
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunnelItem$$Type = ($FunnelItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FunnelItem$$Original = $FunnelItem;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.AllArmInteractionPointTypes$PackagerType" {
import {$ArmInteractionPointType} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPointType"
import {$ArmInteractionPoint} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmInteractionPoint"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllArmInteractionPointTypes$PackagerType extends $ArmInteractionPointType {
static readonly "SORTED_TYPES_VIEW": $List<($ArmInteractionPointType)>

constructor()

public "canCreatePoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "createPoint"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ArmInteractionPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllArmInteractionPointTypes$PackagerType$$Type = ($AllArmInteractionPointTypes$PackagerType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllArmInteractionPointTypes$PackagerType$$Original = $AllArmInteractionPointTypes$PackagerType;}
declare module "com.simibubi.create.content.trains.station.StationBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$StationBlockEntity, $StationBlockEntity$$Type} from "com.simibubi.create.content.trains.station.StationBlockEntity"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $StationBlock extends $Block implements $IBE$$Interface<($StationBlockEntity)>, $IWrenchable$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "ASSEMBLING": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($StationBlockEntity)>
public "getBlockEntityClass"(): $Class<($StationBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($StationBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($StationBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($StationBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($StationBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $StationBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($StationBlockEntity)>
get "blockEntityClass"(): $Class<($StationBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StationBlock$$Type = ($StationBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StationBlock$$Original = $StationBlock;}
declare module "com.simibubi.create.content.logistics.filter.AttributeFilterItem" {
import {$FilterItemStack} from "com.simibubi.create.content.logistics.filter.FilterItemStack"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$List} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$FilterItem} from "com.simibubi.create.content.logistics.filter.FilterItem"
import {$Component} from "net.minecraft.network.chat.Component"
import {$DataComponentType} from "net.minecraft.core.component.DataComponentType"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$Item} from "net.minecraft.world.item.Item"

export class $AttributeFilterItem extends $FilterItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "makeSummary"(arg0: $ItemStack$$Type): $List<($Component)>
public "makeStackWrapper"(arg0: $ItemStack$$Type): $FilterItemStack
public "getFilterItems"(arg0: $ItemStack$$Type): ($ItemStack)[]
public "getComponentType"(): $DataComponentType<(never)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "componentType"(): $DataComponentType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeFilterItem$$Type = ($AttributeFilterItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttributeFilterItem$$Original = $AttributeFilterItem;}
declare module "com.simibubi.create.content.logistics.packagerLink.LogisticallyLinkedBehaviour" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection} from "java.util.Collection"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$IdentifiedInventory$$Type} from "com.simibubi.create.content.logistics.packager.IdentifiedInventory"
import {$BehaviourType} from "com.simibubi.create.foundation.blockEntity.behaviour.BehaviourType"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity, $SmartBlockEntity$$Type} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$AtomicInteger} from "java.util.concurrent.atomic.AtomicInteger"
import {$BlockEntityBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$PackagingRequest} from "com.simibubi.create.content.logistics.packager.PackagingRequest"
import {$PackageOrderWithCrafts$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts"
import {$InventorySummary} from "com.simibubi.create.content.logistics.packager.InventorySummary"
import {$MutableBoolean$$Type} from "org.apache.commons.lang3.mutable.MutableBoolean"
import {$PackagerBlockEntity} from "com.simibubi.create.content.logistics.packager.PackagerBlockEntity"
import {$ItemStackHandler$$Type} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $LogisticallyLinkedBehaviour extends $BlockEntityBehaviour {
static readonly "LINK_ID_GENERATOR": $AtomicInteger
 "linkId": integer
 "blockEntity": $SmartBlockEntity
 "freqId": $UUID
 "redstonePower": integer
static readonly "TYPE": $BehaviourType<($LogisticallyLinkedBehaviour)>

constructor(arg0: $SmartBlockEntity$$Type, arg1: boolean)

public "deductFromAccurateSummary"(arg0: $ItemStackHandler$$Type): void
public "processRequest"(arg0: $ItemStack$$Type, arg1: integer, arg2: StringJS, arg3: integer, arg4: $MutableBoolean$$Type, arg5: integer, arg6: $PackageOrderWithCrafts$$Type, arg7: $IdentifiedInventory$$Type): $Pair<($PackagerBlockEntity), ($PackagingRequest)>
public "mayAdministrate"(arg0: $Player$$Type): boolean
public static "getAllPresent"(arg0: $UUID$$Type, arg1: boolean, arg2: boolean): $Collection<($LogisticallyLinkedBehaviour)>
public static "getAllPresent"(arg0: $UUID$$Type, arg1: boolean): $Collection<($LogisticallyLinkedBehaviour)>
public "lazyTick"(): void
public "isSafeNBT"(): boolean
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "redstonePowerChanged"(arg0: integer): void
public "mayInteractMessage"(arg0: $Player$$Type): boolean
public static "isValidLink"(arg0: $LogisticallyLinkedBehaviour$$Type): boolean
public static "keepAlive"(arg0: $LogisticallyLinkedBehaviour$$Type): void
public static "remove"(arg0: $LogisticallyLinkedBehaviour$$Type): void
public "initialize"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "destroy"(): void
public "getType"(): $BehaviourType<(never)>
public "unload"(): void
public "getSummary"(arg0: $IdentifiedInventory$$Type): $InventorySummary
public "mayInteract"(arg0: $Player$$Type): boolean
get "safeNBT"(): boolean
get "type"(): $BehaviourType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogisticallyLinkedBehaviour$$Type = ($LogisticallyLinkedBehaviour);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LogisticallyLinkedBehaviour$$Original = $LogisticallyLinkedBehaviour;}
declare module "com.simibubi.create.content.trains.entity.TravellingPoint$IPortalListener" {
import {$TrackNodeLocation, $TrackNodeLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$Couple, $Couple$$Type} from "net.createmod.catnip.data.Couple"

export interface $TravellingPoint$IPortalListener$$Interface extends $Predicate$$Interface<($Couple<($TrackNodeLocation)>)> {

(arg0: $Couple<($TrackNodeLocation)>): boolean
}

export class $TravellingPoint$IPortalListener implements $TravellingPoint$IPortalListener$$Interface {
static "not"<T>(arg0: $Predicate$$Type<($Couple<($TrackNodeLocation)>)>): $Predicate<($Couple<($TrackNodeLocation)>)>
static "isEqual"<T>(arg0: any): $Predicate<($Couple<($TrackNodeLocation)>)>
 "negate"(): $Predicate<($Couple<($TrackNodeLocation)>)>
 "and"(arg0: $Predicate$$Type<($Couple<($TrackNodeLocation)>)>): $Predicate<($Couple<($TrackNodeLocation)>)>
 "test"(arg0: $Couple$$Type<($TrackNodeLocation$$Type)>): boolean
 "or"(arg0: $Predicate$$Type<($Couple<($TrackNodeLocation)>)>): $Predicate<($Couple<($TrackNodeLocation)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TravellingPoint$IPortalListener$$Type = ((arg0: $Couple<($TrackNodeLocation)>) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TravellingPoint$IPortalListener$$Original = $TravellingPoint$IPortalListener;}
declare module "com.simibubi.create.content.decoration.palettes.ConnectedPillarBlock" {
import {$RotatedPillarBlock} from "net.minecraft.world.level.block.RotatedPillarBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$LayeredBlock} from "com.simibubi.create.content.decoration.palettes.LayeredBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis, $Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ConnectedPillarBlock extends $LayeredBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RotatedPillarBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "SOUTH": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "EAST": $BooleanProperty
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "setConnection"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: boolean): $BlockState
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "getConnection"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public static "connection"(arg0: $Direction$Axis$$Type, arg1: $Direction$$Type): $BooleanProperty
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConnectedPillarBlock$$Type = ($ConnectedPillarBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConnectedPillarBlock$$Original = $ConnectedPillarBlock;}
declare module "com.simibubi.create.content.logistics.crate.CrateBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CrateBlockEntity extends $SmartBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrateBlockEntity$$Type = ($CrateBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CrateBlockEntity$$Original = $CrateBlockEntity;}
declare module "com.simibubi.create.content.redstone.diodes.BrassDiodeBlockEntity" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$ClipboardCloneable$$Interface} from "com.simibubi.create.content.equipment.clipboard.ClipboardCloneable"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BrassDiodeBlockEntity extends $SmartBlockEntity implements $ClipboardCloneable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isIdle"(): boolean
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "getClipboardKey"(): StringJS
public "writeToClipboard"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type, arg2: $Direction$$Type): boolean
public "readFromClipboard"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type, arg2: $Player$$Type, arg3: $Direction$$Type, arg4: boolean): boolean
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "getProgress"(): float
get "idle"(): boolean
get "clipboardKey"(): StringJS
get "progress"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrassDiodeBlockEntity$$Type = ($BrassDiodeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BrassDiodeBlockEntity$$Original = $BrassDiodeBlockEntity;}
declare module "com.simibubi.create.content.equipment.bell.HauntedBellBlockEntity" {
import {$PartialModel} from "dev.engine_room.flywheel.lib.model.baked.PartialModel"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$AbstractBellBlockEntity} from "com.simibubi.create.content.equipment.bell.AbstractBellBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HauntedBellBlockEntity extends $AbstractBellBlockEntity {
static readonly "EFFECT_TICKS": integer
 "effectTicks": integer
static readonly "DISTANCE": integer
static readonly "RECHARGE_TICKS": integer
 "ringDirection": $Direction
 "ringingTicks": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "isRinging": boolean
static readonly "RING_DURATION": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getBellModel"(): $PartialModel
public "ring"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "tick"(): void
get "bellModel"(): $PartialModel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HauntedBellBlockEntity$$Type = ($HauntedBellBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HauntedBellBlockEntity$$Original = $HauntedBellBlockEntity;}
declare module "com.simibubi.create.content.redstone.link.controller.LecternControllerBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LecternControllerBlockEntity extends $SmartBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "hasUser"(): boolean
public static "playerIsUsingLectern"(arg0: $Player$$Type): boolean
public "isUsedBy"(arg0: $Player$$Type): boolean
public "tryStopUsing"(arg0: $Player$$Type): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getController"(): $ItemStack
public "setController"(arg0: $ItemStack$$Type): void
public static "playerInRange"(arg0: $Player$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): boolean
public "dropController"(arg0: $BlockState$$Type): void
public "tryStartUsing"(arg0: $Player$$Type): void
public "swapControllers"(arg0: $ItemStack$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type, arg3: $BlockState$$Type): void
public "tick"(): void
get "controller"(): $ItemStack
set "controller"(value: $ItemStack$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LecternControllerBlockEntity$$Type = ($LecternControllerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LecternControllerBlockEntity$$Original = $LecternControllerBlockEntity;}
declare module "com.simibubi.create.content.fluids.tank.storage.FluidTankMountedStorageType" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$MountedFluidStorageType} from "com.simibubi.create.api.contraption.storage.fluid.MountedFluidStorageType"
import {$SimpleRegistry} from "com.simibubi.create.api.registry.SimpleRegistry"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidTankMountedStorage} from "com.simibubi.create.content.fluids.tank.storage.FluidTankMountedStorage"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FluidTankMountedStorageType extends $MountedFluidStorageType<($FluidTankMountedStorage)> {
readonly "codec": $MapCodec<(T)>
static readonly "CODEC": $Codec<($MountedFluidStorageType<(never)>)>
static readonly "REGISTRY": $SimpleRegistry<($Block), ($MountedFluidStorageType<(never)>)>

constructor()

public "mount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): $FluidTankMountedStorage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankMountedStorageType$$Type = ($FluidTankMountedStorageType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTankMountedStorageType$$Original = $FluidTankMountedStorageType;}
declare module "com.simibubi.create.content.schematics.SchematicItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$List$$Type} from "java.util.List"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$StructureTemplate} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate"
import {$StructurePlaceSettings} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"

export class $SchematicItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public static "loadSchematic"(arg0: $Level$$Type, arg1: $ItemStack$$Type): $StructureTemplate
public static "writeSize"(arg0: $Level$$Type, arg1: $ItemStack$$Type): void
public static "getSettings"(arg0: $ItemStack$$Type, arg1: boolean): $StructurePlaceSettings
public static "getSettings"(arg0: $ItemStack$$Type): $StructurePlaceSettings
public static "create"(arg0: $Level$$Type, arg1: StringJS, arg2: StringJS): $ItemStack
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicItem$$Type = ($SchematicItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicItem$$Original = $SchematicItem;}
declare module "com.simibubi.create.content.contraptions.MountedStorageManager" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$MountedFluidStorageWrapper} from "com.simibubi.create.api.contraption.storage.fluid.MountedFluidStorageWrapper"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$MountedItemStorageWrapper} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageWrapper"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$CombinedInvWrapper} from "net.neoforged.neoforge.items.wrapper.CombinedInvWrapper"
import {$ImmutableMap} from "com.google.common.collect.ImmutableMap"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$MountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorage"
import {$AbstractContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IItemHandlerModifiable$$Type} from "net.neoforged.neoforge.items.IItemHandlerModifiable"
import {$MountedStorageSyncPacket$$Type} from "com.simibubi.create.content.contraptions.MountedStorageSyncPacket"
import {$IFuelInventory$$Interface} from "com.railwayteam.railways.mixin_interfaces.IFuelInventory"
import {$StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MountedStorageManager implements $IFuelInventory$$Interface {
constructor()

public "attachExternal"(arg0: $IItemHandlerModifiable$$Type): void
public "addBlock"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: $BlockEntity$$Type): void
public "getFluids"(): $MountedFluidStorageWrapper
public "handleSync"(arg0: $MountedStorageSyncPacket$$Type, arg1: $AbstractContraptionEntity$$Type): void
public "getAllItemStorages"(): $ImmutableMap<($BlockPos), ($MountedItemStorage)>
public "railways$getFluidFuels"(): $MountedFluidStorageWrapper
public "handlePlayerStorageInteraction"(arg0: $Contraption$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type): boolean
public "getFuelItems"(): $MountedItemStorageWrapper
public "getMountedItems"(): $MountedItemStorageWrapper
public "tick"(arg0: $AbstractContraptionEntity$$Type): void
public "initialize"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean, arg3: $Contraption$$Type): void
public "unmount"(arg0: $Level$$Type, arg1: $StructureTemplate$StructureBlockInfo$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): void
public "getAllItems"(): $CombinedInvWrapper
get "fluids"(): $MountedFluidStorageWrapper
get "allItemStorages"(): $ImmutableMap<($BlockPos), ($MountedItemStorage)>
get "fuelItems"(): $MountedItemStorageWrapper
get "mountedItems"(): $MountedItemStorageWrapper
get "allItems"(): $CombinedInvWrapper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MountedStorageManager$$Type = ($MountedStorageManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MountedStorageManager$$Original = $MountedStorageManager;}
declare module "com.simibubi.create.content.decoration.CardboardBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $CardboardBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "HORIZONTAL_AXIS": $Property<($Direction$Axis)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getFlammability"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "getFireSpreadSpeed"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CardboardBlock$$Type = ($CardboardBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CardboardBlock$$Original = $CardboardBlock;}
declare module "com.simibubi.create.content.kinetics.deployer.ItemApplicationRecipeParams" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ProcessingRecipeParams} from "com.simibubi.create.content.processing.recipe.ProcessingRecipeParams"

export class $ItemApplicationRecipeParams extends $ProcessingRecipeParams {
static "CODEC": $MapCodec<($ItemApplicationRecipeParams)>
static "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemApplicationRecipeParams)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemApplicationRecipeParams$$Type = ($ItemApplicationRecipeParams);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemApplicationRecipeParams$$Original = $ItemApplicationRecipeParams;}
declare module "com.simibubi.create.content.processing.recipe.StandardProcessingRecipe" {
import {$ProcessingRecipe} from "com.simibubi.create.content.processing.recipe.ProcessingRecipe"
import {$RecipeInput} from "net.minecraft.world.item.crafting.RecipeInput"
import {$IRecipeTypeInfo$$Type} from "com.simibubi.create.foundation.recipe.IRecipeTypeInfo"
import {$ProcessingRecipeParams, $ProcessingRecipeParams$$Type} from "com.simibubi.create.content.processing.recipe.ProcessingRecipeParams"

export class $StandardProcessingRecipe<T extends $RecipeInput> extends $ProcessingRecipe<(T), ($ProcessingRecipeParams)> {
constructor(arg0: $IRecipeTypeInfo$$Type, arg1: $ProcessingRecipeParams$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StandardProcessingRecipe$$Type<T> = ($StandardProcessingRecipe<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StandardProcessingRecipe$$Original<T> = $StandardProcessingRecipe<(T)>;}
declare module "com.simibubi.create.content.processing.burner.BlazeBurnerBlockEntity" {
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$StockTickerBlockEntity} from "com.simibubi.create.content.logistics.stockTicker.StockTickerBlockEntity"
import {$BlazeBurnerBlockEntity$FuelType} from "com.simibubi.create.content.processing.burner.BlazeBurnerBlockEntity$FuelType"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlazeBurnerBlock$HeatLevel} from "com.simibubi.create.content.processing.burner.BlazeBurnerBlock$HeatLevel"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlazeBurnerBlockEntity extends $SmartBlockEntity {
 "stockKeeper": boolean
 "headAnimation": $LerpedFloat
 "goggles": boolean
static readonly "INSERTION_THRESHOLD": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hat": boolean
static readonly "MAX_HEAT_CAPACITY": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getActiveFuel"(): $BlazeBurnerBlockEntity$FuelType
public "getRemainingBurnTime"(): integer
public "getHeatLevelFromBlock"(): $BlazeBurnerBlock$HeatLevel
public "isValidBlockAbove"(): boolean
public "getHeatLevelForRender"(): $BlazeBurnerBlock$HeatLevel
public "spawnParticleBurst"(arg0: boolean): void
public "updateBlockState"(): void
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "lazyTick"(): void
public static "getStockTicker"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): $StockTickerBlockEntity
public "isCreativeFuel"(arg0: $ItemStack$$Type): boolean
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "isCreative"(): boolean
get "activeFuel"(): $BlazeBurnerBlockEntity$FuelType
get "remainingBurnTime"(): integer
get "heatLevelFromBlock"(): $BlazeBurnerBlock$HeatLevel
get "validBlockAbove"(): boolean
get "heatLevelForRender"(): $BlazeBurnerBlock$HeatLevel
get "creative"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlazeBurnerBlockEntity$$Type = ($BlazeBurnerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlazeBurnerBlockEntity$$Original = $BlazeBurnerBlockEntity;}
declare module "com.simibubi.create.content.redstone.displayLink.source.StatTrackingDisplaySource" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$ScoreboardDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.ScoreboardDisplaySource"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $StatTrackingDisplaySource extends $ScoreboardDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatTrackingDisplaySource$$Type = ($StatTrackingDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StatTrackingDisplaySource$$Original = $StatTrackingDisplaySource;}
declare module "com.simibubi.create.content.redstone.displayLink.target.DisplayTargetStats" {
import {$Record} from "java.lang.Record"
import {$DisplayTarget, $DisplayTarget$$Type} from "com.simibubi.create.api.behaviour.display.DisplayTarget"

export class $DisplayTargetStats extends $Record {
constructor(maxRows: integer, maxColumns: integer, type: $DisplayTarget$$Type)

public "maxRows"(): integer
public "maxColumns"(): integer
public "type"(): $DisplayTarget
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayTargetStats$$Type = ({"type"?: $DisplayTarget$$Type, "maxRows"?: integer, "maxColumns"?: integer}) | ([type?: $DisplayTarget$$Type, maxRows?: integer, maxColumns?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DisplayTargetStats$$Original = $DisplayTargetStats;}
declare module "com.simibubi.create.content.redstone.displayLink.source.RedstonePowerDisplaySource" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$PercentOrProgressBarDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.PercentOrProgressBarDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $RedstonePowerDisplaySource extends $PercentOrProgressBarDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstonePowerDisplaySource$$Type = ($RedstonePowerDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstonePowerDisplaySource$$Original = $RedstonePowerDisplaySource;}
declare module "com.simibubi.create.content.processing.burner.BlazeBurnerBlockItem" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"

export class $BlazeBurnerBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "registerBlocks"(arg0: $Map$$Type<($Block$$Type), ($Item$$Type)>, arg1: $Item$$Type): void
public static "withBlaze"(arg0: $Block$$Type, arg1: $Item$Properties$$Type): $BlazeBurnerBlockItem
public "hasCapturedBlaze"(): boolean
public static "empty"(arg0: $Item$Properties$$Type): $BlazeBurnerBlockItem
public "getDescriptionId"(): StringJS
public "interactLivingEntity"(arg0: $ItemStack$$Type, arg1: $Player$$Type, arg2: $LivingEntity$$Type, arg3: $InteractionHand$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlazeBurnerBlockItem$$Type = ($BlazeBurnerBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlazeBurnerBlockItem$$Original = $BlazeBurnerBlockItem;}
declare module "com.simibubi.create.content.processing.sequenced.SequencedRecipe" {
import {$ProcessingRecipe, $ProcessingRecipe$$Type} from "com.simibubi.create.content.processing.recipe.ProcessingRecipe"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$IAssemblyRecipe} from "com.simibubi.create.content.processing.sequenced.IAssemblyRecipe"

export class $SequencedRecipe<T extends $ProcessingRecipe<(object), (object)>> {
static readonly "CODEC": $Codec<($SequencedRecipe<(never)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($SequencedRecipe<(never)>)>

constructor(arg0: T)

public "getRecipe"(): T
public "getAsAssemblyRecipe"(): $IAssemblyRecipe
get "recipe"(): T
get "asAssemblyRecipe"(): $IAssemblyRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencedRecipe$$Type<T> = ($SequencedRecipe<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SequencedRecipe$$Original<T> = $SequencedRecipe<(T)>;}
declare module "com.simibubi.create.content.redstone.DirectedDirectionalBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$TransformableBlock$$Interface} from "com.simibubi.create.api.contraption.transformable.TransformableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DirectedDirectionalBlock extends $HorizontalDirectionalBlock implements $IWrenchable$$Interface, $TransformableBlock$$Interface {
static readonly "TARGET": $EnumProperty<($AttachFace)>
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DirectedDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "getTargetDirection"(arg0: $BlockState$$Type): $Direction
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "transform"(arg0: $BlockState$$Type, arg1: $StructureTransform$$Type): $BlockState
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectedDirectionalBlock$$Type = ($DirectedDirectionalBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectedDirectionalBlock$$Original = $DirectedDirectionalBlock;}
declare module "com.simibubi.create.content.contraptions.AbstractContraptionEntity$ContraptionRotationState" {
import {$Matrix3d} from "com.simibubi.create.foundation.collision.Matrix3d"

export class $AbstractContraptionEntity$ContraptionRotationState {
 "xRotation": float
 "secondYRotation": float
 "zRotation": float
static readonly "NONE": $AbstractContraptionEntity$ContraptionRotationState
 "yRotation": float

constructor()

public "getYawOffset"(): float
public "asMatrix"(): $Matrix3d
public "hasVerticalRotation"(): boolean
get "yawOffset"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractContraptionEntity$ContraptionRotationState$$Type = ($AbstractContraptionEntity$ContraptionRotationState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractContraptionEntity$ContraptionRotationState$$Original = $AbstractContraptionEntity$ContraptionRotationState;}
declare module "com.simibubi.create.content.decoration.MetalScaffoldingBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ScaffoldingBlock} from "net.minecraft.world.level.block.ScaffoldingBlock"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $MetalScaffoldingBlock extends $ScaffoldingBlock implements $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "DISTANCE": $IntegerProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($ScaffoldingBlock)>
static readonly "STABILITY_MAX_DISTANCE": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "BOTTOM": $BooleanProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "hidesNeighborFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $Direction$$Type): boolean
public "supportsExternalFaceHiding"(arg0: $BlockState$$Type): boolean
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "isScaffolding"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $LivingEntity$$Type): boolean
public "getInteractionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetalScaffoldingBlock$$Type = ($MetalScaffoldingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MetalScaffoldingBlock$$Original = $MetalScaffoldingBlock;}
declare module "com.simibubi.create.content.schematics.SchematicPrinter$EntityTargetHandler" {
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"

export interface $SchematicPrinter$EntityTargetHandler$$Interface {

(arg0: $BlockPos, arg1: $Entity): void
}

export class $SchematicPrinter$EntityTargetHandler implements $SchematicPrinter$EntityTargetHandler$$Interface {
 "handle"(arg0: $BlockPos$$Type, arg1: $Entity$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicPrinter$EntityTargetHandler$$Type = ((arg0: $BlockPos, arg1: $Entity) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicPrinter$EntityTargetHandler$$Original = $SchematicPrinter$EntityTargetHandler;}
declare module "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBehaviour" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$FactoryPanelBlockEntity, $FactoryPanelBlockEntity$$Type} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBlockEntity"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$FactoryPanelBlock$PanelSlot, $FactoryPanelBlock$PanelSlot$$Type} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBlock$PanelSlot"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BehaviourType} from "com.simibubi.create.foundation.blockEntity.behaviour.BehaviourType"
import {$FactoryPanelConnection, $FactoryPanelConnection$$Type} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelConnection"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$FactoryPanelPosition, $FactoryPanelPosition$$Type} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelPosition"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$ValueSettingsBoard} from "com.simibubi.create.foundation.blockEntity.behaviour.ValueSettingsBoard"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$Set} from "java.util.Set"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$FactoryPanelSupportBehaviour} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelSupportBehaviour"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$ValueSettingsBehaviour$ValueSettings, $ValueSettingsBehaviour$ValueSettings$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.ValueSettingsBehaviour$ValueSettings"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$FilteringBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.filtering.FilteringBehaviour"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$RequestPromiseQueue} from "com.simibubi.create.content.logistics.packagerLink.RequestPromiseQueue"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"

export class $FactoryPanelBehaviour extends $FilteringBehaviour implements $MenuProvider$$Interface {
static readonly "TOP_LEFT": $BehaviourType<($FactoryPanelBehaviour)>
 "upTo": boolean
static readonly "BOTTOM_RIGHT": $BehaviourType<($FactoryPanelBehaviour)>
 "restockerPromises": $RequestPromiseQueue
 "slot": $FactoryPanelBlock$PanelSlot
 "activeCraftingArrangement": $List<($ItemStack)>
 "network": $UUID
 "recipeAddress": StringJS
 "targeting": $Set<($FactoryPanelPosition)>
 "redstonePowered": boolean
 "blockEntity": $SmartBlockEntity
static readonly "TOP_RIGHT": $BehaviourType<($FactoryPanelBehaviour)>
 "promisedSatisfied": boolean
static readonly "BOTTOM_LEFT": $BehaviourType<($FactoryPanelBehaviour)>
static readonly "TYPE": $BehaviourType<($FilteringBehaviour)>
 "forceClearPromises": boolean
 "waitingForNetwork": boolean
 "satisfied": boolean
 "targetedByLinks": $Map<($BlockPos), ($FactoryPanelConnection)>
 "bulb": $LerpedFloat
 "count": integer
 "active": boolean
 "targetedBy": $Map<($FactoryPanelPosition), ($FactoryPanelConnection)>
 "recipeOutput": integer
 "customLabel": $MutableComponent
 "promiseClearingInterval": integer

constructor(arg0: $FactoryPanelBlockEntity$$Type, arg1: $FactoryPanelBlock$PanelSlot$$Type)

public "disconnectAll"(): void
public "getPanelPosition"(): $FactoryPanelPosition
public "disconnectAllLinks"(): void
public "setNetwork"(arg0: $UUID$$Type): void
public "netId"(): integer
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "formatValue"(arg0: $ValueSettingsBehaviour$ValueSettings$$Type): $MutableComponent
public "addConnection"(arg0: $FactoryPanelPosition$$Type): void
public "getRequiredItems"(): $ItemRequirement
public "lazyTick"(): void
public "writeSafe"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "resetTimer"(): void
public "panelBE"(): $FactoryPanelBlockEntity
public "getValueSettings"(): $ValueSettingsBehaviour$ValueSettings
public "createBoard"(arg0: $Player$$Type, arg1: $BlockHitResult$$Type): $ValueSettingsBoard
public "setValueSettings"(arg0: $Player$$Type, arg1: $ValueSettingsBehaviour$ValueSettings$$Type, arg2: boolean): void
public "onShortInteract"(arg0: $Player$$Type, arg1: $InteractionHand$$Type, arg2: $Direction$$Type, arg3: $BlockHitResult$$Type): void
public "writeToClipboard"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type, arg2: $Direction$$Type): boolean
public "readFromClipboard"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type, arg2: $Player$$Type, arg3: $Direction$$Type, arg4: boolean): boolean
public "isCountVisible"(): boolean
public "canShortInteract"(arg0: $ItemStack$$Type): boolean
public "getTip"(): $MutableComponent
public "getAmountTip"(): $MutableComponent
public "getCountLabelForValueBox"(): $MutableComponent
public "displayScreen"(arg0: $Player$$Type): void
public "getPromised"(): integer
public "getLevelInStorage"(): integer
public "getIngredientStatusColor"(): integer
public "getFrogAddress"(): StringJS
public "getUnloadedLinks"(): integer
public "resetTimerSlightly"(): void
public static "getTypeForSlot"(arg0: $FactoryPanelBlock$PanelSlot$$Type): $BehaviourType<(never)>
public "checkForRedstoneInput"(): void
public "getLabel"(): $MutableComponent
public "tick"(): void
public "setFilter"(arg0: $ItemStack$$Type): boolean
public "enable"(): void
public "getDisplayName"(): $Component
public "isMissingAddress"(): boolean
public static "linkAt"(arg0: $BlockAndTintGetter$$Type, arg1: $FactoryPanelConnection$$Type): $FactoryPanelSupportBehaviour
public static "linkAt"(arg0: $BlockAndTintGetter$$Type, arg1: $FactoryPanelPosition$$Type): $FactoryPanelSupportBehaviour
public "initialize"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "destroy"(): void
public "getType"(): $BehaviourType<(never)>
public static "at"(arg0: $BlockAndTintGetter$$Type, arg1: $FactoryPanelPosition$$Type): $FactoryPanelBehaviour
public static "at"(arg0: $BlockAndTintGetter$$Type, arg1: $FactoryPanelConnection$$Type): $FactoryPanelBehaviour
public "isActive"(): boolean
public "disable"(): void
public "getRenderDistance"(): float
public "moveTo"(arg0: $FactoryPanelPosition$$Type, arg1: $ServerPlayer$$Type): void
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
get "panelPosition"(): $FactoryPanelPosition
get "requiredItems"(): $ItemRequirement
get "valueSettings"(): $ValueSettingsBehaviour$ValueSettings
get "countVisible"(): boolean
get "tip"(): $MutableComponent
get "amountTip"(): $MutableComponent
get "countLabelForValueBox"(): $MutableComponent
get "promised"(): integer
get "levelInStorage"(): integer
get "ingredientStatusColor"(): integer
get "frogAddress"(): StringJS
get "unloadedLinks"(): integer
get "label"(): $MutableComponent
set "filter"(value: $ItemStack$$Type)
get "displayName"(): $Component
get "missingAddress"(): boolean
get "type"(): $BehaviourType<(never)>
get "renderDistance"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryPanelBehaviour$$Type = ($FactoryPanelBehaviour);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FactoryPanelBehaviour$$Original = $FactoryPanelBehaviour;}
declare module "com.simibubi.create.content.processing.burner.BlazeBurnerBlock$HeatLevel" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BlazeBurnerBlock$HeatLevel extends $Enum<($BlazeBurnerBlock$HeatLevel)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($BlazeBurnerBlock$HeatLevel)>
static readonly "SEETHING": $BlazeBurnerBlock$HeatLevel
static readonly "KINDLED": $BlazeBurnerBlock$HeatLevel
static readonly "SMOULDERING": $BlazeBurnerBlock$HeatLevel
static readonly "NONE": $BlazeBurnerBlock$HeatLevel
static readonly "FADING": $BlazeBurnerBlock$HeatLevel

public "nextActiveLevel"(): $BlazeBurnerBlock$HeatLevel
public static "byIndex"(arg0: integer): $BlazeBurnerBlock$HeatLevel
public static "values"(): ($BlazeBurnerBlock$HeatLevel)[]
public static "valueOf"(arg0: StringJS): $BlazeBurnerBlock$HeatLevel
public "isAtLeast"(arg0: $BlazeBurnerBlock$HeatLevel$$Type): boolean
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlazeBurnerBlock$HeatLevel$$Type = (("none") | ("smouldering") | ("fading") | ("kindled") | ("seething"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlazeBurnerBlock$HeatLevel$$Original = $BlazeBurnerBlock$HeatLevel;}
declare module "com.simibubi.create.content.redstone.rail.ControllerRailBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$AbstractMinecart$$Type} from "net.minecraft.world.entity.vehicle.AbstractMinecart"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$RailShape} from "net.minecraft.world.level.block.state.properties.RailShape"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BaseRailBlock} from "net.minecraft.world.level.block.BaseRailBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $ControllerRailBlock extends $BaseRailBlock implements $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ControllerRailBlock)>
static readonly "BACKWARDS": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "POWER": $IntegerProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $EnumProperty<($RailShape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "getShapeProperty"(): $Property<($RailShape)>
public "onMinecartPass"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $AbstractMinecart$$Type): void
public static "isStateBackwards"(arg0: $BlockState$$Type): boolean
public static "getAccelerationVector"(arg0: $BlockState$$Type): $Vec3i
public static "isReversedSlope"(arg0: $BlockState$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "shapeProperty"(): $Property<($RailShape)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ControllerRailBlock$$Type = ($ControllerRailBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ControllerRailBlock$$Original = $ControllerRailBlock;}
declare module "com.simibubi.create.content.logistics.crate.CrateBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CrateBlock extends $WrenchableDirectionalBlock implements $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CrateBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrateBlock$$Type = ($CrateBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CrateBlock$$Original = $CrateBlock;}
declare module "com.simibubi.create.content.kinetics.gearbox.GearboxBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$LootParams$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootParams$Builder"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$GearboxBlockEntity, $GearboxBlockEntity$$Type} from "com.simibubi.create.content.kinetics.gearbox.GearboxBlockEntity"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RotatedPillarKineticBlock} from "com.simibubi.create.content.kinetics.base.RotatedPillarKineticBlock"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"

export class $GearboxBlock extends $RotatedPillarKineticBlock implements $IBE$$Interface<($GearboxBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getDrops"(arg0: $BlockState$$Type, arg1: $LootParams$Builder$$Type): $List<($ItemStack)>
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($GearboxBlockEntity)>
public "getBlockEntityClass"(): $Class<($GearboxBlockEntity)>
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($GearboxBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($GearboxBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($GearboxBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($GearboxBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $GearboxBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($GearboxBlockEntity)>
get "blockEntityClass"(): $Class<($GearboxBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GearboxBlock$$Type = ($GearboxBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GearboxBlock$$Original = $GearboxBlock;}
declare module "com.simibubi.create.content.schematics.cannon.MaterialChecklist" {
import {$Object2IntMap} from "it.unimi.dsi.fastutil.objects.Object2IntMap"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ItemRequirement$$Type} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"

export class $MaterialChecklist {
 "blocksNotLoaded": boolean
static readonly "MAX_ENTRIES_PER_CLIPBOARD_PAGE": integer
 "damageRequired": $Object2IntMap<($Item)>
static readonly "MAX_ENTRIES_PER_PAGE": integer
 "gathered": $Object2IntMap<($Item)>
 "required": $Object2IntMap<($Item)>

constructor()

public "getRequiredAmount"(arg0: $Item$$Type): integer
public "createWrittenClipboard"(): $ItemStack
public "createWrittenBook"(): $ItemStack
public "warnBlockNotLoaded"(): void
public "collect"(arg0: $ItemStack$$Type): void
public "require"(arg0: $ItemRequirement$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaterialChecklist$$Type = ($MaterialChecklist);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MaterialChecklist$$Original = $MaterialChecklist;}
declare module "com.simibubi.create.content.kinetics.fan.NozzleBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$NozzleBlockEntity, $NozzleBlockEntity$$Type} from "com.simibubi.create.content.kinetics.fan.NozzleBlockEntity"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $NozzleBlock extends $WrenchableDirectionalBlock implements $IBE$$Interface<($NozzleBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($NozzleBlockEntity)>
public "getBlockEntityClass"(): $Class<($NozzleBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($NozzleBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($NozzleBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($NozzleBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($NozzleBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $NozzleBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($NozzleBlockEntity)>
get "blockEntityClass"(): $Class<($NozzleBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NozzleBlock$$Type = ($NozzleBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NozzleBlock$$Original = $NozzleBlock;}
declare module "com.simibubi.create.content.kinetics.belt.transport.BeltInventory" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Function$$Type} from "java.util.function.Function"
import {$List} from "java.util.List"
import {$BeltBlockEntity$$Type} from "com.simibubi.create.content.kinetics.belt.BeltBlockEntity"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$TransportedItemStack, $TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"
import {$TransportedItemStackHandlerBehaviour$TransportedResult$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour$TransportedResult"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $BeltInventory {
constructor(arg0: $BeltBlockEntity$$Type)

public "eject"(arg0: $TransportedItemStack$$Type): void
public "ejectAll"(): void
public "applyToEachWithin"(arg0: float, arg1: float, arg2: $Function$$Type<($TransportedItemStack), ($TransportedItemStackHandlerBehaviour$TransportedResult$$Type)>): void
public "getTransportedItems"(): $List<($TransportedItemStack)>
public "canInsertAtFromSide"(arg0: integer, arg1: $Direction$$Type): boolean
public "canInsertAt"(arg0: integer): boolean
public "getStackAtOffset"(arg0: integer): $TransportedItemStack
public "tick"(): void
public "addItem"(arg0: $TransportedItemStack$$Type): void
public "getLazyClientItem"(): $TransportedItemStack
public "write"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
get "transportedItems"(): $List<($TransportedItemStack)>
get "lazyClientItem"(): $TransportedItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltInventory$$Type = ($BeltInventory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltInventory$$Original = $BeltInventory;}
declare module "com.simibubi.create.content.trains.entity.CarriageParticles" {
import {$CarriageContraptionEntity$$Type} from "com.simibubi.create.content.trains.entity.CarriageContraptionEntity"
import {$Carriage$DimensionalCarriageEntity$$Type} from "com.simibubi.create.content.trains.entity.Carriage$DimensionalCarriageEntity"

export class $CarriageParticles {
constructor(arg0: $CarriageContraptionEntity$$Type)

public "tick"(arg0: $Carriage$DimensionalCarriageEntity$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarriageParticles$$Type = ($CarriageParticles);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarriageParticles$$Original = $CarriageParticles;}
declare module "com.simibubi.create.content.contraptions.elevator.ElevatorPulleyBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$HorizontalKineticBlock} from "com.simibubi.create.content.kinetics.base.HorizontalKineticBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ElevatorPulleyBlockEntity, $ElevatorPulleyBlockEntity$$Type} from "com.simibubi.create.content.contraptions.elevator.ElevatorPulleyBlockEntity"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $ElevatorPulleyBlock extends $HorizontalKineticBlock implements $IBE$$Interface<($ElevatorPulleyBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "HORIZONTAL_FACING": $Property<($Direction)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($ElevatorPulleyBlockEntity)>
public "getBlockEntityClass"(): $Class<($ElevatorPulleyBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ElevatorPulleyBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ElevatorPulleyBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ElevatorPulleyBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ElevatorPulleyBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ElevatorPulleyBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ElevatorPulleyBlockEntity)>
get "blockEntityClass"(): $Class<($ElevatorPulleyBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElevatorPulleyBlock$$Type = ($ElevatorPulleyBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ElevatorPulleyBlock$$Original = $ElevatorPulleyBlock;}
declare module "com.simibubi.create.content.logistics.vault.ItemVaultMountedStorage" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Contraption$$Type} from "com.simibubi.create.content.contraptions.Contraption"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ItemVaultBlockEntity$$Type} from "com.simibubi.create.content.logistics.vault.ItemVaultBlockEntity"
import {$WrapperMountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.WrapperMountedItemStorage"
import {$MountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorage"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MountedItemStorageType} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageType"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$ItemStackHandler} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $ItemVaultMountedStorage extends $WrapperMountedItemStorage<($ItemStackHandler)> {
static readonly "CODEC": $MapCodec<($ItemVaultMountedStorage)>
readonly "type": $MountedItemStorageType<($MountedItemStorage)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MountedItemStorage)>

public "handleInteraction"(arg0: $ServerPlayer$$Type, arg1: $Contraption$$Type, arg2: $StructureTemplate$StructureBlockInfo$$Type): boolean
public static "fromLegacy"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): $ItemVaultMountedStorage
public static "fromVault"(arg0: $ItemVaultBlockEntity$$Type): $ItemVaultMountedStorage
public "unmount"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemVaultMountedStorage$$Type = ($ItemVaultMountedStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemVaultMountedStorage$$Original = $ItemVaultMountedStorage;}
declare module "com.simibubi.create.content.trains.track.TrackTargetingBehaviour" {
import {$ITrackBlock} from "com.simibubi.create.content.trains.track.ITrackBlock"
import {$TrackGraphLocation} from "com.simibubi.create.content.trains.graph.TrackGraphLocation"
import {$Direction$AxisDirection, $Direction$AxisDirection$$Type} from "net.minecraft.core.Direction$AxisDirection"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BezierTrackPointLocation, $BezierTrackPointLocation$$Type} from "com.simibubi.create.content.trains.track.BezierTrackPointLocation"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$BehaviourType} from "com.simibubi.create.foundation.blockEntity.behaviour.BehaviourType"
import {$EdgePointType$$Type} from "com.simibubi.create.content.trains.graph.EdgePointType"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$TrackTargetingBehaviour$RenderedTrackOverlayType$$Type} from "com.simibubi.create.content.trains.track.TrackTargetingBehaviour$RenderedTrackOverlayType"
import {$SmartBlockEntity, $SmartBlockEntity$$Type} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$MultiBufferSource$$Type} from "net.minecraft.client.renderer.MultiBufferSource"
import {$TrackEdgePoint, $TrackEdgePoint$$Type} from "com.simibubi.create.content.trains.signal.TrackEdgePoint"
import {$IPreAssembleCallback$$Interface} from "com.railwayteam.railways.mixin_interfaces.IPreAssembleCallback"
import {$BlockEntityBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$AccessorTrackTargetingBehavior$$Interface} from "com.railwayteam.railways.mixin.AccessorTrackTargetingBehavior"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $TrackTargetingBehaviour<T extends $TrackEdgePoint> extends $BlockEntityBehaviour implements $AccessorTrackTargetingBehavior$$Interface, $IPreAssembleCallback$$Interface {
 "blockEntity": $SmartBlockEntity
static readonly "TYPE": $BehaviourType<($TrackTargetingBehaviour<(never)>)>

constructor(arg0: $SmartBlockEntity$$Type, arg1: $EdgePointType$$Type<(T)>)

public "isSafeNBT"(): boolean
public "getTargetDirection"(): $Direction$AxisDirection
public "isOnCurve"(): boolean
public "isOrthogonal"(): boolean
public "invalidateEdgePoint"(arg0: $CompoundTag$$Type): void
public "setTargetTrack"(arg0: $BlockPos$$Type): void
public "setTargetDirection"(arg0: $Direction$AxisDirection$$Type): void
public "getEdgePoint"(): T
public "getTrackBlockState"(): $BlockState
public "getTargetTrack"(): $BlockPos
public "hasValidTrack"(): boolean
public "determineGraphLocation"(): $TrackGraphLocation
public "setEdgePoint"(arg0: $TrackEdgePoint$$Type): void
public "createEdgePoint"(): T
public "getTrack"(): $ITrackBlock
public "getPositionForMapMarker"(): $BlockPos
public "railways$preAssemble"(): void
public "setOrthogonal"(arg0: boolean): void
public "getRotatedDirection"(): $Vec3
public "setRotatedDirection"(arg0: $Vec3$$Type): void
public "getPrevDirection"(): $Vec3
public "setPrevDirection"(arg0: $Vec3$$Type): void
public "getMigrationData"(): $CompoundTag
public "setMigrationData"(arg0: $CompoundTag$$Type): void
public "getTargetBezier"(): $BezierTrackPointLocation
public "setTargetBezier"(arg0: $BezierTrackPointLocation$$Type): void
public "getGlobalPosition"(): $BlockPos
public "tick"(): void
public "transform"(arg0: $BlockEntity$$Type, arg1: $StructureTransform$$Type): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "getId"(): $UUID
public "destroy"(): void
public "getType"(): $BehaviourType<(never)>
public "setId"(arg0: $UUID$$Type): void
public static "render"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Direction$AxisDirection$$Type, arg3: $BezierTrackPointLocation$$Type, arg4: $PoseStack$$Type, arg5: $MultiBufferSource$$Type, arg6: integer, arg7: integer, arg8: $TrackTargetingBehaviour$RenderedTrackOverlayType$$Type, arg9: float): void
get "safeNBT"(): boolean
get "targetDirection"(): $Direction$AxisDirection
get "onCurve"(): boolean
get "orthogonal"(): boolean
set "targetTrack"(value: $BlockPos$$Type)
set "targetDirection"(value: $Direction$AxisDirection$$Type)
get "edgePoint"(): T
get "trackBlockState"(): $BlockState
get "targetTrack"(): $BlockPos
set "edgePoint"(value: $TrackEdgePoint$$Type)
get "track"(): $ITrackBlock
get "positionForMapMarker"(): $BlockPos
set "orthogonal"(value: boolean)
get "rotatedDirection"(): $Vec3
set "rotatedDirection"(value: $Vec3$$Type)
get "prevDirection"(): $Vec3
set "prevDirection"(value: $Vec3$$Type)
get "migrationData"(): $CompoundTag
set "migrationData"(value: $CompoundTag$$Type)
get "targetBezier"(): $BezierTrackPointLocation
set "targetBezier"(value: $BezierTrackPointLocation$$Type)
get "globalPosition"(): $BlockPos
get "id"(): $UUID
get "type"(): $BehaviourType<(never)>
set "id"(value: $UUID$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackTargetingBehaviour$$Type<T> = ($TrackTargetingBehaviour<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackTargetingBehaviour$$Original<T> = $TrackTargetingBehaviour<(T)>;}
declare module "com.simibubi.create.content.contraptions.mounted.MinecartContraptionItem" {
import {$OrientedContraptionEntity$$Type} from "com.simibubi.create.content.contraptions.OrientedContraptionEntity"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$AbstractMinecart$$Type} from "net.minecraft.world.entity.vehicle.AbstractMinecart"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$PlayerInteractEvent$EntityInteract$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$EntityInteract"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$AbstractMinecart$Type$$Type} from "net.minecraft.world.entity.vehicle.AbstractMinecart$Type"

export class $MinecartContraptionItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

public static "chest"(arg0: $Item$Properties$$Type): $MinecartContraptionItem
public static "furnace"(arg0: $Item$Properties$$Type): $MinecartContraptionItem
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "canFitInsideContainerItems"(): boolean
public static "addContraptionToMinecart"(arg0: $Level$$Type, arg1: $ItemStack$$Type, arg2: $AbstractMinecart$$Type, arg3: $Direction$$Type): void
public static "wrenchCanBeUsedToPickUpMinecartContraptions"(arg0: $PlayerInteractEvent$EntityInteract$$Type): void
public static "rideable"(arg0: $Item$Properties$$Type): $MinecartContraptionItem
public static "create"(arg0: $AbstractMinecart$Type$$Type, arg1: $OrientedContraptionEntity$$Type): $ItemStack
public "getDescriptionId"(arg0: $ItemStack$$Type): StringJS
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecartContraptionItem$$Type = ($MinecartContraptionItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecartContraptionItem$$Original = $MinecartContraptionItem;}
declare module "com.simibubi.create.content.kinetics.mechanicalArm.ArmBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$KineticBlock} from "com.simibubi.create.content.kinetics.base.KineticBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$ArmBlockEntity, $ArmBlockEntity$$Type} from "com.simibubi.create.content.kinetics.mechanicalArm.ArmBlockEntity"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ICogWheel$$Interface} from "com.simibubi.create.content.kinetics.simpleRelays.ICogWheel"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $ArmBlock extends $KineticBlock implements $IBE$$Interface<($ArmBlockEntity)>, $ICogWheel$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "CEILING": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "getBlockEntityType"(): $BlockEntityType<($ArmBlockEntity)>
public "getBlockEntityClass"(): $Class<($ArmBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ArmBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ArmBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ArmBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ArmBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ArmBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "isSmallCog"(): boolean
public static "isSmallCog"(arg0: $Block$$Type): boolean
public static "isSmallCog"(arg0: $BlockState$$Type): boolean
public "isLargeCog"(): boolean
public static "isLargeCog"(arg0: $Block$$Type): boolean
public static "isLargeCog"(arg0: $BlockState$$Type): boolean
public "isDedicatedCogWheel"(): boolean
public static "isDedicatedCogWheel"(arg0: $Block$$Type): boolean
public static "isDedicatedCogItem"(arg0: $ItemStack$$Type): boolean
public static "isSmallCogItem"(arg0: $ItemStack$$Type): boolean
public static "isLargeCogItem"(arg0: $ItemStack$$Type): boolean
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ArmBlockEntity)>
get "blockEntityClass"(): $Class<($ArmBlockEntity)>
get "smallCog"(): boolean
get "largeCog"(): boolean
get "dedicatedCogWheel"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmBlock$$Type = ($ArmBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmBlock$$Original = $ArmBlock;}
declare module "com.simibubi.create.content.contraptions.mounted.CartAssembleRailType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CartAssembleRailType extends $Enum<($CartAssembleRailType)> implements $StringRepresentable$$Interface {
static readonly "DETECTOR_RAIL": $CartAssembleRailType
static readonly "REGULAR": $CartAssembleRailType
static readonly "CONTROLLER_RAIL": $CartAssembleRailType
static readonly "ACTIVATOR_RAIL": $CartAssembleRailType
static readonly "POWERED_RAIL": $CartAssembleRailType

public "getBlock"(): $Block
public "getItem"(): $Item
public static "values"(): ($CartAssembleRailType)[]
public static "valueOf"(arg0: StringJS): $CartAssembleRailType
public "matches"(arg0: $BlockState$$Type): boolean
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "block"(): $Block
get "item"(): $Item
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CartAssembleRailType$$Type = (("regular") | ("powered_rail") | ("detector_rail") | ("activator_rail") | ("controller_rail"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CartAssembleRailType$$Original = $CartAssembleRailType;}
declare module "com.simibubi.create.content.fluids.VirtualFluid" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BaseFlowingFluid$Properties$$Type} from "net.neoforged.neoforge.fluids.BaseFlowingFluid$Properties"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BaseFlowingFluid} from "net.neoforged.neoforge.fluids.BaseFlowingFluid"

export class $VirtualFluid extends $BaseFlowingFluid {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty

constructor(arg0: $BaseFlowingFluid$Properties$$Type, arg1: boolean)

public "isSource"(arg0: $FluidState$$Type): boolean
public static "createSource"(arg0: $BaseFlowingFluid$Properties$$Type): $VirtualFluid
public static "createFlowing"(arg0: $BaseFlowingFluid$Properties$$Type): $VirtualFluid
public "getFlowing"(): $Fluid
public "getSource"(): $Fluid
public "getBucket"(): $Item
public "getAmount"(arg0: $FluidState$$Type): integer
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
get "flowing"(): $Fluid
get "source"(): $Fluid
get "bucket"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualFluid$$Type = ($VirtualFluid);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VirtualFluid$$Original = $VirtualFluid;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour" {
import {$SmartBlockEntity, $SmartBlockEntity$$Type} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$TransportedItemStackHandlerBehaviour$PositionGetter$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour$PositionGetter"
import {$Function$$Type} from "java.util.function.Function"
import {$BlockEntityBehaviour} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BehaviourType} from "com.simibubi.create.foundation.blockEntity.behaviour.BehaviourType"
import {$TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"
import {$TransportedItemStackHandlerBehaviour$TransportedResult$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour$TransportedResult"
import {$TransportedItemStackHandlerBehaviour$ProcessingCallback$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour$ProcessingCallback"

export class $TransportedItemStackHandlerBehaviour extends $BlockEntityBehaviour {
 "blockEntity": $SmartBlockEntity
static readonly "TYPE": $BehaviourType<($TransportedItemStackHandlerBehaviour)>

constructor(arg0: $SmartBlockEntity$$Type, arg1: $TransportedItemStackHandlerBehaviour$ProcessingCallback$$Type)

public "handleProcessingOnItem"(arg0: $TransportedItemStack$$Type, arg1: $TransportedItemStackHandlerBehaviour$TransportedResult$$Type): void
public "getWorldPositionOf"(arg0: $TransportedItemStack$$Type): $Vec3
public "withStackPlacement"(arg0: $TransportedItemStackHandlerBehaviour$PositionGetter$$Type): $TransportedItemStackHandlerBehaviour
public "handleCenteredProcessingOnAllItems"(arg0: float, arg1: $Function$$Type<($TransportedItemStack), ($TransportedItemStackHandlerBehaviour$TransportedResult$$Type)>): void
public "handleProcessingOnAllItems"(arg0: $Function$$Type<($TransportedItemStack), ($TransportedItemStackHandlerBehaviour$TransportedResult$$Type)>): void
public "getType"(): $BehaviourType<(never)>
get "type"(): $BehaviourType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransportedItemStackHandlerBehaviour$$Type = ($TransportedItemStackHandlerBehaviour);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TransportedItemStackHandlerBehaviour$$Original = $TransportedItemStackHandlerBehaviour;}
declare module "com.simibubi.create.content.contraptions.minecart.capability.MinecartController" {
import {$AbstractMinecart, $AbstractMinecart$$Type} from "net.minecraft.world.entity.vehicle.AbstractMinecart"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$IAttachmentSerializer} from "net.neoforged.neoforge.attachment.IAttachmentSerializer"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"
import {$INBTSerializable$$Interface} from "net.neoforged.neoforge.common.util.INBTSerializable"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $MinecartController implements $INBTSerializable$$Interface<($CompoundTag)> {
static readonly "SERIALIZER": $IAttachmentSerializer<($CompoundTag), ($MinecartController)>
static readonly "EMPTY": $MinecartController

constructor(arg0: $AbstractMinecart$$Type)

public "isCoupledThroughContraption"(): boolean
public "getCouplingLength"(arg0: boolean): float
public "prepareForCoupling"(arg0: boolean): void
public "coupleWith"(arg0: boolean, arg1: $UUID$$Type, arg2: float, arg3: boolean): void
public "cart"(): $AbstractMinecart
public "sendData"(): void
public "sendData"(arg0: $AbstractMinecart$$Type): void
public "removeConnection"(arg0: boolean): void
public "isStalled"(): boolean
public "setStalledExternally"(arg0: boolean): void
public "isFullyCoupled"(): boolean
public "isConnectedToCoupling"(): boolean
public "isLeadingCoupling"(): boolean
public "hasContraptionCoupling"(arg0: boolean): boolean
public "decouple"(): void
public "getCoupledCart"(arg0: boolean): $UUID
public "tick"(): void
public "isEmpty"(): boolean
public "isPresent"(): boolean
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $Tag$$Type): void
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
get "coupledThroughContraption"(): boolean
get "stalled"(): boolean
set "stalledExternally"(value: boolean)
get "fullyCoupled"(): boolean
get "connectedToCoupling"(): boolean
get "leadingCoupling"(): boolean
get "empty"(): boolean
get "present"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecartController$$Type = ($MinecartController);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecartController$$Original = $MinecartController;}
declare module "com.simibubi.create.content.decoration.copycat.WaterloggedCopycatBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ICopycatBlock$$Type} from "com.copycatsplus.copycats.foundation.copycat.ICopycatBlock"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$CopycatBlock} from "com.simibubi.create.content.decoration.copycat.CopycatBlock"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty$$Type} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $WaterloggedCopycatBlock extends $CopycatBlock implements $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "hidesNeighborFace"(level: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, neighborState: $BlockState$$Type, dir: $Direction$$Type): boolean
public static "getAppearance"(block: $ICopycatBlock$$Type, state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, side: $Direction$$Type, queryState: $BlockState$$Type, queryPos: $BlockPos$$Type): $BlockState
public static "getRequiredItemsForLayer"(state: $BlockState$$Type, property: $IntegerProperty$$Type): $ItemRequirement
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterloggedCopycatBlock$$Type = ($WaterloggedCopycatBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WaterloggedCopycatBlock$$Original = $WaterloggedCopycatBlock;}
declare module "com.simibubi.create.content.redstone.nixieTube.NixieTubeBlockEntity" {
import {$IOverridableSignal$$Interface} from "com.railwayteam.railways.content.distant_signals.IOverridableSignal"
import {$AbstractComputerBehaviour} from "com.simibubi.create.compat.computercraft.AbstractComputerBehaviour"
import {$RegisterCapabilitiesEvent$$Type} from "net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent"
import {$Optional} from "java.util.Optional"
import {$List$$Type} from "java.util.List"
import {$SignalBlockEntity$$Type} from "com.simibubi.create.content.trains.signal.SignalBlockEntity"
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$NixieTubeBlockEntity$ComputerSignal} from "com.simibubi.create.content.redstone.nixieTube.NixieTubeBlockEntity$ComputerSignal"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$SignalBlockEntity$SignalState, $SignalBlockEntity$SignalState$$Type} from "com.simibubi.create.content.trains.signal.SignalBlockEntity$SignalState"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NixieTubeBlockEntity extends $SmartBlockEntity implements $IOverridableSignal$$Interface {
 "computerSignal": $NixieTubeBlockEntity$ComputerSignal
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "computerBehaviour": $AbstractComputerBehaviour
 "signalState": $SignalBlockEntity$SignalState

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "updateDisplayedStrings"(): void
public "getDisplayedStrings"(): $Couple<(StringJS)>
public "getRedstoneStrength"(): integer
public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "reactsToRedstone"(): boolean
public "clearCustomText"(): void
public "updateRedstoneStrength"(arg0: integer): void
public "displayEmptyText"(arg0: integer): void
public "displayCustomText"(arg0: StringJS, arg1: integer): void
public "getFullText"(): $MutableComponent
public "railways$getOverriddenState"(): $Optional
public "railways$refresh"(arg0: $SignalBlockEntity$$Type, arg1: $SignalBlockEntity$SignalState$$Type, arg2: integer, arg3: boolean): void
public "tick"(): void
public "initialize"(): void
public "invalidate"(): void
public static "registerCapabilities"(arg0: $RegisterCapabilitiesEvent$$Type): void
public "railways$refresh"(arg0: $SignalBlockEntity$$Type, arg1: $SignalBlockEntity$SignalState$$Type, arg2: integer): void
get "displayedStrings"(): $Couple<(StringJS)>
get "redstoneStrength"(): integer
get "fullText"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NixieTubeBlockEntity$$Type = ($NixieTubeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NixieTubeBlockEntity$$Original = $NixieTubeBlockEntity;}
declare module "com.simibubi.create.content.contraptions.bearing.WindmillBearingBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$WindmillBearingBlockEntity, $WindmillBearingBlockEntity$$Type} from "com.simibubi.create.content.contraptions.bearing.WindmillBearingBlockEntity"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BearingBlock} from "com.simibubi.create.content.contraptions.bearing.BearingBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $WindmillBearingBlock extends $BearingBlock implements $IBE$$Interface<($WindmillBearingBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($WindmillBearingBlockEntity)>
public "getBlockEntityClass"(): $Class<($WindmillBearingBlockEntity)>
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($WindmillBearingBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($WindmillBearingBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($WindmillBearingBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($WindmillBearingBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $WindmillBearingBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($WindmillBearingBlockEntity)>
get "blockEntityClass"(): $Class<($WindmillBearingBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindmillBearingBlock$$Type = ($WindmillBearingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WindmillBearingBlock$$Original = $WindmillBearingBlock;}
declare module "com.simibubi.create.content.redstone.displayLink.source.ItemThroughputDisplaySource" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$AccumulatedItemCountDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.AccumulatedItemCountDisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"
import {$DisplayLinkBlockEntity$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkBlockEntity"

export class $ItemThroughputDisplaySource extends $AccumulatedItemCountDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
public "itemReceived"(arg0: $DisplayLinkBlockEntity$$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemThroughputDisplaySource$$Type = ($ItemThroughputDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemThroughputDisplaySource$$Original = $ItemThroughputDisplaySource;}
declare module "com.simibubi.create.content.trains.bogey.BogeyStyle" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$BogeyStyle$SizeRenderer$$Type} from "com.simibubi.create.content.trains.bogey.BogeyStyle$SizeRenderer"
import {$PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$VisualizationContext$$Type} from "dev.engine_room.flywheel.api.visualization.VisualizationContext"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$AccessorBogeyStyle$$Interface} from "com.railwayteam.railways.mixin.client.AccessorBogeyStyle"
import {$BogeyVisual} from "com.simibubi.create.content.trains.bogey.BogeyVisual"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MultiBufferSource$$Type} from "net.minecraft.client.renderer.MultiBufferSource"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Set} from "java.util.Set"
import {$AbstractBogeyBlock, $AbstractBogeyBlock$$Type} from "com.simibubi.create.content.trains.bogey.AbstractBogeyBlock"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$BogeySizes$BogeySize, $BogeySizes$BogeySize$$Type} from "com.simibubi.create.content.trains.bogey.BogeySizes$BogeySize"

export class $BogeyStyle implements $AccessorBogeyStyle$$Interface {
readonly "contactParticle": $ParticleOptions
readonly "soundEvent": $Supplier<($SoundEvent)>
readonly "smokeParticle": $ParticleOptions
readonly "cycleGroup": $ResourceLocation
readonly "displayName": $Component
readonly "defaultData": $CompoundTag
readonly "id": $ResourceLocation

constructor(arg0: $ResourceLocation$$Type, arg1: $ResourceLocation$$Type, arg2: $Component$$Type, arg3: $Supplier$$Type<($SoundEvent$$Type)>, arg4: $ParticleOptions$$Type, arg5: $ParticleOptions$$Type, arg6: $CompoundTag$$Type, arg7: $Map$$Type<($BogeySizes$BogeySize$$Type), ($Supplier$$Type<($AbstractBogeyBlock$$Type<(never)>)>)>, arg8: $Map$$Type<($BogeySizes$BogeySize$$Type), ($Supplier$$Type<($Supplier$$Type<($BogeyStyle$SizeRenderer$$Type)>)>)>)

public "validSizes"(): $Set<($BogeySizes$BogeySize)>
public "getBlockForSize"(arg0: $BogeySizes$BogeySize$$Type): $AbstractBogeyBlock<(never)>
public "getNextBlock"(arg0: $BogeySizes$BogeySize$$Type): $AbstractBogeyBlock<(never)>
public "getCycleGroup"(): $Map<($ResourceLocation), ($BogeyStyle)>
public "createVisual"(arg0: $BogeySizes$BogeySize$$Type, arg1: $VisualizationContext$$Type, arg2: float, arg3: boolean): $BogeyVisual
public "getSizeRenderers"(): $Map
public "render"(arg0: $BogeySizes$BogeySize$$Type, arg1: float, arg2: $PoseStack$$Type, arg3: $MultiBufferSource$$Type, arg4: integer, arg5: integer, arg6: float, arg7: $CompoundTag$$Type, arg8: boolean): void
get "sizeRenderers"(): $Map
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BogeyStyle$$Type = ($BogeyStyle);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BogeyStyle$$Original = $BogeyStyle;}
declare module "com.simibubi.create.content.fluids.tank.FluidTankItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $FluidTankItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "place"(arg0: $BlockPlaceContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankItem$$Type = ($FluidTankItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTankItem$$Original = $FluidTankItem;}
declare module "com.simibubi.create.content.logistics.stockTicker.PackageOrderWithCrafts$CraftingEntry" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$PackageOrder, $PackageOrder$$Type} from "com.simibubi.create.content.logistics.stockTicker.PackageOrder"
import {$Record} from "java.lang.Record"

export class $PackageOrderWithCrafts$CraftingEntry extends $Record {
static readonly "CODEC": $Codec<($PackageOrderWithCrafts$CraftingEntry)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($PackageOrderWithCrafts$CraftingEntry)>

constructor(pattern: $PackageOrder$$Type, count: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "count"(): integer
public "pattern"(): $PackageOrder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackageOrderWithCrafts$CraftingEntry$$Type = ({"pattern"?: $PackageOrder$$Type, "count"?: integer}) | ([pattern?: $PackageOrder$$Type, count?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackageOrderWithCrafts$CraftingEntry$$Original = $PackageOrderWithCrafts$CraftingEntry;}
declare module "com.simibubi.create.content.trains.track.TrackBlockEntityTilt" {
import {$BezierConnection, $BezierConnection$$Type} from "com.simibubi.create.content.trains.track.BezierConnection"
import {$ModelProperty} from "net.neoforged.neoforge.client.model.data.ModelProperty"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Optional} from "java.util.Optional"
import {$TrackBlockEntity$$Type} from "com.simibubi.create.content.trains.track.TrackBlockEntity"

export class $TrackBlockEntityTilt {
static readonly "ASCENDING_PROPERTY": $ModelProperty<(double)>
 "smoothingAngle": $Optional<(double)>

constructor(arg0: $TrackBlockEntity$$Type)

public "captureSmoothingHandles"(): void
public "restoreToOriginalCurve"(arg0: $BezierConnection$$Type): $BezierConnection
public static "compareHandles"(arg0: $Vec3$$Type, arg1: $Vec3$$Type): boolean
public "tryApplySmoothing"(): void
public "getYOffsetForAxisEnd"(arg0: $Vec3$$Type): integer
public "undoSmoothing"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackBlockEntityTilt$$Type = ($TrackBlockEntityTilt);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackBlockEntityTilt$$Original = $TrackBlockEntityTilt;}
declare module "com.simibubi.create.content.contraptions.pulley.PulleyBlock$MagnetBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$PulleyBlock$RopeBlockBase} from "com.simibubi.create.content.contraptions.pulley.PulleyBlock$RopeBlockBase"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"

export class $PulleyBlock$MagnetBlock extends $PulleyBlock$RopeBlockBase {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PulleyBlock$MagnetBlock$$Type = ($PulleyBlock$MagnetBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PulleyBlock$MagnetBlock$$Original = $PulleyBlock$MagnetBlock;}
declare module "com.simibubi.create.content.trains.bogey.BogeySizes$BogeySize" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Record} from "java.lang.Record"

export class $BogeySizes$BogeySize extends $Record {
constructor(id: $ResourceLocation$$Type, wheelRadius: float)

public "nextBySize"(): $BogeySizes$BogeySize
public "wheelRadius"(): float
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BogeySizes$BogeySize$$Type = ({"wheelRadius"?: float, "id"?: $ResourceLocation$$Type}) | ([wheelRadius?: float, id?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BogeySizes$BogeySize$$Original = $BogeySizes$BogeySize;}
declare module "com.simibubi.create.content.kinetics.fan.processing.AllFanProcessingTypes$SplashingType" {
import {$FanProcessingType$AirFlowParticleAccess$$Type} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType$AirFlowParticleAccess"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$FanProcessingType, $FanProcessingType$$Interface} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $AllFanProcessingTypes$SplashingType implements $FanProcessingType$$Interface {
constructor()

public "spawnProcessingParticles"(arg0: $Level$$Type, arg1: $Vec3$$Type): void
public "morphAirFlow"(arg0: $FanProcessingType$AirFlowParticleAccess$$Type, arg1: $RandomSource$$Type): void
public "affectEntity"(arg0: $Entity$$Type, arg1: $Level$$Type): void
public "isValidAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public "canProcess"(arg0: $ItemStack$$Type, arg1: $Level$$Type): boolean
public "process"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemStack)>
public "getPriority"(): integer
public static "parse"(arg0: StringJS): $FanProcessingType
public static "getAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $FanProcessingType
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllFanProcessingTypes$SplashingType$$Type = ($AllFanProcessingTypes$SplashingType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllFanProcessingTypes$SplashingType$$Original = $AllFanProcessingTypes$SplashingType;}
declare module "com.simibubi.create.content.trains.entity.CarriageSounds" {
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$CarriageContraptionEntity$$Type} from "com.simibubi.create.content.trains.entity.CarriageContraptionEntity"
import {$Carriage$DimensionalCarriageEntity$$Type} from "com.simibubi.create.content.trains.entity.Carriage$DimensionalCarriageEntity"

export class $CarriageSounds {
constructor(arg0: $CarriageContraptionEntity$$Type)

public "submitSharedSoundVolume"(arg0: $Vec3$$Type, arg1: float): void
public "finalizeSharedVolume"(arg0: float): void
public "tick"(arg0: $Carriage$DimensionalCarriageEntity$$Type): void
public "stop"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarriageSounds$$Type = ($CarriageSounds);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarriageSounds$$Original = $CarriageSounds;}
declare module "com.simibubi.create.content.contraptions.piston.MechanicalPistonBlock$PistonState" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $MechanicalPistonBlock$PistonState extends $Enum<($MechanicalPistonBlock$PistonState)> implements $StringRepresentable$$Interface {
static readonly "EXTENDED": $MechanicalPistonBlock$PistonState
static readonly "MOVING": $MechanicalPistonBlock$PistonState
static readonly "RETRACTED": $MechanicalPistonBlock$PistonState

public static "values"(): ($MechanicalPistonBlock$PistonState)[]
public static "valueOf"(arg0: StringJS): $MechanicalPistonBlock$PistonState
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MechanicalPistonBlock$PistonState$$Type = (("retracted") | ("moving") | ("extended"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MechanicalPistonBlock$PistonState$$Original = $MechanicalPistonBlock$PistonState;}
declare module "com.simibubi.create.content.decoration.MetalScaffoldingBlockItem" {
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$ScaffoldingBlockItem} from "net.minecraft.world.item.ScaffoldingBlockItem"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $MetalScaffoldingBlockItem extends $ScaffoldingBlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "updatePlacementContext"(arg0: $BlockPlaceContext$$Type): $BlockPlaceContext
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetalScaffoldingBlockItem$$Type = ($MetalScaffoldingBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MetalScaffoldingBlockItem$$Original = $MetalScaffoldingBlockItem;}
declare module "com.simibubi.create.content.logistics.packagePort.PackagePortTargetType" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$PackagePortTarget} from "com.simibubi.create.content.logistics.packagePort.PackagePortTarget"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export interface $PackagePortTargetType$$Interface {
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.CreatePackagePortTargetType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.CreatePackagePortTargetTypeTag
}

export class $PackagePortTargetType implements $PackagePortTargetType$$Interface {
 "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($PackagePortTarget)>
 "codec"(): $MapCodec<($PackagePortTarget)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PackagePortTargetType$$Type = (Special.CreatePackagePortTargetType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PackagePortTargetType$$Original = $PackagePortTargetType;}
declare module "com.simibubi.create.content.redstone.displayLink.source.ValueListDisplaySource" {
import {$ModularGuiLineBuilder$$Type} from "com.simibubi.create.foundation.gui.ModularGuiLineBuilder"
import {$FlapDisplayBlockEntity$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayBlockEntity"
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$DisplayTargetStats$$Type} from "com.simibubi.create.content.redstone.displayLink.target.DisplayTargetStats"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DisplayLinkContext$$Type} from "com.simibubi.create.content.redstone.displayLink.DisplayLinkContext"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$FlapDisplayLayout$$Type} from "com.simibubi.create.content.trains.display.FlapDisplayLayout"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $ValueListDisplaySource extends $DisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

public "initConfigurationWidgets"(arg0: $DisplayLinkContext$$Type, arg1: $ModularGuiLineBuilder$$Type, arg2: boolean): void
public "provideText"(arg0: $DisplayLinkContext$$Type, arg1: $DisplayTargetStats$$Type): $List<($MutableComponent)>
public "provideFlapDisplayText"(arg0: $DisplayLinkContext$$Type, arg1: $DisplayTargetStats$$Type): $List<($List<($MutableComponent)>)>
public "loadFlapDisplayLayout"(arg0: $DisplayLinkContext$$Type, arg1: $FlapDisplayBlockEntity$$Type, arg2: $FlapDisplayLayout$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ValueListDisplaySource$$Type = ($ValueListDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ValueListDisplaySource$$Original = $ValueListDisplaySource;}
declare module "com.simibubi.create.content.equipment.clipboard.ClipboardBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$LootParams$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootParams$Builder"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$FaceAttachedHorizontalDirectionalBlock} from "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$ClipboardBlockEntity, $ClipboardBlockEntity$$Type} from "com.simibubi.create.content.equipment.clipboard.ClipboardBlockEntity"

export class $ClipboardBlock extends $FaceAttachedHorizontalDirectionalBlock implements $IBE$$Interface<($ClipboardBlockEntity)>, $IWrenchable$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "WRITTEN": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ClipboardBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($AttachFace)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getDrops"(arg0: $BlockState$$Type, arg1: $LootParams$Builder$$Type): $List<($ItemStack)>
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "getBlockEntityType"(): $BlockEntityType<($ClipboardBlockEntity)>
public "getBlockEntityClass"(): $Class<($ClipboardBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "attack"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($ClipboardBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($ClipboardBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ClipboardBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($ClipboardBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $ClipboardBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($ClipboardBlockEntity)>
get "blockEntityClass"(): $Class<($ClipboardBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipboardBlock$$Type = ($ClipboardBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipboardBlock$$Original = $ClipboardBlock;}
declare module "com.simibubi.create.content.redstone.deskBell.DeskBellBlockEntity" {
import {$SmartBlockEntity} from "com.simibubi.create.foundation.blockEntity.SmartBlockEntity"
import {$LerpedFloat} from "net.createmod.catnip.animation.LerpedFloat"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List$$Type} from "java.util.List"
import {$BlockEntityBehaviour$$Type} from "com.simibubi.create.foundation.blockEntity.behaviour.BlockEntityBehaviour"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DeskBellBlockEntity extends $SmartBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "animation": $LerpedFloat

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "addBehaviours"(arg0: $List$$Type<($BlockEntityBehaviour$$Type)>): void
public "ding"(): void
public "tick"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeskBellBlockEntity$$Type = ($DeskBellBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeskBellBlockEntity$$Original = $DeskBellBlockEntity;}
declare module "com.simibubi.create.content.trains.signal.SingleBlockEntityEdgePoint" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$UUID} from "java.util.UUID"
import {$Level} from "net.minecraft.world.level.Level"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$TrackNodeLocation} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$TrackEdgePoint} from "com.simibubi.create.content.trains.signal.TrackEdgePoint"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Couple} from "net.createmod.catnip.data.Couple"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $SingleBlockEntityEdgePoint extends $TrackEdgePoint {
 "edgeLocation": $Couple<($TrackNodeLocation)>
 "blockEntityPos": $BlockPos
 "blockEntityDimension": $ResourceKey<($Level)>
 "id": $UUID
 "position": double

constructor()

public "canMerge"(): boolean
public "getBlockEntityDimension"(): $ResourceKey<($Level)>
public "blockEntityAdded"(arg0: $BlockEntity$$Type, arg1: boolean): void
public "blockEntityRemoved"(arg0: $BlockPos$$Type, arg1: boolean): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $DimensionPalette$$Type): void
public "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean, arg3: $DimensionPalette$$Type): void
public "invalidate"(arg0: $LevelAccessor$$Type): void
public "getBlockEntityPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingleBlockEntityEdgePoint$$Type = ($SingleBlockEntityEdgePoint);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SingleBlockEntityEdgePoint$$Original = $SingleBlockEntityEdgePoint;}
declare module "com.simibubi.create.content.kinetics.base.BlockBreakingKineticBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$AtomicInteger} from "java.util.concurrent.atomic.AtomicInteger"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $BlockBreakingKineticBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "NEXT_BREAKER_ID": $AtomicInteger
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "lazyTick"(): void
public "onSpeedChanged"(arg0: float): void
public "canBreak"(arg0: $BlockState$$Type, arg1: float): boolean
public "onBlockBroken"(arg0: $BlockState$$Type): void
public static "isBreakable"(arg0: $BlockState$$Type, arg1: float): boolean
public "destroyNextTick"(): void
public "tick"(): void
public "write"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: boolean): void
public "invalidate"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBreakingKineticBlockEntity$$Type = ($BlockBreakingKineticBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBreakingKineticBlockEntity$$Original = $BlockBreakingKineticBlockEntity;}
declare module "com.simibubi.create.content.contraptions.chassis.RadialChassisBlock" {
import {$RotatedPillarBlock} from "net.minecraft.world.level.block.RotatedPillarBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$AbstractChassisBlock} from "com.simibubi.create.content.contraptions.chassis.AbstractChassisBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RadialChassisBlock extends $AbstractChassisBlock {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "STICKY_NORTH": $BooleanProperty
static readonly "STICKY_WEST": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($RotatedPillarBlock)>
static readonly "STICKY_SOUTH": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "STICKY_EAST": $BooleanProperty
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getGlueableSide"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BooleanProperty
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RadialChassisBlock$$Type = ($RadialChassisBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RadialChassisBlock$$Original = $RadialChassisBlock;}
declare module "com.simibubi.create.content.logistics.depot.DepotBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$DepotBlockEntity, $DepotBlockEntity$$Type} from "com.simibubi.create.content.logistics.depot.DepotBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $DepotBlock extends $Block implements $IBE$$Interface<($DepotBlockEntity)>, $IWrenchable$$Interface, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "getBlockEntityType"(): $BlockEntityType<($DepotBlockEntity)>
public "getBlockEntityClass"(): $Class<($DepotBlockEntity)>
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($DepotBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($DepotBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($DepotBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($DepotBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $DepotBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($DepotBlockEntity)>
get "blockEntityClass"(): $Class<($DepotBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DepotBlock$$Type = ($DepotBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DepotBlock$$Original = $DepotBlock;}
declare module "com.simibubi.create.content.trains.entity.ArrivalSoundQueue" {
import {$CarriageContraptionEntity$$Type} from "com.simibubi.create.content.trains.entity.CarriageContraptionEntity"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$Pair} from "net.createmod.catnip.data.Pair"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ArrivalSoundQueue {
 "offset": integer

constructor()

public static "isPlayable"(arg0: $BlockState$$Type): boolean
public "getFirstWhistle"(arg0: $CarriageContraptionEntity$$Type): $Pair<(boolean), (integer)>
public "lastTick"(): integer
public "tick"(arg0: $CarriageContraptionEntity$$Type, arg1: integer, arg2: boolean): boolean
public "add"(arg0: integer, arg1: $BlockPos$$Type): void
public "deserialize"(arg0: $CompoundTag$$Type): void
public "serialize"(arg0: $CompoundTag$$Type): void
public static "play"(arg0: $CarriageContraptionEntity$$Type, arg1: $StructureTemplate$StructureBlockInfo$$Type): void
public "firstTick"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrivalSoundQueue$$Type = ($ArrivalSoundQueue);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArrivalSoundQueue$$Original = $ArrivalSoundQueue;}
declare module "com.simibubi.create.content.kinetics.turntable.TurntableBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KineticBlockEntity} from "com.simibubi.create.content.kinetics.base.KineticBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SequencedGearshiftBlockEntity$SequenceContext} from "com.simibubi.create.content.kinetics.transmission.sequencer.SequencedGearshiftBlockEntity$SequenceContext"

export class $TurntableBlockEntity extends $KineticBlockEntity {
 "sequenceContext": $SequencedGearshiftBlockEntity$SequenceContext
 "networkDirty": boolean
 "updateSpeed": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "source": $BlockPos
 "preventSpeedUpdate": integer
 "network": long

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurntableBlockEntity$$Type = ($TurntableBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurntableBlockEntity$$Original = $TurntableBlockEntity;}
declare module "com.simibubi.create.content.materials.ExperienceNuggetItem" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Map} from "java.util.Map"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Item} from "net.minecraft.world.item.Item"

export class $ExperienceNuggetItem extends $Item {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "isFoil"(arg0: $ItemStack$$Type): boolean
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperienceNuggetItem$$Type = ($ExperienceNuggetItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExperienceNuggetItem$$Original = $ExperienceNuggetItem;}
declare module "com.simibubi.create.content.equipment.toolbox.ToolboxInventory" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ToolboxBlockEntity$$Type} from "com.simibubi.create.content.equipment.toolbox.ToolboxBlockEntity"
import {$AccessorToolboxInventory$$Interface} from "com.railwayteam.railways.mixin.AccessorToolboxInventory"
import {$List} from "java.util.List"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ItemStackHandler} from "net.neoforged.neoforge.items.ItemStackHandler"

export class $ToolboxInventory extends $ItemStackHandler implements $AccessorToolboxInventory$$Interface {
/**
 * 
 * @deprecated
 */
static readonly "BACKWARDS_COMPAT_CODEC": $Codec<($ToolboxInventory)>
static readonly "CODEC": $Codec<($ToolboxInventory)>
static readonly "STACKS_PER_COMPARTMENT": integer
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ToolboxInventory)>

constructor(arg0: $ToolboxBlockEntity$$Type)

public "inLimitedMode"(arg0: $Consumer$$Type<($ToolboxInventory)>): void
public static "canItemsShareCompartment"(arg0: $ItemStack$$Type, arg1: $ItemStack$$Type): boolean
public "distributeToCompartment"(arg0: $ItemStack$$Type, arg1: integer, arg2: boolean): $ItemStack
public "takeFromCompartment"(arg0: integer, arg1: integer, arg2: boolean): $ItemStack
public static "cleanItemNBT"(arg0: $ItemStack$$Type): $ItemStack
public "settle"(arg0: integer): void
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "getFilters"(): $List
public "insertItem"(arg0: integer, arg1: $ItemStack$$Type, arg2: boolean): $ItemStack
public "isItemValid"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "setStackInSlot"(arg0: integer, arg1: $ItemStack$$Type): void
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
public "deserializeNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $Tag$$Type): void
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
set "tle"(value: integer)
get "filters"(): $List
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ToolboxInventory$$Type = ($ToolboxInventory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ToolboxInventory$$Original = $ToolboxInventory;}
declare module "com.simibubi.create.content.decoration.copycat.CopycatPanelBlock" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ICopycatBlock$$Type, $ICopycatBlock$$Interface} from "com.copycatsplus.copycats.foundation.copycat.ICopycatBlock"
import {$BlockColor} from "net.minecraft.client.color.block.BlockColor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$CopycatBlockEntity} from "com.simibubi.create.content.decoration.copycat.CopycatBlockEntity"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty$$Type} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$WaterloggedCopycatBlock} from "com.simibubi.create.content.decoration.copycat.WaterloggedCopycatBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $CopycatPanelBlock extends $WaterloggedCopycatBlock implements $ICopycatBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "useWithoutItem"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, player: $Player$$Type, hitResult: $BlockHitResult$$Type): $InteractionResult
public "hidesNeighborFace"(level: $BlockGetter$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, neighborState: $BlockState$$Type, dir: $Direction$$Type): boolean
public "supportsExternalFaceHiding"(state: $BlockState$$Type): boolean
public "getAppearance"(state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, side: $Direction$$Type, queryState: $BlockState$$Type, queryPos: $BlockPos$$Type): $BlockState
public "canFaceBeOccluded"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "isIgnoredConnectivitySide"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type): boolean
public "canConnectTexturesToward"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "shouldFaceAlwaysRender"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "prepareMaterial"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type, arg4: $InteractionHand$$Type, arg5: $BlockHitResult$$Type, arg6: $BlockState$$Type): $BlockState
public "isAcceptedRegardless"(arg0: $BlockState$$Type): boolean
public static "isOccluded"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "getBlockEntity"(worldIn: $BlockGetter$$Type, pos: $BlockPos$$Type): $CopycatBlockEntity
public "setPlacedBy"(worldIn: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, placer: $LivingEntity$$Type, stack: $ItemStack$$Type): void
public "playerWillDestroy"(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, player: $Player$$Type): $BlockState
public static "getAppearance"(block: $ICopycatBlock$$Type, state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, side: $Direction$$Type, queryState: $BlockState$$Type, queryPos: $BlockPos$$Type): $BlockState
public "getAcceptedBlockState"(pLevel: $Level$$Type, pPos: $BlockPos$$Type, item: $ItemStack$$Type, face: $Direction$$Type): $BlockState
public static "getRequiredItemsForLayer"(state: $BlockState$$Type, property: $IntegerProperty$$Type): $ItemRequirement
public static "wrappedColor"(): $BlockColor
public "onWrenched"(state: $BlockState$$Type, context: $UseOnContext$$Type): $InteractionResult
public "onSneakWrenched"(state: $BlockState$$Type, context: $UseOnContext$$Type): $InteractionResult
public static "getMaterial"(reader: $BlockGetter$$Type, targetPos: $BlockPos$$Type): $BlockState
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopycatPanelBlock$$Type = ($CopycatPanelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CopycatPanelBlock$$Original = $CopycatPanelBlock;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour$ProcessingCallback" {
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$TransportedItemStack, $TransportedItemStack$$Type} from "com.simibubi.create.content.kinetics.belt.transport.TransportedItemStack"
import {$TransportedItemStackHandlerBehaviour$TransportedResult, $TransportedItemStackHandlerBehaviour$TransportedResult$$Type} from "com.simibubi.create.content.kinetics.belt.behaviour.TransportedItemStackHandlerBehaviour$TransportedResult"

export interface $TransportedItemStackHandlerBehaviour$ProcessingCallback$$Interface {

(arg0: float, arg1: $Function<($TransportedItemStack), ($TransportedItemStackHandlerBehaviour$TransportedResult$$Type)>): void
}

export class $TransportedItemStackHandlerBehaviour$ProcessingCallback implements $TransportedItemStackHandlerBehaviour$ProcessingCallback$$Interface {
 "applyToAllItems"(arg0: float, arg1: $Function$$Type<($TransportedItemStack), ($TransportedItemStackHandlerBehaviour$TransportedResult$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransportedItemStackHandlerBehaviour$ProcessingCallback$$Type = ((arg0: float, arg1: $Function<($TransportedItemStack), ($TransportedItemStackHandlerBehaviour$TransportedResult)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TransportedItemStackHandlerBehaviour$ProcessingCallback$$Original = $TransportedItemStackHandlerBehaviour$ProcessingCallback;}
declare module "com.simibubi.create.content.redstone.diodes.PoweredLatchBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$ToggleLatchBlock} from "com.simibubi.create.content.redstone.diodes.ToggleLatchBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PoweredLatchBlock extends $ToggleLatchBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ToggleLatchBlock)>
static "POWERED_SIDE": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static "POWERING": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoweredLatchBlock$$Type = ($PoweredLatchBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PoweredLatchBlock$$Original = $PoweredLatchBlock;}
declare module "com.simibubi.create.content.schematics.requirement.ItemRequirement$ItemUseType" {
import {$Enum} from "java.lang.Enum"

export class $ItemRequirement$ItemUseType extends $Enum<($ItemRequirement$ItemUseType)> {
static readonly "CONSUME": $ItemRequirement$ItemUseType
static readonly "DAMAGE": $ItemRequirement$ItemUseType

public static "values"(): ($ItemRequirement$ItemUseType)[]
public static "valueOf"(arg0: StringJS): $ItemRequirement$ItemUseType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemRequirement$ItemUseType$$Type = (("consume") | ("damage"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemRequirement$ItemUseType$$Original = $ItemRequirement$ItemUseType;}
declare module "com.simibubi.create.content.schematics.SchematicPrinter" {
import {$SchematicPrinter$EntityTargetHandler$$Type} from "com.simibubi.create.content.schematics.SchematicPrinter$EntityTargetHandler"
import {$SchematicPrinter$BlockTargetHandler$$Type} from "com.simibubi.create.content.schematics.SchematicPrinter$BlockTargetHandler"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$SchematicPrinter$PlacementPredicate$$Type} from "com.simibubi.create.content.schematics.SchematicPrinter$PlacementPredicate"
import {$MaterialChecklist$$Type} from "com.simibubi.create.content.schematics.cannon.MaterialChecklist"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$SchematicPrinter$PrintStage} from "com.simibubi.create.content.schematics.SchematicPrinter$PrintStage"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SchematicPrinter {
constructor()

public "advanceCurrentPos"(): boolean
public "getCurrentRequirement"(): $ItemRequirement
public "shouldPlaceCurrent"(arg0: $Level$$Type): boolean
public "shouldPlaceCurrent"(arg0: $Level$$Type, arg1: $SchematicPrinter$PlacementPredicate$$Type): boolean
public "handleCurrentTarget"(arg0: $SchematicPrinter$BlockTargetHandler$$Type, arg1: $SchematicPrinter$EntityTargetHandler$$Type): void
public "loadSchematic"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: boolean): void
public "resetSchematic"(): void
public "isWorldEmpty"(): boolean
public "getAnchor"(): $BlockPos
public "sendBlockUpdates"(arg0: $Level$$Type): void
public "markAllBlockRequirements"(arg0: $MaterialChecklist$$Type, arg1: $Level$$Type, arg2: $SchematicPrinter$PlacementPredicate$$Type): integer
public "markAllEntityRequirements"(arg0: $MaterialChecklist$$Type): void
public "shouldPlaceBlock"(arg0: $Level$$Type, arg1: $SchematicPrinter$PlacementPredicate$$Type, arg2: $BlockPos$$Type): boolean
public "tryAdvanceCurrentPos"(): boolean
public static "shouldDeferBlock"(arg0: $BlockState$$Type): boolean
public "getPrintStage"(): $SchematicPrinter$PrintStage
public "write"(arg0: $CompoundTag$$Type): void
public "isLoaded"(): boolean
public "getCurrentTarget"(): $BlockPos
public "fromTag"(arg0: $CompoundTag$$Type, arg1: boolean): void
public "isErrored"(): boolean
get "currentRequirement"(): $ItemRequirement
get "worldEmpty"(): boolean
get "anchor"(): $BlockPos
get "printStage"(): $SchematicPrinter$PrintStage
get "loaded"(): boolean
get "currentTarget"(): $BlockPos
get "errored"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchematicPrinter$$Type = ($SchematicPrinter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SchematicPrinter$$Original = $SchematicPrinter;}
declare module "com.simibubi.create.content.kinetics.waterwheel.LargeWaterWheelBlockItem" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockItem} from "net.minecraft.world.item.BlockItem"
import {$AdditionalItemPlacement, $AdditionalItemPlacement$$Type} from "net.mehvahdjukaar.moonlight.api.item.additional_placements.AdditionalItemPlacement"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $LargeWaterWheelBlockItem extends $BlockItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Block$$Type, arg1: $Item$Properties$$Type)

public "showBounds"(arg0: $BlockPlaceContext$$Type): void
public "place"(arg0: $BlockPlaceContext$$Type): $InteractionResult
public "moonlight$getAdditionalBehavior"(): $AdditionalItemPlacement
public "moonlight$setAdditionalBehavior"(arg0: $AdditionalItemPlacement$$Type): void
public "moonlight$getClientAnimationExtension"(): any
public "moonlight$setClientAnimationExtension"(arg0: any): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LargeWaterWheelBlockItem$$Type = ($LargeWaterWheelBlockItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LargeWaterWheelBlockItem$$Original = $LargeWaterWheelBlockItem;}
declare module "com.simibubi.create.content.logistics.depot.EjectorBlockEntity$State" {
import {$Enum} from "java.lang.Enum"

export class $EjectorBlockEntity$State extends $Enum<($EjectorBlockEntity$State)> {
static readonly "LAUNCHING": $EjectorBlockEntity$State
static readonly "CHARGED": $EjectorBlockEntity$State
static readonly "RETRACTING": $EjectorBlockEntity$State

public static "values"(): ($EjectorBlockEntity$State)[]
public static "valueOf"(arg0: StringJS): $EjectorBlockEntity$State
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EjectorBlockEntity$State$$Type = (("charged") | ("launching") | ("retracting"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EjectorBlockEntity$State$$Original = $EjectorBlockEntity$State;}
declare module "com.simibubi.create.content.trains.bogey.BogeyVisual" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$Instance$$Type} from "dev.engine_room.flywheel.api.instance.Instance"
import {$Consumer$$Type} from "java.util.function.Consumer"

export interface $BogeyVisual$$Interface {
}

export class $BogeyVisual implements $BogeyVisual$$Interface {
 "hide"(): void
 "collectCrumblingInstances"(arg0: $Consumer$$Type<($Instance)>): void
 "updateLight"(arg0: integer): void
 "update"(arg0: $CompoundTag$$Type, arg1: float, arg2: $PoseStack$$Type): void
 "delete"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BogeyVisual$$Type = ($BogeyVisual);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BogeyVisual$$Original = $BogeyVisual;}
declare module "com.simibubi.create.content.kinetics.fan.AirCurrent$AirCurrentSegment" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $AirCurrent$AirCurrentSegment {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AirCurrent$AirCurrentSegment$$Type = ($AirCurrent$AirCurrentSegment);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AirCurrent$AirCurrentSegment$$Original = $AirCurrent$AirCurrentSegment;}
declare module "com.simibubi.create.content.equipment.sandPaper.SandPaperItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$ItemAbility$$Type} from "net.neoforged.neoforge.common.ItemAbility"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IClientItemExtensions$$Type} from "net.neoforged.neoforge.client.extensions.common.IClientItemExtensions"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$UseAnim} from "net.minecraft.world.item.UseAnim"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$TriState} from "net.createmod.catnip.data.TriState"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$CustomUseEffectsItem$$Interface} from "com.simibubi.create.foundation.item.CustomUseEffectsItem"

export class $SandPaperItem extends $Item implements $CustomUseEffectsItem$$Interface {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "initializeClient"(arg0: $Consumer$$Type<($IClientItemExtensions)>): void
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "getEnchantmentValue"(): integer
public static "spawnParticles"(arg0: $Vec3$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type): void
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public "getEatingSound"(): $SoundEvent
public "getUseDuration"(arg0: $ItemStack$$Type, arg1: $LivingEntity$$Type): integer
public "getUseAnimation"(arg0: $ItemStack$$Type): $UseAnim
public "releaseUsing"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $LivingEntity$$Type, arg3: integer): void
public "canPerformAction"(arg0: $ItemStack$$Type, arg1: $ItemAbility$$Type): boolean
public "shouldTriggerUseEffects"(arg0: $ItemStack$$Type, arg1: $LivingEntity$$Type): $TriState
public "triggerUseEffects"(arg0: $ItemStack$$Type, arg1: $LivingEntity$$Type, arg2: integer, arg3: $RandomSource$$Type): boolean
public "finishUsingItem"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $LivingEntity$$Type): $ItemStack
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "enchantmentValue"(): integer
get "eatingSound"(): $SoundEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SandPaperItem$$Type = ($SandPaperItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SandPaperItem$$Original = $SandPaperItem;}
declare module "com.simibubi.create.content.kinetics.base.HorizontalKineticBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$KineticBlock} from "com.simibubi.create.content.kinetics.base.KineticBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $HorizontalKineticBlock extends $KineticBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "HORIZONTAL_FACING": $Property<($Direction)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getPreferredHorizontalFacing"(arg0: $BlockPlaceContext$$Type): $Direction
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HorizontalKineticBlock$$Type = ($HorizontalKineticBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HorizontalKineticBlock$$Original = $HorizontalKineticBlock;}
declare module "com.simibubi.create.content.logistics.packager.repackager.RepackagerBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$PackagerBlock} from "com.simibubi.create.content.logistics.packager.PackagerBlock"
import {$WrenchableDirectionalBlock} from "com.simibubi.create.foundation.block.WrenchableDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$PackagerBlockEntity} from "com.simibubi.create.content.logistics.packager.PackagerBlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RepackagerBlock extends $PackagerBlock {
static readonly "LINKED": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WrenchableDirectionalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($PackagerBlockEntity)>
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($PackagerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RepackagerBlock$$Type = ($RepackagerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RepackagerBlock$$Original = $RepackagerBlock;}
declare module "com.simibubi.create.content.contraptions.actors.harvester.HarvesterBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$CachedRenderBBBlockEntity} from "com.simibubi.create.foundation.blockEntity.CachedRenderBBBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HarvesterBlockEntity extends $CachedRenderBBBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getAnimatedSpeed"(): float
public "setAnimatedSpeed"(arg0: float): void
get "animatedSpeed"(): float
set "animatedSpeed"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HarvesterBlockEntity$$Type = ($HarvesterBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HarvesterBlockEntity$$Original = $HarvesterBlockEntity;}
declare module "com.simibubi.create.content.logistics.item.filter.attribute.attributes.ShulkerFillLevelAttribute$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemAttribute} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttribute"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ItemAttributeType$$Interface} from "com.simibubi.create.content.logistics.item.filter.attribute.ItemAttributeType"

export class $ShulkerFillLevelAttribute$Type implements $ItemAttributeType$$Interface {
constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ItemAttribute)>
public "getAllAttributes"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemAttribute)>
public "createAttribute"(): $ItemAttribute
public "codec"(): $MapCodec<($ItemAttribute)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShulkerFillLevelAttribute$Type$$Type = ($ShulkerFillLevelAttribute$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShulkerFillLevelAttribute$Type$$Original = $ShulkerFillLevelAttribute$Type;}
declare module "com.simibubi.create.content.decoration.MetalLadderBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$LadderBlock} from "net.minecraft.world.level.block.LadderBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MetalLadderBlock extends $LadderBlock implements $IWrenchable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LadderBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "skipRendering"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "supportsExternalFaceHiding"(arg0: $BlockState$$Type): boolean
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetalLadderBlock$$Type = ($MetalLadderBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MetalLadderBlock$$Original = $MetalLadderBlock;}
declare module "com.simibubi.create.content.contraptions.bearing.BearingBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DirectionalKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalKineticBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BearingBlock extends $DirectionalKineticBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "hasShaftTowards"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "showCapacityWithAnnotation"(): boolean
public "getRotationAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BearingBlock$$Type = ($BearingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BearingBlock$$Original = $BearingBlock;}
declare module "com.simibubi.create.content.equipment.zapper.ZapperItem" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$AbstractClientPlayer$$Type} from "net.minecraft.client.player.AbstractClientPlayer"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$CustomArmPoseItem$$Interface} from "com.simibubi.create.foundation.item.CustomArmPoseItem"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$HumanoidModel$ArmPose} from "net.minecraft.client.model.HumanoidModel$ArmPose"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$UseAnim} from "net.minecraft.world.item.UseAnim"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ZapperItem extends $Item implements $CustomArmPoseItem$$Interface {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Item$Properties$$Type)

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "canAttackBlock"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): boolean
public "useOn"(arg0: $UseOnContext$$Type): $InteractionResult
public "shouldCauseReequipAnimation"(arg0: $ItemStack$$Type, arg1: $ItemStack$$Type, arg2: boolean): boolean
public "getArmPose"(arg0: $ItemStack$$Type, arg1: $AbstractClientPlayer$$Type, arg2: $InteractionHand$$Type): $HumanoidModel$ArmPose
public "validateUsage"(arg0: $ItemStack$$Type): $Component
public "isZapper"(arg0: $ItemStack$$Type): boolean
public "use"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "setBlockEntityData"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CompoundTag$$Type, arg4: $Player$$Type): void
public "onEntitySwing"(arg0: $ItemStack$$Type, arg1: $LivingEntity$$Type): boolean
public "getUseAnimation"(arg0: $ItemStack$$Type): $UseAnim
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ZapperItem$$Type = ($ZapperItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ZapperItem$$Original = $ZapperItem;}
declare module "com.simibubi.create.content.processing.recipe.StandardProcessingRecipe$Serializer" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$RecipeSerializer, $RecipeSerializer$$Type, $RecipeSerializer$$Interface} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$StandardProcessingRecipe} from "com.simibubi.create.content.processing.recipe.StandardProcessingRecipe"
import {$StandardProcessingRecipe$Factory, $StandardProcessingRecipe$Factory$$Type} from "com.simibubi.create.content.processing.recipe.StandardProcessingRecipe$Factory"

export class $StandardProcessingRecipe$Serializer<R extends $StandardProcessingRecipe<(object)>> implements $RecipeSerializer$$Interface<(R)> {
constructor(arg0: $StandardProcessingRecipe$Factory$$Type<(R)>)

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (R)>
public "factory"(): $StandardProcessingRecipe$Factory<(R)>
public "codec"(): $MapCodec<(R)>
public static "register"<S extends $RecipeSerializer<(object)>, T extends $Recipe<(object)>>(arg0: StringJS, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StandardProcessingRecipe$Serializer$$Type<R> = ($StandardProcessingRecipe$Serializer<(R)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StandardProcessingRecipe$Serializer$$Original<R> = $StandardProcessingRecipe$Serializer<(R)>;}
declare module "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBlock" {
import {$FactoryPanelBlockEntity, $FactoryPanelBlockEntity$$Type} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBlockEntity"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$FactoryPanelBlock$PanelSlot} from "com.simibubi.create.content.logistics.factoryBoard.FactoryPanelBlock$PanelSlot"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$FaceAttachedHorizontalDirectionalBlock} from "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ItemRequirement} from "com.simibubi.create.content.schematics.requirement.ItemRequirement"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$IWrenchable$$Interface} from "com.simibubi.create.content.equipment.wrench.IWrenchable"
import {$SpecialBlockItemRequirement$$Interface} from "com.simibubi.create.api.schematic.requirement.SpecialBlockItemRequirement"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $FactoryPanelBlock extends $FaceAttachedHorizontalDirectionalBlock implements $ProperWaterloggedBlock$$Interface, $IBE$$Interface<($FactoryPanelBlockEntity)>, $IWrenchable$$Interface, $SpecialBlockItemRequirement$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FactoryPanelBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($AttachFace)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "canBeReplaced"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onDestroyedByPlayer"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type, arg4: boolean, arg5: $FluidState$$Type): boolean
public "getRequiredItems"(arg0: $BlockState$$Type, arg1: $BlockEntity$$Type): $ItemRequirement
public "getBlockEntityType"(): $BlockEntityType<($FactoryPanelBlockEntity)>
public "getBlockEntityClass"(): $Class<($FactoryPanelBlockEntity)>
public static "connectedDirection"(arg0: $BlockState$$Type): $Direction
public static "getTargetedSlot"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $Vec3$$Type): $FactoryPanelBlock$PanelSlot
public "onSneakWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "canAttachLenient"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public static "getXRot"(arg0: $BlockState$$Type): float
public static "getYRot"(arg0: $BlockState$$Type): float
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getDirectSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($FactoryPanelBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($FactoryPanelBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FactoryPanelBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FactoryPanelBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $FactoryPanelBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public "updateAfterWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($FactoryPanelBlockEntity)>
get "blockEntityClass"(): $Class<($FactoryPanelBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FactoryPanelBlock$$Type = ($FactoryPanelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FactoryPanelBlock$$Original = $FactoryPanelBlock;}
declare module "com.simibubi.create.content.kinetics.belt.behaviour.BeltProcessingBehaviour$ProcessingResult" {
import {$Enum} from "java.lang.Enum"

export class $BeltProcessingBehaviour$ProcessingResult extends $Enum<($BeltProcessingBehaviour$ProcessingResult)> {
static readonly "PASS": $BeltProcessingBehaviour$ProcessingResult
static readonly "REMOVE": $BeltProcessingBehaviour$ProcessingResult
static readonly "HOLD": $BeltProcessingBehaviour$ProcessingResult

public static "values"(): ($BeltProcessingBehaviour$ProcessingResult)[]
public static "valueOf"(arg0: StringJS): $BeltProcessingBehaviour$ProcessingResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltProcessingBehaviour$ProcessingResult$$Type = (("pass") | ("hold") | ("remove"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltProcessingBehaviour$ProcessingResult$$Original = $BeltProcessingBehaviour$ProcessingResult;}
declare module "com.simibubi.create.content.contraptions.AbstractContraptionEntity" {
import {$Optional} from "java.util.Optional"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$PoseStack$$Type} from "com.mojang.blaze3d.vertex.PoseStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$MoverType$$Type} from "net.minecraft.world.entity.MoverType"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$ScoreHolder} from "net.minecraft.world.scores.ScoreHolder"
import {$StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$PortalProcessor} from "net.minecraft.world.entity.PortalProcessor"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$IEntityWithComplexSpawn$$Interface} from "net.neoforged.neoforge.entity.IEntityWithComplexSpawn"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$AbstractContraptionEntity$ContraptionRotationState} from "com.simibubi.create.content.contraptions.AbstractContraptionEntity$ContraptionRotationState"
import {$Entity$MoveFunction$$Type} from "net.minecraft.world.entity.Entity$MoveFunction"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection$$Type} from "java.util.Collection"
import {$Map} from "java.util.Map"
import {$EntityType$Builder, $EntityType$Builder$$Type} from "net.minecraft.world.entity.EntityType$Builder"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$AccessorAbstractContraptionEntity$$Interface} from "com.railwayteam.railways.mixin.AccessorAbstractContraptionEntity"
import {$Contraption} from "com.simibubi.create.content.contraptions.Contraption"
import {$Entity$RemovalReason, $Entity$RemovalReason$$Type} from "net.minecraft.world.entity.Entity$RemovalReason"
import {$StructureTransform$$Type} from "com.simibubi.create.content.contraptions.StructureTransform"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$EntityInLevelCallback} from "net.minecraft.world.level.entity.EntityInLevelCallback"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MutableInt} from "org.apache.commons.lang3.mutable.MutableInt"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"

export class $AbstractContraptionEntity extends $Entity implements $IEntityWithComplexSpawn$$Interface, $AccessorAbstractContraptionEntity$$Interface {
 "hasImpulse": boolean
 "tickCount": integer
 "noPhysics": boolean
 "yo": double
static readonly "BOARDING_COOLDOWN": integer
 "removalReason": $Entity$RemovalReason
 "yRotO": float
static readonly "CONTENTS_SLOT_INDEX": integer
 "level": $Level
 "moveDist": float
static readonly "ID_TAG": StringJS
 "mainSupportingBlockPos": $Optional<($BlockPos)>
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0": double
 "xRotO": float
 "zo": double
 "walkDist": float
 "xOld": double
 "noCulling": boolean
 "wasInPowderSnow": boolean
 "hurtMarked": boolean
 "staleTicks": integer
 "invulnerableTime": integer
static readonly "UUID_TAG": StringJS
static readonly "BASE_TICKS_REQUIRED_TO_FREEZE": integer
 "fallDistance": float
 "portalProcess": $PortalProcessor
 "verticalCollision": boolean
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5": double
static readonly "MAX_ENTITY_TAG_COUNT": integer
static readonly "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2": float
 "verticalCollisionBelow": boolean
 "yOld": double
static readonly "DEFAULT_BB_WIDTH": float
 "minorHorizontalCollision": boolean
static readonly "DEFAULT_BB_HEIGHT": float
 "levelCallback": $EntityInLevelCallback
 "walkDistO": float
static readonly "FREEZE_HURT_FREQUENCY": integer
 "flyDist": float
 "isInPowderSnow": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
static readonly "PASSENGERS_TAG": StringJS
 "blocksBuilding": boolean
 "wasOnFire": boolean
 "zOld": double
static readonly "TOTAL_AIR_SUPPLY": integer
 "xo": double
readonly "collidingEntities": $Map<($Entity), ($MutableInt)>
static readonly "BASE_SAFE_FALL_DISTANCE": integer
 "wasTouchingWater": boolean
 "horizontalCollision": boolean

constructor(arg0: $EntityType$$Type<(never)>, arg1: $Level$$Type)

public "addSittingPassenger"(arg0: $Entity$$Type, arg1: integer): void
public "handlePlayerInteraction"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $InteractionHand$$Type): boolean
public "stopControlling"(arg0: $BlockPos$$Type): void
public "startControlling"(arg0: $BlockPos$$Type, arg1: $Player$$Type): boolean
public "setControllingPlayer"(arg0: $UUID$$Type): void
public "getControllingPlayer"(): $Optional<($UUID)>
public "toGlobalVector"(arg0: $Vec3$$Type, arg1: float, arg2: boolean): $Vec3
public "toGlobalVector"(arg0: $Vec3$$Type, arg1: float): $Vec3
public "getYawOffset"(): float
public "getRotationState"(): $AbstractContraptionEntity$ContraptionRotationState
public static "yawFromVector"(arg0: $Vec3$$Type): float
public "applyRotation"(arg0: $Vec3$$Type, arg1: float): $Vec3
public "reverseRotation"(arg0: $Vec3$$Type, arg1: float): $Vec3
public "isStalled"(): boolean
public "tickActors"(): void
public "supportsTerrainCollision"(): boolean
public "collisionEnabled"(): boolean
public "getContraptionName"(): $Component
public "toLocalVector"(arg0: $Vec3$$Type, arg1: float, arg2: boolean): $Vec3
public "toLocalVector"(arg0: $Vec3$$Type, arg1: float): $Vec3
public "alignPassenger"(arg0: $Entity$$Type): void
public "getContactPointMotion"(arg0: $Vec3$$Type): $Vec3
public "refreshPSIs"(): void
public "getPrevPositionVec"(): $Vec3
public static "pitchFromVector"(arg0: $Vec3$$Type): float
public "setContraptionMotion"(arg0: $Vec3$$Type): void
public "isReadyForRender"(): boolean
public "isAliveOrStale"(): boolean
public "isPrevPosInvalid"(): boolean
public "railways$setSkipActorStop"(arg0: boolean): void
public "writeSpawnData"(arg0: $RegistryFriendlyByteBuf$$Type): void
public "readSpawnData"(arg0: $RegistryFriendlyByteBuf$$Type): void
public "getAnchorVec"(): $Vec3
public "getPrevAnchorVec"(): $Vec3
public "applyLocalTransforms"(arg0: $PoseStack$$Type, arg1: float): void
public "getPassengerPosition"(arg0: $Entity$$Type, arg1: float): $Vec3
public "railways$moveCollidedEntitiesOnDisassembly"(arg0: $StructureTransform$$Type): void
public "tick"(): void
public "kill"(): void
public "move"(arg0: $MoverType$$Type, arg1: $Vec3$$Type): void
public "move"(arg0: double, arg1: double, arg2: double): void
public "control"(arg0: $BlockPos$$Type, arg1: $Collection$$Type<(integer)>, arg2: $Player$$Type): boolean
public "remove"(arg0: $Entity$RemovalReason$$Type): void
public static "build"(arg0: $EntityType$Builder$$Type<(never)>): $EntityType$Builder<(never)>
public "setBlock"(arg0: $BlockPos$$Type, arg1: $StructureTemplate$StructureBlockInfo$$Type): void
public "disassemble"(): void
public "attack"(arg0: $DamageSource$$Type, arg1: float): boolean
public "setPos"(arg0: double, arg1: double, arg2: double): void
public "fireImmune"(): boolean
public "setDeltaMovement"(arg0: $Vec3$$Type): void
public "getDismountLocationForPassenger"(arg0: $LivingEntity$$Type): $Vec3
public "isPickable"(): boolean
public "igniteForTicks"(arg0: integer): void
public "saveWithoutId"(arg0: $CompoundTag$$Type): $CompoundTag
public "onRemovedFromLevel"(): void
public "canCollideWith"(arg0: $Entity$$Type): boolean
public "positionRider"(arg0: $Entity$$Type, arg1: $Entity$MoveFunction$$Type): void
public "isIgnoringBlockTriggers"(): boolean
public "hasExactlyOnePlayerPassenger"(): boolean
public "getPistonPushReaction"(): $PushReaction
public "getContraption"(): $Contraption
public "registerColliding"(arg0: $Entity$$Type): void
public static "forNameOnly"(arg0: StringJS): $ScoreHolder
public static "fromGameProfile"(arg0: $GameProfile$$Type): $ScoreHolder
/**
 * 
 * @deprecated
 */
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $Tag
set "controllingPlayer"(value: $UUID$$Type)
get "controllingPlayer"(): $Optional<($UUID)>
get "yawOffset"(): float
get "rotationState"(): $AbstractContraptionEntity$ContraptionRotationState
get "stalled"(): boolean
get "contraptionName"(): $Component
get "prevPositionVec"(): $Vec3
set "contraptionMotion"(value: $Vec3$$Type)
get "readyForRender"(): boolean
get "aliveOrStale"(): boolean
get "prevPosInvalid"(): boolean
get "anchorVec"(): $Vec3
get "prevAnchorVec"(): $Vec3
set "deltaMovement"(value: $Vec3$$Type)
get "pickable"(): boolean
get "ignoringBlockTriggers"(): boolean
get "pistonPushReaction"(): $PushReaction
get "contraption"(): $Contraption
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractContraptionEntity$$Type = ($AbstractContraptionEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractContraptionEntity$$Original = $AbstractContraptionEntity;}
declare module "com.simibubi.create.content.trains.graph.TrackNodeLocation$DiscoveredLocation" {
import {$TrackNodeLocation} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$BezierConnection, $BezierConnection$$Type} from "com.simibubi.create.content.trains.track.BezierConnection"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$TrackMaterial$$Type} from "com.simibubi.create.content.trains.track.TrackMaterial"

export class $TrackNodeLocation$DiscoveredLocation extends $TrackNodeLocation {
static readonly "ZERO": $Vec3i
static readonly "CODEC": $Codec<($Vec3i)>
 "yOffsetPixels": integer
 "dimension": $ResourceKey<($Level)>

constructor(arg0: $Level$$Type, arg1: $Vec3$$Type)
constructor(arg0: $Level$$Type, arg1: double, arg2: double, arg3: double)
constructor(arg0: $ResourceKey$$Type<($Level)>, arg1: $Vec3$$Type)

public "connectedViaTurn"(): boolean
public "shouldForceNode"(): boolean
public "differentMaterials"(): boolean
public "notInLineWith"(arg0: $Vec3$$Type): boolean
public "getTurn"(): $BezierConnection
public "materials"(arg0: $TrackMaterial$$Type, arg1: $TrackMaterial$$Type): $TrackNodeLocation$DiscoveredLocation
public "viaTurn"(arg0: $BezierConnection$$Type): $TrackNodeLocation$DiscoveredLocation
public "materialA"(arg0: $TrackMaterial$$Type): $TrackNodeLocation$DiscoveredLocation
public "materialB"(arg0: $TrackMaterial$$Type): $TrackNodeLocation$DiscoveredLocation
public "withNormal"(arg0: $Vec3$$Type): $TrackNodeLocation$DiscoveredLocation
public "withYOffset"(arg0: integer): $TrackNodeLocation$DiscoveredLocation
public "forceNode"(): $TrackNodeLocation$DiscoveredLocation
public "getDirection"(): $Vec3
public "withDirection"(arg0: $Vec3$$Type): $TrackNodeLocation$DiscoveredLocation
get "turn"(): $BezierConnection
get "direction"(): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackNodeLocation$DiscoveredLocation$$Type = ($TrackNodeLocation$DiscoveredLocation);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackNodeLocation$DiscoveredLocation$$Original = $TrackNodeLocation$DiscoveredLocation;}
declare module "com.simibubi.create.content.contraptions.behaviour.dispenser.storage.DispenserMountedStorage" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$SimpleMountedStorage} from "com.simibubi.create.api.contraption.storage.item.simple.SimpleMountedStorage"
import {$IItemHandler$$Type} from "net.neoforged.neoforge.items.IItemHandler"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MountedItemStorageType} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorageType"
import {$MountedItemStorage} from "com.simibubi.create.api.contraption.storage.item.MountedItemStorage"

export class $DispenserMountedStorage extends $SimpleMountedStorage {
static readonly "CODEC": $MapCodec<($DispenserMountedStorage)>
readonly "type": $MountedItemStorageType<($MountedItemStorage)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MountedItemStorage)>

constructor(arg0: $IItemHandler$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DispenserMountedStorage$$Type = ($DispenserMountedStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DispenserMountedStorage$$Original = $DispenserMountedStorage;}
declare module "com.simibubi.create.content.fluids.potion.PotionFluid" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$VirtualFluid} from "com.simibubi.create.content.fluids.VirtualFluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BaseFlowingFluid$Properties$$Type} from "net.neoforged.neoforge.fluids.BaseFlowingFluid$Properties"
import {$PotionFluid$BottleType$$Type} from "com.simibubi.create.content.fluids.potion.PotionFluid$BottleType"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"

export class $PotionFluid extends $VirtualFluid {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty

constructor(arg0: $BaseFlowingFluid$Properties$$Type, arg1: boolean)

public static "createSource"(arg0: $BaseFlowingFluid$Properties$$Type): $PotionFluid
public static "createFlowing"(arg0: $BaseFlowingFluid$Properties$$Type): $PotionFluid
public static "addPotionToFluidStack"(arg0: $FluidStack$$Type, arg1: $PotionContents$$Type): $FluidStack
public static "of"(arg0: integer, arg1: $PotionContents$$Type, arg2: $PotionFluid$BottleType$$Type): $FluidStack
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionFluid$$Type = ($PotionFluid);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotionFluid$$Original = $PotionFluid;}
declare module "com.simibubi.create.content.logistics.crate.CreativeCrateBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$CrateBlock} from "com.simibubi.create.content.logistics.crate.CrateBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$CreativeCrateBlockEntity, $CreativeCrateBlockEntity$$Type} from "com.simibubi.create.content.logistics.crate.CreativeCrateBlockEntity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $CreativeCrateBlock extends $CrateBlock implements $IBE$$Interface<($CreativeCrateBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CrateBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getBlockEntityType"(): $BlockEntityType<($CreativeCrateBlockEntity)>
public "getBlockEntityClass"(): $Class<($CreativeCrateBlockEntity)>
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($CreativeCrateBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($CreativeCrateBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CreativeCrateBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CreativeCrateBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $CreativeCrateBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getRotatedBlockState"(arg0: $BlockState$$Type, arg1: $Direction$$Type): $BlockState
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($CreativeCrateBlockEntity)>
get "blockEntityClass"(): $Class<($CreativeCrateBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeCrateBlock$$Type = ($CreativeCrateBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeCrateBlock$$Original = $CreativeCrateBlock;}
declare module "com.simibubi.create.content.trains.signal.SignalBlockEntity$SignalState" {
import {$Enum} from "java.lang.Enum"

export class $SignalBlockEntity$SignalState extends $Enum<($SignalBlockEntity$SignalState)> {
static readonly "RED": $SignalBlockEntity$SignalState
static readonly "YELLOW": $SignalBlockEntity$SignalState
static readonly "INVALID": $SignalBlockEntity$SignalState
static readonly "GREEN": $SignalBlockEntity$SignalState

public "isRedLight"(arg0: float): boolean
public "isYellowLight"(arg0: float): boolean
public "isGreenLight"(arg0: float): boolean
public static "values"(): ($SignalBlockEntity$SignalState)[]
public static "valueOf"(arg0: StringJS): $SignalBlockEntity$SignalState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignalBlockEntity$SignalState$$Type = (("red") | ("yellow") | ("green") | ("invalid"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignalBlockEntity$SignalState$$Original = $SignalBlockEntity$SignalState;}
declare module "com.simibubi.create.content.logistics.tunnel.BeltTunnelBlock$Shape" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BeltTunnelBlock$Shape extends $Enum<($BeltTunnelBlock$Shape)> implements $StringRepresentable$$Interface {
static readonly "CLOSED": $BeltTunnelBlock$Shape
static readonly "CROSS": $BeltTunnelBlock$Shape
static readonly "T_LEFT": $BeltTunnelBlock$Shape
static readonly "STRAIGHT": $BeltTunnelBlock$Shape
static readonly "T_RIGHT": $BeltTunnelBlock$Shape
static readonly "WINDOW": $BeltTunnelBlock$Shape

public static "values"(): ($BeltTunnelBlock$Shape)[]
public static "valueOf"(arg0: StringJS): $BeltTunnelBlock$Shape
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeltTunnelBlock$Shape$$Type = (("straight") | ("window") | ("closed") | ("t_left") | ("t_right") | ("cross"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeltTunnelBlock$Shape$$Original = $BeltTunnelBlock$Shape;}
declare module "com.simibubi.create.content.redstone.displayLink.source.EnchantPowerDisplaySource" {
import {$DisplaySource} from "com.simibubi.create.api.behaviour.display.DisplaySource"
import {$BlockEntityType} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$List} from "java.util.List"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$NumericSingleLineDisplaySource} from "com.simibubi.create.content.redstone.displayLink.source.NumericSingleLineDisplaySource"
import {$SimpleRegistry$Multi} from "com.simibubi.create.api.registry.SimpleRegistry$Multi"

export class $EnchantPowerDisplaySource extends $NumericSingleLineDisplaySource {
static readonly "BY_BLOCK_ENTITY": $SimpleRegistry$Multi<($BlockEntityType<(never)>), ($DisplaySource)>
static readonly "WHITESPACE": $MutableComponent
static readonly "EMPTY": $List<($MutableComponent)>
static readonly "EMPTY_LINE": $MutableComponent
static readonly "BY_BLOCK": $SimpleRegistry$Multi<($Block), ($DisplaySource)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantPowerDisplaySource$$Type = ($EnchantPowerDisplaySource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnchantPowerDisplaySource$$Original = $EnchantPowerDisplaySource;}
declare module "com.simibubi.create.content.kinetics.deployer.DeployerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$DirectionalAxisKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalAxisKineticBlock"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$DeployerBlockEntity, $DeployerBlockEntity$$Type} from "com.simibubi.create.content.kinetics.deployer.DeployerBlockEntity"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $DeployerBlock extends $DirectionalAxisKineticBlock implements $IBE$$Interface<($DeployerBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "AXIS_ALONG_FIRST_COORDINATE": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getBlockEntityType"(): $BlockEntityType<($DeployerBlockEntity)>
public "getBlockEntityClass"(): $Class<($DeployerBlockEntity)>
public "onWrenched"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type): $InteractionResult
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($DeployerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($DeployerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($DeployerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($DeployerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $DeployerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($DeployerBlockEntity)>
get "blockEntityClass"(): $Class<($DeployerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeployerBlock$$Type = ($DeployerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeployerBlock$$Original = $DeployerBlock;}
declare module "com.simibubi.create.content.equipment.armor.DivingHelmetItem" {
import {$ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$HolderLookup$RegistryLookup$$Type} from "net.minecraft.core.HolderLookup$RegistryLookup"
import {$LivingBreatheEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingBreatheEvent"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemEnchantments} from "net.minecraft.world.item.enchantment.ItemEnchantments"
import {$EquipmentSlot} from "net.minecraft.world.entity.EquipmentSlot"
import {$Supplier} from "java.util.function.Supplier"
import {$BaseArmorItem} from "com.simibubi.create.content.equipment.armor.BaseArmorItem"
import {$Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$Item} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $DivingHelmetItem extends $BaseArmorItem {
static readonly "BASE_ATTACK_DAMAGE_ID": $ResourceLocation
static readonly "DEFAULT_MAX_STACK_SIZE": integer
static readonly "MAX_BAR_WIDTH": integer
static readonly "BASE_ATTACK_SPEED_ID": $ResourceLocation
static readonly "SLOT": $EquipmentSlot
static readonly "ABSOLUTE_MAX_STACK_SIZE": integer
static readonly "DISPENSE_ITEM_BEHAVIOR": $DispenseItemBehavior
static readonly "TYPE": $ArmorItem$Type
 "defaultModifiers": $Supplier<($ItemAttributeModifiers)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>

constructor(arg0: $Holder$$Type<($ArmorMaterial)>, arg1: $Item$Properties$$Type, arg2: $ResourceLocation$$Type)

public "supportsEnchantment"(arg0: $ItemStack$$Type, arg1: $Holder$$Type<($Enchantment)>): boolean
public "getEnchantmentLevel"(arg0: $ItemStack$$Type, arg1: $Holder$$Type<($Enchantment)>): integer
public "getAllEnchantments"(arg0: $ItemStack$$Type, arg1: $HolderLookup$RegistryLookup$$Type<($Enchantment$$Type)>): $ItemEnchantments
public static "isWornBy"(arg0: $Entity$$Type): boolean
public static "breatheUnderwater"(arg0: $LivingBreatheEvent$$Type): void
public static "getWornItem"(arg0: $Entity$$Type): $ItemStack
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DivingHelmetItem$$Type = ($DivingHelmetItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DivingHelmetItem$$Original = $DivingHelmetItem;}
declare module "com.simibubi.create.content.schematics.cannon.LaunchedItem" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$HolderGetter$$Type} from "net.minecraft.core.HolderGetter"

export class $LaunchedItem {
 "stack": $ItemStack
 "totalTicks": integer
 "ticksRemaining": integer
 "target": $BlockPos

public static "fromNBT"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $HolderGetter$$Type<($Block$$Type)>): $LaunchedItem
public "update"(arg0: $Level$$Type): boolean
public "serializeNBT"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LaunchedItem$$Type = ($LaunchedItem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LaunchedItem$$Original = $LaunchedItem;}
declare module "com.simibubi.create.content.trains.graph.TrackGraph" {
import {$BezierConnection$$Type} from "com.simibubi.create.content.trains.track.BezierConnection"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$EdgePointType$$Type} from "com.simibubi.create.content.trains.graph.EdgePointType"
import {$Pair$$Type} from "net.createmod.catnip.data.Pair"
import {$TrackEdge, $TrackEdge$$Type} from "com.simibubi.create.content.trains.graph.TrackEdge"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$TrackNodeLocation, $TrackNodeLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackNodeLocation"
import {$TrackNodeLocation$DiscoveredLocation$$Type} from "com.simibubi.create.content.trains.graph.TrackNodeLocation$DiscoveredLocation"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$DimensionPalette$$Type} from "com.simibubi.create.content.trains.graph.DimensionPalette"
import {$TrackEdgePoint, $TrackEdgePoint$$Type} from "com.simibubi.create.content.trains.signal.TrackEdgePoint"
import {$Color} from "net.createmod.catnip.theme.Color"
import {$TrackNode, $TrackNode$$Type} from "com.simibubi.create.content.trains.graph.TrackNode"
import {$TrackGraphBounds} from "com.simibubi.create.content.trains.graph.TrackGraphBounds"
import {$AtomicInteger} from "java.util.concurrent.atomic.AtomicInteger"
import {$Set} from "java.util.Set"
import {$Couple$$Type} from "net.createmod.catnip.data.Couple"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $TrackGraph {
static readonly "graphNetIdGenerator": $AtomicInteger
static readonly "nodeNetIdGenerator": $AtomicInteger
 "color": $Color
 "id": $UUID

constructor()
constructor(arg0: $UUID$$Type)

public "loadNode"(arg0: $TrackNodeLocation$$Type, arg1: integer, arg2: $Vec3$$Type): void
public "distanceToLocationSqr"(arg0: $Level$$Type, arg1: $Vec3$$Type): float
public "getPoint"<T extends $TrackEdgePoint>(arg0: $EdgePointType$$Type<(T)>, arg1: $UUID$$Type): T
public "resolveIntersectingEdgeGroups"(arg0: $Level$$Type): void
public "markDirty"(): void
public "findDisconnectedGraphs"(arg0: $LevelAccessor$$Type, arg1: $Map$$Type<(integer), ($Pair$$Type<(integer), ($UUID$$Type)>)>): $Set<($TrackGraph)>
public "locateNode"(arg0: $Level$$Type, arg1: $Vec3$$Type): $TrackNode
public "locateNode"(arg0: $TrackNodeLocation$$Type): $TrackNode
public "tickPoints"(arg0: boolean): void
public "setNetId"(arg0: integer): void
public "getPoints"<T extends $TrackEdgePoint>(arg0: $EdgePointType$$Type<(T)>): $Collection<(T)>
public "getNodes"(): $Set<($TrackNodeLocation)>
public "getConnectionsFrom"(arg0: $TrackNode$$Type): $Map<($TrackNode), ($TrackEdge)>
public "removePoint"<T extends $TrackEdgePoint>(arg0: $EdgePointType$$Type<(T)>, arg1: $UUID$$Type): T
public "addPoint"<T extends $TrackEdgePoint>(arg0: $EdgePointType$$Type<(T)>, arg1: T): void
public "putConnection"(arg0: $TrackNode$$Type, arg1: $TrackNode$$Type, arg2: $TrackEdge$$Type): boolean
public static "nextNodeId"(): integer
public "addNodeIfAbsent"(arg0: $TrackNode$$Type): boolean
public "invalidateBounds"(): void
public "transferAll"(arg0: $TrackGraph$$Type): void
public "createNodeIfAbsent"(arg0: $TrackNodeLocation$DiscoveredLocation$$Type): boolean
public static "nextGraphId"(): integer
public "connectNodes"(arg0: $LevelAccessor$$Type, arg1: $TrackNodeLocation$DiscoveredLocation$$Type, arg2: $TrackNodeLocation$DiscoveredLocation$$Type, arg3: $BezierConnection$$Type): void
public "disconnectNodes"(arg0: $TrackNode$$Type, arg1: $TrackNode$$Type): void
public "deferIntersectionUpdate"(arg0: $TrackEdge$$Type): void
public "getChecksum"(): integer
public "getConnection"(arg0: $Couple$$Type<($TrackNode$$Type)>): $TrackEdge
public "isEmpty"(): boolean
public "getBounds"(arg0: $Level$$Type): $TrackGraphBounds
public "write"(arg0: $HolderLookup$Provider$$Type, arg1: $DimensionPalette$$Type): $CompoundTag
public static "read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $DimensionPalette$$Type): $TrackGraph
public "transfer"(arg0: $LevelAccessor$$Type, arg1: $TrackNode$$Type, arg2: $TrackGraph$$Type): void
public "getNode"(arg0: integer): $TrackNode
public "removeNode"(arg0: $LevelAccessor$$Type, arg1: $TrackNodeLocation$$Type): boolean
public "setId"(arg0: $UUID$$Type): void
public "addNode"(arg0: $TrackNode$$Type): void
set "netId"(value: integer)
get "nodes"(): $Set<($TrackNodeLocation)>
get "checksum"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackGraph$$Type = ($TrackGraph);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackGraph$$Original = $TrackGraph;}
declare module "com.simibubi.create.content.processing.sequenced.SequencedAssemblyRecipe" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$List} from "java.util.List"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$RecipeType, $RecipeType$$Type} from "net.minecraft.world.item.crafting.RecipeType"
import {$SequencedAssemblyRecipeSerializer$$Type} from "com.simibubi.create.content.processing.sequenced.SequencedAssemblyRecipeSerializer"
import {$ProcessingOutput} from "com.simibubi.create.content.processing.recipe.ProcessingOutput"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$RecipeWrapper, $RecipeWrapper$$Type} from "net.neoforged.neoforge.items.wrapper.RecipeWrapper"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ProcessingRecipe} from "com.simibubi.create.content.processing.recipe.ProcessingRecipe"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$Recipe$$Interface} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$ItemTooltipEvent$$Type} from "net.neoforged.neoforge.event.entity.player.ItemTooltipEvent"
import {$Class$$Type} from "java.lang.Class"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$SequencedRecipe} from "com.simibubi.create.content.processing.sequenced.SequencedRecipe"

export class $SequencedAssemblyRecipe implements $Recipe$$Interface<($RecipeWrapper)> {
readonly "resultPool": $List<($ProcessingOutput)>

constructor(arg0: $SequencedAssemblyRecipeSerializer$$Type)

public "assemble"(arg0: $RecipeWrapper$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
public "assemble"(arg0: $RecipeInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
public static "addToTooltip"(arg0: $ItemTooltipEvent$$Type): void
public static "getRecipes"<R extends $ProcessingRecipe<(object), (object)>>(arg0: $Level$$Type, arg1: $ItemStack$$Type, arg2: $RecipeType$$Type<(R)>, arg3: $Class$$Type<(R)>, arg4: $Predicate$$Type<($RecipeHolder<(R)>)>): $List<($RecipeHolder<(R)>)>
public "getSerializer"(): $RecipeSerializer<(never)>
public static "getRecipe"<I extends $RecipeInput, R extends $ProcessingRecipe<(object), (object)>>(arg0: $Level$$Type, arg1: I, arg2: $RecipeType$$Type<(R)>, arg3: $Class$$Type<(R)>): $Optional<($RecipeHolder<(R)>)>
public static "getRecipe"<I extends $RecipeInput, R extends $ProcessingRecipe<(object), (object)>>(arg0: $Level$$Type, arg1: I, arg2: $RecipeType$$Type<(R)>, arg3: $Class$$Type<(R)>, arg4: $Predicate$$Type<($RecipeHolder<(R)>)>): $Optional<($RecipeHolder<(R)>)>
public static "getRecipe"<R extends $ProcessingRecipe<(object), (object)>>(arg0: $Level$$Type, arg1: $ItemStack$$Type, arg2: $RecipeType$$Type<(R)>, arg3: $Class$$Type<(R)>): $Optional<($RecipeHolder<(R)>)>
public "getTransitionalItem"(): $ItemStack
public "getLoops"(): integer
public "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
public "getResultItem"(arg0: $HolderLookup$Provider$$Type): $ItemStack
public "getOutputChance"(): float
public "getIngredient"(): $Ingredient
public "getSequence"(): $List<($SequencedRecipe<(never)>)>
public "matches"(arg0: $RecipeInput$$Type, arg1: $Level$$Type): boolean
public "matches"(arg0: $RecipeWrapper$$Type, arg1: $Level$$Type): boolean
public "getType"(): $RecipeType<(never)>
public "isSpecial"(): boolean
public "getRemainingItems"(arg0: $RecipeWrapper$$Type): $NonNullList<($ItemStack)>
public "getIngredients"(): $NonNullList<($Ingredient)>
public "showNotification"(): boolean
public "getToastSymbol"(): $ItemStack
public "isIncomplete"(): boolean
public "getGroup"(): StringJS
get "serializer"(): $RecipeSerializer<(never)>
get "transitionalItem"(): $ItemStack
get "loops"(): integer
get "outputChance"(): float
get "ingredient"(): $Ingredient
get "sequence"(): $List<($SequencedRecipe<(never)>)>
get "type"(): $RecipeType<(never)>
get "special"(): boolean
get "ingredients"(): $NonNullList<($Ingredient)>
get "toastSymbol"(): $ItemStack
get "incomplete"(): boolean
get "group"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencedAssemblyRecipe$$Type = ($SequencedAssemblyRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SequencedAssemblyRecipe$$Original = $SequencedAssemblyRecipe;}
declare module "com.simibubi.create.content.fluids.pipes.valve.FluidValveBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$Class} from "java.lang.Class"
import {$FluidValveBlockEntity, $FluidValveBlockEntity$$Type} from "com.simibubi.create.content.fluids.pipes.valve.FluidValveBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$IAxisPipe$$Interface} from "com.simibubi.create.content.fluids.pipes.IAxisPipe"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ProperWaterloggedBlock$$Interface} from "com.simibubi.create.foundation.block.ProperWaterloggedBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$DirectionalAxisKineticBlock} from "com.simibubi.create.content.kinetics.base.DirectionalAxisKineticBlock"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $FluidValveBlock extends $DirectionalAxisKineticBlock implements $IAxisPipe$$Interface, $IBE$$Interface<($FluidValveBlockEntity)>, $ProperWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "AXIS_ALONG_FIRST_COORDINATE": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "ENABLED": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getBlockEntityType"(): $BlockEntityType<($FluidValveBlockEntity)>
public "getBlockEntityClass"(): $Class<($FluidValveBlockEntity)>
public static "isOpenAt"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public static "getPipeAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getAxis"(arg0: $BlockState$$Type): $Direction$Axis
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public static "getAxisOf"(arg0: $BlockState$$Type): $Direction$Axis
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($FluidValveBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($FluidValveBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FluidValveBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($FluidValveBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $FluidValveBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "withWater"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): $BlockState
public static "withWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): $BlockState
public "updateWater"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "fluidState"(arg0: $BlockState$$Type): $FluidState
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "playRotateSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "playRemoveSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($FluidValveBlockEntity)>
get "blockEntityClass"(): $Class<($FluidValveBlockEntity)>
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidValveBlock$$Type = ($FluidValveBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidValveBlock$$Original = $FluidValveBlock;}
declare module "com.simibubi.create.content.kinetics.fan.processing.AllFanProcessingTypes$BlastingType" {
import {$FanProcessingType$AirFlowParticleAccess$$Type} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType$AirFlowParticleAccess"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$FanProcessingType, $FanProcessingType$$Interface} from "com.simibubi.create.content.kinetics.fan.processing.FanProcessingType"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $AllFanProcessingTypes$BlastingType implements $FanProcessingType$$Interface {
constructor()

public "spawnProcessingParticles"(arg0: $Level$$Type, arg1: $Vec3$$Type): void
public "morphAirFlow"(arg0: $FanProcessingType$AirFlowParticleAccess$$Type, arg1: $RandomSource$$Type): void
public "affectEntity"(arg0: $Entity$$Type, arg1: $Level$$Type): void
public "isValidAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public "canProcess"(arg0: $ItemStack$$Type, arg1: $Level$$Type): boolean
public "process"(arg0: $ItemStack$$Type, arg1: $Level$$Type): $List<($ItemStack)>
public "getPriority"(): integer
public static "parse"(arg0: StringJS): $FanProcessingType
public static "getAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $FanProcessingType
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllFanProcessingTypes$BlastingType$$Type = ($AllFanProcessingTypes$BlastingType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllFanProcessingTypes$BlastingType$$Original = $AllFanProcessingTypes$BlastingType;}
declare module "com.simibubi.create.content.trains.track.TrackMaterial$TrackModelHolder" {
import {$PartialModel, $PartialModel$$Type} from "dev.engine_room.flywheel.lib.model.baked.PartialModel"
import {$Record} from "java.lang.Record"

export class $TrackMaterial$TrackModelHolder extends $Record {
constructor(tie: $PartialModel$$Type, leftSegment: $PartialModel$$Type, rightSegment: $PartialModel$$Type)

public "leftSegment"(): $PartialModel
public "rightSegment"(): $PartialModel
public "tie"(): $PartialModel
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrackMaterial$TrackModelHolder$$Type = ({"leftSegment"?: $PartialModel$$Type, "rightSegment"?: $PartialModel$$Type, "tie"?: $PartialModel$$Type}) | ([leftSegment?: $PartialModel$$Type, rightSegment?: $PartialModel$$Type, tie?: $PartialModel$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrackMaterial$TrackModelHolder$$Original = $TrackMaterial$TrackModelHolder;}
declare module "com.simibubi.create.content.kinetics.crusher.CrushingWheelControllerBlock" {
import {$IBE$$Interface} from "com.simibubi.create.foundation.block.IBE"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$DirectionalBlock} from "net.minecraft.world.level.block.DirectionalBlock"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$CrushingWheelControllerBlockEntity, $CrushingWheelControllerBlockEntity$$Type} from "com.simibubi.create.content.kinetics.crusher.CrushingWheelControllerBlockEntity"
import {$Item} from "net.minecraft.world.item.Item"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult, $InteractionResult$$Type} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult, $ItemInteractionResult$$Type} from "net.minecraft.world.ItemInteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $CrushingWheelControllerBlock extends $DirectionalBlock implements $IBE$$Interface<($CrushingWheelControllerBlockEntity)> {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CrushingWheelControllerBlock)>
static readonly "VALID": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "canBeReplaced"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): boolean
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "updateSpeed"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): void
public "getBlockEntityType"(): $BlockEntityType<($CrushingWheelControllerBlockEntity)>
public "getBlockEntityClass"(): $Class<($CrushingWheelControllerBlockEntity)>
public "checkEntityForProcessing"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): void
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "entityInside"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): void
public "addRunningEffects"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getTicker"<S extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(S)>): $BlockEntityTicker<(S)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getBlockEntityOptional"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Optional<($CrushingWheelControllerBlockEntity)>
public "withBlockEntityDo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Consumer$$Type<($CrushingWheelControllerBlockEntity)>): void
public "onBlockEntityUse"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CrushingWheelControllerBlockEntity), ($InteractionResult$$Type)>): $InteractionResult
public "onBlockEntityUseItemOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Function$$Type<($CrushingWheelControllerBlockEntity), ($ItemInteractionResult$$Type)>): $ItemInteractionResult
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $CrushingWheelControllerBlockEntity
public static "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "blockEntityType"(): $BlockEntityType<($CrushingWheelControllerBlockEntity)>
get "blockEntityClass"(): $Class<($CrushingWheelControllerBlockEntity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrushingWheelControllerBlock$$Type = ($CrushingWheelControllerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CrushingWheelControllerBlock$$Original = $CrushingWheelControllerBlock;}
