declare module "dev.latvian.mods.kubejs.util.Lazy" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Supplier$$Type, $Supplier$$Interface} from "java.util.function.Supplier"
import {$Class$$Type} from "java.lang.Class"
import {$Duration$$Type} from "java.time.Duration"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $Lazy<T> implements $Supplier$$Interface<(T)> {
public "get"(): T
public static "map"<K, V>(supplier: $Consumer$$Type<($Map<(K), (V)>)>): $Lazy<($Map<(K), (V)>)>
public static "of"<T>(supplier: $Supplier$$Type<(T)>): $Lazy<(T)>
public static "of"<T>(supplier: $Supplier$$Type<(T)>, expires: $Duration$$Type): $Lazy<(T)>
public static "serviceLoader"<T>(type: $Class$$Type<(T)>): $Lazy<(T)>
public static "identityMap"<K, V>(supplier: $Consumer$$Type<($Map<(K), (V)>)>): $Lazy<($Map<(K), (V)>)>
public "forget"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Lazy$$Type<T> = ($Lazy<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Lazy$$Original<T> = $Lazy<(T)>;}
declare module "dev.latvian.mods.kubejs.util.JsonSerializable" {
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"

export interface $JsonSerializable$$Interface {

(): $JsonElement$$Type
}

export class $JsonSerializable implements $JsonSerializable$$Interface {
 "toJson"(): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonSerializable$$Type = (() => $JsonElement$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JsonSerializable$$Original = $JsonSerializable;}
declare module "dev.latvian.mods.kubejs.client.KubeJSKeybinds$TickingKeyEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$KubeJSKeybinds$KubeKey$$Type} from "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KubeKey"
import {$KubeJSKeybinds$KeyEvent} from "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KeyEvent"

export class $KubeJSKeybinds$TickingKeyEvent extends $KubeJSKeybinds$KeyEvent {
constructor(player: $LocalPlayer$$Type, key: $KubeJSKeybinds$KubeKey$$Type)

public "getTicks"(): integer
public "getEntity"(): $Player
get "ticks"(): integer
get "entity"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSKeybinds$TickingKeyEvent$$Type = ($KubeJSKeybinds$TickingKeyEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSKeybinds$TickingKeyEvent$$Original = $KubeJSKeybinds$TickingKeyEvent;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RegisterSubtypesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$List$$Type} from "java.util.List"
import {$SubtypeInterpreter$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.SubtypeInterpreter"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"

export interface $RegisterSubtypesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {
}

export class $RegisterSubtypesKubeEvent<E, F> implements $RegisterSubtypesKubeEvent$$Interface {
 "useComponents"(filter: F): void
 "useComponents"(filter: F, components: $List$$Type<($DataComponentType$$Type<(never)>)>): void
 "register"(filter: F, interpreter: $SubtypeInterpreter$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterSubtypesKubeEvent$$Type<E, F> = ($RegisterSubtypesKubeEvent<(E), (F)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegisterSubtypesKubeEvent$$Original<E, F> = $RegisterSubtypesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.script.ConsoleLine" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Collection} from "java.util.Collection"
import {$FriendlyByteBuf} from "net.minecraft.network.FriendlyByteBuf"
import {$List} from "java.util.List"
import {$Supplier$$Interface} from "java.util.function.Supplier"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$ConsoleJS, $ConsoleJS$$Type} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$LogType} from "dev.latvian.mods.kubejs.util.LogType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConsoleLine implements $Supplier$$Interface<($JsonElement)> {
readonly "console": $ConsoleJS
static readonly "EMPTY_ARRAY": ($ConsoleLine)[]
 "sourceLines": $Collection<($SourceLine)>
 "externalFile": $Path
 "stackTrace": $List<(StringJS)>
 "message": StringJS
 "type": $LogType
static readonly "STREAM_CODEC": $StreamCodec<($FriendlyByteBuf), ($ConsoleLine)>
readonly "timestamp": long
 "group": StringJS

constructor(console: $ConsoleJS$$Type, timestamp: long, message: StringJS)

public "customData"(key: StringJS, data: $JsonElement$$Type, override: boolean): $ConsoleLine
public "withSourceLine"(source: StringJS, line: integer): $ConsoleLine
public "withSourceLine"(sourceLine: $SourceLine$$Type): $ConsoleLine
public "get"(): $JsonElement
public "toString"(): StringJS
public "toJson"(): $JsonObject
public "getText"(): StringJS
public "withExternalFile"(path: $Path$$Type): $ConsoleLine
get "text"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleLine$$Type = ($ConsoleLine);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConsoleLine$$Original = $ConsoleLine;}
declare module "dev.latvian.mods.kubejs.item.ArmorMaterialBuilder" {
import {$ArmorMaterial} from "net.minecraft.world.item.ArmorMaterial"
import {$Map$$Type} from "java.util.Map"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$ArmorMaterial$Layer$$Type} from "net.minecraft.world.item.ArmorMaterial$Layer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorMaterialBuilder extends $BuilderBase<($ArmorMaterial)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "knockbackResistance"(v: float): this
public "enchantmentValue"(v: integer): this
public "repairIngredient"(v: $Supplier$$Type<($Ingredient$$Type)>): this
public "toughness"(v: float): this
public "equipSound"(sound: $Holder$$Type<($SoundEvent)>): this
public "defense"(v: $Map$$Type<($ArmorItem$Type$$Type), (integer)>): this
public "layers"(v: ($ArmorMaterial$Layer$$Type)[]): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorMaterialBuilder$$Type = ($ArmorMaterialBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorMaterialBuilder$$Original = $ArmorMaterialBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.JavaWrapper" {
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Map$$Type} from "java.util.Map"
import {$BaseFunction$$Type} from "dev.latvian.mods.rhino.BaseFunction"
import {$Class$$Type} from "java.lang.Class"
import {$ConsoleJS} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$Record, $Record$$Type} from "java.lang.Record"

/**
 * Methods for working with Java classes. Reflection my beloved â™¥
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $JavaWrapper$$Interface {
}

export class $JavaWrapper implements $JavaWrapper$$Interface {
static "mergeRecord"<R extends $Record>(original: R, merge: $Map$$Type<(StringJS), (never)>): R
/**
 * Creates a custom ConsoleJS instance for you to use to, well, log stuff
 */
static "createConsole"(name: StringJS): $ConsoleJS
static "makeFunctionProxy"<T>(targetClass: $TypeInfo$$Type, arg1: $BaseFunction$$Type): T
/**
 * Loads the specified class, and returns null if class is not found or allowed.
 * The returned object can have public static methods and fields accessed directly from it.
 * Constructors can be used with the new keyword.
 */
static "tryLoadClass"(className: StringJS): any
/**
 * Loads the specified class, and throws error if class it not found or allowed.
 * The returned object can have public static methods and fields accessed directly from it.
 * Constructors can be used with the new keyword.
 */
static "loadClass"(className: StringJS): any
/**
 * Cast the object to a target type, use if Rhino can't determine the parameter type due to type erasure.
 */
static "cast"<T>(targetClass: $Class$$Type<(T)>, object: any): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaWrapper$$Type = ($JavaWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JavaWrapper$$Original = $JavaWrapper;}
declare module "dev.latvian.mods.kubejs.core.GameRulesKJS" {
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $GameRulesKJS$$Interface {
}

export class $GameRulesKJS implements $GameRulesKJS$$Interface {
 "kjs$set"(rule: StringJS, value: StringJS): void
 "kjs$get"(rule: StringJS): $GameRules$Value<(never)>
 "kjs$getString"(rule: StringJS): StringJS
 "kjs$getBoolean"(rule: StringJS): boolean
 "kjs$getInt"(rule: StringJS): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRulesKJS$$Type = ($GameRulesKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRulesKJS$$Original = $GameRulesKJS;}
declare module "dev.latvian.mods.kubejs.item.ItemSmeltedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an item is smelted by a player.
 */
export class $ItemSmeltedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, smelted: $ItemStack$$Type)

/**
 * The item that was smelted.
 */
public "getItem"(): $ItemStack
/**
 * The player that smelted the item.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemSmeltedKubeEvent$$Type = ($ItemSmeltedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemSmeltedKubeEvent$$Original = $ItemSmeltedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.BlockDropsKubeEvent" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level} from "net.minecraft.world.level.Level"
import {$ItemEntity} from "net.minecraft.world.entity.item.ItemEntity"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockDropsEvent$$Type} from "net.neoforged.neoforge.event.level.BlockDropsEvent"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Modify dropped items and xp from block.
 */
export class $BlockDropsKubeEvent implements $KubeEntityEvent$$Interface {
constructor(event: $BlockDropsEvent$$Type)

/**
 * Dropped items. Immutable.
 */
public "getItems"(): $List<($ItemStack)>
/**
 * The experience dropped by the block.
 */
public "getXp"(): integer
/**
 * The tool used when breaking this block. May be null.
 */
public "getTool"(): $ItemStack
/**
 * Sets the experience dropped by the block.
 */
public "setXp"(xp: integer): void
/**
 * Dropped item entities.
 */
public "getItemEntities"(): $List<($ItemEntity)>
public "containsItem"(item: $ItemPredicate$$Type): boolean
public "addItem"(item: $ItemStack$$Type): $ItemEntity
/**
 * The block that was broken.
 */
public "getBlock"(): $LevelBlock
public "getLevel"(): $Level
public "getEntity"(): $Entity
public "removeItem"(item: $ItemPredicate$$Type): void
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "items"(): $List<($ItemStack)>
get "xp"(): integer
get "tool"(): $ItemStack
set "xp"(value: integer)
get "itemEntities"(): $List<($ItemEntity)>
get "block"(): $LevelBlock
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDropsKubeEvent$$Type = ($BlockDropsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockDropsKubeEvent$$Original = $BlockDropsKubeEvent;}
declare module "dev.latvian.mods.kubejs.event.TargetedEventHandler" {
import {$EventHandler} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$EventGroup} from "dev.latvian.mods.kubejs.event.EventGroup"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Supplier} from "java.util.function.Supplier"
import {$ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$Class} from "java.lang.Class"
import {$Set} from "java.util.Set"
import {$ScriptTypePredicate} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"
import {$EventResult} from "dev.latvian.mods.kubejs.event.EventResult"

export class $TargetedEventHandler<E> extends $EventHandler {
static readonly "DONTENUM": integer
readonly "eventType": $Supplier<($Class<($KubeEvent)>)>
readonly "scriptTypePredicate": $ScriptTypePredicate
static readonly "CONST": integer
readonly "name": StringJS
static readonly "UNINITIALIZED_CONST": integer
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "PERMANENT": integer
readonly "group": $EventGroup

public "hasResult"(): $EventHandler
public "forEachListener"(type: $ScriptType$$Type, callback: $Consumer$$Type<($EventHandlerContainer)>): void
public "findUniqueExtraIds"(type: $ScriptType$$Type): $Set<(E)>
public "hasListeners"(): boolean
public "hasListeners"(extraId: E): boolean
public "post"(event: $KubeEvent$$Type, extraId: E): $EventResult
public "post"(type: $ScriptTypeHolder$$Type, extraId: E, event: $KubeEvent$$Type): $EventResult
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "getPrototype"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "getParentScope"(): $Scriptable
public "setParentScope"(arg0: $Scriptable$$Type): void
public "getAllIds"(): (any)[]
public "getIds"(): (any)[]
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
get "parentScope"(): $Scriptable
set "parentScope"(value: $Scriptable$$Type)
get "allIds"(): (any)[]
get "ids"(): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TargetedEventHandler$$Type<E> = ($TargetedEventHandler<(E)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TargetedEventHandler$$Original<E> = $TargetedEventHandler<(E)>;}
declare module "dev.latvian.mods.kubejs.block.BlockBrokenKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$BlockEvent$BreakEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$BreakEvent"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a block is destroyed by a player.
 */
export class $BlockBrokenKubeEvent implements $KubePlayerEvent$$Interface {
constructor(event: $BlockEvent$BreakEvent$$Type)

/**
 * The block that was broken.
 */
public "getBlock"(): $LevelBlock
/**
 * The player that broke the block.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "block"(): $LevelBlock
get "entity"(): $LivingEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBrokenKubeEvent$$Type = ($BlockBrokenKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBrokenKubeEvent$$Original = $BlockBrokenKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemDroppedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player drops an item.
 */
export class $ItemDroppedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, entity: $ItemEntity$$Type)

/**
 * The item entity that was spawned when dropping.
 */
public "getItemEntity"(): $ItemEntity
/**
 * The item that was dropped.
 */
public "getItem"(): $ItemStack
/**
 * The player that dropped the item.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "itemEntity"(): $ItemEntity
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDroppedKubeEvent$$Type = ($ItemDroppedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemDroppedKubeEvent$$Original = $ItemDroppedKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.ID" {
import {$UnaryOperator} from "java.util.function.UnaryOperator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$DataResult} from "com.mojang.serialization.DataResult"

export interface $ID$$Interface {
}

export class $ID implements $ID$$Interface {
static readonly "ITEM": $UnaryOperator<(StringJS)>
static readonly "PNG_TEXTURE_MCMETA": $UnaryOperator<(StringJS)>
static readonly "PARTICLE": $UnaryOperator<(StringJS)>
static readonly "BLOCK_MODEL": $UnaryOperator<(StringJS)>
static readonly "BLOCKSTATE": $UnaryOperator<(StringJS)>
static readonly "BLOCK": $UnaryOperator<(StringJS)>
static readonly "ITEM_MODEL": $UnaryOperator<(StringJS)>
static readonly "PNG_TEXTURE": $UnaryOperator<(StringJS)>
static readonly "AIR": $ResourceLocation
static readonly "BLOCK_LOOT_TABLE": $UnaryOperator<(StringJS)>
static readonly "UNKNOWN": $ResourceLocation
static readonly "MODEL": $UnaryOperator<(StringJS)>

static "kjsString"(id: StringJS): StringJS
static "kjs"(o: any): $ResourceLocation
static "reduceKjs"(id: $ResourceLocation$$Type): StringJS
static "isKey"(from: any): boolean
static "namespace"(s: StringJS): StringJS
static "of"(o: any, preferKJS: boolean): $ResourceLocation
static "url"(id: $ResourceLocation$$Type): StringJS
static "read"(reader: $StringReader$$Type): $DataResult<($ResourceLocation)>
static "mc"(o: any): $ResourceLocation
static "path"(s: StringJS): StringJS
static "reduce"(id: $ResourceLocation$$Type): StringJS
static "string"(id: StringJS): StringJS
static "resourcePath"(id: $ResourceLocation$$Type): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ID$$Type = ($ID);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ID$$Original = $ID;}
declare module "dev.latvian.mods.kubejs.util.ErrorStack" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ErrorStack {
static readonly "NONE": $ErrorStack

constructor()

public "atString"(): StringJS
public "stringAt"(): StringJS
public "push"(parent: any): void
public "pop"(): void
public "toString"(): StringJS
public "setKey"(index: integer): void
public "setKey"(key: any): void
set "key"(value: integer)
set "key"(value: any)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ErrorStack$$Type = ($ErrorStack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ErrorStack$$Original = $ErrorStack;}
declare module "dev.latvian.mods.kubejs.fluid.FluidLike" {
import {$ReplacementMatch, $ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"

export interface $FluidLike$$Interface extends $ReplacementMatch$$Interface {
get "fluid"(): $Fluid
get "amount"(): integer
get "empty"(): boolean
}

export class $FluidLike implements $FluidLike$$Interface {
 "getFluid"(): $Fluid
 "getAmount"(): integer
 "copy"(amount: integer): $FluidLike
 "isEmpty"(): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidLike$$Type = ($FluidLike);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidLike$$Original = $FluidLike;}
declare module "dev.latvian.mods.kubejs.recipe.special.SpecialRecipeSerializerManager" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"

export class $SpecialRecipeSerializerManager implements $KubeEvent$$Interface {
static readonly "INSTANCE": $SpecialRecipeSerializerManager

constructor()

public "ignoreSpecialFlag"(id: $ResourceLocation$$Type): void
public "addSpecialFlag"(id: $ResourceLocation$$Type): void
public "ignoreSpecialMod"(modid: StringJS): void
public "addSpecialMod"(modid: StringJS): void
public "reset"(): void
public "isSpecial"(recipe: $Recipe$$Type<(never)>): boolean
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialRecipeSerializerManager$$Type = ($SpecialRecipeSerializerManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpecialRecipeSerializerManager$$Original = $SpecialRecipeSerializerManager;}
declare module "dev.latvian.mods.kubejs.level.ExplosionProperties" {
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$Level$ExplosionInteraction, $Level$ExplosionInteraction$$Type} from "net.minecraft.world.level.Level$ExplosionInteraction"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ExplosionDamageCalculator, $ExplosionDamageCalculator$$Type} from "net.minecraft.world.level.ExplosionDamageCalculator"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$Record} from "java.lang.Record"

export class $ExplosionProperties extends $Record {
constructor(source: $Entity$$Type, damageSource: $DamageSource$$Type, damageCalculator: $ExplosionDamageCalculator$$Type, strength: (float)?, causesFire: (boolean)?, mode: $Level$ExplosionInteraction$$Type, particles: (boolean)?, smallParticles: $ParticleOptions$$Type, largeParticles: $ParticleOptions$$Type, explosionSound: $Holder$$Type<($SoundEvent)>)

public "damageCalculator"(): $ExplosionDamageCalculator
public "explosionSound"(): $Holder<($SoundEvent)>
public "smallParticles"(): $ParticleOptions
public "largeParticles"(): $ParticleOptions
public "causesFire"(): $Optional<(boolean)>
public "mode"(): $Level$ExplosionInteraction
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "source"(): $Entity
public "particles"(): $Optional<(boolean)>
public "strength"(): $Optional<(float)>
public "damageSource"(): $DamageSource
public "explode"(level: $Level$$Type, x: double, y: double, z: double): $Explosion
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionProperties$$Type = ({"damageCalculator"?: $ExplosionDamageCalculator$$Type, "largeParticles"?: $ParticleOptions$$Type, "explosionSound"?: $Holder$$Type<($SoundEvent)>, "damageSource"?: $DamageSource$$Type, "particles"?: (boolean)?, "causesFire"?: (boolean)?, "mode"?: $Level$ExplosionInteraction$$Type, "source"?: $Entity$$Type, "strength"?: (float)?, "smallParticles"?: $ParticleOptions$$Type}) | ([damageCalculator?: $ExplosionDamageCalculator$$Type, largeParticles?: $ParticleOptions$$Type, explosionSound?: $Holder$$Type<($SoundEvent)>, damageSource?: $DamageSource$$Type, particles?: (boolean)?, causesFire?: (boolean)?, mode?: $Level$ExplosionInteraction$$Type, source?: $Entity$$Type, strength?: (float)?, smallParticles?: $ParticleOptions$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionProperties$$Original = $ExplosionProperties;}
declare module "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile" {
import {$VirtualDataPack$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataPack"
import {$KubeDataGenerator} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BiConsumer, $BiConsumer$$Type, $BiConsumer$$Interface} from "java.util.function.BiConsumer"
import {$DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Holder$$Type} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualDataMapFile<RT, DT> implements $BiConsumer$$Interface<($ResourceLocation), (DT)> {
readonly "registryAccess": $RegistryAccessContainer
readonly "registry": $Registry<(RT)>
readonly "pack": $KubeDataGenerator

constructor(type: $DataMapType$$Type<(RT), (DT)>, pack: $VirtualDataPack$$Type)

public "remove"(holder: RT): void
public "remove"(holder: $Holder$$Type<(RT)>): void
public "remove"(holders: $HolderSet$$Type<(RT)>): void
public "clear"(): void
public "replaceAll"(): void
public "add"(holders: $HolderSet$$Type<(RT)>, value: DT, replace: boolean): void
public "add"(holders: $HolderSet$$Type<(RT)>, value: DT): void
public "add"(holder: $Holder$$Type<(RT)>, value: DT): void
public "add"(holder: $Holder$$Type<(RT)>, value: DT, replace: boolean): void
public "add"(holder: RT, value: DT, replace: boolean): void
public "add"(holder: RT, value: DT): void
public "removeTag"(tag: $TagKey$$Type<(RT)>): void
public "addTag"(tag: $TagKey$$Type<(RT)>, value: DT): void
public "addTag"(tag: $TagKey$$Type<(RT)>, value: DT, replace: boolean): void
public "andThen"(arg0: $BiConsumer$$Type<($ResourceLocation), (DT)>): $BiConsumer<($ResourceLocation), (DT)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualDataMapFile$$Type<RT, DT> = ($VirtualDataMapFile<(RT), (DT)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VirtualDataMapFile$$Original<RT, DT> = $VirtualDataMapFile<(RT), (DT)>;}
declare module "dev.latvian.mods.kubejs.item.FoodBuilder" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$FoodEatenKubeEvent$$Type} from "dev.latvian.mods.kubejs.item.FoodEatenKubeEvent"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"

export class $FoodBuilder {
constructor()
constructor(properties: $FoodProperties$$Type)

/**
 * Sets the hunger restored.
 */
public "nutrition"(h: integer): $FoodBuilder
/**
 * Sets seconds it takes to eat the food.
 */
public "eatSeconds"(seconds: float): $FoodBuilder
/**
 * Sets whether the food is always edible.
 */
public "alwaysEdible"(flag: boolean): $FoodBuilder
/**
 * Sets the food is always edible.
 */
public "alwaysEdible"(): $FoodBuilder
/**
 * Sets the food is fast to eat (having half of the eating time).
 */
public "fastToEat"(): $FoodBuilder
/**
 * Sets the saturation modifier. Note that the saturation restored is hunger * saturation.
 */
public "saturation"(s: float): $FoodBuilder
public "build"(): $FoodProperties
/**
 * Adds an effect to the food. Note that the effect duration is in ticks (20 ticks = 1 second).
 * 
 * @param mobEffectId - The id of the effect. Can be either a string or a ResourceLocation.
 * @param duration - The duration of the effect in ticks.
 * @param amplifier - The amplifier of the effect. 0 means level 1, 1 means level 2, etc.
 * @param probability - The probability of the effect being applied. 1 = 100%.
 */
public "effect"(mobEffectId: $ResourceLocation$$Type, duration: integer, amplifier: integer, probability: float): $FoodBuilder
/**
 * Removes an effect from the food.
 */
public "removeEffect"(mobEffect: $MobEffect$$Type): $FoodBuilder
/**
 * Sets a callback that is called when the food is eaten.
 * 
 * Note: This is currently not having effect in `ItemEvents.modification`,
 * as firing this callback requires an `ItemBuilder` instance in the `Item`.
 */
public "eaten"(e: $Consumer$$Type<($FoodEatenKubeEvent)>): $FoodBuilder
public "usingConvertsTo"(stack: $ItemStack$$Type): $FoodBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoodBuilder$$Type = ($FoodBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoodBuilder$$Original = $FoodBuilder;}
declare module "dev.latvian.mods.kubejs.client.icon.KubeIconType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$KubeIcon} from "dev.latvian.mods.kubejs.client.icon.KubeIcon"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $KubeIconType<T extends $KubeIcon> extends $Record {
static readonly "TYPES": $Lazy<($Map<($ResourceLocation), ($KubeIconType<(never)>)>)>
static readonly "CODEC": $Codec<($KubeIconType<(never)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($KubeIconType<(never)>)>

constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>)
constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>)

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "codec"(): $MapCodec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeIconType$$Type<T> = ({"codec"?: $MapCodec$$Type<(T)>, "id"?: $ResourceLocation$$Type, "streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>}) | ([codec?: $MapCodec$$Type<(T)>, id?: $ResourceLocation$$Type, streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeIconType$$Original<T> = $KubeIconType<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Info" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record} from "java.lang.Record"

export class $FluidData$Info extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$Info)>

constructor(filter: $FluidIngredient$$Type, info: $List$$Type<($Component$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "info"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$Info$$Type = ({"filter"?: $FluidIngredient$$Type, "info"?: $List$$Type<($Component$$Type)>}) | ([filter?: $FluidIngredient$$Type, info?: $List$$Type<($Component$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$Info$$Original = $FluidData$Info;}
declare module "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions" {
import {$ComponentFunctions, $ComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$Map$$Type} from "java.util.Map"
import {$UUID$$Type} from "java.util.UUID"
import {$MutableDataComponentHolder} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$List$$Type} from "java.util.List"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export interface $MutableDataComponentHolderFunctions$$Interface extends $ComponentFunctions$$Interface {
get "componentHolder"(): $MutableDataComponentHolder
get "componentMap"(): $DataComponentMap
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "componentString"(): StringJS
set "customData"(value: $CompoundTag$$Type)
get "customData"(): $CompoundTag
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customModelData"(value: integer)
get "additionalTooltipHidden"(): void
get "tooltipHidden"(): void
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "lockCode"(value: StringJS)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
}

export class $MutableDataComponentHolderFunctions implements $MutableDataComponentHolderFunctions$$Interface {
 "getComponentHolder"(): $MutableDataComponentHolder
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): this
 "getComponentMap"(): $DataComponentMap
 "resetComponents"(): $ComponentFunctions
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "getComponentString"(): StringJS
 "setCustomData"(tag: $CompoundTag$$Type): void
 "getCustomData"(): $CompoundTag
 "setRarity"(rarity: $Rarity$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setCustomModelData"(data: integer): void
 "setAdditionalTooltipHidden"(): void
 "setTooltipHidden"(): void
 "setGlintOverride"(override: boolean): void
 "setDyedColor"(color: $KubeColor$$Type): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "setLockCode"(lock: StringJS): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableDataComponentHolderFunctions$$Type = ($MutableDataComponentHolderFunctions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MutableDataComponentHolderFunctions$$Original = $MutableDataComponentHolderFunctions;}
declare module "dev.latvian.mods.kubejs.client.LangKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Pattern} from "java.util.regex.Pattern"
import {$LangKubeEvent$Key, $LangKubeEvent$Key$$Type} from "dev.latvian.mods.kubejs.client.LangKubeEvent$Key"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Record} from "java.lang.Record"

export class $LangKubeEvent extends $Record implements $KubeEvent$$Interface {
static readonly "PATTERN": $Pattern

constructor(lang: StringJS, map: $Map$$Type<($LangKubeEvent$Key$$Type), (StringJS)>)

public "painting"(paintingId: $ResourceLocation$$Type, title: StringJS, author: StringJS): void
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "add"(namespace: StringJS, key: StringJS, value: StringJS): void
public "add"(key: StringJS, value: StringJS): void
public "map"(): $Map<($LangKubeEvent$Key), (StringJS)>
public "addAll"(namespace: StringJS, map: $Map$$Type<(StringJS), (StringJS)>): void
public "addAll"(map: $Map$$Type<(StringJS), (StringJS)>): void
public "lang"(): StringJS
public "renameBlock"(block: $Block$$Type, name: StringJS): void
public "renameItem"(item: $ItemStack$$Type, name: StringJS): void
public "renameEntity"(id: $ResourceLocation$$Type, name: StringJS): void
public "renameBiome"(id: $ResourceLocation$$Type, name: StringJS): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LangKubeEvent$$Type = ({"map"?: $Map$$Type<($LangKubeEvent$Key$$Type), (StringJS)>, "lang"?: StringJS}) | ([map?: $Map$$Type<($LangKubeEvent$Key$$Type), (StringJS)>, lang?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LangKubeEvent$$Original = $LangKubeEvent;}
declare module "dev.latvian.mods.kubejs.fluid.FluidWrapper" {
import {$DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$List} from "java.util.List"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$SizedFluidIngredient, $SizedFluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$FluidWrapper$ReadFn$$Type} from "dev.latvian.mods.kubejs.fluid.FluidWrapper$ReadFn"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"

export interface $FluidWrapper$$Interface {
public static get "types"(): $List<(StringJS)>
public static get "empty"(): $FluidStack
}

export class $FluidWrapper implements $FluidWrapper$$Interface {
static readonly "FLUID_TYPE_INFO": $TypeInfo
static readonly "EMPTY_STACK_RESULT": $DataResult<($FluidStack)>
static readonly "EMPTY_SIZED_RESULT": $DataResult<($SizedFluidIngredient)>
static readonly "TYPE_INFO": $TypeInfo
static readonly "EMPTY_SIZED": $SizedFluidIngredient
static readonly "INGREDIENT_TYPE_INFO": $TypeInfo
static readonly "SIZED_INGREDIENT_TYPE_INFO": $TypeInfo
static readonly "EMPTY_INGREDIENT_RESULT": $DataResult<($FluidIngredient)>

/**
 * Returns an ingredient that accepts the given set of fluids under the given component filter.
 */
static "ingredientOf"(base: $HolderSet$$Type<($Fluid)>, data: $DataComponentMap$$Type): $FluidIngredient
/**
 * Returns an ingredient that accepts the given set of items under the given (optionally strict) component filter.
 */
static "ingredientOf"(base: $HolderSet$$Type<($Fluid)>, data: $DataComponentMap$$Type, strict: boolean): $FluidIngredient
static "ingredientOf"(of: $FluidIngredient$$Type): $FluidIngredient
static "ingredientOfString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($FluidIngredient)>
static "sizedIngredientOfString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($SizedFluidIngredient)>
static "readWithContext"<T>(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS, fn: $FluidWrapper$ReadFn$$Type<(T)>, name: StringJS): $DataResult<(T)>
static "sizedIngredientOf"(arg0: $FluidIngredient$$Type, amount: integer): $SizedFluidIngredient
static "sizedIngredientOf"(of: $SizedFluidIngredient$$Type): $SizedFluidIngredient
static "readSizedIngredient"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<($SizedFluidIngredient)>
static "water"(amount: integer): $FluidStack
static "water"(): $FluidStack
static "parseString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($FluidStack)>
/**
 * Returns a FluidStack of the input, with the specified amount
 */
static "of"(o: $FluidStack$$Type, amount: integer): $FluidStack
/**
 * Returns a FluidStack of the input
 */
static "of"(o: $FluidStack$$Type): $FluidStack
/**
 * Returns a FluidStack of the input, with the specified data components
 */
static "of"(o: $FluidStack$$Type, components: $DataComponentMap$$Type): $FluidStack
/**
 * Returns a FluidStack of the input, with the specified amount and data components
 */
static "of"(o: $FluidStack$$Type, amount: integer, components: $DataComponentMap$$Type): $FluidStack
static "read"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<($FluidStack)>
static "getId"(fluid: $Fluid$$Type): $ResourceLocation
static "getType"(id: $ResourceLocation$$Type): $Fluid
static "exists"(id: $ResourceLocation$$Type): boolean
static "getTypes"(): $List<(StringJS)>
static "getEmpty"(): $FluidStack
static "lava"(amount: integer): $FluidStack
static "lava"(): $FluidStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidWrapper$$Type = ($FluidWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidWrapper$$Original = $FluidWrapper;}
declare module "dev.latvian.mods.kubejs.script.ConsoleJS" {
import {$ContextFactory} from "dev.latvian.mods.rhino.ContextFactory"
import {$KJSWSSession} from "dev.latvian.mods.kubejs.web.KJSWSSession"
import {$Pattern, $Pattern$$Type} from "java.util.regex.Pattern"
import {$Component} from "net.minecraft.network.chat.Component"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$LogType$$Type} from "dev.latvian.mods.kubejs.util.LogType"
import {$HTTPResponse} from "dev.latvian.apps.tinyserver.http.response.HTTPResponse"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Class$$Type} from "java.lang.Class"
import {$Throwable$$Type} from "java.lang.Throwable"
import {$WSHandler} from "dev.latvian.apps.tinyserver.ws.WSHandler"
import {$KJSHTTPRequest, $KJSHTTPRequest$$Type} from "dev.latvian.mods.kubejs.web.KJSHTTPRequest"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ConsoleLine, $ConsoleLine$$Type} from "dev.latvian.mods.kubejs.script.ConsoleLine"
import {$Logger, $Logger$$Type} from "org.slf4j.Logger"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConsoleJS {
static "SERVER": $ConsoleJS
readonly "scriptType": $ScriptType
static "STARTUP": $ConsoleJS
 "wsBroadcaster": $WSHandler<($KJSHTTPRequest), ($KJSWSSession)>
static "CLIENT": $ConsoleJS
 "contextFactory": $WeakReference<($ContextFactory)>

constructor(m: $ScriptType$$Type, log: $Logger$$Type)

public "startCapturingErrors"(): void
public "groupEnd"(): void
public "group"(): void
public "log"(...message: (any)[]): void
public "flush"(sync: boolean): void
public "info"(message: any): $ConsoleLine
public "getLogger"(): $Logger
public "trace"(): void
public "debug"(message: any): $ConsoleLine
public "error"(message: StringJS, throwable: $Throwable$$Type): $ConsoleLine
public "error"(message: StringJS, sourceLine: $SourceLine$$Type, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "error"(message: StringJS, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "error"(message: any): $ConsoleLine
public "warn"(message: any): $ConsoleLine
public "warn"(message: StringJS, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "warn"(message: StringJS, error: $Throwable$$Type): $ConsoleLine
public "warn"(message: StringJS, sourceLine: $SourceLine$$Type, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "writeToFile"(type: $LogType$$Type, timestamp: long, line: StringJS): void
public "writeToFile"(type: $LogType$$Type, line: StringJS): void
public "printObject"(o: any, tree: boolean): void
public "printObject"(o: any): void
public "handleError"(line: $ConsoleLine$$Type, error: $Throwable$$Type, exitPattern: $Pattern$$Type, print: boolean): void
public "stopCapturingErrors"(): void
public "setDebugEnabled"(m: boolean): void
public "resetFile"(): void
public "shouldPrintDebug"(): boolean
public "printClass"(className: StringJS): void
public "printClass"(className: StringJS, tree: boolean): void
public static "getCurrent"(): $ConsoleJS
public static "methodPattern"(c: $Class$$Type<(never)>, method: StringJS): $Pattern
public "setMuted"(m: boolean): void
public "getMuted"(): boolean
public "getDebugEnabled"(): boolean
public "setWriteToFile"(m: boolean): void
public "getWriteToFile"(): boolean
public "infof"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "warnf"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "errorf"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "debugf"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "getScriptLine"(): integer
public "errorsComponent"(command: StringJS): $Component
public "getErrorsResponse"(ctx: $KJSHTTPRequest$$Type): $HTTPResponse
public "getWarningsResponse"(ctx: $KJSHTTPRequest$$Type): $HTTPResponse
get "logger"(): $Logger
set "debugEnabled"(value: boolean)
public static get "current"(): $ConsoleJS
set "muted"(value: boolean)
get "muted"(): boolean
get "debugEnabled"(): boolean
get "scriptLine"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleJS$$Type = ($ConsoleJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConsoleJS$$Original = $ConsoleJS;}
declare module "dev.latvian.mods.kubejs.recipe.schema.function.ResolvedRecipeSchemaFunction" {
import {$RecipeScriptContext, $RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"

export interface $ResolvedRecipeSchemaFunction$$Interface {

(cx: $RecipeScriptContext, args: $List<(any)>): void
}

export class $ResolvedRecipeSchemaFunction implements $ResolvedRecipeSchemaFunction$$Interface {
 "execute"(cx: $RecipeScriptContext$$Type, args: $List$$Type<(any)>): void
 "arguments"(): $List<($RecipeComponent<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResolvedRecipeSchemaFunction$$Type = ((cx: $RecipeScriptContext, args: $List<(any)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ResolvedRecipeSchemaFunction$$Original = $ResolvedRecipeSchemaFunction;}
declare module "dev.latvian.mods.kubejs.core.EntityCollectionKJS" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityCollectionKJS$$Interface {

(): $Iterable$$Type<($Entity$$Type)>
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "entities"(): $EntityArrayList
}

export class $EntityCollectionKJS implements $EntityCollectionKJS$$Interface {
 "getMcEntities"(): $Iterable<($Entity)>
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityCollectionKJS$$Type = (() => $Iterable$$Type<($Entity$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityCollectionKJS$$Original = $EntityCollectionKJS;}
declare module "dev.latvian.mods.kubejs.client.icon.KubeIcon" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$KubeIconType, $KubeIconType$$Type} from "dev.latvian.mods.kubejs.client.icon.KubeIconType"

export interface $KubeIcon$$Interface {

(): $KubeIconType$$Type<(never)>
get "type"(): $KubeIconType<(never)>
}

export class $KubeIcon implements $KubeIcon$$Interface {
static readonly "CODEC": $Codec<($KubeIcon)>
static readonly "OPTIONAL_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Optional<($KubeIcon)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($KubeIcon)>

 "getType"(): $KubeIconType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeIcon$$Type = (() => $KubeIconType$$Type<(never)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeIcon$$Original = $KubeIcon;}
declare module "dev.latvian.mods.kubejs.util.NBTSerializable" {
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"

export interface $NBTSerializable$$Interface {

(): $Tag$$Type
}

export class $NBTSerializable implements $NBTSerializable$$Interface {
 "toNBT"(): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTSerializable$$Type = (() => $Tag$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NBTSerializable$$Original = $NBTSerializable;}
declare module "dev.latvian.mods.kubejs.script.data.GeneratedData" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$IoSupplier, $IoSupplier$$Interface} from "net.minecraft.server.packs.resources.IoSupplier"
import {$InputStream} from "java.io.InputStream"
import {$Path$$Type} from "java.nio.file.Path"
import {$ZipFile$$Type} from "java.util.zip.ZipFile"
import {$ZipEntry$$Type} from "java.util.zip.ZipEntry"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $GeneratedData extends $Record implements $IoSupplier$$Interface<($InputStream)> {
static readonly "PACK_META": $GeneratedData
static readonly "INTERNAL_RELOAD": $GeneratedData
static readonly "PACK_ICON": $GeneratedData

constructor(id: $ResourceLocation$$Type, data: $Supplier$$Type<((byte)[])>)

public "get"(): $InputStream
public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "data"(): $Supplier<((byte)[])>
public "id"(): $ResourceLocation
public static "json"(id: $ResourceLocation$$Type, json: $Supplier$$Type<($JsonElement$$Type)>): $GeneratedData
public static "create"(arg0: $ZipFile$$Type, arg1: $ZipEntry$$Type): $IoSupplier<($InputStream)>
public static "create"(arg0: $Path$$Type): $IoSupplier<($InputStream)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedData$$Type = ({"id"?: $ResourceLocation$$Type, "data"?: $Supplier$$Type<((byte)[])>}) | ([id?: $ResourceLocation$$Type, data?: $Supplier$$Type<((byte)[])>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeneratedData$$Original = $GeneratedData;}
declare module "dev.latvian.mods.kubejs.util.LogType" {
import {$Enum} from "java.lang.Enum"
import {$BiConsumer} from "java.util.function.BiConsumer"
import {$Logger} from "org.slf4j.Logger"

export class $LogType extends $Enum<($LogType)> {
static readonly "INIT": $LogType
readonly "callback": $BiConsumer<($Logger), (StringJS)>
static readonly "ERROR": $LogType
static readonly "VALUES": ($LogType)[]
readonly "id": StringJS
static readonly "INFO": $LogType
static readonly "DEBUG": $LogType
static readonly "WARN": $LogType

public static "values"(): ($LogType)[]
public static "valueOf"(name: StringJS): $LogType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogType$$Type = (("init") | ("debug") | ("info") | ("warn") | ("error"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LogType$$Original = $LogType;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext" {
import {$RecipePostProcessor} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Record} from "java.lang.Record"

export class $RecipeTypeRegistryContext extends $Record {
constructor(registries: $RegistryAccessContainer$$Type, storage: $RecipeSchemaStorage$$Type)

public "recipeComponentCodec"(): $Codec<($RecipeComponent<(never)>)>
public "recipePostProcessorCodec"(): $Codec<($RecipePostProcessor)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "storage"(): $RecipeSchemaStorage
public "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeRegistryContext$$Type = ({"registries"?: $RegistryAccessContainer$$Type, "storage"?: $RecipeSchemaStorage$$Type}) | ([registries?: $RegistryAccessContainer$$Type, storage?: $RecipeSchemaStorage$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeTypeRegistryContext$$Original = $RecipeTypeRegistryContext;}
declare module "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator$Part" {
import {$VariantBlockStateGenerator$Model} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $MultipartBlockStateGenerator$Part {
constructor()

public "model"(s: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartBlockStateGenerator$Part$$Type = ($MultipartBlockStateGenerator$Part);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultipartBlockStateGenerator$Part$$Original = $MultipartBlockStateGenerator$Part;}
declare module "dev.latvian.mods.kubejs.block.BlockStoppedFallingKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a falling block finishes falling.
 */
export class $BlockStoppedFallingKubeEvent implements $KubeEntityEvent$$Interface {
readonly "fallSpeed": double
readonly "replacedBlock": $LevelBlock
readonly "block": $LevelBlock

constructor(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, entity: $FallingBlockEntity$$Type, fallSpeed: double, replacedState: $BlockState$$Type)

public "getLevel"(): $Level
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStoppedFallingKubeEvent$$Type = ($BlockStoppedFallingKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStoppedFallingKubeEvent$$Original = $BlockStoppedFallingKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveRecipesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export interface $RemoveRecipesKubeEvent$$Interface extends $KubeEvent$$Interface {

(category: $ResourceLocation, recipesToRemove: ($ResourceLocation)[]): void
}

export class $RemoveRecipesKubeEvent implements $RemoveRecipesKubeEvent$$Interface {
 "removeFromCategory"(category: $ResourceLocation$$Type, recipesToRemove: ($ResourceLocation$$Type)[]): void
 "remove"(recipesToRemove: (Special.RecipeId)[]): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveRecipesKubeEvent$$Type = ((category: $ResourceLocation, recipesToRemove: ($ResourceLocation)[]) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoveRecipesKubeEvent$$Original = $RemoveRecipesKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.TextIcons" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Style} from "net.minecraft.network.chat.Style"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Component} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $TextIcons$$Interface {
}

export class $TextIcons implements $TextIcons$$Interface {
static readonly "STYLE": $Style
static readonly "FONT": $ResourceLocation
static readonly "NAME": $Component
static readonly "ALL_ICONS": StringJS

static "fire"(): $MutableComponent
static "camera"(): $MutableComponent
static "itemTag"(): $MutableComponent
static "yes"(): $MutableComponent
static "yes"(yes: boolean): $MutableComponent
static "minus"(): $MutableComponent
static "no"(): $MutableComponent
static "tag"(): $MutableComponent
static "info"(): $MutableComponent
static "id"(): $MutableComponent
static "copy"(): $MutableComponent
static "error"(): $MutableComponent
static "warn"(): $MutableComponent
static "plus"(): $MutableComponent
static "icon"(character: $MutableComponent$$Type): $MutableComponent
static "logo"(): $MutableComponent
static "crafting"(): $MutableComponent
static "icons"(characters: StringJS): $MutableComponent
static "smallSpace"(): $MutableComponent
static "tilde"(): $MutableComponent
static "blockTagIcon"(): $MutableComponent
static "entityTypeTag"(): $MutableComponent
static "fluidTag"(): $MutableComponent
static "prototypeComponent"(): $MutableComponent
static "patchedComponent"(): $MutableComponent
static "vscode"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextIcons$$Type = ($TextIcons);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextIcons$$Original = $TextIcons;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeSchemaType} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$LinkedHashMap} from "java.util.LinkedHashMap"
import {$RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAwareSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RegistryAwareSchema"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"

export class $RecipeNamespace extends $LinkedHashMap<(StringJS), ($RecipeSchemaType)> {
readonly "name": StringJS
readonly "storage": $RecipeSchemaStorage

constructor(storage: $RecipeSchemaStorage$$Type, name: StringJS)

public "getRegisteredOrThrow"(id: StringJS): $RecipeSchemaType
public "registerBasic"(id: StringJS, ...keys: ($RecipeKey$$Type<(never)>)[]): $RecipeNamespace
public "withExistingParent"(id: StringJS, parent: $ResourceLocation$$Type): $RecipeNamespace
public "shaped"(id: StringJS): $RecipeNamespace
public "shapeless"(id: StringJS): $RecipeNamespace
public "toString"(): StringJS
public "register"(id: StringJS, type: $RecipeSchema$$Type): $RecipeNamespace
public "register"(id: StringJS, type: $RegistryAwareSchema$$Type): $RecipeNamespace
public "special"(id: StringJS): $RecipeNamespace
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeNamespace$$Type = ($RecipeNamespace);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeNamespace$$Original = $RecipeNamespace;}
declare module "dev.latvian.mods.kubejs.block.custom.ButtonBlockBuilder" {
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Consumer} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ButtonOrPressurePlateBuilder$$Interface} from "dev.latvian.mods.kubejs.block.custom.ButtonOrPressurePlateBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

export class $ButtonBlockBuilder extends $ShapedBlockBuilder implements $ButtonOrPressurePlateBuilder$$Interface {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "BUTTON_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "ticksToStayPressed"(ticks: $TickDuration$$Type): $BlockBuilder
public "behaviour"(behaviour: $BlockSetType$$Type): $BlockBuilder
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonBlockBuilder$$Type = ($ButtonBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ButtonBlockBuilder$$Original = $ButtonBlockBuilder;}
declare module "dev.latvian.mods.kubejs.core.RecipeInputKJS" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput} from "net.minecraft.world.item.crafting.RecipeInput"
import {$List} from "java.util.List"
import {$SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeInputKJS$$Interface {
}

export class $RecipeInputKJS implements $RecipeInputKJS$$Interface {
 "findAll"(): $List<($ItemStack)>
 "findAll"(filter: $SlotFilter$$Type): $List<($ItemStack)>
 "find"(filter: $SlotFilter$$Type, skip: integer): $ItemStack
 "find"(filter: $SlotFilter$$Type): $ItemStack
 "self"(): $RecipeInput
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeInputKJS$$Type = ($RecipeInputKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeInputKJS$$Original = $RecipeInputKJS;}
declare module "dev.latvian.mods.kubejs.core.IngredientKJS" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ItemStackSet} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ItemMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ItemPredicate, $ItemPredicate$$Interface} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set} from "java.util.Set"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Stream} from "java.util.stream.Stream"
import {$SizedIngredient} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IngredientKJS$$Interface extends $ItemPredicate$$Interface, $Replaceable$$Interface, $WithCodec$$Interface, $ItemMatch$$Interface {

(itemStack: $ItemStack): boolean
get "stackArray"(): ($ItemStack)[]
get "tagKey"(): $TagKey<($Item)>
get "codec"(): $Codec<(never)>
get "wildcard"(): boolean
get "stacks"(): $ItemStackSet
get "displayStacks"(): $ItemStackSet
get "itemStream"(): $Stream<($Item)>
get "itemTypes"(): $Set<($Item)>
get "itemIds"(): $Set<(StringJS)>
get "first"(): $ItemStack
}

export class $IngredientKJS implements $IngredientKJS$$Interface {
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "asIngredient"(): $Ingredient
 "withCount"(count: integer): $SizedIngredient
 "getStackArray"(): ($ItemStack)[]
 "and"(ingredient: $Ingredient$$Type): $Ingredient
 "or"(ingredient: $Ingredient$$Type): $Ingredient
 "except"(subtracted: $Ingredient$$Type): $Ingredient
 "asStack"(): $SizedIngredient
 "getTagKey"(): $TagKey<($Item)>
 "containsAnyTag"(): boolean
 "toIngredientString"(ops: $DynamicOps$$Type<($Tag$$Type)>): StringJS
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, item: $ItemStack$$Type, exact: boolean): boolean
 "self"(): $Ingredient
 "getCodec"(): $Codec<(never)>
 "isWildcard"(): boolean
 "canBeUsedForMatching"(): boolean
 "getStacks"(): $ItemStackSet
 "testItem"(item: $Item$$Type): boolean
 "getDisplayStacks"(): $ItemStackSet
 "getItemStream"(): $Stream<($Item)>
 "getItemTypes"(): $Set<($Item)>
 "getItemIds"(): $Set<(StringJS)>
 "getFirst"(): $ItemStack
 "test"(itemStack: $ItemStack$$Type): boolean
 "test"(itemStack: any): boolean
static "wrap"(from: any): $ItemPredicate
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientKJS$$Type = ((itemStack: $ItemStack) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientKJS$$Original = $IngredientKJS;}
declare module "dev.latvian.mods.kubejs.net.KubeServerData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$ItemTooltipData, $ItemTooltipData$$Type} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$RecipeViewerData, $RecipeViewerData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"
import {$Record} from "java.lang.Record"

export class $KubeServerData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($KubeServerData)>

constructor(recipeViewerData: ($RecipeViewerData$$Type)?, itemTooltipData: $List$$Type<($ItemTooltipData$$Type)>)

public "recipeViewerData"(): $Optional<($RecipeViewerData)>
public "itemTooltipData"(): $List<($ItemTooltipData)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "collect"(): $KubeServerData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeServerData$$Type = ({"recipeViewerData"?: ($RecipeViewerData$$Type)?, "itemTooltipData"?: $List$$Type<($ItemTooltipData$$Type)>}) | ([recipeViewerData?: ($RecipeViewerData$$Type)?, itemTooltipData?: $List$$Type<($ItemTooltipData$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeServerData$$Original = $KubeServerData;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaRegistry" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeNamespace} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAwareSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RegistryAwareSchema"

export class $RecipeSchemaRegistry implements $KubeEvent$$Interface {
constructor(storage: $RecipeSchemaStorage$$Type)

public "namespace"(namespace: StringJS): $RecipeNamespace
public "register"(id: $ResourceLocation$$Type, schema: $RegistryAwareSchema$$Type): void
public "register"(id: $ResourceLocation$$Type, schema: $RecipeSchema$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaRegistry$$Type = ($RecipeSchemaRegistry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchemaRegistry$$Original = $RecipeSchemaRegistry;}
declare module "dev.latvian.mods.kubejs.core.LazyComponentKJS" {
import {$Supplier$$Interface} from "java.util.function.Supplier"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LazyComponentKJS$$Interface extends $Supplier$$Interface<($Component)> {

(): $Component$$Type
}

export class $LazyComponentKJS implements $LazyComponentKJS$$Interface {
 "get"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyComponentKJS$$Type = (() => $Component$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LazyComponentKJS$$Original = $LazyComponentKJS;}
declare module "dev.latvian.mods.kubejs.script.KubeJSFileWatcherThread" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Thread} from "java.lang.Thread"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$ScriptFile, $ScriptFile$$Type} from "dev.latvian.mods.kubejs.script.ScriptFile"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSFileWatcherThread extends $Thread {
readonly "reload": $Runnable
readonly "scriptType": $ScriptType
static readonly "MIN_PRIORITY": integer
readonly "files": ($ScriptFile)[]
static readonly "MAX_PRIORITY": integer
static readonly "NORM_PRIORITY": integer

constructor(scriptType: $ScriptType$$Type, files: ($ScriptFile$$Type)[], reload: $Runnable$$Type)

public "run"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSFileWatcherThread$$Type = ($KubeJSFileWatcherThread);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSFileWatcherThread$$Original = $KubeJSFileWatcherThread;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate" {
import {$BlockIDPredicate$PropertyObject} from "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate$PropertyObject"
import {$LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$BlockPredicate$$Interface} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List} from "java.util.List"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockIDPredicate implements $BlockPredicate$$Interface {
constructor(i: $ResourceLocation$$Type)

public "getBlockProperties"(): $List<($BlockIDPredicate$PropertyObject)>
public "toString"(): StringJS
public "with"(key: StringJS, value: StringJS): $BlockIDPredicate
public "checkState"(state: $BlockState$$Type): boolean
public "check"(b: $LevelBlock$$Type): boolean
public "getBlockState"(): $BlockState
get "blockProperties"(): $List<($BlockIDPredicate$PropertyObject)>
get "blockState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIDPredicate$$Type = ($BlockIDPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockIDPredicate$$Original = $BlockIDPredicate;}
declare module "dev.latvian.mods.kubejs.block.BlockStartedFallingKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a falling block starts to fall.
 */
export class $BlockStartedFallingKubeEvent implements $KubeEntityEvent$$Interface {
constructor(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, entity: $FallingBlockEntity$$Type)

public "getBlock"(): $LevelBlock
public "getLevel"(): $Level
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "block"(): $LevelBlock
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStartedFallingKubeEvent$$Type = ($BlockStartedFallingKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStartedFallingKubeEvent$$Original = $BlockStartedFallingKubeEvent;}
declare module "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubeLivingEntityEvent$$Interface extends $KubeEntityEvent$$Interface {

(): $LivingEntity$$Type
get "entity"(): $LivingEntity
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export class $KubeLivingEntityEvent implements $KubeLivingEntityEvent$$Interface {
 "getEntity"(): $LivingEntity
 "getLevel"(): $Level
 "getPlayer"(): $Player
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeLivingEntityEvent$$Type = (() => $LivingEntity$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeLivingEntityEvent$$Original = $KubeLivingEntityEvent;}
declare module "dev.latvian.mods.kubejs.block.custom.FallingBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $FallingBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "dustColor"(color: $KubeColor$$Type): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FallingBlockBuilder$$Type = ($FallingBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FallingBlockBuilder$$Original = $FallingBlockBuilder;}
declare module "dev.latvian.mods.kubejs.item.JukeboxSongBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$JukeboxSong} from "net.minecraft.world.item.JukeboxSong"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export class $JukeboxSongBuilder extends $BuilderBase<($JukeboxSong)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "comparatorOutput"(comparatorOutput: integer): this
public "song"(sound: $Holder$$Type<($SoundEvent)>, length: float): this
public "description"(description: $Component$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JukeboxSongBuilder$$Type = ($JukeboxSongBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JukeboxSongBuilder$$Original = $JukeboxSongBuilder;}
declare module "dev.latvian.mods.kubejs.core.ContainerKJS" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container} from "net.minecraft.world.Container"
import {$List} from "java.util.List"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$InventoryKJS$$Interface} from "dev.latvian.mods.kubejs.core.InventoryKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ContainerKJS$$Interface extends $InventoryKJS$$Interface {
get "mutable"(): boolean
get "slots"(): integer
get "width"(): integer
get "height"(): integer
get "changed"(): void
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}

export class $ContainerKJS implements $ContainerKJS$$Interface {
 "self"(): $Container
 "isMutable"(): boolean
 "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
 "getSlots"(): integer
 "getStackInSlot"(slot: integer): $ItemStack
 "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
 "getSlotLimit"(slot: integer): integer
 "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
 "clear"(): void
 "getWidth"(): integer
 "getHeight"(): integer
 "getBlock"(level: $Level$$Type): $LevelBlock
 "setChanged"(): void
 "asContainer"(): $Container
 "isEmpty"(): boolean
 "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "clear"(match: $ItemPredicate$$Type): void
 "find"(match: $ItemPredicate$$Type): integer
 "find"(): integer
 "count"(match: $ItemPredicate$$Type): integer
 "count"(): integer
 "countNonEmpty"(): integer
 "countNonEmpty"(match: $ItemPredicate$$Type): integer
 "getAllItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerKJS$$Type = ($ContainerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ContainerKJS$$Original = $ContainerKJS;}
declare module "dev.latvian.mods.kubejs.core.AdvancementNodeKJS" {
import {$DisplayInfo} from "net.minecraft.advancements.DisplayInfo"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$AdvancementNode, $AdvancementNode$$Type} from "net.minecraft.advancements.AdvancementNode"
import {$Set} from "java.util.Set"
import {$Component} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $AdvancementNodeKJS$$Interface {
get "parent"(): $AdvancementNode
get "children"(): $Set<($AdvancementNode)>
get "displayText"(): $Component
get "description"(): $Component
get "display"(): $DisplayInfo
get "title"(): $Component
get "id"(): $ResourceLocation
}

export class $AdvancementNodeKJS implements $AdvancementNodeKJS$$Interface {
 "getParent"(): $AdvancementNode
 "getChildren"(): $Set<($AdvancementNode)>
 "addChild"(a: $AdvancementNode$$Type): void
 "getDisplayText"(): $Component
 "hasDisplay"(): boolean
 "getDescription"(): $Component
 "getDisplay"(): $DisplayInfo
 "self"(): $AdvancementNode
 "getTitle"(): $Component
 "getId"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdvancementNodeKJS$$Type = ($AdvancementNodeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AdvancementNodeKJS$$Original = $AdvancementNodeKJS;}
declare module "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemModificationKubeEvent$ItemModifications$$Type} from "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent$ItemModifications"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Consumer$$Type} from "java.util.function.Consumer"

/**
 * Invoked after all items are registered to modify them.
 */
export class $ItemModificationKubeEvent implements $KubeEvent$$Interface {
constructor()

/**
 * Modifies items matching the given ingredient.
 * 
 * **NOTE**: tag ingredients are not supported at this time.
 */
public "modify"(arg0: $ItemPredicate$$Type, c: $Consumer$$Type<($ItemModificationKubeEvent$ItemModifications)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModificationKubeEvent$$Type = ($ItemModificationKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemModificationKubeEvent$$Original = $ItemModificationKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Value" {
import {$CustomObjectRecipeComponent$Key, $CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Comparable, $Comparable$$Interface} from "java.lang.Comparable"
import {$Map$Entry, $Map$Entry$$Type, $Map$Entry$$Interface} from "java.util.Map$Entry"
import {$Record} from "java.lang.Record"

export class $CustomObjectRecipeComponent$Value extends $Record implements $Map$Entry$$Interface<($CustomObjectRecipeComponent$Key), (any)>, $Comparable$$Interface<($CustomObjectRecipeComponent$Value)> {
constructor(key: $CustomObjectRecipeComponent$Key$$Type, index: integer, value: any)

public "index"(): integer
public "value"(): any
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "compareTo"(value: any): integer
public "compareTo"(value: $CustomObjectRecipeComponent$Value$$Type): integer
public "getValue"(): any
public "getKey"(): any
public "key"(): $CustomObjectRecipeComponent$Key
public "setValue"(object: any): any
public static "copyOf"<K, V>(arg0: $Map$Entry$$Type<($CustomObjectRecipeComponent$Key$$Type), (any)>): $Map$Entry<($CustomObjectRecipeComponent$Key), (any)>
public static "comparingByKey"<K, V>(arg0: $Comparator$$Type<($CustomObjectRecipeComponent$Key)>): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
public static "comparingByKey"<K extends $Comparable<(object)>, V>(): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
public static "comparingByValue"<K, V extends $Comparable<(object)>>(): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
public static "comparingByValue"<K, V>(arg0: $Comparator$$Type<(any)>): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomObjectRecipeComponent$Value$$Type = ({"key"?: $CustomObjectRecipeComponent$Key$$Type, "value"?: any, "index"?: integer}) | ([key?: $CustomObjectRecipeComponent$Key$$Type, value?: any, index?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomObjectRecipeComponent$Value$$Original = $CustomObjectRecipeComponent$Value;}
declare module "dev.latvian.mods.kubejs.block.BlockRightClickedKubeEvent" {
import {$BlockHitResult, $BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks on a block.
 */
export class $BlockRightClickedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(item: $ItemStack$$Type, player: $Player$$Type, hand: $InteractionHand$$Type, pos: $BlockPos$$Type, direction: $Direction$$Type, hitResult: $BlockHitResult$$Type)

/**
 * The hand that was used to right click the block.
 */
public "getHand"(): $InteractionHand
public "getHitResult"(): $BlockHitResult
/**
 * The face of the block being right clicked.
 */
public "getFacing"(): $Direction
/**
 * The position of the block that was right clicked.
 */
public "getItem"(): $ItemStack
/**
 * The block that was right clicked.
 */
public "getBlock"(): $LevelBlock
/**
 * The player that right clicked the block.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "hand"(): $InteractionHand
get "hitResult"(): $BlockHitResult
get "facing"(): $Direction
get "item"(): $ItemStack
get "block"(): $LevelBlock
get "entity"(): $LivingEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRightClickedKubeEvent$$Type = ($BlockRightClickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockRightClickedKubeEvent$$Original = $BlockRightClickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.DynamicItemTooltipsKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"

export class $DynamicItemTooltipsKubeEvent implements $KubeEvent$$Interface {
readonly "item": $ItemStack
readonly "advanced": boolean
readonly "ctrl": boolean
readonly "startup": boolean
readonly "shift": boolean
readonly "alt": boolean
readonly "lines": $List<($Component)>
readonly "creative": boolean

constructor(item: $ItemStack$$Type, flags: $TooltipFlag$$Type, lines: $List$$Type<($Component$$Type)>, startup: boolean)

public "add"(text: $List$$Type<($Component$$Type)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicItemTooltipsKubeEvent$$Type = ($DynamicItemTooltipsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DynamicItemTooltipsKubeEvent$$Original = $DynamicItemTooltipsKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Variant" {
import {$VariantBlockStateGenerator$Model} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement} from "com.google.gson.JsonElement"

export class $VariantBlockStateGenerator$Variant {
constructor()

public "model"(s: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Variant$$Type = ($VariantBlockStateGenerator$Variant);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VariantBlockStateGenerator$Variant$$Original = $VariantBlockStateGenerator$Variant;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Override" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $ModelGenerator$Override {
constructor(model: $ResourceLocation$$Type)

public "predicate"(property: $ResourceLocation$$Type, value: float): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Override$$Type = ($ModelGenerator$Override);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$Override$$Original = $ModelGenerator$Override;}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent$Before" {
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ExplosionKubeEvent} from "dev.latvian.mods.kubejs.level.ExplosionKubeEvent"

/**
 * Invoked right before an explosion happens.
 */
export class $ExplosionKubeEvent$Before extends $ExplosionKubeEvent {
constructor(level: $Level$$Type, explosion: $Explosion$$Type)

/**
 * Sets the size of the explosion.
 */
public "setSize"(s: float): void
/**
 * Returns the size of the explosion.
 */
public "getSize"(): float
set "size"(value: float)
get "size"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$Before$$Type = ($ExplosionKubeEvent$Before);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionKubeEvent$Before$$Original = $ExplosionKubeEvent$Before;}
declare module "dev.latvian.mods.kubejs.server.ServerKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $ServerKubeEvent implements $KubeEvent$$Interface {
readonly "server": $MinecraftServer

constructor(s: $MinecraftServer$$Type)

public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerKubeEvent$$Type = ($ServerKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerKubeEvent$$Original = $ServerKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.PlatformWrapper$ModInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PlatformWrapper$ModInfo {
constructor(i: StringJS)

public "getName"(): StringJS
public "setName"(n: StringJS): void
public "getId"(): StringJS
public "getVersion"(): StringJS
public "getCustomName"(): StringJS
get "name"(): StringJS
set "name"(value: StringJS)
get "id"(): StringJS
get "version"(): StringJS
get "customName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformWrapper$ModInfo$$Type = ($PlatformWrapper$ModInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlatformWrapper$ModInfo$$Original = $PlatformWrapper$ModInfo;}
declare module "dev.latvian.mods.kubejs.fluid.ThickFluidBuilder" {
import {$FluidBucketItemBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$FlowingFluidBuilder} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$FluidBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$FluidBlockBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$FluidTypeBuilder} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ThickFluidBuilder extends $FluidBuilder {
static readonly "WATER_COLOR": $KubeColor
 "bucketItem": $FluidBucketItemBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "flowingFluid": $FlowingFluidBuilder
 "sourceLine": $SourceLine
 "fluidType": $FluidTypeBuilder
 "block": $FluidBlockBuilder
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThickFluidBuilder$$Type = ($ThickFluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThickFluidBuilder$$Original = $ThickFluidBuilder;}
declare module "dev.latvian.mods.kubejs.client.LoadedTexture" {
import {$BufferedImage$$Type} from "java.awt.image.BufferedImage"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map$$Type} from "java.util.Map"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"

export class $LoadedTexture {
readonly "pixels": (integer)[]
readonly "width": integer
static readonly "EMPTY": $LoadedTexture
readonly "mcmeta": (byte)[]
readonly "height": integer

constructor(img: $BufferedImage$$Type, mcmeta: (byte)[])
constructor(width: integer, height: integer, pixels: (integer)[], mcmeta: (byte)[])

public "toBytes"(): (byte)[]
public static "load"(id: $ResourceLocation$$Type): $LoadedTexture
public "copy"(): $LoadedTexture
public "resize"(newWidth: integer, newHeight: integer): $LoadedTexture
public "remap"(remap: $Map$$Type<($KubeColor$$Type), ($KubeColor$$Type)>): $LoadedTexture
public "tint"(tint: $KubeColor$$Type): $LoadedTexture
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoadedTexture$$Type = ($LoadedTexture);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LoadedTexture$$Original = $LoadedTexture;}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$IngredientAction} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $IngredientActionType<T extends $IngredientAction> extends $Record {
static readonly "TYPES": $Lazy<($Map<($ResourceLocation), ($IngredientActionType<(never)>)>)>
static readonly "CODEC": $Codec<($IngredientActionType<(never)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientActionType<(never)>)>

constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>)
constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>)

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "codec"(): $MapCodec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientActionType$$Type<T> = ({"codec"?: $MapCodec$$Type<(T)>, "id"?: $ResourceLocation$$Type, "streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>}) | ([codec?: $MapCodec$$Type<(T)>, id?: $ResourceLocation$$Type, streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientActionType$$Original<T> = $IngredientActionType<(T)>;}
declare module "dev.latvian.mods.kubejs.core.RegistryObjectKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RegistryObjectKJS$$Interface<T> extends $SpecialEquality$$Interface {
get "registryId"(): $ResourceKey<($Registry<(T)>)>
get "registry"(): $Registry<(T)>
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<(T)>)>
get "tags"(): $List<($ResourceLocation)>
get "key"(): $ResourceKey<(T)>
get "id"(): StringJS
}

export class $RegistryObjectKJS<T> implements $RegistryObjectKJS$$Interface {
 "getRegistryId"(): $ResourceKey<($Registry<(T)>)>
 "getRegistry"(): $Registry<(T)>
 "asHolder"(): $Holder<(T)>
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "getTagKeys"(): $List<($TagKey<(T)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getKey"(): $ResourceKey<(T)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryObjectKJS$$Type<T> = ($RegistryObjectKJS<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryObjectKJS$$Original<T> = $RegistryObjectKJS<(T)>;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateModifyPlacementCallback" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand} from "net.minecraft.world.InteractionHand"
import {$Direction} from "net.minecraft.core.Direction"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level} from "net.minecraft.world.level.Level"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockStateModifyCallback} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $BlockStateModifyPlacementCallback extends $BlockStateModifyCallback {
readonly "minecraftBlock": $Block
readonly "context": $BlockPlaceContext
 "block": $LevelBlock

constructor(context: $BlockPlaceContext$$Type, block: $Block$$Type)

/**
 * Gets the clicked position in world
 */
public "getClickedPos"(): $BlockPos
/**
 * Gets the facing direction of the clicked block face
 */
public "getClickedFace"(): $Direction
/**
 * Returns if the hit posiiton in the block-space is inside the 1x1x1 cube of the block
 */
public "isInside"(): boolean
/**
 * Gets the position in the block-space of where it was clicked
 */
public "getClickLocation"(): $Vec3
/**
 * Gets the nearest horizontal direction to where the player is looking. NORTH if there is no player
 */
public "getHorizontalDirection"(): $Direction
/**
 * Gets an array of all directions, ordered by which the player is looking closest to
 */
public "getNearestLookingDirections"(): ($Direction)[]
/**
 * Gets the direction closes to where the player is currently looking
 */
public "getNearestLookingDirection"(): $Direction
/**
 * Gets the hand that is placing the block
 */
public "getHand"(): $InteractionHand
/**
 * Returns if the block being placed is replacing the block clicked
 */
public "replacingClickedOnBlock"(): boolean
/**
 * Returns if the block being placed thinks it can be placed here. This is used for replacement checks, like placing blocks in water or tall grass
 */
public "canPlace"(): boolean
/**
 * Gets the vertical direction (UP/DOWN) closest to where the player is currently looking
 */
public "getNearestLookingVerticalDirection"(): $Direction
/**
 * Gets the FluidSate at the clicked position
 */
public "getFluidStateAtClickedPos"(): $FluidState
/**
 * Checks if the position clicked has a specified fluid there
 */
public "isClickedPosIn"(fluid: $Fluid$$Type): boolean
/**
 * Checks if the block currently occupying the position this is being placed in is the same block type.
 * Used for things like candles, where multiple can be in the same block-space.
 */
public "isReplacingSelf"(): boolean
/**
 * Gets the clicked block
 */
public "getClickedBlock"(): $LevelBlock
/**
 * Gets the item being placed
 */
public "getItem"(): $ItemStack
/**
 * Gets the level
 */
public "getLevel"(): $Level
/**
 * Get the horizontal rotation of the player
 */
public "getRotation"(): float
/**
 * Set if this block is waterlogged or not
 */
public "waterlogged"(waterlogged: boolean): $BlockStateModifyPlacementCallback
/**
 * Set this block as waterlogged if it is in water
 */
public "waterlogged"(): $BlockStateModifyPlacementCallback
/**
 * Checks if this block is in water
 */
public "isInWater"(): boolean
/**
 * Returns if the player is using the 'secondary' function of this item. Basically checks if they are holding shift
 */
public "isSecondaryUseActive"(): boolean
/**
 * Gets the player placing the block, if available
 */
public "getPlayer"(): $Player
get "clickedPos"(): $BlockPos
get "clickedFace"(): $Direction
get "inside"(): boolean
get "clickLocation"(): $Vec3
get "horizontalDirection"(): $Direction
get "nearestLookingDirections"(): ($Direction)[]
get "nearestLookingDirection"(): $Direction
get "hand"(): $InteractionHand
get "nearestLookingVerticalDirection"(): $Direction
get "fluidStateAtClickedPos"(): $FluidState
get "replacingSelf"(): boolean
get "clickedBlock"(): $LevelBlock
get "item"(): $ItemStack
get "level"(): $Level
get "rotation"(): float
get "inWater"(): boolean
get "secondaryUseActive"(): boolean
get "player"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateModifyPlacementCallback$$Type = ($BlockStateModifyPlacementCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateModifyPlacementCallback$$Original = $BlockStateModifyPlacementCallback;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback" {
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Enum} from "java.lang.Enum"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$IntegerProperty$$Type} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty$$Type} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty$$Type} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockStateModifyCallback {
constructor(state: $BlockState$$Type)

/**
 * Updates the shape of this block. Mostly used in waterloggable blocks to update the water flow
 */
public "updateShape"(direction: $Direction$$Type, blockState: $BlockState$$Type, levelAccessor: $LevelAccessor$$Type, blockPos: $BlockPos$$Type, blockPos2: $BlockPos$$Type): $BlockStateModifyCallback
/**
 * Gets the value of the passed in property as an Optional. If the property does not exist in this block the Optional will be empty
 */
public "getOptionalValue"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): $Optional<(T)>
public "populateNeighbours"(map: $Map$$Type<($Map$$Type<($Property$$Type<(never)>), ($Comparable$$Type<(never)>)>), ($BlockState$$Type)>): $BlockStateModifyCallback
/**
 * Get a map of this blocks properties to it's value
 */
public "getValues"(): $Map<($Property<(never)>), ($Comparable<(never)>)>
/**
 * Gets the value of the pased in property
 */
public "get"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): T
public "toString"(): StringJS
/**
 * Gets the value of the passed in property
 */
public "getValue"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): T
/**
 * Sets the value of the specified enum property
 */
public "set"<T extends $Enum<(object)>>(property: $EnumProperty$$Type<(T)>, value: StringJS): $BlockStateModifyCallback
/**
 * Sets the value of the specified boolean property
 */
public "set"(property: $BooleanProperty$$Type, value: boolean): $BlockStateModifyCallback
/**
 * Sets the value of the specified integer property
 */
public "set"(property: $IntegerProperty$$Type, value: integer): $BlockStateModifyCallback
/**
 * Get the properties this block has that can be changed
 */
public "getProperties"(): $Collection<($Property<(never)>)>
/**
 * Gets the state. If it has been modified, gets the new state
 */
public "getState"(): $BlockState
/**
 * Sets the value of the specified property
 */
public "setValue"<T extends $Comparable<(object)>, V extends $Comparable<(object)>>(property: $Property$$Type<(T)>, comparable: V): $BlockStateModifyCallback
/**
 * Rotate the block using the specified Rotation
 */
public "rotate"(rotation: $Rotation$$Type): $BlockStateModifyCallback
/**
 * Mirror the block using the specified Mirror
 */
public "mirror"(mirror: $Mirror$$Type): $BlockStateModifyCallback
/**
 * Checks if this block has the specified property
 */
public "hasProperty"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): boolean
/**
 * Cycles the property
 */
public "cycle"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): $BlockStateModifyCallback
get "values"(): $Map<($Property<(never)>), ($Comparable<(never)>)>
get "properties"(): $Collection<($Property<(never)>)>
get "state"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateModifyCallback$$Type = ($BlockStateModifyCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateModifyCallback$$Original = $BlockStateModifyCallback;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties$Blocks" {
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $BuildingMaterialProperties$Blocks extends $Record {
constructor(slab: (boolean)?, stairs: (boolean)?, fence: (boolean)?, fenceGate: (boolean)?, wall: (boolean)?, pressurePlate: (boolean)?, button: (boolean)?, trapdoor: (boolean)?, door: (boolean)?)

public "door"(): $Optional<(boolean)>
public "slab"(): $Optional<(boolean)>
public "trapdoor"(): $Optional<(boolean)>
public "pressurePlate"(): $Optional<(boolean)>
public "stairs"(): $Optional<(boolean)>
public "fenceGate"(): $Optional<(boolean)>
public "wall"(): $Optional<(boolean)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "fence"(): $Optional<(boolean)>
public "button"(): $Optional<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuildingMaterialProperties$Blocks$$Type = ({"slab"?: (boolean)?, "pressurePlate"?: (boolean)?, "fence"?: (boolean)?, "button"?: (boolean)?, "door"?: (boolean)?, "fenceGate"?: (boolean)?, "stairs"?: (boolean)?, "wall"?: (boolean)?, "trapdoor"?: (boolean)?}) | ([slab?: (boolean)?, pressurePlate?: (boolean)?, fence?: (boolean)?, button?: (boolean)?, door?: (boolean)?, fenceGate?: (boolean)?, stairs?: (boolean)?, wall?: (boolean)?, trapdoor?: (boolean)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuildingMaterialProperties$Blocks$$Original = $BuildingMaterialProperties$Blocks;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.TextWrapper" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ItemLore} from "net.minecraft.world.item.component.ItemLore"
import {$List$$Type} from "java.util.List"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ClickEvent, $ClickEvent$$Type} from "net.minecraft.network.chat.ClickEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * The hub for all things text components. Format text to your hearts content!
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $TextWrapper$$Interface {
}

export class $TextWrapper implements $TextWrapper$$Interface {
static readonly "TYPE_INFO": $TypeInfo

static "ofTag"(tag: $Tag$$Type): $Component
/**
 * Returns a ClickEvent of the input
 */
static "clickEventOf"(event: $ClickEvent$$Type): $ClickEvent
/**
 * Returns a colorful representation of the input nbt. Useful for displaying NBT to the player
 */
static "prettyPrintNbt"(tag: $Tag$$Type): $Component
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translateWithFallback"(key: StringJS, fallback: StringJS): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translateWithFallback"(key: StringJS, fallback: StringJS, ...objects: (any)[]): $MutableComponent
/**
 * Returns a component of the input, colored gold
 */
static "gold"(text: $MutableComponent$$Type): $MutableComponent
static "lore"(lore: $List$$Type<($Component$$Type)>): $ItemLore
/**
 * Returns a component of the input, colored dark blue
 */
static "darkBlue"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark green
 */
static "darkGreen"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark aqua
 */
static "darkAqua"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark red
 */
static "darkRed"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark purple
 */
static "darkPurple"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark gray
 */
static "darkGray"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored aqua
 */
static "aqua"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored light purple
 */
static "lightPurple"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a plain component of the string, or empty if it is an empty string
 */
static "ofString"(s: StringJS): $MutableComponent
/**
 * Returns a component of the input, colored gray
 */
static "gray"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component displaying all entities matching the input selector
 */
static "selector"(selector: StringJS): $MutableComponent
/**
 * Returns a component displaying all entities matching the input selector, with a custom separator
 */
static "selector"(selector: StringJS, separator: $Component$$Type): $MutableComponent
/**
 * Checks if the passed in component, and all its children are empty
 */
static "isEmpty"(component: $Component$$Type): boolean
/**
 * Joins all components
 */
static "join"(...texts: ($Component$$Type)[]): $MutableComponent
/**
 * Joins all components in the list with the separator component
 */
static "join"(separator: $MutableComponent$$Type, texts: $Iterable$$Type<($Component$$Type)>): $MutableComponent
/**
 * Returns a Component of the input
 */
static "of"(component: $MutableComponent$$Type): $MutableComponent
/**
 * Returns an empty component
 */
static "empty"(): $MutableComponent
static "info"(text: $Component$$Type): $MutableComponent
/**
 * Returns a component of the input, colored red
 */
static "red"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a plain component of the passed in string, even if empty
 */
static "string"(text: StringJS): $MutableComponent
/**
 * Returns a plain component of the input
 */
static "literal"(text: StringJS): $MutableComponent
static "warn"(text: $Component$$Type): $MutableComponent
/**
 * Returns a component of the input, colored black
 */
static "black"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored blue
 */
static "blue"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored green
 */
static "green"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored white
 */
static "white"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored yellow
 */
static "yellow"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a score component of the input objective, for the provided selector
 */
static "score"(selector: StringJS, objective: StringJS): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects
 */
static "translatable"(key: Special.LangKey, ...objects: (any)[]): $MutableComponent
/**
 * Returns a translatable component of the input key
 */
static "translatable"(key: Special.LangKey): $MutableComponent
/**
 * Returns a translatable component of the input key
 */
static "translate"(key: Special.LangKey): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects
 */
static "translate"(key: Special.LangKey, ...objects: (any)[]): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translatableWithFallback"(key: StringJS, fallback: StringJS, ...objects: (any)[]): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translatableWithFallback"(key: StringJS, fallback: StringJS): $MutableComponent
/**
 * Returns a keybinding component of the input keybinding descriptor
 */
static "keybind"(keybind: StringJS): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextWrapper$$Type = ($TextWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextWrapper$$Original = $TextWrapper;}
declare module "dev.latvian.mods.kubejs.event.KubeEvent" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $KubeEvent$$Interface {
}

export class $KubeEvent implements $KubeEvent$$Interface {
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeEvent$$Type = ($KubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeEvent$$Original = $KubeEvent;}
declare module "dev.latvian.mods.kubejs.server.ServerScriptManager" {
import {$VirtualDataPack} from "dev.latvian.mods.kubejs.script.data.VirtualDataPack"
import {$Map} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$GeneratedDataStage} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$PackResources, $PackResources$$Type} from "net.minecraft.server.packs.PackResources"
import {$PreTagKubeEvent} from "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent"
import {$RecipeSchemaStorage} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$KubeJSContextFactory} from "dev.latvian.mods.kubejs.script.KubeJSContextFactory"
import {$SyncServerDataPayload} from "dev.latvian.mods.kubejs.net.SyncServerDataPayload"
import {$ScriptPack} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ScriptManager} from "dev.latvian.mods.kubejs.script.ScriptManager"

export class $ServerScriptManager extends $ScriptManager {
readonly "virtualPacks": $Map<($GeneratedDataStage), ($VirtualDataPack)>
readonly "scriptType": $ScriptType
readonly "registriesDataPack": $VirtualDataPack
readonly "internalDataPack": $VirtualDataPack
 "canListenEvents": boolean
readonly "recipeSchemaStorage": $RecipeSchemaStorage
 "firstLoad": boolean
readonly "packs": $Map<(StringJS), ($ScriptPack)>
readonly "preTagEvents": $Map<($ResourceKey<(never)>), ($PreTagKubeEvent)>
 "serverData": $SyncServerDataPayload
 "contextFactory": $KubeJSContextFactory

public static "createForDataGen"(): $ServerScriptManager
public "reloadAndCapture"(): void
public "loadFromDirectory"(): void
public "loadAdditional"(): void
public static "createPackResources"(original: $List$$Type<($PackResources$$Type)>): $List<($PackResources)>
public "reload"(): void
public static "release"(): $ServerScriptManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerScriptManager$$Type = ($ServerScriptManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerScriptManager$$Original = $ServerScriptManager;}
declare module "dev.latvian.mods.kubejs.fluid.ThinFluidBuilder" {
import {$FluidBucketItemBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$FlowingFluidBuilder} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$FluidBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$FluidBlockBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$FluidTypeBuilder} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ThinFluidBuilder extends $FluidBuilder {
static readonly "WATER_COLOR": $KubeColor
 "bucketItem": $FluidBucketItemBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "flowingFluid": $FlowingFluidBuilder
 "sourceLine": $SourceLine
 "fluidType": $FluidTypeBuilder
 "block": $FluidBlockBuilder
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThinFluidBuilder$$Type = ($ThinFluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThinFluidBuilder$$Original = $ThinFluidBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.ClassFilter" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Class$$Type} from "java.lang.Class"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ClassFilter {
readonly "scriptType": $ScriptType

constructor(scriptType: $ScriptType$$Type)

public "isAllowed"(s: StringJS): boolean
public "allow"(s: StringJS): void
public "allow"(c: $Class$$Type<(never)>): void
public "deny"(c: $Class$$Type<(never)>): void
public "deny"(s: StringJS): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassFilter$$Type = ($ClassFilter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClassFilter$$Original = $ClassFilter;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$Mode" {
import {$Enum} from "java.lang.Enum"

export class $HighlightRenderer$Mode extends $Enum<($HighlightRenderer$Mode)> {
static readonly "SCREEN": $HighlightRenderer$Mode
static readonly "NONE": $HighlightRenderer$Mode
static readonly "WORLD": $HighlightRenderer$Mode

public static "values"(): ($HighlightRenderer$Mode)[]
public static "valueOf"(name: StringJS): $HighlightRenderer$Mode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightRenderer$Mode$$Type = (("none") | ("screen") | ("world"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightRenderer$Mode$$Original = $HighlightRenderer$Mode;}
declare module "dev.latvian.mods.kubejs.recipe.filter.RecipeFilterParseEvent" {
import {$Context} from "dev.latvian.mods.rhino.Context"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeFilter, $RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$Event} from "net.neoforged.bus.api.Event"

export class $RecipeFilterParseEvent extends $Event {
readonly "cx": $Context
readonly "filters": $List<($RecipeFilter)>
readonly "map": $Map<(never), (never)>

constructor(filters: $List$$Type<($RecipeFilter$$Type)>, map: $Map$$Type<(never), (never)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFilterParseEvent$$Type = ($RecipeFilterParseEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeFilterParseEvent$$Original = $RecipeFilterParseEvent;}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator" {
import {$VariantBlockStateGenerator$Variant$$Type} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Variant"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $VariantBlockStateGenerator {
constructor()

public "simpleVariant"(key: StringJS, model: $ResourceLocation$$Type): void
public "variant"(key: StringJS, consumer: $Consumer$$Type<($VariantBlockStateGenerator$Variant)>): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$$Type = ($VariantBlockStateGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VariantBlockStateGenerator$$Original = $VariantBlockStateGenerator;}
declare module "dev.latvian.mods.kubejs.recipe.CachedTagLookup" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List, $List$$Type} from "java.util.List"
import {$Set} from "java.util.Set"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$Holder} from "net.minecraft.core.Holder"

export class $CachedTagLookup<T> {
readonly "registry": $Registry<(T)>
readonly "originalMap": $Map<($ResourceLocation), ($List<($TagLoader$EntryWithSource)>)>

constructor(registry: $Registry$$Type<(T)>, originalMap: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>)

public "keyToValue"(): $Map<($TagKey<(T)>), ($Set<(T)>)>
public "bindingMap"(): $Map<($TagKey<(T)>), ($List<($Holder<(T)>)>)>
public "values"(key: $TagKey$$Type<(T)>): $Set<(T)>
public "isEmpty"(key: $TagKey$$Type<(T)>): boolean
public "keys"(value: T): $Set<($TagKey<(T)>)>
public "build"(builders: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>): $Map<($ResourceLocation), ($Collection<(T)>)>
public "tagMap"(): $Map<($ResourceLocation), ($Collection<($Holder<(T)>)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedTagLookup$$Type<T> = ($CachedTagLookup<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CachedTagLookup$$Original<T> = $CachedTagLookup<(T)>;}
declare module "dev.latvian.mods.kubejs.web.SessionInfo" {
import {$Set, $Set$$Type} from "java.util.Set"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record} from "java.lang.Record"

export class $SessionInfo extends $Record {
static readonly "NONE": $SessionInfo

constructor(source: StringJS, tags: $Set$$Type<(StringJS)>)

public "tags"(): $Set<(StringJS)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "source"(): StringJS
public static "fromJson"(info: $SessionInfo$$Type, json: $JsonObject$$Type): $SessionInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionInfo$$Type = ({"source"?: StringJS, "tags"?: $Set$$Type<(StringJS)>}) | ([source?: StringJS, tags?: $Set$$Type<(StringJS)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SessionInfo$$Original = $SessionInfo;}
declare module "dev.latvian.mods.kubejs.block.custom.BasicKubeBlock$Builder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $BasicKubeBlock$Builder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicKubeBlock$Builder$$Type = ($BasicKubeBlock$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasicKubeBlock$Builder$$Original = $BasicKubeBlock$Builder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.UtilsWrapper" {
import {$Pattern} from "java.util.regex.Pattern"
import {$Collection$$Type} from "java.util.Collection"
import {$Map} from "java.util.Map"
import {$List} from "java.util.List"
import {$Duration$$Type} from "java.time.Duration"
import {$Runnable$$Type} from "java.lang.Runnable"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Random$$Type} from "java.util.Random"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$CountingMap} from "dev.latvian.mods.kubejs.util.CountingMap"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Stat} from "net.minecraft.stats.Stat"
import {$CreativeModeTab} from "net.minecraft.world.item.CreativeModeTab"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$Supplier$$Type} from "java.util.function.Supplier"

/**
 * A collection of utilities
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $UtilsWrapper$$Interface {
public static get "systemTime"(): long
public static get "random"(): $RandomSource
}

export class $UtilsWrapper implements $UtilsWrapper$$Interface {
/**
 * Get a new random with the specified seed
 */
static "newRandom"(seed: long): $RandomSource
/**
 * Gets a random object from the list using the passed in random
 */
static "randomOf"(random: $Random$$Type, objects: $Collection$$Type<(any)>): any
/**
 * Returns a new counting map
 */
static "newCountingMap"(): $CountingMap
/**
 * Gets the current system time, in milliseconds
 */
static "getSystemTime"(): long
/**
 * Returns a lazy value with the supplier function as its value factory, that will expire after the specified time
 */
static "expiringLazy"<T>(supplier: $Supplier$$Type<(T)>, expires: $Duration$$Type): $Lazy<(T)>
/**
 * Returns a Stat of the passed in ResourceLocation.
 * Note that this requires the same ResourceLocation to get the same stat, so should not be used unless you want to make your own stat, and are storing an actual ResourceLocation somewhere to access it.
 */
static "getStat"(id: $ResourceLocation$$Type): $Stat<($ResourceLocation)>
/**
 * Runs the provided runnable function in KubeJS' background thread and returns its CompletableFuture
 */
static "runAsync"(task: $Runnable$$Type): $CompletableFuture<(void)>
/**
 * Returns a new mutable list
 */
static "newList"(): $List<(never)>
/**
 * Returns a lazy value with the supplier function as its value factory
 */
static "lazy"<T>(supplier: $Supplier$$Type<(T)>): $Lazy<(T)>
/**
 * Runs the provided supplier function in KubeJS' background thread and returns its CompletableFuture
 */
static "supplyAsync"(task: $Supplier$$Type<(any)>): $CompletableFuture<(any)>
/**
 * Returns a regex pattern of the input
 */
static "regex"(s: any): $Pattern
/**
 * Returns a regex pattern of the input with the specified flags
 */
static "regex"(pattern: StringJS, flags: integer): $Pattern
/**
 * Get an immutable empty list
 */
static "emptyList"<T>(): $List<(T)>
/**
 * Checks if the passed in object is an instance of WrappedJS
 */
static "isWrapped"(o: any): boolean
/**
 * Returns a new mutable map
 */
static "newMap"(): $Map<(never), (never)>
/**
 * Get an immutable empty map
 */
static "emptyMap"<K, V>(): $Map<(K), (V)>
/**
 * Get a Random, for generating random numbers. Note this will always return the same Random instance
 */
static "getRandom"(): $RandomSource
/**
 * Gets a SoundEvent from the id
 */
static "getSound"(id: $ResourceLocation$$Type): $SoundEvent
/**
 * Returns the creative tab associated with the id
 */
static "findCreativeTab"(id: $ResourceLocation$$Type): $CreativeModeTab
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UtilsWrapper$$Type = ($UtilsWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UtilsWrapper$$Original = $UtilsWrapper;}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder" {
import {$ToDoubleFunction$$Type} from "java.util.function.ToDoubleFunction"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$CropBlockBuilder$ShapeBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$ShapeBuilder"
import {$KubeDataGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$CropBlockBuilder$SurviveCallback$$Type} from "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$SurviveCallback"
import {$RandomTickCallback, $RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

export class $CropBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "CROP_ITEM_TAGS": ($ResourceLocation)[]
static readonly "CROP_BLOCK_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

/**
 * Add a crop output with a specific amount.
 */
public "crop"(output: $Holder$$Type<($Item)>, chance: $NumberProvider$$Type): this
/**
 * Add a crop output with exactly one output.
 */
public "crop"(output: $Holder$$Type<($Item)>): this
public "randomTick"(randomTickCallback: $Consumer$$Type<($RandomTickCallback)>): $BlockBuilder
public "generateLootTable"(generator: $KubeDataGenerator$$Type): $LootTable
public "bonemeal"(bonemealCallback: $ToIntFunction$$Type<($RandomTickCallback)>): this
public "noItem"(): $BlockBuilder
public "farmersCanPlant"(): this
public "survive"(surviveCallback: $CropBlockBuilder$SurviveCallback$$Type): this
public "growTick"(growSpeedCallback: $ToDoubleFunction$$Type<($RandomTickCallback)>): this
/**
 * Remove seed drops from the loot table, does not prevent seed item from creating.
 */
public "noSeeds"(): this
/**
 * Set the age of the crop and the shape of the crop at that age.
 */
public "age"(age: integer, builder: $Consumer$$Type<($CropBlockBuilder$ShapeBuilder)>): this
/**
 * Set the age of the crop. Note that the box will be the same for all ages (A full block size).
 */
public "age"(age: integer): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$$Type = ($CropBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CropBlockBuilder$$Original = $CropBlockBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.ColorWrapper" {
import {$ColorRGBA} from "net.minecraft.util.ColorRGBA"
import {$Map} from "java.util.Map"
import {$DyeColor} from "net.minecraft.world.item.DyeColor"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$TextColor} from "net.minecraft.network.chat.TextColor"
import {$ChatFormatting} from "net.minecraft.ChatFormatting"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ColorWrapper$$Interface {
}

export class $ColorWrapper implements $ColorWrapper$$Interface {
static readonly "BLUE_DYE": $KubeColor
static readonly "GOLD": $KubeColor
static readonly "GRAY": $KubeColor
static readonly "MAGENTA_DYE": $KubeColor
static readonly "BLUE": $KubeColor
static readonly "DARK_AQUA": $KubeColor
static readonly "TEXT": $Map<(StringJS), ($ChatFormatting)>
static readonly "DYE": $Map<(StringJS), ($DyeColor)>
static readonly "WHITE_DYE": $KubeColor
static readonly "DARK_RED": $KubeColor
static readonly "LIGHT_PURPLE": $KubeColor
static readonly "BROWN_DYE": $KubeColor
static readonly "BLACK": $KubeColor
static readonly "GRAY_DYE": $KubeColor
static readonly "NONE": $KubeColor
static readonly "LIGHT_BLUE_DYE": $KubeColor
static readonly "AQUA": $KubeColor
static readonly "WHITE": $KubeColor
static readonly "LIGHT_GRAY_DYE": $KubeColor
static readonly "BLACK_DYE": $KubeColor
static readonly "RED_DYE": $KubeColor
static readonly "PURPLE_DYE": $KubeColor
static readonly "GREEN_DYE": $KubeColor
static readonly "PINK_DYE": $KubeColor
static readonly "DARK_BLUE": $KubeColor
static readonly "GREEN": $KubeColor
static readonly "CYAN_DYE": $KubeColor
static readonly "RED": $KubeColor
static readonly "DARK_PURPLE": $KubeColor
static readonly "ORANGE_DYE": $KubeColor
static readonly "YELLOW_DYE": $KubeColor
static readonly "DARK_GREEN": $KubeColor
static readonly "YELLOW": $KubeColor
static readonly "LIME_DYE": $KubeColor
static readonly "DARK_GRAY": $KubeColor
static readonly "MAP": $Map<(StringJS), ($KubeColor)>

static "rgba"(r: integer, g: integer, b: integer, a: integer): $KubeColor
static "wrapTextColor"(o: any): $TextColor
static "wrapColorRGBA"(o: any): $ColorRGBA
static "createMapped"(o: any, ...names: (StringJS)[]): $KubeColor
static "wrap"(o: any): $KubeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColorWrapper$$Type = ($ColorWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ColorWrapper$$Original = $ColorWrapper;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Chestplate" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorItemBuilder$Chestplate extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "CHESTPLATE_TAGS": ($ResourceLocation)[]

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Chestplate$$Type = ($ArmorItemBuilder$Chestplate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Chestplate$$Original = $ArmorItemBuilder$Chestplate;}
declare module "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$TextAction, $TextAction$$Type} from "dev.latvian.mods.kubejs.text.action.TextAction"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$TooltipRequirements, $TooltipRequirements$$Type} from "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements"
import {$List, $List$$Type} from "java.util.List"
import {$Record} from "java.lang.Record"

export class $ItemTooltipData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemTooltipData)>

constructor(filter: ($Ingredient$$Type)?, requirements: ($TooltipRequirements$$Type)?, actions: $List$$Type<($TextAction$$Type)>)

public "requirements"(): $Optional<($TooltipRequirements)>
public "actions"(): $List<($TextAction)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Optional<($Ingredient)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTooltipData$$Type = ({"filter"?: ($Ingredient$$Type)?, "requirements"?: ($TooltipRequirements$$Type)?, "actions"?: $List$$Type<($TextAction$$Type)>}) | ([filter?: ($Ingredient$$Type)?, requirements?: ($TooltipRequirements$$Type)?, actions?: $List$$Type<($TextAction$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemTooltipData$$Original = $ItemTooltipData;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Pickaxe" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Pickaxe extends $DiggerItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
static readonly "PICKAXE_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "PICKAXE_MODEL": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Pickaxe$$Type = ($DiggerItemBuilder$Pickaxe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Pickaxe$$Original = $DiggerItemBuilder$Pickaxe;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Group" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Record} from "java.lang.Record"

export class $ItemData$Group extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$Group)>

constructor(filter: $Ingredient$$Type, groupId: $ResourceLocation$$Type, description: $Component$$Type)

public "groupId"(): $ResourceLocation
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Ingredient
public "description"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$Group$$Type = ({"filter"?: $Ingredient$$Type, "groupId"?: $ResourceLocation$$Type, "description"?: $Component$$Type}) | ([filter?: $Ingredient$$Type, groupId?: $ResourceLocation$$Type, description?: $Component$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$Group$$Original = $ItemData$Group;}
declare module "dev.latvian.mods.kubejs.entity.KubeEntityEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubeEntityEvent$$Interface extends $KubeLevelEvent$$Interface {

(): $Entity$$Type
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export class $KubeEntityEvent implements $KubeEntityEvent$$Interface {
 "getLevel"(): $Level
 "getEntity"(): $Entity
 "getPlayer"(): $Player
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeEntityEvent$$Type = (() => $Entity$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeEntityEvent$$Original = $KubeEntityEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemEntityInteractedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks on an entity.
 */
export class $ItemEntityInteractedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, entity: $Entity$$Type, hand: $InteractionHand$$Type, item: $ItemStack$$Type)

/**
 * The hand that was used to interact with the entity.
 */
public "getHand"(): $InteractionHand
/**
 * The item that was used to interact with the entity.
 */
public "getItem"(): $ItemStack
/**
 * The player that interacted with the entity.
 */
public "getEntity"(): $LivingEntity
/**
 * The entity that was interacted with.
 */
public "getTarget"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "hand"(): $InteractionHand
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "target"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEntityInteractedKubeEvent$$Type = ($ItemEntityInteractedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemEntityInteractedKubeEvent$$Original = $ItemEntityInteractedKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type, $RecipeComponent$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Set$$Type} from "java.util.Set"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$EitherRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$CustomObjectRecipeComponent$Key, $CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$CustomObjectRecipeComponent$Value, $CustomObjectRecipeComponent$Value$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Value"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$ListRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $CustomObjectRecipeComponent implements $RecipeComponent$$Interface<($List<($CustomObjectRecipeComponent$Value)>)> {
static readonly "TYPE": $RecipeComponentType<(never)>

constructor(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>)

public "hasPriority"(hasPriority: $Predicate$$Type<($Set<(StringJS)>)>): $CustomObjectRecipeComponent
public "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, list: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): void
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, list: any): void
public "createCopy"(): $CustomObjectRecipeComponent
public "type"(): $RecipeComponentType<(never)>
public "toString"(): StringJS
public "wrap"(rcx: $RecipeScriptContext$$Type, from: any): any
public "isEmpty"(value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): boolean
public "isEmpty"(value: any): boolean
public "replace"(cx: $RecipeScriptContext$$Type, original: any, match: $ReplacementMatchInfo$$Type, arg3: any): any
public "replace"(cx: $RecipeScriptContext$$Type, original: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>, match: $ReplacementMatchInfo$$Type, arg3: any): $List<($CustomObjectRecipeComponent$Value)>
public "matches"(cx: $RecipeMatchContext$$Type, value: any, match: $ReplacementMatchInfo$$Type): boolean
public "matches"(cx: $RecipeMatchContext$$Type, value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, value: any): void
public "validate"(ctx: $RecipeValidationContext$$Type, value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): void
public "typeInfo"(): $TypeInfo
public "keys"(): $List<($CustomObjectRecipeComponent$Key)>
public "codec"(): $Codec<($List<($CustomObjectRecipeComponent$Value)>)>
public "mapCodec"(): $MapCodec<($List<($CustomObjectRecipeComponent$Value)>)>
public "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<($CustomObjectRecipeComponent$Value$$Type)>)>, json: $JsonObject$$Type): void
public "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<($CustomObjectRecipeComponent$Value$$Type)>)>, json: $JsonObject$$Type): void
public "orSelf"(): $RecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "outputKey"(name: StringJS): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
public "asListOrSelf"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "asConditionalList"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "asConditionalListOrSelf"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($List<($CustomObjectRecipeComponent$Value)>)>)>
public "withCodec"(codec: $Codec$$Type<($List$$Type<($CustomObjectRecipeComponent$Value$$Type)>)>): $RecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "allowEmpty"(): boolean
public "inputKey"(name: StringJS): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
public "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>), (O)>
public "isIgnored"(): boolean
public "toString"(ops: $OpsContainer$$Type, value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): StringJS
public static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
public static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
public "asList"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "createBuilder"(): $RecipeComponentBuilder
public "spread"(value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): $List<(never)>
public "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($List<($CustomObjectRecipeComponent$Value)>)>)>
public "otherKey"(name: StringJS): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
get "ignored"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomObjectRecipeComponent$$Type = ($CustomObjectRecipeComponent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomObjectRecipeComponent$$Original = $CustomObjectRecipeComponent;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.RemoteRecipeViewerDataUpdatedEvent" {
import {$Event} from "net.neoforged.bus.api.Event"
import {$RecipeViewerData, $RecipeViewerData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"

export class $RemoteRecipeViewerDataUpdatedEvent extends $Event {
readonly "data": $RecipeViewerData

constructor(data: $RecipeViewerData$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoteRecipeViewerDataUpdatedEvent$$Type = ($RemoteRecipeViewerDataUpdatedEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoteRecipeViewerDataUpdatedEvent$$Original = $RemoteRecipeViewerDataUpdatedEvent;}
declare module "dev.latvian.mods.kubejs.core.MenuTypeKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$MenuType} from "net.minecraft.world.inventory.MenuType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MenuTypeKJS$$Interface extends $RegistryObjectKJS$$Interface<($MenuType<(never)>)> {
get "registryId"(): $ResourceKey<($Registry<($MenuType<(never)>)>)>
get "registry"(): $Registry<($MenuType<(never)>)>
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($MenuType<(never)>)>)>
get "tags"(): $List<($ResourceLocation)>
get "key"(): $ResourceKey<($MenuType<(never)>)>
get "id"(): StringJS
}

export class $MenuTypeKJS implements $MenuTypeKJS$$Interface {
 "getRegistryId"(): $ResourceKey<($Registry<($MenuType<(never)>)>)>
 "getRegistry"(): $Registry<($MenuType<(never)>)>
 "asHolder"(): $Holder<($MenuType<(never)>)>
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "getTagKeys"(): $List<($TagKey<($MenuType<(never)>)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getKey"(): $ResourceKey<($MenuType<(never)>)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MenuTypeKJS$$Type = ($MenuTypeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MenuTypeKJS$$Original = $MenuTypeKJS;}
declare module "dev.latvian.mods.kubejs.event.EventExceptionHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$EventHandlerContainer, $EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"

export interface $EventExceptionHandler$$Interface {

(event: $KubeEvent, container: $EventHandlerContainer, ex: $Throwable): $Throwable$$Type
}

export class $EventExceptionHandler implements $EventExceptionHandler$$Interface {
 "handle"(event: $KubeEvent$$Type, container: $EventHandlerContainer$$Type, ex: $Throwable$$Type): $Throwable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventExceptionHandler$$Type = ((event: $KubeEvent, container: $EventHandlerContainer, ex: $Throwable) => $Throwable$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventExceptionHandler$$Original = $EventExceptionHandler;}
declare module "dev.latvian.mods.kubejs.recipe.ModifyCraftingItemKubeEvent" {
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"

export class $ModifyCraftingItemKubeEvent implements $KubeEvent$$Interface {
 "item": $ItemStack
readonly "grid": $RecipeInput
readonly "width": integer
readonly "index": integer
readonly "height": integer

constructor(grid: $RecipeInput$$Type, width: integer, height: integer, item: $ItemStack$$Type, index: integer)
constructor(grid: $CraftingInput$$Type, item: $ItemStack$$Type, index: integer)

/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifyCraftingItemKubeEvent$$Type = ($ModifyCraftingItemKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModifyCraftingItemKubeEvent$$Original = $ModifyCraftingItemKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.TagManagerKJS" {
import {$ReloadableServerResourceHolderKJS$$Interface} from "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS"
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $TagManagerKJS$$Interface extends $ReloadableServerResourceHolderKJS$$Interface {
}

export class $TagManagerKJS implements $TagManagerKJS$$Interface {
 "kjs$getResources"(): $ReloadableServerResourcesKJS
 "kjs$setResources"(resources: $ReloadableServerResourcesKJS$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagManagerKJS$$Type = ($TagManagerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagManagerKJS$$Original = $TagManagerKJS;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BlockWrapper" {
import {$RegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.registry.RegistryKubeEvent"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$BlockEntityPredicate} from "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockIDPredicate} from "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate"
import {$BlockSetType} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$BlockPredicate, $BlockPredicate$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BuildingMaterialProperties$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

/**
 * Various block related helper functions
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $BlockWrapper {
static readonly "TYPE_INFO": $TypeInfo
static readonly "STATE_TYPE_INFO": $TypeInfo

constructor()

public static "wrapSetType"(from: any, target: $TypeInfo$$Type): $BlockSetType
/**
 * Parses a block state from the input string. May throw for invalid inputs!
 */
public static "wrapBlockState"(registries: $RegistryAccessContainer$$Type, o: any): $BlockState
public static "parseBlockState"(registries: $RegistryAccessContainer$$Type, string: StringJS): $BlockState
public static "registerBuildingMaterial"(event: $RegistryKubeEvent$$Type<($Block$$Type)>, id: $ResourceLocation$$Type, properties: $BuildingMaterialProperties$$Type): void
public static "registerBuildingMaterial"(event: $RegistryKubeEvent$$Type<($Block$$Type)>, id: $ResourceLocation$$Type): void
/**
 * Gets a list of all blocks with tags
 */
public static "getTaggedIds"(tag: $ResourceLocation$$Type): $List<($ResourceLocation)>
public static "getAllBlockStates"(): $Collection<($BlockState)>
/**
 * Get a map of direction name to Direction. Functionally identical to Direction.ALL
 */
public static "getFacing"(): $Map<(StringJS), ($Direction)>
public static "entity"(id: $ResourceLocation$$Type): $BlockEntityPredicate
/**
 * Gets a Block from a block id
 */
public static "getBlock"(id: $ResourceLocation$$Type): $Block
public static "id"(id: $ResourceLocation$$Type, properties: $Map$$Type<(StringJS), (any)>): $BlockIDPredicate
public static "id"(id: $ResourceLocation$$Type): $BlockIDPredicate
/**
 * Gets a blocks id from the Block
 */
public static "getId"(block: $Block$$Type): $ResourceLocation
public static "custom"(predicate: $BlockPredicate$$Type): $BlockPredicate
public static "withProperties"(state: $BlockState$$Type, properties: $Map$$Type<(never), (never)>): $BlockState
/**
 * Gets a list of the classname of all registered blocks
 */
public static "getTypeList"(): $List<(StringJS)>
public static get "allBlockStates"(): $Collection<($BlockState)>
public static get "facing"(): $Map<(StringJS), ($Direction)>
public static get "typeList"(): $List<(StringJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockWrapper$$Type = ($BlockWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockWrapper$$Original = $BlockWrapper;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage" {
import {$RecipePostProcessor} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$Map} from "java.util.Map"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecipeSchemaType} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$ServerScriptManager$$Type} from "dev.latvian.mods.kubejs.server.ServerScriptManager"
import {$RecipeNamespace} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$KubeRecipeFactory} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"

export class $RecipeSchemaStorage {
readonly "mappings": $Map<(StringJS), ($ResourceLocation)>
readonly "recipeTypes": $Map<($ResourceLocation), ($KubeRecipeFactory)>
readonly "schemaTypes": $Map<(StringJS), ($RecipeSchemaType)>
 "recipeComponentCodec": $Codec<($RecipeComponent<(never)>)>
 "recipePostProcessorCodec": $Codec<($RecipePostProcessor)>
readonly "namespaces": $Map<(StringJS), ($RecipeNamespace)>

constructor(manager: $ServerScriptManager$$Type)

public "fireEvents"(registries: $RegistryAccessContainer$$Type, resourceManager: $ResourceManager$$Type): void
public "namespace"(namespace: StringJS): $RecipeNamespace
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaStorage$$Type = ($RecipeSchemaStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchemaStorage$$Original = $RecipeSchemaStorage;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveCategoriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export interface $RemoveCategoriesKubeEvent$$Interface extends $KubeEvent$$Interface {

(categories: ($ResourceLocation)[]): void
}

export class $RemoveCategoriesKubeEvent implements $RemoveCategoriesKubeEvent$$Interface {
 "remove"(categories: ($ResourceLocation$$Type)[]): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveCategoriesKubeEvent$$Type = ((categories: ($ResourceLocation)[]) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoveCategoriesKubeEvent$$Original = $RemoveCategoriesKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider" {
import {$ClientLevel, $ClientLevel$$Type} from "net.minecraft.client.multiplayer.ClientLevel"
import {$ParticleProvider} from "net.minecraft.client.particle.ParticleProvider"
import {$Particle, $Particle$$Type} from "net.minecraft.client.particle.Particle"
import {$ParticleEngine$SpriteParticleRegistration$$Interface} from "net.minecraft.client.particle.ParticleEngine$SpriteParticleRegistration"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$SpriteSet, $SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"

export interface $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Interface<T extends $ParticleOptions> extends $ParticleEngine$SpriteParticleRegistration$$Interface<(T)> {

(type: T, clientLevel: $ClientLevel, x: double, y: double, z: double, sprites: $SpriteSet, xSpeed: double, ySpeed: double, zSpeed: double): $Particle$$Type
}

export class $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider<T extends $ParticleOptions> implements $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Interface {
 "create"(sprites: $SpriteSet$$Type): $ParticleProvider<(T)>
 "create"(type: T, clientLevel: $ClientLevel$$Type, x: double, y: double, z: double, sprites: $SpriteSet$$Type, xSpeed: double, ySpeed: double, zSpeed: double): $Particle
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type<T> = ((type: T, clientLevel: $ClientLevel, x: double, y: double, z: double, sprites: $SpriteSet, xSpeed: double, ySpeed: double, zSpeed: double) => $Particle$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Original<T> = $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext" {
import {$RecipeLikeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.RecipeLikeContext"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeMatchContext$$Interface extends $RecipeLikeContext$$Interface {
}

export class $RecipeMatchContext implements $RecipeMatchContext$$Interface {
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
 "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeMatchContext$$Type = ($RecipeMatchContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeMatchContext$$Original = $RecipeMatchContext;}
declare module "dev.latvian.mods.kubejs.util.KubeResourceLocation" {
import {$UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $KubeResourceLocation extends $Record {
static readonly "CODEC": $Codec<($ResourceLocation)>

constructor(wrapped: $ResourceLocation$$Type)

public "wrapped"(): $ResourceLocation
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "wrap"(from: any): $ResourceLocation
public "withPath"(path: $UnaryOperator$$Type<(StringJS)>): $ResourceLocation
public "withPath"(path: StringJS): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeResourceLocation$$Type = ({"wrapped"?: $ResourceLocation$$Type}) | ([wrapped?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeResourceLocation$$Original = $KubeResourceLocation;}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent$After" {
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$List, $List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$ExplosionKubeEvent} from "dev.latvian.mods.kubejs.level.ExplosionKubeEvent"

/**
 * Invoked right after an explosion happens.
 */
export class $ExplosionKubeEvent$After extends $ExplosionKubeEvent {
constructor(level: $Level$$Type, explosion: $Explosion$$Type, affectedEntities: $List$$Type<($Entity$$Type)>)

/**
 * Remove an entity from the list of affected entities.
 */
public "removeAffectedEntity"(entity: $Entity$$Type): void
/**
 * Remove all entities from the list of affected entities.
 */
public "removeAllAffectedEntities"(): void
/**
 * Remove a block from the list of affected blocks.
 */
public "removeAffectedBlock"(block: $LevelBlock$$Type): void
/**
 * Remove all blocks from the list of affected blocks.
 */
public "removeAllAffectedBlocks"(): void
/**
 * Remove all knockback from all affected *players*.
 */
public "removeKnockback"(): void
/**
 * Gets a list of all blocks affected by the explosion.
 */
public "getAffectedBlocks"(): $List<($LevelBlock)>
/**
 * Gets a list of all entities affected by the explosion.
 */
public "getAffectedEntities"(): $EntityArrayList
get "affectedBlocks"(): $List<($LevelBlock)>
get "affectedEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$After$$Type = ($ExplosionKubeEvent$After);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionKubeEvent$After$$Original = $ExplosionKubeEvent$After;}
declare module "dev.latvian.mods.kubejs.player.PlayerClonedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player respawns.
 * 
 * The reason of respawn can be either death or returning from the end.
 */
export class $PlayerClonedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $ServerPlayer$$Type, oldPlayer: $ServerPlayer$$Type, keepData: boolean)

/**
 * Gets whether the player's data was kept, e.g. when returning from the end.
 */
public "getKeepData"(): boolean
/**
 * Gets the player that was before respawn. Note that this entity is already removed from the world.
 */
public "getOldPlayer"(): $ServerPlayer
/**
 * Gets the player that respawned.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "keepData"(): boolean
get "oldPlayer"(): $ServerPlayer
get "entity"(): $LivingEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerClonedKubeEvent$$Type = ($PlayerClonedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerClonedKubeEvent$$Original = $PlayerClonedKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemData$DataComponentSubtypes, $ItemData$DataComponentSubtypes$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$DataComponentSubtypes"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$ItemData$Info, $ItemData$Info$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Info"
import {$ItemData$Group, $ItemData$Group$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Group"
import {$Record} from "java.lang.Record"

export class $ItemData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData)>

constructor(addedEntries: $List$$Type<($ItemStack$$Type)>, removedEntries: $List$$Type<($Ingredient$$Type)>, completelyRemovedEntries: $List$$Type<($Ingredient$$Type)>, groupedEntries: $List$$Type<($ItemData$Group$$Type)>, info: $List$$Type<($ItemData$Info$$Type)>, dataComponentSubtypes: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>)

public "groupedEntries"(): $List<($ItemData$Group)>
public "removedEntries"(): $List<($Ingredient)>
public "completelyRemovedEntries"(): $List<($Ingredient)>
public "addedEntries"(): $List<($ItemStack)>
public "dataComponentSubtypes"(): $List<($ItemData$DataComponentSubtypes)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $ItemData
public "info"(): $List<($ItemData$Info)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$$Type = ({"dataComponentSubtypes"?: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>, "removedEntries"?: $List$$Type<($Ingredient$$Type)>, "groupedEntries"?: $List$$Type<($ItemData$Group$$Type)>, "completelyRemovedEntries"?: $List$$Type<($Ingredient$$Type)>, "info"?: $List$$Type<($ItemData$Info$$Type)>, "addedEntries"?: $List$$Type<($ItemStack$$Type)>}) | ([dataComponentSubtypes?: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>, removedEntries?: $List$$Type<($Ingredient$$Type)>, groupedEntries?: $List$$Type<($ItemData$Group$$Type)>, completelyRemovedEntries?: $List$$Type<($Ingredient$$Type)>, info?: $List$$Type<($ItemData$Info$$Type)>, addedEntries?: $List$$Type<($ItemStack$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$$Original = $ItemData;}
declare module "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KubeKey" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSKeybinds$KubeKey {
readonly "id": StringJS

constructor(id: StringJS)

public "equals"(obj: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSKeybinds$KubeKey$$Type = ($KubeJSKeybinds$KubeKey);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSKeybinds$KubeKey$$Original = $KubeJSKeybinds$KubeKey;}
declare module "dev.latvian.mods.kubejs.core.WindowKJS" {
import {$List, $List$$Type} from "java.util.List"
import {$IoSupplier, $IoSupplier$$Type} from "net.minecraft.server.packs.resources.IoSupplier"
import {$InputStream, $InputStream$$Type} from "java.io.InputStream"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WindowKJS$$Interface {
}

export class $WindowKJS implements $WindowKJS$$Interface {
 "kjs$loadIcons"(original: $List$$Type<($IoSupplier$$Type<($InputStream$$Type)>)>): $List<($IoSupplier<($InputStream)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowKJS$$Type = ($WindowKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WindowKJS$$Original = $WindowKJS;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateMirrorCallback" {
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Rotation} from "net.minecraft.world.level.block.Rotation"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockStateModifyCallback} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateMirrorCallback extends $BlockStateModifyCallback {
constructor(state: $BlockState$$Type, mirror: $Mirror$$Type)

/**
 * Gets the Mirror
 */
public "getMirror"(): $Mirror
/**
 * Mirrors the direction passed in
 */
public "mirror"(dir: $Direction$$Type): $Direction
/**
 * Gets the rotation of the direction passed in relative to this mirror
 */
public "getRotation"(dir: $Direction$$Type): $Rotation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateMirrorCallback$$Type = ($BlockStateMirrorCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateMirrorCallback$$Original = $BlockStateMirrorCallback;}
declare module "dev.latvian.mods.kubejs.core.EntityGetterKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$EntityCollectionKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityCollectionKJS"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityGetterKJS$$Interface extends $EntityCollectionKJS$$Interface {
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "entities"(): $EntityArrayList
}

export class $EntityGetterKJS implements $EntityGetterKJS$$Interface {
 "self"(): $EntityGetter
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityGetterKJS$$Type = ($EntityGetterKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityGetterKJS$$Original = $EntityGetterKJS;}
declare module "dev.latvian.mods.kubejs.core.FluidStackKJS" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ComponentFunctions} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$UUID$$Type} from "java.util.UUID"
import {$MutableDataComponentHolder} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$List, $List$$Type} from "java.util.List"
import {$FluidMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$MutableDataComponentHolderFunctions, $MutableDataComponentHolderFunctions$$Interface} from "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions"
import {$FluidLike, $FluidLike$$Interface} from "dev.latvian.mods.kubejs.fluid.FluidLike"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map$$Type} from "java.util.Map"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Unit$$Type} from "net.minecraft.util.Unit"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FluidStackKJS$$Interface extends $Replaceable$$Interface, $SpecialEquality$$Interface, $WithCodec$$Interface, $FluidLike$$Interface, $FluidMatch$$Interface, $MutableDataComponentHolderFunctions$$Interface, $RegistryObjectKJS$$Interface<($Fluid)> {
get "fluid"(): $Fluid
get "amount"(): integer
get "registryId"(): $ResourceKey<($Registry<($Fluid)>)>
get "registry"(): $Registry<($Fluid)>
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "key"(): $ResourceKey<($Fluid)>
get "codec"(): $Codec<(never)>
get "empty"(): boolean
get "id"(): StringJS
get "componentHolder"(): $MutableDataComponentHolder
get "componentMap"(): $DataComponentMap
get "tagKeys"(): $List<($TagKey<($Fluid)>)>
get "tags"(): $List<($ResourceLocation)>
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "componentString"(): StringJS
set "customData"(value: $CompoundTag$$Type)
get "customData"(): $CompoundTag
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customModelData"(value: integer)
get "additionalTooltipHidden"(): void
get "tooltipHidden"(): void
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "lockCode"(value: StringJS)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
}

export class $FluidStackKJS implements $FluidStackKJS$$Interface {
 "getFluid"(): $Fluid
 "getAmount"(): integer
 "copy"(amount: integer): $FluidLike
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
 "getRegistry"(): $Registry<($Fluid)>
 "asHolder"(): $Holder<($Fluid)>
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "kjs$getWebIconURL"(ops: $DynamicOps$$Type<($Tag$$Type)>, size: integer): $RelativeURL
 "kjs$equalsIgnoringCount"(stack: $FluidStack$$Type): boolean
 "matches"(cx: $RecipeMatchContext$$Type, ingredient: $FluidIngredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, s: $FluidStack$$Type, exact: boolean): boolean
 "kjs$self"(): $FluidStack
 "getKey"(): $ResourceKey<($Fluid)>
 "getCodec"(): $Codec<(never)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "isEmpty"(): boolean
 "getId"(): StringJS
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
 "getComponentHolder"(): $MutableDataComponentHolder
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): $MutableDataComponentHolderFunctions
 "getComponentMap"(): $DataComponentMap
 "getTagKeys"(): $List<($TagKey<($Fluid)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
static "wrap"(o: any): $ReplacementMatch
 "resetComponents"(): $ComponentFunctions
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "getComponentString"(): StringJS
 "setCustomData"(tag: $CompoundTag$$Type): void
 "getCustomData"(): $CompoundTag
 "setRarity"(rarity: $Rarity$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setCustomModelData"(data: integer): void
 "setAdditionalTooltipHidden"(): void
 "setTooltipHidden"(): void
 "setGlintOverride"(override: boolean): void
 "setDyedColor"(color: $KubeColor$$Type): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "setLockCode"(lock: StringJS): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStackKJS$$Type = ($FluidStackKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidStackKJS$$Original = $FluidStackKJS;}
declare module "dev.latvian.mods.kubejs.core.mixin.RecipeInputMixin" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput} from "net.minecraft.world.item.crafting.RecipeInput"
import {$List} from "java.util.List"
import {$SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$RecipeInputKJS$$Interface} from "dev.latvian.mods.kubejs.core.RecipeInputKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeInputMixin$$Interface extends $RecipeInputKJS$$Interface {
}

export class $RecipeInputMixin implements $RecipeInputMixin$$Interface {
 "findAll"(): $List<($ItemStack)>
 "findAll"(filter: $SlotFilter$$Type): $List<($ItemStack)>
 "find"(filter: $SlotFilter$$Type, skip: integer): $ItemStack
 "find"(filter: $SlotFilter$$Type): $ItemStack
 "self"(): $RecipeInput
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeInputMixin$$Type = ($RecipeInputMixin);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeInputMixin$$Original = $RecipeInputMixin;}
declare module "dev.latvian.mods.kubejs.player.SimplePlayerKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $SimplePlayerKubeEvent implements $KubePlayerEvent$$Interface {
constructor(p: $Player$$Type)

public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimplePlayerKubeEvent$$Type = ($SimplePlayerKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimplePlayerKubeEvent$$Original = $SimplePlayerKubeEvent;}
declare module "dev.latvian.mods.kubejs.registry.ServerRegistryKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$List$$Type} from "java.util.List"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$CustomBuilderObject} from "dev.latvian.mods.kubejs.registry.CustomBuilderObject"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"

export class $ServerRegistryKubeEvent<T> implements $KubeEvent$$Interface {
readonly "registryKey": $ResourceKey<($Registry<(T)>)>
readonly "codec": $Codec<(T)>
readonly "jsonOps": $DynamicOps<($JsonElement)>

constructor(registryKey: $ResourceKey$$Type<($Registry<(T)>)>, jsonOps: $DynamicOps$$Type<($JsonElement$$Type)>, codec: $Codec$$Type<(T)>, builders: $List$$Type<($BuilderBase$$Type<(never)>)>)

public "createFromJson"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): $CustomBuilderObject
public "createCustom"(id: $ResourceLocation$$Type, object: $Supplier$$Type<(any)>): $CustomBuilderObject
public "create"(id: $ResourceLocation$$Type, type: $ResourceLocation$$Type): $BuilderBase<(T)>
public "create"(id: $ResourceLocation$$Type): $BuilderBase<(T)>
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerRegistryKubeEvent$$Type<T> = ($ServerRegistryKubeEvent<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerRegistryKubeEvent$$Original<T> = $ServerRegistryKubeEvent<(T)>;}
declare module "dev.latvian.mods.kubejs.script.SourceLine" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $SourceLine extends $Record {
static readonly "UNKNOWN": $SourceLine

constructor(source: StringJS, line: integer)

public "isUnknown"(): boolean
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"(): $SourceLine
public static "of"(source: StringJS, line: integer): $SourceLine
public "line"(): integer
public "source"(): StringJS
public static "write"(buf: $FriendlyByteBuf$$Type, sourceLine: $SourceLine$$Type): void
public static "read"(buf: $FriendlyByteBuf$$Type): $SourceLine
public static "fromJson"(json: $JsonObject$$Type): $SourceLine
public "toJson"(): $JsonObject
get "unknown"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SourceLine$$Type = ({"source"?: StringJS, "line"?: integer}) | ([source?: StringJS, line?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SourceLine$$Original = $SourceLine;}
declare module "dev.latvian.mods.kubejs.core.ComponentKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$FormattedText, $FormattedText$$Type} from "net.minecraft.network.chat.FormattedText"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$UUID$$Type} from "java.util.UUID"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type, $Component$$Interface} from "net.minecraft.network.chat.Component"
import {$FormattedText$StyledContentConsumer$$Type} from "net.minecraft.network.chat.FormattedText$StyledContentConsumer"
import {$Message$$Type} from "com.mojang.brigadier.Message"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$WrappedJS$$Interface} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ComponentContents} from "net.minecraft.network.chat.ComponentContents"
import {$FormattedText$ContentConsumer$$Type} from "net.minecraft.network.chat.FormattedText$ContentConsumer"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$Style, $Style$$Type} from "net.minecraft.network.chat.Style"
import {$ClickEvent$$Type} from "net.minecraft.network.chat.ClickEvent"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$FormattedCharSequence} from "net.minecraft.util.FormattedCharSequence"
import {$URI$$Type} from "java.net.URI"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$Date$$Type} from "java.util.Date"
import {$DataSource$$Type} from "net.minecraft.network.chat.contents.DataSource"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ComponentKJS$$Interface extends $Component$$Interface, $WithCodec$$Interface, $WrappedJS$$Interface {
get "codec"(): $Codec<(never)>
get "contents"(): $ComponentContents
get "string"(): StringJS
get "visualOrderText"(): $FormattedCharSequence
get "style"(): $Style
get "siblings"(): $List<($Component)>
}

export class $ComponentKJS implements $ComponentKJS$$Interface {
 "forEach"(action: $Consumer$$Type<($Component)>): void
 "self"(): $MutableComponent
 "getCodec"(): $Codec<(never)>
 "asIterable"(): $Iterable<($Component)>
 "color"(c: $KubeColor$$Type): $MutableComponent
 "bold"(value: boolean): $MutableComponent
 "bold"(): $MutableComponent
 "italic"(): $MutableComponent
 "italic"(value: boolean): $MutableComponent
 "underlined"(): $MutableComponent
 "underlined"(value: boolean): $MutableComponent
 "strikethrough"(): $MutableComponent
 "strikethrough"(value: boolean): $MutableComponent
 "obfuscated"(): $MutableComponent
 "obfuscated"(value: boolean): $MutableComponent
 "click"(s: $ClickEvent$$Type): $MutableComponent
 "hasStyle"(): boolean
 "hasSiblings"(): boolean
 "black"(): $MutableComponent
 "darkBlue"(): $MutableComponent
 "darkGreen"(): $MutableComponent
 "darkAqua"(): $MutableComponent
 "darkRed"(): $MutableComponent
 "darkPurple"(): $MutableComponent
 "gold"(): $MutableComponent
 "gray"(): $MutableComponent
 "darkGray"(): $MutableComponent
 "blue"(): $MutableComponent
 "green"(): $MutableComponent
 "aqua"(): $MutableComponent
 "red"(): $MutableComponent
 "lightPurple"(): $MutableComponent
 "yellow"(): $MutableComponent
 "white"(): $MutableComponent
 "noColor"(): $MutableComponent
 "insertion"(s: StringJS): $MutableComponent
 "font"(s: $ResourceLocation$$Type): $MutableComponent
 "clickRunCommand"(command: StringJS): $MutableComponent
 "clickSuggestCommand"(command: StringJS): $MutableComponent
 "clickCopy"(text: StringJS): $MutableComponent
 "clickChangePage"(page: StringJS): $MutableComponent
 "clickOpenUrl"(url: StringJS): $MutableComponent
 "clickOpenFile"(path: StringJS): $MutableComponent
 "hover"(s: $Component$$Type): $MutableComponent
 "isEmpty"(): boolean
/**
 * 
 * @deprecated
 */
 "rawComponent"(): $MutableComponent
/**
 * 
 * @deprecated
 */
 "rawCopy"(): $MutableComponent
/**
 * 
 * @deprecated
 */
 "component"(): $Component
 "visit"<T>(arg0: $FormattedText$ContentConsumer$$Type<(T)>): $Optional<(T)>
 "visit"<T>(arg0: $FormattedText$StyledContentConsumer$$Type<(T)>, arg1: $Style$$Type): $Optional<(T)>
static "selector"(arg0: StringJS, arg1: ($Component$$Type)?): $MutableComponent
 "getContents"(): $ComponentContents
 "contains"(arg0: $Component$$Type): boolean
static "empty"(): $MutableComponent
 "copy"(): $MutableComponent
static "literal"(arg0: StringJS): $MutableComponent
 "getString"(): StringJS
 "getString"(arg0: integer): StringJS
static "score"(arg0: StringJS, arg1: StringJS): $MutableComponent
static "nullToEmpty"(arg0: StringJS): $Component
static "translatable"(arg0: StringJS): $MutableComponent
static "translatable"(arg0: StringJS, ...arg1: (any)[]): $MutableComponent
 "getVisualOrderText"(): $FormattedCharSequence
 "getStyle"(): $Style
 "getSiblings"(): $List<($Component)>
 "tryCollapseToString"(): StringJS
 "plainCopy"(): $MutableComponent
 "toFlatList"(arg0: $Style$$Type): $List<($Component)>
 "toFlatList"(): $List<($Component)>
static "translatableEscape"(arg0: StringJS, ...arg1: (any)[]): $MutableComponent
static "translatableWithFallback"(arg0: StringJS, arg1: StringJS): $MutableComponent
static "translatableWithFallback"(arg0: StringJS, arg1: StringJS, ...arg2: (any)[]): $MutableComponent
static "keybind"(arg0: StringJS): $MutableComponent
static "nbt"(arg0: StringJS, arg1: boolean, arg2: ($Component$$Type)?, arg3: $DataSource$$Type): $MutableComponent
static "translationArg"(arg0: $URI$$Type): $Component
static "translationArg"(arg0: $ChunkPos$$Type): $Component
static "translationArg"(arg0: $Date$$Type): $Component
static "translationArg"(arg0: $ResourceLocation$$Type): $Component
static "translationArg"(arg0: $UUID$$Type): $Component
static "translationArg"(arg0: $Message$$Type): $Component
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
static "of"(arg0: StringJS, arg1: $Style$$Type): $FormattedText
static "of"(arg0: StringJS): $FormattedText
static "composite"(arg0: $List$$Type<($FormattedText$$Type)>): $FormattedText
static "composite"(...arg0: ($FormattedText$$Type)[]): $FormattedText
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentKJS$$Type = ($ComponentKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentKJS$$Original = $ComponentKJS;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.KMath" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Vector4f} from "org.joml.Vector4f"
import {$Vector3f} from "org.joml.Vector3f"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$Quaternionf} from "org.joml.Quaternionf"
import {$Matrix4f} from "org.joml.Matrix4f"
import {$Vector3d} from "org.joml.Vector3d"
import {$Matrix3f} from "org.joml.Matrix3f"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $KMath$$Interface {
}

export class $KMath implements $KMath$$Interface {
static readonly "DEGREES_TO_RADIANS": double
static readonly "E": double
static readonly "PI": double
static readonly "RADIANS_TO_DEGREES": double

static "v3f"(x: float, y: float, z: float): $Vector3f
static "v4f"(x: float, y: float, z: float, w: float): $Vector4f
static "m3f"(): $Matrix3f
static "m4f"(): $Matrix4f
static "deg"(value: double): double
static "v3d"(x: double, y: double, z: double): $Vector3d
static "floor"(value: double): long
static "ceil"(value: double): long
static "clamp"(value: double, min: double, max: double): double
static "map"(value: double, min0: double, max0: double, min1: double, max1: double): double
static "v3"(x: double, y: double, z: double): $Vec3
static "block"(x: double, y: double, z: double): $BlockPos
static "isPowerOfTwo"(value: integer): boolean
static "rad"(value: double): double
static "quaternion"(x: float, y: float, z: float, w: float): $Quaternionf
static "lerp"(value: double, min: double, max: double): double
static "clampedLerp"(value: double, min: double, max: double): double
static "degreesDifference"(current: double, target: double): double
static "rotateIfNecessary"(current: double, target: double, max: double): double
static "approach"(current: double, target: double, speed: double): double
static "approachDegrees"(current: double, target: double, speed: double): double
static "wrapDegrees"(d: double): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMath$$Type = ($KMath);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KMath$$Original = $KMath;}
declare module "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Class$$Type} from "java.lang.Class"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Record} from "java.lang.Record"

export class $KubeRecipeFactory extends $Record {
static readonly "DEFAULT": $KubeRecipeFactory

constructor(id: $ResourceLocation$$Type, recipeType: $Class$$Type<(never)>, factory: $Supplier$$Type<($KubeRecipe$$Type)>)
constructor(id: $ResourceLocation$$Type, recipeType: $TypeInfo$$Type, factory: $Supplier$$Type<($KubeRecipe$$Type)>)

public "recipeType"(): $TypeInfo
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "factory"(): $Supplier<($KubeRecipe)>
public "id"(): $ResourceLocation
public "create"(type: $RecipeTypeFunction$$Type, sourceLine: $SourceLine$$Type, save: boolean): $KubeRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipeFactory$$Type = ({"factory"?: $Supplier$$Type<($KubeRecipe$$Type)>, "id"?: $ResourceLocation$$Type, "recipeType"?: $TypeInfo$$Type}) | ([factory?: $Supplier$$Type<($KubeRecipe$$Type)>, id?: $ResourceLocation$$Type, recipeType?: $TypeInfo$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRecipeFactory$$Original = $KubeRecipeFactory;}
declare module "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $FluidBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
readonly "fluidBuilder": $FluidBuilder
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(b: $FluidBuilder$$Type)

public "item"(i: $Consumer$$Type<($ItemBuilder)>): $BlockBuilder
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBlockBuilder$$Type = ($FluidBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidBlockBuilder$$Original = $FluidBlockBuilder;}
declare module "dev.latvian.mods.kubejs.core.ClientPacketListenerKJS" {
import {$KubeSessionData} from "dev.latvian.mods.kubejs.client.KubeSessionData"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ClientPacketListenerKJS$$Interface {
}

export class $ClientPacketListenerKJS implements $ClientPacketListenerKJS$$Interface {
 "kjs$sessionData"(): $KubeSessionData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPacketListenerKJS$$Type = ($ClientPacketListenerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientPacketListenerKJS$$Original = $ClientPacketListenerKJS;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Boots" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorItemBuilder$Boots extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "BOOT_TAGS": ($ResourceLocation)[]
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Boots$$Type = ($ArmorItemBuilder$Boots);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Boots$$Original = $ArmorItemBuilder$Boots;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentType" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$Map} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Class$$Type} from "java.lang.Class"
import {$Record} from "java.lang.Record"

export class $BlockEntityAttachmentType extends $Record {
static readonly "ALL": $Lazy<($Map<($ResourceLocation), ($BlockEntityAttachmentType)>)>

constructor(id: $ResourceLocation$$Type, type: $Class$$Type<(never)>)
constructor(id: $ResourceLocation$$Type, typeInfo: $TypeInfo$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "typeInfo"(): $TypeInfo
public "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentType$$Type = ({"id"?: $ResourceLocation$$Type, "typeInfo"?: $TypeInfo$$Type}) | ([id?: $ResourceLocation$$Type, typeInfo?: $TypeInfo$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentType$$Original = $BlockEntityAttachmentType;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateRotateCallback" {
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockStateModifyCallback} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateRotateCallback extends $BlockStateModifyCallback {
constructor(state: $BlockState$$Type, rotation: $Rotation$$Type)

/**
 * Rotates the specified direction
 */
public "rotate"(dir: $Direction$$Type): $Direction
/**
 * Get the Rotation that this block is being rotated by
 */
public "getRotation"(): $Rotation
get "rotation"(): $Rotation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateRotateCallback$$Type = ($BlockStateRotateCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateRotateCallback$$Original = $BlockStateRotateCallback;}
declare module "dev.latvian.mods.kubejs.block.callback.EntityFallenOnBlockCallback" {
import {$DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$EntitySteppedOnBlockCallback} from "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EntityFallenOnBlockCallback extends $EntitySteppedOnBlockCallback {
constructor(level: $Level$$Type, entity: $Entity$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fallHeight: float)

/**
 * Applies fall damage to the entity as if they had fallen from the provided height, and multiplies it by the provided multiplier.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(fallHeight: float, multiplier: float): boolean
/**
 * Damages the entity using the provided damage source, using the fall height and multiplier to calculate the damage amount.
 * Note this does not force the damage, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(fallHeight: float, multiplier: float, damageSource: $DamageSource$$Type): boolean
/**
 * Applies default fall damage to the entity.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(): boolean
/**
 * Applies fall damage to the entity, multiplier by the multiplier.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(multiplier: float): boolean
/**
 * Get the height the entity has fallen
 */
public "getFallHeight"(): float
get "fallHeight"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityFallenOnBlockCallback$$Type = ($EntityFallenOnBlockCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityFallenOnBlockCallback$$Original = $EntityFallenOnBlockCallback;}
declare module "dev.latvian.mods.kubejs.misc.MobEffectBuilder$EffectEntityCallback" {
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $MobEffectBuilder$EffectEntityCallback$$Interface {

(entity: $LivingEntity, level: integer): void
}

export class $MobEffectBuilder$EffectEntityCallback implements $MobEffectBuilder$EffectEntityCallback$$Interface {
 "applyEffectTick"(entity: $LivingEntity$$Type, level: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectBuilder$EffectEntityCallback$$Type = ((entity: $LivingEntity, level: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobEffectBuilder$EffectEntityCallback$$Original = $MobEffectBuilder$EffectEntityCallback;}
declare module "dev.latvian.mods.kubejs.entity.LivingEntityDeathKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before a living entity dies.
 * 
 * **NOTE**: You need to set hp to > 0 besides cancelling the event to prevent the entity from dying.
 */
export class $LivingEntityDeathKubeEvent implements $KubeLivingEntityEvent$$Interface {
constructor(entity: $LivingEntity$$Type, source: $DamageSource$$Type)

/**
 * The damage source that triggers the death.
 */
public "getSource"(): $DamageSource
/**
 * The entity that dies.
 */
public "getEntity"(): $Entity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "source"(): $DamageSource
get "entity"(): $Entity
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityDeathKubeEvent$$Type = ($LivingEntityDeathKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LivingEntityDeathKubeEvent$$Original = $LivingEntityDeathKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.RecipeLikeKJS" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeSchema} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeLikeKJS$$Interface {
get "typeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
get "serializer"(): $RecipeSerializer<(never)>
get "group"(): StringJS
set "group"(value: StringJS)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "mod"(): StringJS
get "type"(): $ResourceLocation
}

export class $RecipeLikeKJS implements $RecipeLikeKJS$$Interface {
 "getTypeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
 "getSerializer"(): $RecipeSerializer<(never)>
 "getGroup"(): StringJS
 "setGroup"(group: StringJS): void
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getMod"(): StringJS
 "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "getType"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeLikeKJS$$Type = ($RecipeLikeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeLikeKJS$$Original = $RecipeLikeKJS;}
declare module "dev.latvian.mods.kubejs.stages.Stages" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Collection, $Collection$$Type} from "java.util.Collection"

export interface $Stages$$Interface {
get "all"(): $Collection<(StringJS)>
get "player"(): $Player
}

export class $Stages implements $Stages$$Interface {
 "toggle"(stage: StringJS): boolean
 "addNoUpdate"(stage: StringJS): boolean
 "removeNoUpdate"(stage: StringJS): boolean
 "getAll"(): $Collection<(StringJS)>
 "has"(stage: StringJS): boolean
 "remove"(stage: StringJS): boolean
 "clear"(): boolean
 "replace"(stages: $Collection$$Type<(StringJS)>): void
 "add"(stage: StringJS): boolean
 "set"(stage: StringJS, enabled: boolean): boolean
 "sync"(): void
 "getPlayer"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Stages$$Type = ($Stages);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Stages$$Original = $Stages;}
declare module "dev.latvian.mods.kubejs.util.CountingMap" {
import {$Collection} from "java.util.Collection"
import {$Object2LongEntry, $Object2LongEntry$$Type} from "dev.latvian.mods.kubejs.util.Object2LongEntry"
import {$List} from "java.util.List"
import {$Set} from "java.util.Set"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $CountingMap {
constructor()

public "getValues"(): $Collection<(long)>
public "getKeys"(): $Set<(any)>
public "get"(key: any): long
public "clear"(): void
public "add"(key: any, value: long): long
public "set"(key: any, value: long): long
public "forEach"(forEach: $Consumer$$Type<($Object2LongEntry)>): void
public "getSize"(): integer
public "getEntries"(): $List<($Object2LongEntry)>
public "getTotalCount"(): long
get "values"(): $Collection<(long)>
get "keys"(): $Set<(any)>
get "size"(): integer
get "entries"(): $List<($Object2LongEntry)>
get "totalCount"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CountingMap$$Type = ($CountingMap);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CountingMap$$Original = $CountingMap;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$UseCallback" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"

export interface $ItemBuilder$UseCallback$$Interface {

(level: $Level, player: $Player, interactionHand: $InteractionHand): boolean
}

export class $ItemBuilder$UseCallback implements $ItemBuilder$UseCallback$$Interface {
 "use"(level: $Level$$Type, player: $Player$$Type, interactionHand: $InteractionHand$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$UseCallback$$Type = ((level: $Level, player: $Player, interactionHand: $InteractionHand) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$UseCallback$$Original = $ItemBuilder$UseCallback;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$HighlightRenderer$$Type} from "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntitySelector$$Type} from "net.minecraft.commands.arguments.selector.EntitySelector"
import {$ClientPlayerKubeEvent} from "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

/**
 * Invoked when block and entity highlight is rendered.
 */
export class $HighlightKubeEvent extends $ClientPlayerKubeEvent {
constructor(mc: $Minecraft$$Type, renderer: $HighlightRenderer$$Type)

public "addEntities"(selector: $EntitySelector$$Type, color: $KubeColor$$Type): void
public "addBlock"(pos: $BlockPos$$Type, color: $KubeColor$$Type): void
public "addBlocks"(from: $BlockPos$$Type, to: $BlockPos$$Type, color: $KubeColor$$Type): void
public "addTargetBlock"(color: $KubeColor$$Type): void
public "addEntitiesByType"(type: $EntityType$$Type<(never)>, color: $KubeColor$$Type): void
public "addTargetEntity"(color: $KubeColor$$Type): void
public "getTargetEntity"(): $Entity
public "getTargetBlock"(): $LevelBlock
public "addEntity"(entity: $Entity$$Type, color: $KubeColor$$Type): void
public "getClient"(): $Minecraft
public "addTarget"(color: $KubeColor$$Type): void
public "getEntity"(): $Player
get "targetEntity"(): $Entity
get "targetBlock"(): $LevelBlock
get "client"(): $Minecraft
get "entity"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightKubeEvent$$Type = ($HighlightKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightKubeEvent$$Original = $HighlightKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents" {
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$LinkedList} from "java.util.LinkedList"
import {$AtomicInteger} from "java.util.concurrent.atomic.AtomicInteger"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

export class $ScheduledEvents {
 "currentTick": long
readonly "factory": $Supplier<($ScheduledEvents$ScheduledEvent)>
readonly "nextId": $AtomicInteger
 "currentMillis": long
readonly "events": $LinkedList<($ScheduledEvents$ScheduledEvent)>
readonly "futureEvents": $LinkedList<($ScheduledEvents$ScheduledEvent)>

constructor(factory: $Supplier$$Type<($ScheduledEvents$ScheduledEvent$$Type)>)

public "clear"(id: integer): void
public "schedule"(timer: $TemporalAmount$$Type, repeating: boolean, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
public "schedule"(timer: long, ofTicks: boolean, repeating: boolean, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
public "tickAll"(nowTicks: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$$Type = ($ScheduledEvents);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduledEvents$$Original = $ScheduledEvents;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockPredicate" {
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"

export interface $BlockPredicate$$Interface {

(block: $LevelBlock): boolean
}

export class $BlockPredicate implements $BlockPredicate$$Interface {
 "check"(block: $LevelBlock$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPredicate$$Type = ((block: $LevelBlock) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPredicate$$Original = $BlockPredicate;}
declare module "dev.latvian.mods.kubejs.script.data.VirtualResourcePack" {
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$ExportablePackResources$$Interface} from "dev.latvian.mods.kubejs.script.data.ExportablePackResources"
import {$MetadataSectionSerializer$$Type} from "net.minecraft.server.packs.metadata.MetadataSectionSerializer"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$GeneratedDataStage, $GeneratedDataStage$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$IoSupplier} from "net.minecraft.server.packs.resources.IoSupplier"
import {$Component} from "net.minecraft.network.chat.Component"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PackType, $PackType$$Type} from "net.minecraft.server.packs.PackType"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$PackResources$ResourceOutput$$Type} from "net.minecraft.server.packs.PackResources$ResourceOutput"
import {$Set} from "java.util.Set"
import {$InputStream} from "java.io.InputStream"
import {$Path$$Type} from "java.nio.file.Path"
import {$AbstractPackResources} from "net.minecraft.server.packs.AbstractPackResources"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualResourcePack extends $AbstractPackResources implements $KubeResourceGenerator$$Interface, $ExportablePackResources$$Interface {
readonly "component": $Component
readonly "stage": $GeneratedDataStage
readonly "scriptType": $ScriptType
readonly "packType": $PackType
readonly "registries": $Supplier<($RegistryAccessContainer)>
readonly "info": StringJS

constructor(scriptType: $ScriptType$$Type, packType: $PackType$$Type, stage: $GeneratedDataStage$$Type, registries: $Supplier$$Type<($RegistryAccessContainer$$Type)>)

public "export"(root: $Path$$Type): void
public "reset"(): void
public "toString"(): StringJS
public "add"(data: $GeneratedData$$Type): void
public "getResource"(type: $PackType$$Type, location: $ResourceLocation$$Type): $IoSupplier<($InputStream)>
public "close"(): void
public "listResources"(packType: $PackType$$Type, namespace: StringJS, path: StringJS, visitor: $PackResources$ResourceOutput$$Type): void
public "getNamespaces"(type: $PackType$$Type): $Set<(StringJS)>
public "getRegistries"(): $RegistryAccessContainer
public "getRootResource"(...path: (StringJS)[]): $IoSupplier<($InputStream)>
public "getMetadataSection"<T>(serializer: $MetadataSectionSerializer$$Type<(T)>): T
public "packId"(): StringJS
public "exportPath"(): StringJS
public "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
public "flush"(): void
public "text"(id: $ResourceLocation$$Type, content: StringJS): void
public "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualResourcePack$$Type = ($VirtualResourcePack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VirtualResourcePack$$Original = $VirtualResourcePack;}
declare module "dev.latvian.mods.kubejs.block.custom.StairBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $StairBlockBuilder extends $ShapedBlockBuilder {
static readonly "STAIR_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StairBlockBuilder$$Type = ($StairBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StairBlockBuilder$$Original = $StairBlockBuilder;}
declare module "dev.latvian.mods.kubejs.script.ScriptFileInfo" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$ScriptPackInfo, $ScriptPackInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptPackInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptFileInfo {
readonly "path": $Path
readonly "file": StringJS
readonly "location": StringJS
readonly "id": $ResourceLocation
readonly "pack": $ScriptPackInfo
readonly "locationPath": StringJS

constructor(p: $ScriptPackInfo$$Type, ph: $Path$$Type, f: StringJS)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptFileInfo$$Type = ($ScriptFileInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptFileInfo$$Original = $ScriptFileInfo;}
declare module "dev.latvian.mods.kubejs.block.custom.CarpetBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $CarpetBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "CARPET_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarpetBlockBuilder$$Type = ($CarpetBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarpetBlockBuilder$$Original = $CarpetBlockBuilder;}
declare module "dev.latvian.mods.kubejs.block.RandomTickKubeEvent" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $RandomTickKubeEvent implements $KubeLevelEvent$$Interface {
readonly "random": $RandomSource

constructor(level: $ServerLevel$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, random: $RandomSource$$Type)

public "getBlock"(): $LevelBlock
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "block"(): $LevelBlock
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomTickKubeEvent$$Type = ($RandomTickKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomTickKubeEvent$$Original = $RandomTickKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper$Data" {
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $DataMapWrapper$Data<T, A> extends $Record {
constructor(element: T, data: A)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "data"(): A
public "element"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataMapWrapper$Data$$Type<T, A> = ({"element"?: T, "data"?: A}) | ([element?: T, data?: A]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataMapWrapper$Data$$Original<T, A> = $DataMapWrapper$Data<(T), (A)>;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$AnimalArmor" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$AnimalArmorItem$BodyType$$Type} from "net.minecraft.world.item.AnimalArmorItem$BodyType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorItemBuilder$AnimalArmor extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

public "bodyType"(type: $AnimalArmorItem$BodyType$$Type): this
public "overlay"(o: boolean): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$AnimalArmor$$Type = ($ArmorItemBuilder$AnimalArmor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$AnimalArmor$$Original = $ArmorItemBuilder$AnimalArmor;}
declare module "dev.latvian.mods.kubejs.fluid.FluidWrapper$ReadFn" {
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$StringReader, $StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$DataResult, $DataResult$$Type} from "com.mojang.serialization.DataResult"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"

export interface $FluidWrapper$ReadFn$$Interface<T> {

(registryOps: $DynamicOps<($Tag)>, reader: $StringReader): $DataResult$$Type<(T)>
}

export class $FluidWrapper$ReadFn<T> implements $FluidWrapper$ReadFn$$Interface {
 "read"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidWrapper$ReadFn$$Type<T> = ((registryOps: $DynamicOps<($Tag)>, reader: $StringReader) => $DataResult$$Type<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidWrapper$ReadFn$$Original<T> = $FluidWrapper$ReadFn<(T)>;}
declare module "dev.latvian.mods.kubejs.core.BlockBehaviourKJS" {
import {$Map} from "java.util.Map"
import {$List} from "java.util.List"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Holder} from "net.minecraft.core.Holder"
import {$BlockProviderKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockProviderKJS"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockBehaviourKJS$$Interface extends $BlockProviderKJS$$Interface {

(): $Block$$Type
set "hasCollision"(value: boolean)
set "explosionResistance"(value: float)
set "isRandomlyTicking"(value: boolean)
set "randomTickCallback"(value: $Consumer$$Type<($RandomTickCallback)>)
set "soundType"(value: $SoundType$$Type)
set "friction"(value: float)
set "speedFactor"(value: float)
set "jumpFactor"(value: float)
get "typeData"(): $Map<(StringJS), (any)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "key"(): $ResourceKey<($Block)>
get "id"(): StringJS
get "block"(): $Block
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockBehaviourKJS implements $BlockBehaviourKJS$$Interface {
 "setHasCollision"(v: boolean): void
 "setExplosionResistance"(v: float): void
 "setIsRandomlyTicking"(v: boolean): void
 "setRandomTickCallback"(callback: $Consumer$$Type<($RandomTickCallback)>): void
 "setSoundType"(v: $SoundType$$Type): void
 "setFriction"(v: float): void
 "setSpeedFactor"(v: float): void
 "setJumpFactor"(v: float): void
 "getTypeData"(): $Map<(StringJS), (any)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getRegistry"(): $Registry<($Block)>
 "asHolder"(): $Holder<($Block)>
 "getKey"(): $ResourceKey<($Block)>
 "getId"(): StringJS
 "getBlock"(): $Block
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviourKJS$$Type = (() => $Block$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviourKJS$$Original = $BlockBehaviourKJS;}
declare module "dev.latvian.mods.kubejs.entity.LivingEntityDropsKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$List} from "java.util.List"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingDropsEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDropsEvent"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$ItemEntity} from "net.minecraft.world.entity.item.ItemEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $LivingEntityDropsKubeEvent implements $KubeLivingEntityEvent$$Interface {
 "eventDrops": $List<($ItemEntity)>

constructor(e: $LivingDropsEvent$$Type)

public "getDrops"(): $List<($ItemEntity)>
public "isRecentlyHit"(): boolean
public "addDrop"(stack: $ItemStack$$Type): $ItemEntity
public "addDrop"(stack: $ItemStack$$Type, chance: float): $ItemEntity
public "getSource"(): $DamageSource
public "getEntity"(): $Entity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "drops"(): $List<($ItemEntity)>
get "recentlyHit"(): boolean
get "source"(): $DamageSource
get "entity"(): $Entity
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityDropsKubeEvent$$Type = ($LivingEntityDropsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LivingEntityDropsKubeEvent$$Original = $LivingEntityDropsKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.PlatformWrapper" {
import {$Map} from "java.util.Map"
import {$Set} from "java.util.Set"
import {$PlatformWrapper$ModInfo} from "dev.latvian.mods.kubejs.script.PlatformWrapper$ModInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PlatformWrapper {
constructor()

public static "breakpoint"(...args: (any)[]): void
public static "setModName"(modId: StringJS, name: StringJS): void
public static "getMcVersion"(): StringJS
public static "getMinecraftVersionString"(): StringJS
public static "getCurrentThreadName"(): StringJS
public static "getPackMode"(): StringJS
public static "isGeneratingData"(): boolean
/**
 * 
 * @deprecated
 */
public static "isForge"(): boolean
public static "getInfo"(modID: StringJS): $PlatformWrapper$ModInfo
/**
 * 
 * @deprecated
 */
public static "getName"(): StringJS
public static "isLoaded"(modId: StringJS): boolean
public static "getList"(): $Set<(StringJS)>
public static "getMods"(): $Map<(StringJS), ($PlatformWrapper$ModInfo)>
/**
 * 
 * @deprecated
 */
public static "isFabric"(): boolean
public static "isDevelopmentEnvironment"(): boolean
public static "getModVersion"(): StringJS
public static "isClientEnvironment"(): boolean
public static "getMinecraftVersion"(): integer
public static get "mcVersion"(): StringJS
public static get "minecraftVersionString"(): StringJS
public static get "currentThreadName"(): StringJS
public static get "packMode"(): StringJS
public static get "generatingData"(): boolean
public static get "forge"(): boolean
public static get "name"(): StringJS
public static get "list"(): $Set<(StringJS)>
public static get "mods"(): $Map<(StringJS), ($PlatformWrapper$ModInfo)>
public static get "fabric"(): boolean
public static get "developmentEnvironment"(): boolean
public static get "modVersion"(): StringJS
public static get "clientEnvironment"(): boolean
public static get "minecraftVersion"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformWrapper$$Type = ($PlatformWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlatformWrapper$$Original = $PlatformWrapper;}
declare module "dev.latvian.mods.kubejs.util.WrappedJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $WrappedJS$$Interface {
}

export class $WrappedJS implements $WrappedJS$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedJS$$Type = ($WrappedJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WrappedJS$$Original = $WrappedJS;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$CreativeTabCallback$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabCallback"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CreativeModeTab, $CreativeModeTab$$Type} from "net.minecraft.world.item.CreativeModeTab"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$CreativeModeTab$TabVisibility$$Type} from "net.minecraft.world.item.CreativeModeTab$TabVisibility"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

export class $CreativeTabKubeEvent implements $KubeEvent$$Interface {
readonly "tab": $CreativeModeTab
readonly "showRestrictedItems": boolean

constructor(tab: $CreativeModeTab$$Type, showRestrictedItems: boolean, callback: $CreativeTabCallback$$Type)

public "addAfter"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[]): void
public "addAfter"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
public "removeFromParent"(filter: $ItemPredicate$$Type): void
public "removeFromSearch"(filter: $ItemPredicate$$Type): void
public "addBefore"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[]): void
public "addBefore"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
public "remove"(filter: $ItemPredicate$$Type): void
public "add"(items: ($ItemStack$$Type)[]): void
public "add"(items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
public "setIcon"(icon: $ItemStack$$Type): void
public "setDisplayName"(component: $Component$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
set "icon"(value: $ItemStack$$Type)
set "displayName"(value: $Component$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabKubeEvent$$Type = ($CreativeTabKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabKubeEvent$$Original = $CreativeTabKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemCraftedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Container$$Type} from "net.minecraft.world.Container"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player crafts an item.
 */
export class $ItemCraftedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, crafted: $ItemStack$$Type, container: $Container$$Type)

/**
 * The item that was crafted.
 */
public "getItem"(): $ItemStack
/**
 * The player that crafted the item.
 */
public "getEntity"(): $LivingEntity
/**
 * The inventory that the item was crafted in.
 */
public "getInventory"(): $InventoryKJS
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "inventory"(): $InventoryKJS
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemCraftedKubeEvent$$Type = ($ItemCraftedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemCraftedKubeEvent$$Original = $ItemCraftedKubeEvent;}
declare module "dev.latvian.mods.kubejs.server.CommandKubeEvent" {
import {$ParseResults, $ParseResults$$Type} from "com.mojang.brigadier.ParseResults"
import {$CommandEvent$$Type} from "net.neoforged.neoforge.event.CommandEvent"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$ServerKubeEvent} from "dev.latvian.mods.kubejs.server.ServerKubeEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$CommandSourceStack, $CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"

export class $CommandKubeEvent extends $ServerKubeEvent {
readonly "server": $MinecraftServer

constructor(event: $CommandEvent$$Type)

public "setParseResults"(parse: $ParseResults$$Type<($CommandSourceStack$$Type)>): void
public "getParseResults"(): $ParseResults<($CommandSourceStack)>
public "getCommandName"(): StringJS
public "getInput"(): StringJS
public "setException"(exception: $Throwable$$Type): void
public "getException"(): $Throwable
set "parseResults"(value: $ParseResults$$Type<($CommandSourceStack$$Type)>)
get "parseResults"(): $ParseResults<($CommandSourceStack)>
get "commandName"(): StringJS
get "input"(): StringJS
set "exception"(value: $Throwable$$Type)
get "exception"(): $Throwable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandKubeEvent$$Type = ($CommandKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandKubeEvent$$Original = $CommandKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.entity.EnergyStorageAttachment$Factory" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $EnergyStorageAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(capacity: integer, maxReceive: (integer)?, maxExtract: (integer)?, autoOutput: (integer)?)

public "autoOutput"(): $Optional<(integer)>
public "isTicking"(): boolean
public "maxExtract"(): $Optional<(integer)>
public "maxReceive"(): $Optional<(integer)>
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "capacity"(): integer
get "ticking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyStorageAttachment$Factory$$Type = ({"maxReceive"?: (integer)?, "autoOutput"?: (integer)?, "capacity"?: integer, "maxExtract"?: (integer)?}) | ([maxReceive?: (integer)?, autoOutput?: (integer)?, capacity?: integer, maxExtract?: (integer)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnergyStorageAttachment$Factory$$Original = $EnergyStorageAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.player.EntityArrayList" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ArrayList} from "java.util.ArrayList"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection$$Type} from "java.util.Collection"
import {$SequencedCollection} from "java.util.SequencedCollection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntitySelector$$Type} from "net.minecraft.commands.arguments.selector.EntitySelector"
import {$DataSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $EntityArrayList extends $ArrayList<($Entity)> implements $MessageSenderKJS$$Interface, $DataSenderKJS$$Interface {
static readonly "ALWAYS_TRUE_PREDICATE": $Predicate<($Entity)>

constructor(entities: $Iterable$$Type<($Entity$$Type)>)
/**
 * 
 * @deprecated
 */
constructor(level: $Level$$Type, entities: $Iterable$$Type<($Entity$$Type)>)
constructor(size: integer)

public "addAllIterable"(entities: $Iterable$$Type<($Entity$$Type)>): void
public "filterDistance"(x: double, y: double, z: double, distance: double): $EntityArrayList
public "filterDistance"(pos: $BlockPos$$Type, distance: double): $EntityArrayList
public "oneFilter"(filter: $Predicate$$Type<($Entity)>): $EntityArrayList
public "filterSelector"(selector: $EntitySelector$$Type): $EntityArrayList
public "filterPlayers"(): $EntityArrayList
public "filterItems"(): $EntityArrayList
public "filterType"(type: $EntityType$$Type<(never)>): $EntityArrayList
public "kill"(): void
public "filter"(filterList: $List$$Type<($Predicate$$Type<($Entity$$Type)>)>): $EntityArrayList
public "getFirst"(): any
public "tell"(message: $Component$$Type): void
public "setStatusMessage"(message: $Component$$Type): void
public "runCommand"(command: StringJS): void
public "runCommandSilent"(command: StringJS): void
public "setActivePostShader"(id: $ResourceLocation$$Type): void
public "getName"(): $Component
public "getDisplayName"(): $Component
public "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
public "playSound"(id: $SoundEvent$$Type): void
public "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
public "sendData"(channel: StringJS): void
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public "reversed"(): $SequencedCollection
public "containsAll"(arg0: $Collection$$Type<(never)>): boolean
get "first"(): any
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityArrayList$$Type = ($EntityArrayList);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityArrayList$$Original = $EntityArrayList;}
declare module "dev.latvian.mods.kubejs.client.AtlasSpriteRegistryKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $AtlasSpriteRegistryKubeEvent implements $KubeEvent$$Interface {
constructor(registry: $Consumer$$Type<($ResourceLocation)>)

public "register"(id: $ResourceLocation$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtlasSpriteRegistryKubeEvent$$Type = ($AtlasSpriteRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AtlasSpriteRegistryKubeEvent$$Original = $AtlasSpriteRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$CustomObjectRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$RecipeComponent, $RecipeComponent$$Type, $RecipeComponent$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$ListRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record} from "java.lang.Record"

export class $EitherRecipeComponent<H, L> extends $Record implements $RecipeComponent$$Interface<($Either<(H), (L)>)> {
static readonly "TYPE": $RecipeComponentType<(never)>

constructor(left: $RecipeComponent$$Type<(H)>, right: $RecipeComponent$$Type<(L)>)
constructor(left: $RecipeComponent$$Type<(H)>, right: $RecipeComponent$$Type<(L)>, codec: $Codec$$Type<($Either$$Type<(H), (L)>)>, typeInfo: $TypeInfo$$Type)

public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: $Either$$Type<(H), (L)>): void
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: any): void
public "type"(): $RecipeComponentType<(never)>
public "equals"(o: any): boolean
public "toString"(ops: $OpsContainer$$Type, value: $Either$$Type<(H), (L)>): StringJS
public "toString"(ops: $OpsContainer$$Type, value: any): StringJS
public "toString"(): StringJS
public "hashCode"(): integer
public "wrap"(cx: $RecipeScriptContext$$Type, from: any): any
public "replace"(cx: $RecipeScriptContext$$Type, original: any, match: $ReplacementMatchInfo$$Type, arg3: any): any
public "replace"(cx: $RecipeScriptContext$$Type, original: $Either$$Type<(H), (L)>, match: $ReplacementMatchInfo$$Type, arg3: any): $Either<(H), (L)>
public "matches"(cx: $RecipeMatchContext$$Type, value: $Either$$Type<(H), (L)>, match: $ReplacementMatchInfo$$Type): boolean
public "matches"(cx: $RecipeMatchContext$$Type, value: any, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, value: $Either$$Type<(H), (L)>): void
public "validate"(ctx: $RecipeValidationContext$$Type, value: any): void
public "typeInfo"(): $TypeInfo
public "spread"(value: $Either$$Type<(H), (L)>): $List<(never)>
public "spread"(value: any): $List
public "left"(): $RecipeComponent<(H)>
public "right"(): $RecipeComponent<(L)>
public "codec"(): $Codec<($Either<(H), (L)>)>
public "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($Either$$Type<(H), (L)>)>, json: $JsonObject$$Type): void
public "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($Either$$Type<(H), (L)>)>, json: $JsonObject$$Type): void
public "orSelf"(): $RecipeComponent<($Either<(H), (L)>)>
public "outputKey"(name: StringJS): $RecipeKey<($Either<(H), (L)>)>
public "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
public "asListOrSelf"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "asConditionalList"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "asConditionalListOrSelf"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($Either<(H), (L)>)>)>
public "withCodec"(codec: $Codec$$Type<($Either$$Type<(H), (L)>)>): $RecipeComponent<($Either<(H), (L)>)>
public "allowEmpty"(): boolean
public "inputKey"(name: StringJS): $RecipeKey<($Either<(H), (L)>)>
public "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($Either<(H), (L)>), (O)>
public "isIgnored"(): boolean
public "isEmpty"(value: $Either$$Type<(H), (L)>): boolean
public static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
public static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<($Either<(H), (L)>)>
public "asList"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "createBuilder"(): $RecipeComponentBuilder
public "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($Either<(H), (L)>)>)>
public "otherKey"(name: StringJS): $RecipeKey<($Either<(H), (L)>)>
get "ignored"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EitherRecipeComponent$$Type<H, L> = ({"codec"?: $Codec$$Type<($Either$$Type<(H), (L)>)>, "left"?: $RecipeComponent$$Type<(H)>, "typeInfo"?: $TypeInfo$$Type, "right"?: $RecipeComponent$$Type<(L)>}) | ([codec?: $Codec$$Type<($Either$$Type<(H), (L)>)>, left?: $RecipeComponent$$Type<(H)>, typeInfo?: $TypeInfo$$Type, right?: $RecipeComponent$$Type<(L)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EitherRecipeComponent$$Original<H, L> = $EitherRecipeComponent<(H), (L)>;}
declare module "dev.latvian.mods.kubejs.core.BlockStateKJS" {
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$List} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder} from "net.minecraft.core.Holder"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockStateKJS$$Interface extends $RegistryObjectKJS$$Interface<($Block)>, $Replaceable$$Interface {
set "destroySpeed"(value: float)
set "lightEmission"(value: integer)
set "requiresTool"(value: boolean)
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "key"(): $ResourceKey<($Block)>
get "id"(): StringJS
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockStateKJS implements $BlockStateKJS$$Interface {
 "setDestroySpeed"(v: float): void
 "setLightEmission"(v: integer): void
 "setRequiresTool"(v: boolean): void
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getRegistry"(): $Registry<($Block)>
 "asHolder"(): $Holder<($Block)>
 "randomTickOverride"(state: $BlockState$$Type, level: $ServerLevel$$Type, pos: $BlockPos$$Type, random: $RandomSource$$Type): boolean
 "getWebIconURL"(size: integer): $RelativeURL
 "toString"(): StringJS
 "getKey"(): $ResourceKey<($Block)>
 "getId"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateKJS$$Type = ($BlockStateKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateKJS$$Original = $BlockStateKJS;}
declare module "dev.latvian.mods.kubejs.block.custom.FenceGateBlockBuilder" {
import {$WoodType$$Type} from "net.minecraft.world.level.block.state.properties.WoodType"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $FenceGateBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "FENCE_GATE_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "behaviour"(wt: StringJS): this
public "behaviour"(wt: $WoodType$$Type): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceGateBlockBuilder$$Type = ($FenceGateBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FenceGateBlockBuilder$$Original = $FenceGateBlockBuilder;}
declare module "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LocalPlayer, $LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $ClientPlayerKubeEvent implements $KubePlayerEvent$$Interface, $ClientKubeEvent$$Interface {
constructor(player: $LocalPlayer$$Type)

public "getEntity"(): $Player
public "getPlayer"(): $LocalPlayer
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
get "entity"(): $Player
get "player"(): $LocalPlayer
get "client"(): $Minecraft
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerKubeEvent$$Type = ($ClientPlayerKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientPlayerKubeEvent$$Original = $ClientPlayerKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.CreativeModeTabKJS" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $CreativeModeTabKJS$$Interface {
}

export class $CreativeModeTabKJS implements $CreativeModeTabKJS$$Interface {
 "kjs$setDisplayName"(component: $Component$$Type): void
 "kjs$setIcon"(icon: $ItemStack$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeModeTabKJS$$Type = ($CreativeModeTabKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeModeTabKJS$$Original = $CreativeModeTabKJS;}
declare module "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EntitySteppedOnBlockCallback {
constructor(level: $Level$$Type, entity: $Entity$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

/**
 * Returns the block
 */
public "getBlock"(): $LevelBlock
/**
 * Returns the level
 */
public "getLevel"(): $Level
/**
 * Returns the entity
 */
public "getEntity"(): $Entity
/**
 * Returns the BlockState
 */
public "getState"(): $BlockState
/**
 * Returns if the entity is suppressing bouncing (for players this is true if the player is crouching)
 */
public "isSuppressingBounce"(): boolean
/**
 * Returns the block's position
 */
public "getPos"(): $BlockPos
get "block"(): $LevelBlock
get "level"(): $Level
get "entity"(): $Entity
get "state"(): $BlockState
get "suppressingBounce"(): boolean
get "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySteppedOnBlockCallback$$Type = ($EntitySteppedOnBlockCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySteppedOnBlockCallback$$Original = $EntitySteppedOnBlockCallback;}
declare module "dev.latvian.mods.kubejs.block.DetectorBlockKubeEvent" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a detector block registered in KubeJS receives a block update.
 * 
 * `Powered`/`Unpowered` event will be fired when the detector block is powered/unpowered.
 */
export class $DetectorBlockKubeEvent implements $KubeLevelEvent$$Interface {
constructor(i: StringJS, l: $Level$$Type, p: $BlockPos$$Type, pow: boolean)

/**
 * If the detector block is powered.
 */
public "isPowered"(): boolean
/**
 * The id of the detector block when it was registered.
 */
public "getDetectorId"(): StringJS
/**
 * The detector block.
 */
public "getBlock"(): $LevelBlock
/**
 * The level where the detector block is located.
 */
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "powered"(): boolean
get "detectorId"(): StringJS
get "block"(): $LevelBlock
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlockKubeEvent$$Type = ($DetectorBlockKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DetectorBlockKubeEvent$$Original = $DetectorBlockKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.DebugInfoKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$List, $List$$Type} from "java.util.List"
import {$ClientPlayerKubeEvent} from "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent"

/**
 * Invoked when the debug info is rendered.
 */
export class $DebugInfoKubeEvent extends $ClientPlayerKubeEvent {
constructor(player: $LocalPlayer$$Type, l: $List$$Type<(StringJS)>)

/**
 * Whether the debug info should be rendered.
 */
public "getShowDebug"(): boolean
/**
 * The lines of debug info. Mutating this list will change the debug info.
 */
public "getLines"(): $List<(StringJS)>
public "getEntity"(): $Player
get "showDebug"(): boolean
get "lines"(): $List<(StringJS)>
get "entity"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DebugInfoKubeEvent$$Type = ($DebugInfoKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DebugInfoKubeEvent$$Original = $DebugInfoKubeEvent;}
declare module "dev.latvian.mods.kubejs.event.EventTargetType$Transformer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $EventTargetType$Transformer$$Interface {

(source: any): any
}

export class $EventTargetType$Transformer implements $EventTargetType$Transformer$$Interface {
static readonly "IDENTITY": $EventTargetType$Transformer

 "transform"(source: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventTargetType$Transformer$$Type = ((source: any) => any);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventTargetType$Transformer$$Original = $EventTargetType$Transformer;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$RegistryOps$$Type} from "net.minecraft.resources.RegistryOps"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$KubeRecipeFactory, $KubeRecipeFactory$$Type} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RecipePostProcessor, $RecipePostProcessor$$Type} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$RecipeConstructor, $RecipeConstructor$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeConstructor"
import {$RecipeFunctionInstance, $RecipeFunctionInstance$$Type} from "dev.latvian.mods.kubejs.recipe.schema.function.RecipeFunctionInstance"
import {$RecipeOptional, $RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Int2ObjectMap} from "it.unimi.dsi.fastutil.ints.Int2ObjectMap"

export class $RecipeSchema {
readonly "functions": $Map<(StringJS), ($RecipeFunctionInstance)>
 "recipeFactory": $KubeRecipeFactory
readonly "keys": $List<($RecipeKey<(never)>)>
readonly "keyOverrides": $Map<($RecipeKey<(never)>), ($RecipeOptional<(never)>)>
readonly "includedKeys": $List<($RecipeKey<(never)>)>

constructor(...keys: ($RecipeKey$$Type<(never)>)[])
constructor(keyOverrides: $Map$$Type<($RecipeKey$$Type<(never)>), ($RecipeOptional$$Type<(never)>)>, keys: $List$$Type<($RecipeKey$$Type<(never)>)>)

public "minRequiredArguments"(): integer
public "uniqueIds"(): $List<($RecipeKey<(never)>)>
public "uniqueIds"(keys: $SequencedCollection$$Type<($RecipeKey$$Type<(never)>)>): $RecipeSchema
public "constructorsGenerated"(): boolean
public "getOptionalKey"<T>(id: StringJS): $RecipeKey<(T)>
public "setOpFunction"<T>(name: StringJS, key: $RecipeKey$$Type<(T)>, value: T): $RecipeSchema
public "addToListOpFunction"<T>(name: StringJS, key: $RecipeKey$$Type<($List$$Type<(T)>)>): $RecipeSchema
public "typeOverride"(id: $ResourceLocation$$Type): $RecipeSchema
public "buildUniqueId"(r: $KubeRecipe$$Type): StringJS
public "inputCount"(): integer
public "postProcessors"(): $List<($RecipePostProcessor)>
public "outputCount"(): integer
public "isHidden"(): boolean
public "getKey"<T>(id: StringJS): $RecipeKey<(T)>
public "factory"(factory: $KubeRecipeFactory$$Type): $RecipeSchema
public "constructor"(arg0: $RecipeConstructor$$Type): $RecipeSchema
public "addConstructor"(...keys: ($RecipeKey$$Type<(never)>)[]): $RecipeSchema
public "constructors"(): $Int2ObjectMap<($RecipeConstructor)>
public "function"(arg0: $RecipeFunctionInstance$$Type): $RecipeSchema
public "deserialize"(sourceLine: $SourceLine$$Type, type: $RecipeTypeFunction$$Type, id: $ResourceLocation$$Type, json: $JsonObject$$Type): $KubeRecipe
public "toJson"(storage: $RecipeSchemaStorage$$Type, schemaType: $RecipeSchemaType$$Type, ops: $RegistryOps$$Type<($JsonElement$$Type)>): $JsonObject
public "uniqueId"(key: $RecipeKey$$Type<(never)>): $RecipeSchema
public "postProcessor"(processor: $RecipePostProcessor$$Type): $RecipeSchema
get "hidden"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchema$$Type = ($RecipeSchema);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchema$$Original = $RecipeSchema;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$ShaderChain" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PostChain, $PostChain$$Type} from "net.minecraft.client.renderer.PostChain"
import {$Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$MutableBoolean, $MutableBoolean$$Type} from "org.apache.commons.lang3.mutable.MutableBoolean"
import {$RenderTarget, $RenderTarget$$Type} from "com.mojang.blaze3d.pipeline.RenderTarget"
import {$Record} from "java.lang.Record"

export class $HighlightRenderer$ShaderChain extends $Record {
constructor(postChain: $PostChain$$Type, renderInput: $RenderTarget$$Type, mcDepthInput: $RenderTarget$$Type, renderOutput: $RenderTarget$$Type, renderAnything: $MutableBoolean$$Type)

public "mcDepthInput"(): $RenderTarget
public "clearInput"(mc: $Minecraft$$Type): void
public "renderInput"(): $RenderTarget
public "renderOutput"(): $RenderTarget
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "load"(mc: $Minecraft$$Type, id: $ResourceLocation$$Type): $HighlightRenderer$ShaderChain
public "close"(): void
public "draw"(mc: $Minecraft$$Type, delta: float): void
public "clearDepth"(mc: $Minecraft$$Type, copy: boolean): void
public "postChain"(): $PostChain
public "renderAnything"(): $MutableBoolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightRenderer$ShaderChain$$Type = ({"renderInput"?: $RenderTarget$$Type, "mcDepthInput"?: $RenderTarget$$Type, "renderOutput"?: $RenderTarget$$Type, "postChain"?: $PostChain$$Type, "renderAnything"?: $MutableBoolean$$Type}) | ([renderInput?: $RenderTarget$$Type, mcDepthInput?: $RenderTarget$$Type, renderOutput?: $RenderTarget$$Type, postChain?: $PostChain$$Type, renderAnything?: $MutableBoolean$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightRenderer$ShaderChain$$Original = $HighlightRenderer$ShaderChain;}
declare module "dev.latvian.mods.kubejs.misc.SoundEventBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$SoundsGenerator$SoundGen$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen"

export class $SoundEventBuilder extends $BuilderBase<($SoundEvent)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "sounds"(gen: $Consumer$$Type<($SoundsGenerator$SoundGen)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundEventBuilder$$Type = ($SoundEventBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundEventBuilder$$Original = $SoundEventBuilder;}
declare module "dev.latvian.mods.kubejs.util.NotificationToastData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$KubeIcon, $KubeIcon$$Type} from "dev.latvian.mods.kubejs.client.icon.KubeIcon"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Duration, $Duration$$Type} from "java.time.Duration"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $NotificationToastData extends $Record {
static readonly "CODEC": $MapCodec<($NotificationToastData)>
static readonly "DEFAULT_BORDER_COLOR": $KubeColor
static readonly "DEFAULT_BACKGROUND_COLOR": $KubeColor
static readonly "DEFAULT_DURATION": $Duration
static readonly "DEFAULT_OUTLINE_COLOR": $KubeColor
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($NotificationToastData)>

constructor(duration: $Duration$$Type, text: $Component$$Type, icon: ($KubeIcon$$Type)?, iconSize: integer, outlineColor: ($KubeColor$$Type)?, borderColor: ($KubeColor$$Type)?, backgroundColor: ($KubeColor$$Type)?, textShadow: boolean)

public "borderColor"(): $Optional<($KubeColor)>
public static "ofText"(text: $Component$$Type): $NotificationToastData
public "backgroundColor"(): $Optional<($KubeColor)>
public "textShadow"(): boolean
public "iconSize"(): integer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "duration"(): $Duration
public "text"(): $Component
public "icon"(): $Optional<($KubeIcon)>
public static "ofTitle"(title: $Component$$Type, text: $Component$$Type): $NotificationToastData
public "outlineColor"(): $Optional<($KubeColor)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotificationToastData$$Type = ({"text"?: $Component$$Type, "textShadow"?: boolean, "outlineColor"?: ($KubeColor$$Type)?, "duration"?: $Duration$$Type, "backgroundColor"?: ($KubeColor$$Type)?, "borderColor"?: ($KubeColor$$Type)?, "icon"?: ($KubeIcon$$Type)?, "iconSize"?: integer}) | ([text?: $Component$$Type, textShadow?: boolean, outlineColor?: ($KubeColor$$Type)?, duration?: $Duration$$Type, backgroundColor?: ($KubeColor$$Type)?, borderColor?: ($KubeColor$$Type)?, icon?: ($KubeIcon$$Type)?, iconSize?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NotificationToastData$$Original = $NotificationToastData;}
declare module "dev.latvian.mods.kubejs.client.MenuScreenRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$RegisterMenuScreensEvent$$Type} from "net.neoforged.neoforge.client.event.RegisterMenuScreensEvent"
import {$MenuScreens$ScreenConstructor$$Type} from "net.minecraft.client.gui.screens.MenuScreens$ScreenConstructor"

export class $MenuScreenRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $RegisterMenuScreensEvent$$Type)

public "register"(type: $MenuType$$Type<(never)>, arg1: $MenuScreens$ScreenConstructor$$Type): void
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MenuScreenRegistryKubeEvent$$Type = ($MenuScreenRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MenuScreenRegistryKubeEvent$$Original = $MenuScreenRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.HolderSetWrapper" {
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Iterator} from "java.util.Iterator"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Spliterator} from "java.util.Spliterator"
import {$List} from "java.util.List"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Set} from "java.util.Set"
import {$Record} from "java.lang.Record"
import {$Consumer$$Type} from "java.util.function.Consumer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $HolderSetWrapper<T> extends $Record implements $Iterable$$Interface<(T)> {
constructor(registry: $Registry$$Type<(T)>, holders: $HolderSet$$Type<(T)>)

public "holders"(): $HolderSet<(T)>
public "getValues"(): $List<(T)>
public "getKeys"(): $Set<($ResourceLocation)>
public "size"(): integer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $Iterator<(T)>
public "contains"(id: $ResourceLocation$$Type): boolean
public "containsValue"(value: T): boolean
public "registry"(): $Registry<(T)>
public "getRandom"(random: $RandomSource$$Type): T
public "getRandom"(): T
public "spliterator"(): $Spliterator<(T)>
public "forEach"(arg0: $Consumer$$Type<(T)>): void
[Symbol.iterator](): IterableIterator<T>;
get "values"(): $List<(T)>
get "keys"(): $Set<($ResourceLocation)>
get "empty"(): boolean
get "random"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolderSetWrapper$$Type<T> = ({"holders"?: $HolderSet$$Type<(T)>, "registry"?: $Registry$$Type<(T)>}) | ([holders?: $HolderSet$$Type<(T)>, registry?: $Registry$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HolderSetWrapper$$Original<T> = $HolderSetWrapper<(T)>;}
declare module "dev.latvian.mods.kubejs.core.RecipeHolderKJS" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeSchema} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeHolder} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RecipeLikeKJS$$Interface} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeHolderKJS$$Interface extends $RecipeLikeKJS$$Interface {
get "typeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
get "serializer"(): $RecipeSerializer<(never)>
get "recipe"(): $Recipe<(never)>
get "group"(): StringJS
set "group"(value: StringJS)
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "mod"(): StringJS
get "type"(): $ResourceLocation
}

export class $RecipeHolderKJS implements $RecipeHolderKJS$$Interface {
 "getTypeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
 "getSerializer"(): $RecipeSerializer<(never)>
 "getRecipe"(): $Recipe<(never)>
 "getGroup"(): StringJS
 "setGroup"(group: StringJS): void
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "self"(): $RecipeHolder<(never)>
 "getMod"(): StringJS
 "getType"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeHolderKJS$$Type = ($RecipeHolderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeHolderKJS$$Original = $RecipeHolderKJS;}
declare module "dev.latvian.mods.kubejs.block.BlockPlacedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$BlockEvent$EntityPlaceEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$EntityPlaceEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a block is placed.
 */
export class $BlockPlacedKubeEvent implements $KubeEntityEvent$$Interface {
constructor(event: $BlockEvent$EntityPlaceEvent$$Type)

/**
 * The block that is placed.
 */
public "getBlock"(): $LevelBlock
/**
 * The level of the block that was placed.
 */
public "getLevel"(): $Level
/**
 * The entity that placed the block. Can be `null`, e.g. when a block is placed by a dispenser.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "block"(): $LevelBlock
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPlacedKubeEvent$$Type = ($BlockPlacedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPlacedKubeEvent$$Original = $BlockPlacedKubeEvent;}
declare module "dev.latvian.mods.kubejs.level.KubeLevelEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubeLevelEvent$$Interface extends $KubeEvent$$Interface {

(): $Level$$Type
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export class $KubeLevelEvent implements $KubeLevelEvent$$Interface {
 "getLevel"(): $Level
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeLevelEvent$$Type = (() => $Level$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeLevelEvent$$Original = $KubeLevelEvent;}
declare module "dev.latvian.mods.kubejs.block.custom.FenceBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $FenceBlockBuilder extends $ShapedBlockBuilder {
static readonly "FENCE_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceBlockBuilder$$Type = ($FenceBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FenceBlockBuilder$$Original = $FenceBlockBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder" {
import {$Pattern} from "java.util.regex.Pattern"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Record} from "java.lang.Record"

export class $UniqueIdBuilder extends $Record {
static readonly "MULTIPLE_UNDERSCORES_PATTERN": $Pattern
static readonly "NON_W_PATTERN": $Pattern

constructor(builder: $StringBuilder$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "append"(string: StringJS): void
public "append"(id: $ResourceLocation$$Type): void
public "append"(key: $ResourceKey$$Type<(never)>): void
public "hashCode"(): integer
public "builder"(): $StringBuilder
public "build"(): StringJS
public "appendSeparator"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniqueIdBuilder$$Type = ({"builder"?: $StringBuilder$$Type}) | ([builder?: $StringBuilder$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UniqueIdBuilder$$Original = $UniqueIdBuilder;}
declare module "dev.latvian.mods.kubejs.player.KubePlayerEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubePlayerEvent$$Interface extends $KubeLivingEntityEvent$$Interface {
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export class $KubePlayerEvent implements $KubePlayerEvent$$Interface {
 "getEntity"(): $Entity
 "getPlayer"(): $Player
 "getLevel"(): $Level
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubePlayerEvent$$Type = ($KubePlayerEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubePlayerEvent$$Original = $KubePlayerEvent;}
declare module "dev.latvian.mods.kubejs.block.callback.RandomTickCallback" {
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Level} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

export class $RandomTickCallback {
readonly "random": $RandomSource
readonly "block": $LevelBlock

constructor(block: $LevelBlock$$Type, random: $RandomSource$$Type)

public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
get "level"(): $Level
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomTickCallback$$Type = ($RandomTickCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomTickCallback$$Original = $RandomTickCallback;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$DataComponentSubtypes" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Record} from "java.lang.Record"

export class $ItemData$DataComponentSubtypes extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$DataComponentSubtypes)>

constructor(filter: $Ingredient$$Type, components: $List$$Type<($DataComponentType$$Type<(never)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Ingredient
public "components"(): $List<($DataComponentType<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$DataComponentSubtypes$$Type = ({"filter"?: $Ingredient$$Type, "components"?: $List$$Type<($DataComponentType$$Type<(never)>)>}) | ([filter?: $Ingredient$$Type, components?: $List$$Type<($DataComponentType$$Type<(never)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$DataComponentSubtypes$$Original = $ItemData$DataComponentSubtypes;}
declare module "dev.latvian.mods.kubejs.core.MinecraftServerKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$EntityCollectionKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityCollectionKJS"
import {$WithAttachedData$$Interface} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$AdvancementNode} from "net.minecraft.advancements.AdvancementNode"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$ScheduledEvents} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$WithPersistentData$$Interface} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MinecraftEnvironmentKJS$$Interface} from "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$ScheduledEvents$ScheduledEvent} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$AttachedData} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$PlayerSelector$$Type} from "dev.latvian.mods.kubejs.core.PlayerSelector"
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$ServerPlayer} from "net.minecraft.server.level.ServerPlayer"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$DataSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MinecraftServerKJS$$Interface extends $WithAttachedData$$Interface<($MinecraftServer)>, $WithPersistentData$$Interface, $DataSenderKJS$$Interface, $MinecraftEnvironmentKJS$$Interface, $EntityCollectionKJS$$Interface {
get "overworld"(): $ServerLevel
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "data"(): $AttachedData<($MinecraftServer)>
get "persistentData"(): $CompoundTag
get "scheduledEvents"(): $ScheduledEvents
get "entities"(): $EntityArrayList
get "displayName"(): $Component
}

export class $MinecraftServerKJS implements $MinecraftServerKJS$$Interface {
 "getAdvancement"(id: $ResourceLocation$$Type): $AdvancementNode
 "restoreInventories"(): $Map<($UUID), ($Map<(integer), ($ItemStack)>)>
 "getPlayer"(selector: $PlayerSelector$$Type): $ServerPlayer
 "getOverworld"(): $ServerLevel
 "self"(): $MinecraftServer
 "tell"(message: $Component$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getName"(): $Component
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "getLevel"(dimension: $ResourceLocation$$Type): $ServerLevel
 "getMcEntities"(): $Iterable<($Entity)>
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getData"(): $AttachedData<($MinecraftServer)>
 "getPersistentData"(): $CompoundTag
 "sendData"(channel: StringJS): void
 "getScheduledEvents"(): $ScheduledEvents
 "schedule"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeating"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeatingInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getEntities"(): $EntityArrayList
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftServerKJS$$Type = ($MinecraftServerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecraftServerKJS$$Original = $MinecraftServerKJS;}
declare module "dev.latvian.mods.kubejs.client.KubeAnimatedParticle" {
import {$ClientLevel, $ClientLevel$$Type} from "net.minecraft.client.multiplayer.ClientLevel"
import {$Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$SpriteSet, $SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$SimpleAnimatedParticle} from "net.minecraft.client.particle.SimpleAnimatedParticle"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $KubeAnimatedParticle extends $SimpleAnimatedParticle {
 "bCol": float
 "gravity": float
 "gCol": float
 "x": double
 "y": double
 "z": double
 "zd": double
 "rCol": float
 "yd": double
 "xd": double
 "age": integer

constructor(level: $ClientLevel$$Type, x: double, y: double, z: double, sprites: $SpriteSet$$Type)

public "onTick"(tick: $Consumer$$Type<($KubeAnimatedParticle)>): void
public "getLightColor"(partialTick: float): integer
/**
 * Sets teh friction of the particle, the particle's motion is multiplied by this value every tick
 */
public "setFriction"(f: float): void
public "getYSpeed"(): double
public "setFasterWhenYMotionBlocked"(b: boolean): void
public "getXSpeed"(): double
public "setPhysicality"(hasPhysics: boolean): void
public "setLightColor"(arg0: $Float2IntFunction$$Type): void
public "getZSpeed"(): double
public "getSpriteSet"(): $SpriteSet
public "setGravity"(g: float): void
public "tick"(): void
public "setColor"(color: $KubeColor$$Type, alpha: boolean): void
public "setColor"(color: $KubeColor$$Type): void
public "getLevel"(): $ClientLevel
public "getY"(): double
public "getX"(): double
public "getZ"(): double
public "getRandom"(): $RandomSource
public "setSpeed"(speed: $Vec3$$Type): void
set "friction"(value: float)
get "YSpeed"(): double
set "fasterWhenYMotionBlocked"(value: boolean)
get "XSpeed"(): double
set "physicality"(value: boolean)
set "lightColor"(value: $Float2IntFunction$$Type)
get "ZSpeed"(): double
get "spriteSet"(): $SpriteSet
set "color"(value: $KubeColor$$Type)
get "level"(): $ClientLevel
get "random"(): $RandomSource
set "speed"(value: $Vec3$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeAnimatedParticle$$Type = ($KubeAnimatedParticle);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeAnimatedParticle$$Original = $KubeAnimatedParticle;}
declare module "dev.latvian.mods.kubejs.generator.KubeResourceGenerator" {
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $KubeResourceGenerator$$Interface extends $KubeEvent$$Interface {
get "registries"(): $RegistryAccessContainer
}

export class $KubeResourceGenerator implements $KubeResourceGenerator$$Interface {
 "flush"(): void
 "add"(data: $GeneratedData$$Type): void
 "text"(id: $ResourceLocation$$Type, content: StringJS): void
 "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
 "getRegistries"(): $RegistryAccessContainer
 "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeResourceGenerator$$Type = ($KubeResourceGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeResourceGenerator$$Original = $KubeResourceGenerator;}
declare module "dev.latvian.mods.kubejs.script.ScriptPack" {
import {$List} from "java.util.List"
import {$ScriptFile} from "dev.latvian.mods.kubejs.script.ScriptFile"
import {$ScriptPackInfo, $ScriptPackInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptPackInfo"
import {$ScriptManager, $ScriptManager$$Type} from "dev.latvian.mods.kubejs.script.ScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptPack {
readonly "manager": $ScriptManager
readonly "scripts": $List<($ScriptFile)>
readonly "info": $ScriptPackInfo

constructor(m: $ScriptManager$$Type, i: $ScriptPackInfo$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptPack$$Type = ($ScriptPack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptPack$$Original = $ScriptPack;}
declare module "dev.latvian.mods.kubejs.core.EntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$WithPersistentData$$Interface} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ScriptTypeHolder$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityKJS$$Interface extends $WithPersistentData$$Interface, $MessageSenderKJS$$Interface, $ScriptTypeHolder$$Interface {
get "name"(): $Component
get "displayName"(): $Component
get "living"(): boolean
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "server"(): $MinecraftServer
get "block"(): $LevelBlock
get "nbt"(): $CompoundTag
set "nbt"(value: $CompoundTag$$Type)
get "scriptType"(): $ScriptType
get "type"(): StringJS
get "profile"(): $GameProfile
get "player"(): boolean
get "item"(): $ItemStack
get "frame"(): boolean
get "monster"(): boolean
get "animal"(): boolean
get "ambientCreature"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
set "x"(value: double)
set "y"(value: double)
set "z"(value: double)
get "motionX"(): double
set "motionX"(value: double)
get "motionY"(): double
set "motionY"(value: double)
get "motionZ"(): double
set "motionZ"(value: double)
get "passengers"(): $EntityArrayList
get "teamId"(): StringJS
get "facing"(): $Direction
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $EntityKJS implements $EntityKJS$$Interface {
 "self"(): $Entity
 "tell"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "getServer"(): $MinecraftServer
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "getNbt"(): $CompoundTag
 "setNbt"(nbt: $CompoundTag$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "getType"(): StringJS
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "getItem"(): $ItemStack
 "isFrame"(): boolean
 "isMonster"(): boolean
 "isAnimal"(): boolean
 "isAmbientCreature"(): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setX"(x: double): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "getMotionX"(): double
 "setMotionX"(x: double): void
 "getMotionY"(): double
 "setMotionY"(y: double): void
 "getMotionZ"(): double
 "setMotionZ"(z: double): void
 "setRotation"(yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "getTeamId"(): StringJS
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "getFacing"(): $Direction
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "spawn"(): void
 "attack"(hp: float): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityKJS$$Type = ($EntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityKJS$$Original = $EntityKJS;}
declare module "dev.latvian.mods.kubejs.item.ItemTintFunction" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"

export interface $ItemTintFunction$$Interface {

(stack: $ItemStack, index: integer): $KubeColor$$Type
}

export class $ItemTintFunction implements $ItemTintFunction$$Interface {
static readonly "POTION": $ItemTintFunction
static readonly "TYPE_INFO": $TypeInfo
static readonly "BLOCK": $ItemTintFunction
static readonly "DISPLAY_COLOR_NBT": $ItemTintFunction
static readonly "MAP": $ItemTintFunction

static "wrap"(o: any): $ItemTintFunction
 "getColor"(stack: $ItemStack$$Type, index: integer): $KubeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTintFunction$$Type = (($ItemTintFunction$$Type)[]) | (StringJS) | ((stack: $ItemStack, index: integer) => void) | ((stack: $ItemStack, index: integer) => $KubeColor$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemTintFunction$$Original = $ItemTintFunction;}
declare module "dev.latvian.mods.kubejs.block.BlockRenderType" {
import {$Enum} from "java.lang.Enum"

export class $BlockRenderType extends $Enum<($BlockRenderType)> {
static readonly "CUTOUT": $BlockRenderType
static readonly "TRANSLUCENT": $BlockRenderType
static readonly "CUTOUT_MIPPED": $BlockRenderType
static readonly "SOLID": $BlockRenderType

public static "values"(): ($BlockRenderType)[]
public static "valueOf"(name: StringJS): $BlockRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRenderType$$Type = (("solid") | ("cutout") | ("cutout_mipped") | ("translucent"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockRenderType$$Original = $BlockRenderType;}
declare module "dev.latvian.mods.kubejs.recipe.CachedItemTagLookup" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List, $List$$Type} from "java.util.List"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$CachedTagLookup} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"

export class $CachedItemTagLookup extends $CachedTagLookup<($Item)> {
readonly "registry": $Registry<(T)>
readonly "originalMap": $Map<($ResourceLocation), ($List<($TagLoader$EntryWithSource)>)>

constructor(registry: $Registry$$Type<($Item$$Type)>, originalMap: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>)

public "isEmpty"(key: $TagKey$$Type<($Item)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedItemTagLookup$$Type = ($CachedItemTagLookup);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CachedItemTagLookup$$Original = $CachedItemTagLookup;}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction" {
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IngredientActionHolder$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$IngredientActionType} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionType"

export interface $IngredientAction$$Interface {
get "type"(): $IngredientActionType<(never)>
}

export class $IngredientAction implements $IngredientAction$$Interface {
static readonly "CODEC": $Codec<($IngredientAction)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientAction)>

static "getRemaining"(input: $CraftingInput$$Type, index: integer, ingredientActions: $List$$Type<($IngredientActionHolder$$Type)>): $ItemStack
 "transform"(old: $ItemStack$$Type, index: integer, input: $CraftingInput$$Type): $ItemStack
 "getType"(): $IngredientActionType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientAction$$Type = ($IngredientAction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientAction$$Original = $IngredientAction;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockEntityAttachment$$Interface {
get "wrappedObject"(): any
}

export class $BlockEntityAttachment implements $BlockEntityAttachment$$Interface {
 "serverTick"(): void
 "getWrappedObject"(): any
 "deserialize"(registries: $HolderLookup$Provider$$Type, tag: $Tag$$Type): void
 "serialize"(registries: $HolderLookup$Provider$$Type): $Tag
 "onRemove"(level: $ServerLevel$$Type, blockEntity: $KubeBlockEntity$$Type, newState: $BlockState$$Type): void
 "getCapability"<CAP, SRC>(capability: $BlockCapability$$Type<(CAP), (SRC)>): CAP
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachment$$Type = ($BlockEntityAttachment);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachment$$Original = $BlockEntityAttachment;}
declare module "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$MultipartBlockStateGenerator$Part$$Type} from "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator$Part"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $MultipartBlockStateGenerator {
constructor()

public "part"(when: StringJS, model: $ResourceLocation$$Type): void
public "part"(when: StringJS, consumer: $Consumer$$Type<($MultipartBlockStateGenerator$Part)>): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartBlockStateGenerator$$Type = ($MultipartBlockStateGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultipartBlockStateGenerator$$Original = $MultipartBlockStateGenerator;}
declare module "dev.latvian.mods.kubejs.event.EventGroup" {
import {$EventHandler} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Map} from "java.util.Map"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ScriptTypePredicate$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$Class$$Type} from "java.lang.Class"

export class $EventGroup {
readonly "name": StringJS

public "getHandlers"(): $Map<(StringJS), ($EventHandler)>
public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "add"(name: StringJS, scriptType: $ScriptTypePredicate$$Type, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public static "of"(name: StringJS): $EventGroup
public "common"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "client"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "server"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "startup"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
get "handlers"(): $Map<(StringJS), ($EventHandler)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventGroup$$Type = ($EventGroup);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventGroup$$Original = $EventGroup;}
declare module "dev.latvian.mods.kubejs.script.data.VirtualDataPack" {
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$GeneratedDataStage, $GeneratedDataStage$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$Component} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$VirtualResourcePack} from "dev.latvian.mods.kubejs.script.data.VirtualResourcePack"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$VillagerProfession$$Type} from "net.minecraft.world.entity.npc.VillagerProfession"
import {$KubeDataGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$PackType} from "net.minecraft.server.packs.PackType"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$VirtualDataMapFile$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$VillagerType$$Type} from "net.minecraft.world.entity.npc.VillagerType"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualDataPack extends $VirtualResourcePack implements $KubeDataGenerator$$Interface {
readonly "component": $Component
readonly "stage": $GeneratedDataStage
readonly "scriptType": $ScriptType
readonly "packType": $PackType
readonly "registries": $Supplier<($RegistryAccessContainer)>
readonly "info": StringJS

constructor(stage: $GeneratedDataStage$$Type, registries: $Supplier$$Type<($RegistryAccessContainer$$Type)>)

public "dataMap"<R, T>(type: $DataMapType$$Type<(R), (T)>, consumer: $Consumer$$Type<($VirtualDataMapFile<(R), (T)>)>): void
public "reset"(): void
public "flush"(): void
public "setCompostable"(items: $ItemPredicate$$Type, chance: float, canVillagerCompost: boolean): void
public "removeCompostable"(items: $ItemPredicate$$Type): void
public "setFurnaceFuel"(items: $ItemPredicate$$Type, ticks: $TickDuration$$Type): void
public "removeFurnaceFuel"(items: $ItemPredicate$$Type): void
public "setMonsterRoomMobs"(entityType: $EntityType$$Type<(never)>, weight: integer): void
public "setOxidizable"(from: $Block$$Type, to: $Block$$Type): void
public "setParrotImitation"(type: $EntityType$$Type<(never)>, sound: $SoundEvent$$Type): void
public "setRaidHeroGifts"(profession: $VillagerProfession$$Type, lootTable: $ResourceKey$$Type<($LootTable)>): void
public "setVibrationFrequency"(gameEvent: $GameEvent$$Type, frequency: integer): void
public "setVillagerType"(biome: $ResourceKey$$Type<($Biome)>, villagerType: $VillagerType$$Type): void
public "setWaxable"(from: $Block$$Type, to: $Block$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualDataPack$$Type = ($VirtualDataPack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VirtualDataPack$$Original = $VirtualDataPack;}
declare module "dev.latvian.mods.kubejs.block.entity.InventoryAttachment$Factory" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $InventoryAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(width: integer, height: integer, inputFilter: ($ItemPredicate$$Type)?)

public "inputFilter"(): $Optional<($ItemPredicate)>
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "width"(): integer
public "height"(): integer
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryAttachment$Factory$$Type = ({"height"?: integer, "inputFilter"?: ($ItemPredicate$$Type)?, "width"?: integer}) | ([height?: integer, inputFilter?: ($ItemPredicate$$Type)?, width?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryAttachment$Factory$$Original = $InventoryAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.web.KJSWSSession" {
import {$WSSession} from "dev.latvian.apps.tinyserver.ws.WSSession"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$SessionInfo} from "dev.latvian.mods.kubejs.web.SessionInfo"
import {$KJSHTTPRequest} from "dev.latvian.mods.kubejs.web.KJSHTTPRequest"

export class $KJSWSSession extends $WSSession<($KJSHTTPRequest)> {
 "info": $SessionInfo

constructor()

public "onTextMessage"(message: StringJS): void
public "onEvent"(type: StringJS, payload: $JsonElement$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KJSWSSession$$Type = ($KJSWSSession);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KJSWSSession$$Original = $KJSWSSession;}
declare module "dev.latvian.mods.kubejs.block.DetectorBlock$Builder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $DetectorBlock$Builder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "detectorId"(id: StringJS): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlock$Builder$$Type = ($DetectorBlock$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DetectorBlock$Builder$$Original = $DetectorBlock$Builder;}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

export interface $ScheduledEvents$Callback$$Interface {

(event: $ScheduledEvents$ScheduledEvent): void
}

export class $ScheduledEvents$Callback implements $ScheduledEvents$Callback$$Interface {
static readonly "TYPE_INFO": $TypeInfo

 "onCallback"(event: $ScheduledEvents$ScheduledEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$Callback$$Type = ((event: $ScheduledEvents$ScheduledEvent) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduledEvents$Callback$$Original = $ScheduledEvents$Callback;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$CustomObjectRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$EitherRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$ListRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"

export interface $RecipeComponent$$Interface<T> {
get "ignored"(): boolean
}

export class $RecipeComponent<T> implements $RecipeComponent$$Interface {
 "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<(T)>, json: $JsonObject$$Type): void
 "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<(T)>, json: $JsonObject$$Type): void
 "orSelf"(): $RecipeComponent<(T)>
 "outputKey"(name: StringJS): $RecipeKey<(T)>
 "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
 "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: T): void
 "asListOrSelf"(): $ListRecipeComponent<(T)>
 "asConditionalList"(): $ListRecipeComponent<(T)>
 "asConditionalListOrSelf"(): $ListRecipeComponent<(T)>
 "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
 "withCodec"(codec: $Codec$$Type<(T)>): $RecipeComponent<(T)>
 "allowEmpty"(): boolean
 "inputKey"(name: StringJS): $RecipeKey<(T)>
 "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<(T), (O)>
 "isIgnored"(): boolean
 "type"(): $RecipeComponentType<(never)>
 "toString"(ops: $OpsContainer$$Type, value: T): StringJS
 "wrap"(cx: $RecipeScriptContext$$Type, from: any): T
 "isEmpty"(value: T): boolean
 "replace"(cx: $RecipeScriptContext$$Type, original: T, match: $ReplacementMatchInfo$$Type, arg3: any): T
 "matches"(cx: $RecipeMatchContext$$Type, value: T, match: $ReplacementMatchInfo$$Type): boolean
static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
 "validate"(ctx: $RecipeValidationContext$$Type, value: T): void
 "typeInfo"(): $TypeInfo
 "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<(T)>
 "asList"(): $ListRecipeComponent<(T)>
 "createBuilder"(): $RecipeComponentBuilder
 "spread"(value: T): $List<(never)>
 "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
 "otherKey"(name: StringJS): $RecipeKey<(T)>
 "codec"(): $Codec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponent$$Type<T> = ($RecipeComponent<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponent$$Original<T> = $RecipeComponent<(T)>;}
declare module "dev.latvian.mods.kubejs.core.ItemKJS" {
import {$Map} from "java.util.Map"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$List} from "java.util.List"
import {$Holder} from "net.minecraft.core.Holder"
import {$ItemStackKey} from "dev.latvian.mods.kubejs.item.ItemStackKey"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemKJS$$Interface extends $IngredientSupplierKJS$$Interface, $RegistryObjectKJS$$Interface<($Item)> {
get "typeData"(): $Map<(StringJS), (any)>
set "nameKey"(value: StringJS)
get "registryId"(): $ResourceKey<($Registry<($Item)>)>
get "registry"(): $Registry<($Item)>
set "itemBuilder"(value: $ItemBuilder$$Type)
get "typeItemStackKey"(): $ItemStackKey
set "craftingRemainder"(value: $Item$$Type)
set "canRepair"(value: boolean)
get "item"(): $Item
get "itemBuilder"(): $ItemBuilder
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($Item)>)>
get "tags"(): $List<($ResourceLocation)>
get "key"(): $ResourceKey<($Item)>
get "id"(): StringJS
}

export class $ItemKJS implements $ItemKJS$$Interface {
 "getTypeData"(): $Map<(StringJS), (any)>
 "setNameKey"(key: StringJS): void
 "getRegistryId"(): $ResourceKey<($Registry<($Item)>)>
 "getRegistry"(): $Registry<($Item)>
 "setItemBuilder"(b: $ItemBuilder$$Type): void
 "getTypeItemStackKey"(): $ItemStackKey
 "setCraftingRemainder"(i: $Item$$Type): void
 "setCanRepair"(repairable: boolean): void
 "getItem"(): $Item
 "getItemBuilder"(): $ItemBuilder
 "kjs$asIngredient"(): $Ingredient
 "asHolder"(): $Holder<($Item)>
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "getTagKeys"(): $List<($TagKey<($Item)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getKey"(): $ResourceKey<($Item)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemKJS$$Type = ($ItemKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemKJS$$Original = $ItemKJS;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicateDataCheck" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"

export interface $BlockEntityPredicateDataCheck$$Interface {

(data: $CompoundTag): boolean
}

export class $BlockEntityPredicateDataCheck implements $BlockEntityPredicateDataCheck$$Interface {
 "checkData"(data: $CompoundTag$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityPredicateDataCheck$$Type = ((data: $CompoundTag) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityPredicateDataCheck$$Original = $BlockEntityPredicateDataCheck;}
declare module "dev.latvian.mods.kubejs.gui.KubeJSGUI" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$SimpleContainer} from "net.minecraft.world.SimpleContainer"
import {$Component} from "net.minecraft.network.chat.Component"

export class $KubeJSGUI {
 "playerSlotsY": integer
 "playerSlotsX": integer
 "inventoryHeight": integer
 "width": integer
 "inventoryLabelY": integer
 "inventoryWidth": integer
 "inventoryLabelX": integer
 "title": $Component
 "inventory": $InventoryKJS
static readonly "EMPTY_CONTAINER": $SimpleContainer
 "height": integer

constructor(buf: $FriendlyByteBuf$$Type)
constructor()

public "setInventory"(inv: $InventoryKJS$$Type): void
public "write"(buf: $FriendlyByteBuf$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSGUI$$Type = ($KubeJSGUI);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSGUI$$Original = $KubeJSGUI;}
declare module "dev.latvian.mods.kubejs.util.OpsContainer" {
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $OpsContainer {
static readonly "DEFAULT": $OpsContainer

constructor(nbt: $DynamicOps$$Type<($Tag$$Type)>, json: $DynamicOps$$Type<($JsonElement$$Type)>, java: $DynamicOps$$Type<(any)>)

public "decode"<T>(codec: $Codec$$Type<(T)>, o: any): T
public "java"(): $DynamicOps<(any)>
public "json"(): $DynamicOps<($JsonElement)>
public "nbt"(): $DynamicOps<($Tag)>
public "decodeMap"<T>(codec: $MapCodec$$Type<(T)>, o: any): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpsContainer$$Type = ($OpsContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OpsContainer$$Original = $OpsContainer;}
declare module "dev.latvian.mods.kubejs.item.ModifyItemTooltipsKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$TooltipRequirements$$Type} from "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$ItemTooltipData$$Type} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TextActionBuilder$$Type} from "dev.latvian.mods.kubejs.text.action.TextActionBuilder"

export class $ModifyItemTooltipsKubeEvent implements $KubeEvent$$Interface {
constructor(callback: $Consumer$$Type<($ItemTooltipData)>)

public "add"(filter: $Ingredient$$Type, requirements: $TooltipRequirements$$Type, text: $List$$Type<($Component$$Type)>): void
public "add"(filter: $Ingredient$$Type, text: $List$$Type<($Component$$Type)>): void
public "modify"(filter: $Ingredient$$Type, consumer: $Consumer$$Type<($TextActionBuilder)>): void
public "modify"(filter: $Ingredient$$Type, requirements: $TooltipRequirements$$Type, consumer: $Consumer$$Type<($TextActionBuilder)>): void
public "modifyAll"(requirements: $TooltipRequirements$$Type, consumer: $Consumer$$Type<($TextActionBuilder)>): void
public "modifyAll"(consumer: $Consumer$$Type<($TextActionBuilder)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifyItemTooltipsKubeEvent$$Type = ($ModifyItemTooltipsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModifyItemTooltipsKubeEvent$$Original = $ModifyItemTooltipsKubeEvent;}
declare module "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS" {
import {$MobEffectInstance, $MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$Map} from "java.util.Map"
import {$Collection} from "java.util.Collection"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MobEffect, $MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $EntityPotionEffectsJS {
constructor(e: $LivingEntity$$Type)

public "getActive"(): $Collection<($MobEffectInstance)>
public "getActive"(mobEffect: $Holder$$Type<($MobEffect)>): $MobEffectInstance
public "getMap"(): $Map<($Holder<($MobEffect)>), ($MobEffectInstance)>
public "getDuration"(mobEffect: $Holder$$Type<($MobEffect)>): integer
public "clear"(): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, showParticles: boolean): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>, duration: integer): void
public "isActive"(mobEffect: $Holder$$Type<($MobEffect)>): boolean
public "isApplicable"(effect: $MobEffectInstance$$Type): boolean
get "active"(): $Collection<($MobEffectInstance)>
get "map"(): $Map<($Holder<($MobEffect)>), ($MobEffectInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityPotionEffectsJS$$Type = ($EntityPotionEffectsJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityPotionEffectsJS$$Original = $EntityPotionEffectsJS;}
declare module "dev.latvian.mods.kubejs.web.RelativeURL" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Record} from "java.lang.Record"

export class $RelativeURL extends $Record {
constructor(path: StringJS, query: $Map$$Type<(StringJS), (StringJS)>)
constructor(path: StringJS)

public "fullString"(): StringJS
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "query"(): $Map<(StringJS), (StringJS)>
public "path"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RelativeURL$$Type = ({"query"?: $Map$$Type<(StringJS), (StringJS)>, "path"?: StringJS}) | ([query?: $Map$$Type<(StringJS), (StringJS)>, path?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RelativeURL$$Original = $RelativeURL;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentHandler" {
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Set$$Type} from "java.util.Set"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

export interface $BlockEntityAttachmentHandler$$Interface {
}

export class $BlockEntityAttachmentHandler implements $BlockEntityAttachmentHandler$$Interface {
 "attachCustomCapability"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capability: $BlockCapability$$Type<(never), (never)>, dataFactory: $Supplier$$Type<(never)>): void
 "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer): void
 "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, inputFilter: $FluidIngredient$$Type): void
 "attach"(id: StringJS, type: $ResourceLocation$$Type, directions: $Set$$Type<($Direction$$Type)>, args: any): void
 "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer): void
 "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer, inputFilter: $ItemPredicate$$Type): void
 "energyStorage"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, maxReceive: integer, maxExtract: integer, autoOutput: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentHandler$$Type = ($BlockEntityAttachmentHandler);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentHandler$$Original = $BlockEntityAttachmentHandler;}
declare module "dev.latvian.mods.kubejs.recipe.special.ShapedKubeJSRecipe" {
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IngredientActionHolder, $IngredientActionHolder$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder"
import {$List, $List$$Type} from "java.util.List"
import {$CraftingBookCategory$$Type} from "net.minecraft.world.item.crafting.CraftingBookCategory"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ShapedRecipePattern, $ShapedRecipePattern$$Type} from "net.minecraft.world.item.crafting.ShapedRecipePattern"
import {$RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$ShapedRecipe} from "net.minecraft.world.item.crafting.ShapedRecipe"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$KubeJSCraftingRecipe$$Interface} from "dev.latvian.mods.kubejs.recipe.special.KubeJSCraftingRecipe"

export class $ShapedKubeJSRecipe extends $ShapedRecipe implements $KubeJSCraftingRecipe$$Interface {
readonly "result": $ItemStack
readonly "pattern": $ShapedRecipePattern

constructor(group: StringJS, category: $CraftingBookCategory$$Type, pattern: $ShapedRecipePattern$$Type, result: $ItemStack$$Type, showNotification: boolean, mirror: boolean, ingredientActions: $List$$Type<($IngredientActionHolder$$Type)>, modifyResult: StringJS, stage: StringJS)

public "kjs$getMirror"(): boolean
public "kjs$getIngredientActions"(): $List<($IngredientActionHolder)>
public "kjs$getModifyResult"(): StringJS
public "kjs$getStage"(): StringJS
public "assemble"(input: $CraftingInput$$Type, registryAccess: $HolderLookup$Provider$$Type): $ItemStack
public "assemble"(input: $RecipeInput$$Type, registryAccess: $HolderLookup$Provider$$Type): $ItemStack
public "getRemainingItems"(input: $RecipeInput$$Type): $NonNullList
public "getRemainingItems"(input: $CraftingInput$$Type): $NonNullList<($ItemStack)>
public "getSerializer"(): $RecipeSerializer<(never)>
public "kjs$getRemainingItems"(input: $CraftingInput$$Type): $NonNullList<($ItemStack)>
public "kjs$assemble"(input: $CraftingInput$$Type, registryAccess: $HolderLookup$Provider$$Type): $ItemStack
get "serializer"(): $RecipeSerializer<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedKubeJSRecipe$$Type = ($ShapedKubeJSRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShapedKubeJSRecipe$$Original = $ShapedKubeJSRecipe;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $RecipeComponentBuilder$$Interface {
}

export class $RecipeComponentBuilder implements $RecipeComponentBuilder$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentBuilder$$Type = ($RecipeComponentBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentBuilder$$Original = $RecipeComponentBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$FinishUsingCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $ItemBuilder$FinishUsingCallback$$Interface {

(itemStack: $ItemStack, level: $Level, livingEntity: $LivingEntity): $ItemStack$$Type
}

export class $ItemBuilder$FinishUsingCallback implements $ItemBuilder$FinishUsingCallback$$Interface {
 "finishUsingItem"(itemStack: $ItemStack$$Type, level: $Level$$Type, livingEntity: $LivingEntity$$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$FinishUsingCallback$$Type = ((itemStack: $ItemStack, level: $Level, livingEntity: $LivingEntity) => $ItemStack$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$FinishUsingCallback$$Original = $ItemBuilder$FinishUsingCallback;}
declare module "dev.latvian.mods.kubejs.core.ItemStackKJS" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ItemEnchantments, $ItemEnchantments$$Type} from "net.minecraft.world.item.enchantment.ItemEnchantments"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$MutableDataComponentHolderFunctions, $MutableDataComponentHolderFunctions$$Interface} from "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ItemMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ItemComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ItemComponentFunctions"
import {$LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Unit$$Type} from "net.minecraft.util.Unit"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ComponentFunctions} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$UUID$$Type} from "java.util.UUID"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$MutableDataComponentHolder} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$List, $List$$Type} from "java.util.List"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ToStringJS$$Interface} from "dev.latvian.mods.rhino.util.ToStringJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Map, $Map$$Type} from "java.util.Map"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemStackKJS$$Interface extends $SpecialEquality$$Interface, $WithCodec$$Interface, $IngredientSupplierKJS$$Interface, $ToStringJS$$Interface, $Replaceable$$Interface, $ItemComponentFunctions$$Interface, $MutableDataComponentHolderFunctions$$Interface, $ItemMatch$$Interface, $RegistryObjectKJS$$Interface<($Item)> {
get "typeData"(): $Map<(StringJS), (any)>
get "registryId"(): $ResourceKey<($Registry<($Item)>)>
get "registry"(): $Registry<($Item)>
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "enchantments"(): $ItemEnchantments
get "harvestSpeed"(): float
get "componentString"(): StringJS
get "key"(): $ResourceKey<($Item)>
get "codec"(): $Codec<($ItemStack)>
get "id"(): StringJS
get "block"(): $Block
set "food"(value: $FoodProperties$$Type)
set "maxStackSize"(value: integer)
set "maxDamage"(value: integer)
set "damage"(value: integer)
get "unbreakable"(): void
set "itemName"(value: $Component$$Type)
set "repairCost"(value: integer)
get "fireResistant"(): void
set "tool"(value: $Tool$$Type)
set "mapItemColor"(value: $KubeColor$$Type)
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "bucketEntityData"(value: $CompoundTag$$Type)
set "blockEntityData"(value: $CompoundTag$$Type)
set "instrument"(value: $Holder$$Type<($Instrument)>)
get "unbreakableWithTooltip"(): void
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
set "fireworks"(value: $Fireworks$$Type)
set "noteBlockSound"(value: $ResourceLocation$$Type)
get "attributeModifiers"(): $ItemAttributeModifiers
get "componentHolder"(): $MutableDataComponentHolder
get "componentMap"(): $DataComponentMap
get "tagKeys"(): $List<($TagKey<($Item)>)>
get "tags"(): $List<($ResourceLocation)>
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "customData"(value: $CompoundTag$$Type)
get "customData"(): $CompoundTag
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customModelData"(value: integer)
get "additionalTooltipHidden"(): void
get "tooltipHidden"(): void
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "lockCode"(value: StringJS)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
get "baseAttackDamage"(): double
get "baseAttackSpeed"(): double
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "attackSpeed"(value: double)
set "attackDamage"(value: double)
get "attackDamage"(): double
get "attackSpeed"(): double
set "baseAttackSpeed"(value: double)
set "baseAttackDamage"(value: double)
}

export class $ItemStackKJS implements $ItemStackKJS$$Interface {
 "getTypeData"(): $Map<(StringJS), (any)>
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getRegistryId"(): $ResourceKey<($Registry<($Item)>)>
 "getRegistry"(): $Registry<($Item)>
 "asHolder"(): $Holder<($Item)>
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "asIngredient"(): $Ingredient
 "getWebIconURL"(ops: $DynamicOps$$Type<($Tag$$Type)>, size: integer): $RelativeURL
 "equalsIgnoringCount"(stack: $ItemStack$$Type): boolean
 "getEnchantments"(): $ItemEnchantments
 "getHarvestSpeed"(block: $LevelBlock$$Type): float
 "getHarvestSpeed"(): float
 "toItemString0"(dynamicOps: $DynamicOps$$Type<($Tag$$Type)>): StringJS
 "withCount"(c: integer): this
 "withCustomName"(name: $Component$$Type): this
 "hasEnchantment"(enchantment: $Holder$$Type<($Enchantment)>, level: integer): boolean
 "enchant"(enchantments: $ItemEnchantments$$Type): this
 "enchant"(enchantment: $Holder$$Type<($Enchantment)>, level: integer): this
 "areItemsEqual"(other: $ItemStack$$Type): boolean
 "areComponentsEqual"(other: $ItemStack$$Type): boolean
 "toStringJS"(): StringJS
 "toItemString"(): StringJS
/**
 * 
 * @deprecated
 */
 "withChance"(chance: float): $ItemStack
 "withLore"(lines: ($Component$$Type)[]): this
 "withLore"(lines: ($Component$$Type)[], styledLines: ($Component$$Type)[]): this
 "getComponentString"(): StringJS
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, s: $ItemStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
 "self"(): $ItemStack
 "getKey"(): $ResourceKey<($Item)>
 "getCodec"(): $Codec<($ItemStack)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
 "getBlock"(): $Block
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
static "toStringJS"(arg1: any): StringJS
 "setFood"(foodProperties: $FoodProperties$$Type): void
 "setFood"(nutrition: integer, saturation: float): void
 "setMaxStackSize"(size: integer): void
 "setMaxDamage"(maxDamage: integer): void
 "setDamage"(damage: integer): void
 "setUnbreakable"(): void
 "setItemName"(component: $Component$$Type): void
 "setRepairCost"(repairCost: integer): void
 "setFireResistant"(): void
 "setTool"(tool: $Tool$$Type): void
 "setMapItemColor"(color: $KubeColor$$Type): void
 "setChargedProjectiles"(items: $List$$Type<($ItemStack$$Type)>): void
 "setBundleContents"(items: $List$$Type<($ItemStack$$Type)>): void
 "setBucketEntityData"(tag: $CompoundTag$$Type): void
 "setBlockEntityData"(tag: $CompoundTag$$Type): void
 "setInstrument"(instrument: $Holder$$Type<($Instrument)>): void
 "setUnbreakableWithTooltip"(): void
 "setFireworkExplosion"(explosion: $FireworkExplosion$$Type): void
 "setFireworks"(fireworks: $Fireworks$$Type): void
 "setNoteBlockSound"(id: $ResourceLocation$$Type): void
 "getAttributeModifiers"(): $ItemAttributeModifiers
 "getComponentHolder"(): $MutableDataComponentHolder
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): $MutableDataComponentHolderFunctions
 "getComponentMap"(): $DataComponentMap
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
 "getTagKeys"(): $List<($TagKey<($Item)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "resetComponents"(): $ComponentFunctions
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setCustomData"(tag: $CompoundTag$$Type): void
 "getCustomData"(): $CompoundTag
 "setRarity"(rarity: $Rarity$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setCustomModelData"(data: integer): void
 "setAdditionalTooltipHidden"(): void
 "setTooltipHidden"(): void
 "setGlintOverride"(override: boolean): void
 "setDyedColor"(color: $KubeColor$$Type): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "setLockCode"(lock: StringJS): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "getBaseAttackDamage"(): double
 "getBaseAttackSpeed"(): double
 "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
 "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
 "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
 "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
 "setAttackSpeed"(speed: double): void
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
 "setAttackDamage"(dmg: double): void
 "getAttackDamage"(): double
 "getAttackSpeed"(): double
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
 "setBaseAttackSpeed"(speed: double): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
 "setBaseAttackDamage"(dmg: double): void
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackKJS$$Type = ($ItemStackKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemStackKJS$$Original = $ItemStackKJS;}
declare module "dev.latvian.mods.kubejs.misc.CustomStatBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CustomStatBuilder extends $BuilderBase<($ResourceLocation)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomStatBuilder$$Type = ($CustomStatBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomStatBuilder$$Original = $CustomStatBuilder;}
declare module "dev.latvian.mods.kubejs.core.ServerLevelKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$WithPersistentData$$Interface} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$LevelKJS$$Interface} from "dev.latvian.mods.kubejs.core.LevelKJS"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ServerLevelKJS$$Interface extends $LevelKJS$$Interface, $WithPersistentData$$Interface {

(): $AttachedData$$Type<($Level$$Type)>
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "side"(): $ScriptType
get "dimension"(): $ResourceLocation
get "overworld"(): boolean
set "time"(value: long)
get "persistentData"(): $CompoundTag
get "data"(): $AttachedData<($Level)>
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "displayName"(): $Component
get "entities"(): $EntityArrayList
}

export class $ServerLevelKJS implements $ServerLevelKJS$$Interface {
 "self"(): $EntityGetter
 "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "tell"(message: $Component$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getName"(): $Component
 "getBlock"(pos: $BlockPos$$Type): $LevelBlock
 "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
 "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
 "getSide"(): $ScriptType
 "getDimension"(): $ResourceLocation
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
 "isOverworld"(): boolean
 "setTime"(time: long): void
 "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
 "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
 "getPersistentData"(): $CompoundTag
 "getData"(): $AttachedData<($Level)>
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getDisplayName"(): $Component
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerLevelKJS$$Original = $ServerLevelKJS;}
declare module "dev.latvian.mods.kubejs.util.Tristate" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $Tristate extends $Enum<($Tristate)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($Tristate)>
static readonly "TRUE": $Tristate
static readonly "FALSE": $Tristate
static readonly "VALUES": ($Tristate)[]
static readonly "DEFAULT": $Tristate
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($Tristate)>

public static "values"(): ($Tristate)[]
public "test"(enabled: $BooleanSupplier$$Type): boolean
public "test"(enabled: boolean): boolean
public static "valueOf"(name: StringJS): $Tristate
public static "wrap"(from: any): $Tristate
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Tristate$$Type = (("false") | ("true") | ("default"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Tristate$$Original = $Tristate;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.SizedIngredientWrapper" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$SizedIngredient, $SizedIngredient$$Type} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * Various SizedIngredient related helper methods
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $SizedIngredientWrapper$$Interface {
}

export class $SizedIngredientWrapper implements $SizedIngredientWrapper$$Interface {
/**
 * An ingredient that matches everything
 */
static readonly "all": $SizedIngredient
static readonly "TYPE_INFO": $TypeInfo
/**
 * A completely empty ingredient that will only match air
 */
static readonly "empty": $SizedIngredient

static "ofTag"(tag: $TagKey$$Type<($Item)>, count: integer): $SizedIngredient
/**
 * Returns a sized ingredient of the input
 */
static "of"(ingredient: $Ingredient$$Type, count: integer): $SizedIngredient
/**
 * Returns a sized ingredient of the input
 */
static "of"(ingredient: $SizedIngredient$$Type): $SizedIngredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedIngredientWrapper$$Type = ($SizedIngredientWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SizedIngredientWrapper$$Original = $SizedIngredientWrapper;}
declare module "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Map} from "java.util.Map"
import {$UUID} from "java.util.UUID"
import {$BlockEntityInfo, $BlockEntityInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ClientGamePacketListener} from "net.minecraft.network.protocol.game.ClientGamePacketListener"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $KubeBlockEntity extends $BlockEntity {
readonly "attachments": $Map<(StringJS), (any)>
 "data": $CompoundTag
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "tick": integer
 "placerId": $UUID
 "cycle": integer
readonly "blockKey": $ResourceKey<($Block)>
static readonly "TICKER": $BlockEntityTicker<($KubeBlockEntity)>
readonly "x": integer
readonly "y": integer
readonly "z": integer
readonly "info": $BlockEntityInfo

constructor(blockPos: $BlockPos$$Type, blockState: $BlockState$$Type, entityInfo: $BlockEntityInfo$$Type)

public "loadAdditional"(tag: $CompoundTag$$Type, registries: $HolderLookup$Provider$$Type): void
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "getPlacer"(): $Entity
public "sendEvent"(eventId: integer, data: integer): void
public "getBlock"(): $LevelBlock
public "setLevel"(level: $Level$$Type): void
public "save"(): void
public "sync"(): void
public "triggerEvent"(eventId: integer, data: integer): boolean
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "placer"(): $Entity
get "block"(): $LevelBlock
set "level"(value: $Level$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeBlockEntity$$Type = ($KubeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeBlockEntity$$Original = $KubeBlockEntity;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$ReleaseUsingCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $ItemBuilder$ReleaseUsingCallback$$Interface {

(itemStack: $ItemStack, level: $Level, user: $LivingEntity, tick: integer): void
}

export class $ItemBuilder$ReleaseUsingCallback implements $ItemBuilder$ReleaseUsingCallback$$Interface {
 "releaseUsing"(itemStack: $ItemStack$$Type, level: $Level$$Type, user: $LivingEntity$$Type, tick: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$ReleaseUsingCallback$$Type = ((itemStack: $ItemStack, level: $Level, user: $LivingEntity, tick: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$ReleaseUsingCallback$$Original = $ItemBuilder$ReleaseUsingCallback;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory" {
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentInfo, $BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$BlockEntityAttachment, $BlockEntityAttachment$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"

export interface $BlockEntityAttachmentFactory$$Interface {

(info: $BlockEntityAttachmentInfo, entity: $KubeBlockEntity): $BlockEntityAttachment$$Type
get "ticking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
}

export class $BlockEntityAttachmentFactory implements $BlockEntityAttachmentFactory$$Interface {
 "isTicking"(): boolean
 "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
 "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentFactory$$Type = ((info: $BlockEntityAttachmentInfo, entity: $KubeBlockEntity) => $BlockEntityAttachment$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentFactory$$Original = $BlockEntityAttachmentFactory;}
declare module "dev.latvian.mods.kubejs.util.TinyMap" {
import {$Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$TinyMap$Entry, $TinyMap$Entry$$Type} from "dev.latvian.mods.kubejs.util.TinyMap$Entry"
import {$Record} from "java.lang.Record"

export class $TinyMap<K, V> extends $Record {
constructor(collection: $Collection$$Type<($TinyMap$Entry$$Type<(K), (V)>)>)
constructor(entries: ($TinyMap$Entry$$Type<(K), (V)>)[])
constructor(map: $TinyMap$$Type<(K), (V)>)

public static "ofMap"<K, V>(map: $Map$$Type<(K), (V)>): $TinyMap<(K), (V)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public "toMap"(): $Map<(K), (V)>
public "entries"(): ($TinyMap$Entry<(K), (V)>)[]
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinyMap$$Type<K, V> = ({"entries"?: ($TinyMap$Entry$$Type<(K), (V)>)[]}) | ([entries?: ($TinyMap$Entry$$Type<(K), (V)>)[]]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TinyMap$$Original<K, V> = $TinyMap<(K), (V)>;}
declare module "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Tristate, $Tristate$$Type} from "dev.latvian.mods.kubejs.util.Tristate"
import {$Record} from "java.lang.Record"

export class $TooltipRequirements extends $Record {
static readonly "DEFAULT": $TooltipRequirements
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($TooltipRequirements)>

constructor(shift: $Tristate$$Type, ctrl: $Tristate$$Type, alt: $Tristate$$Type, advanced: $Tristate$$Type, creative: $Tristate$$Type, stages: $Map$$Type<(StringJS), ($Tristate$$Type)>)

public "ctrl"(): $Tristate
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "shift"(): $Tristate
public "alt"(): $Tristate
public "advanced"(): $Tristate
public "creative"(): $Tristate
public "stages"(): $Map<(StringJS), ($Tristate)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipRequirements$$Type = ({"alt"?: $Tristate$$Type, "ctrl"?: $Tristate$$Type, "stages"?: $Map$$Type<(StringJS), ($Tristate$$Type)>, "advanced"?: $Tristate$$Type, "shift"?: $Tristate$$Type, "creative"?: $Tristate$$Type}) | ([alt?: $Tristate$$Type, ctrl?: $Tristate$$Type, stages?: $Map$$Type<(StringJS), ($Tristate$$Type)>, advanced?: $Tristate$$Type, shift?: $Tristate$$Type, creative?: $Tristate$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TooltipRequirements$$Original = $TooltipRequirements;}
declare module "dev.latvian.mods.kubejs.util.Object2LongEntry" {
import {$Comparable$$Interface} from "java.lang.Comparable"
import {$Object2LongMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongMap$Entry"

export class $Object2LongEntry implements $Comparable$$Interface<($Object2LongEntry)> {
readonly "value": long
readonly "key": any

constructor(k: any, v: long)
constructor(entry: $Object2LongMap$Entry$$Type<(any)>)

public "compareTo"(o: any): integer
public "compareTo"(o: $Object2LongEntry$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongEntry$$Type = ($Object2LongEntry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Object2LongEntry$$Original = $Object2LongEntry;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabContentSupplier" {
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"

export interface $CreativeTabContentSupplier$$Interface {

(showRestrictedItems: boolean): $ItemPredicate$$Type
}

export class $CreativeTabContentSupplier implements $CreativeTabContentSupplier$$Interface {
static readonly "DEFAULT": $CreativeTabContentSupplier

 "getContent"(showRestrictedItems: boolean): $ItemPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabContentSupplier$$Type = ((showRestrictedItems: boolean) => $ItemPredicate$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabContentSupplier$$Original = $CreativeTabContentSupplier;}
declare module "dev.latvian.mods.kubejs.command.ArgumentTypeWrapper" {
import {$CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$ArgumentType} from "com.mojang.brigadier.arguments.ArgumentType"
import {$CommandRegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"

export interface $ArgumentTypeWrapper$$Interface {
}

export class $ArgumentTypeWrapper implements $ArgumentTypeWrapper$$Interface {
 "getResult"(context: $CommandContext$$Type<($CommandSourceStack$$Type)>, input: StringJS): any
 "create"(event: $CommandRegistryKubeEvent$$Type): $ArgumentType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentTypeWrapper$$Type = ($ArgumentTypeWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArgumentTypeWrapper$$Original = $ArgumentTypeWrapper;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$CreativeModeTab} from "net.minecraft.world.item.CreativeModeTab"
import {$CreativeTabContentSupplier$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabContentSupplier"
import {$CreativeTabIconSupplier$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabIconSupplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CreativeTabBuilder extends $BuilderBase<($CreativeModeTab)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "content"(content: $CreativeTabContentSupplier$$Type): this
public "icon"(icon: $CreativeTabIconSupplier$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabBuilder$$Type = ($CreativeTabBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabBuilder$$Original = $CreativeTabBuilder;}
declare module "dev.latvian.mods.kubejs.block.state.BlockStatePredicate" {
import {$ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Collection} from "java.util.Collection"
import {$OreConfiguration$TargetBlockState$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Set} from "java.util.Set"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockStatePredicate$$Interface extends $Predicate$$Interface<($BlockState)>, $ReplacementMatch$$Interface {

(state: $BlockState): boolean
get "blockIds"(): $Set<($ResourceLocation)>
get "blocks"(): $Collection<($Block)>
get "blockStates"(): $Collection<($BlockState)>
}

export class $BlockStatePredicate implements $BlockStatePredicate$$Interface {
static "wrapRuleTest"(o: any): $RuleTest
 "asRuleTest"(): $RuleTest
 "testBlock"(block: $Block$$Type): boolean
 "getBlockIds"(): $Set<($ResourceLocation)>
 "test"(state: any): boolean
 "test"(state: $BlockState$$Type): boolean
static "wrap"(o: any): $BlockStatePredicate
 "check"(targetStates: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>): boolean
static "fromString"(s: StringJS): $BlockStatePredicate
 "getBlocks"(): $Collection<($Block)>
 "getBlockStates"(): $Collection<($BlockState)>
 "or"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
static "isEqual"<T>(arg0: any): $Predicate<($BlockState)>
 "negate"(): $Predicate<($BlockState)>
 "and"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
static "not"<T>(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
}
export type BlockStatePredicateObject = {"or"?: $BlockStatePredicate$$Type, "not"?: $BlockStatePredicate$$Type};
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStatePredicate$$Type = (($BlockStatePredicate$$Type)[]) | (BlockStatePredicateObject) | ($Block$$Type) | (Special.BlockTag) | (RegExp) | ("*") | ("-") | ((state: $BlockState) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStatePredicate$$Original = $BlockStatePredicate;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Shovel" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Shovel extends $DiggerItemBuilder {
static readonly "SHOVEL_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "SHOVEL_MODEL": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Shovel$$Type = ($DiggerItemBuilder$Shovel);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Shovel$$Original = $DiggerItemBuilder$Shovel;}
declare module "dev.latvian.mods.kubejs.script.ScriptManager" {
import {$ScriptPack, $ScriptPack$$Type} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$Map} from "java.util.Map"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Path$$Type} from "java.nio.file.Path"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$KubeJSContextFactory} from "dev.latvian.mods.kubejs.script.KubeJSContextFactory"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptManager {
readonly "scriptType": $ScriptType
 "canListenEvents": boolean
readonly "packs": $Map<(StringJS), ($ScriptPack)>
 "contextFactory": $KubeJSContextFactory

constructor(t: $ScriptType$$Type)

public "loadFromDirectory"(): void
public "collectScripts"(pack: $ScriptPack$$Type, dir: $Path$$Type, path: StringJS): void
public "loadPackFromDirectory"(path: $Path$$Type, name: StringJS, exampleFile: boolean): void
public "loadAdditional"(): void
public "isClassAllowed"(name: StringJS): boolean
public "reload"(): void
public "unload"(): void
public "getRegistries"(): $RegistryAccessContainer
get "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptManager$$Type = ($ScriptManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptManager$$Original = $ScriptManager;}
declare module "dev.latvian.mods.kubejs.core.MessageSenderKJS" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MessageSenderKJS$$Interface {
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export class $MessageSenderKJS implements $MessageSenderKJS$$Interface {
 "tell"(message: $Component$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageSenderKJS$$Type = ($MessageSenderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MessageSenderKJS$$Original = $MessageSenderKJS;}
declare module "dev.latvian.mods.kubejs.client.KeybindRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$KeybindRegistryKubeEvent$Builder} from "dev.latvian.mods.kubejs.client.KeybindRegistryKubeEvent$Builder"
import {$Minecraft} from "net.minecraft.client.Minecraft"

export class $KeybindRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor()

public "register"(id: StringJS, defaultKey: StringJS): $KeybindRegistryKubeEvent$Builder
public "register"(id: StringJS): $KeybindRegistryKubeEvent$Builder
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeybindRegistryKubeEvent$$Type = ($KeybindRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KeybindRegistryKubeEvent$$Original = $KeybindRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.text.action.TooltipActionType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$TextAction} from "dev.latvian.mods.kubejs.text.action.TextAction"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Record} from "java.lang.Record"

export class $TooltipActionType<T extends $TextAction> extends $Record {
constructor(type: integer, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>)

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
public "type"(): integer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipActionType$$Type<T> = ({"type"?: integer, "streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>}) | ([type?: integer, streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TooltipActionType$$Original<T> = $TooltipActionType<(T)>;}
declare module "dev.latvian.mods.kubejs.level.LevelBlock" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Holder} from "net.minecraft.core.Holder"
import {$BlockProviderKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockProviderKJS"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

export interface $LevelBlock$$Interface extends $BlockProviderKJS$$Interface {
get "drops"(): $List<($ItemStack)>
set "entityData"(value: $CompoundTag$$Type)
get "centerY"(): double
get "playersInRadius"(): $EntityArrayList
get "down"(): $LevelBlock
get "up"(): $LevelBlock
get "north"(): $LevelBlock
get "south"(): $LevelBlock
get "west"(): $LevelBlock
get "east"(): $LevelBlock
get "entityId"(): StringJS
get "light"(): integer
get "skyLight"(): integer
get "blockLight"(): integer
get "canSeeSky"(): boolean
get "biomeId"(): $ResourceLocation
get "item"(): $ItemStack
get "dimension"(): $ResourceLocation
get "level"(): $Level
get "entity"(): $BlockEntity
get "y"(): integer
get "properties"(): $Map<(StringJS), (StringJS)>
get "x"(): integer
get "z"(): integer
get "blockState"(): $BlockState
get "inventory"(): $InventoryKJS
get "block"(): $Block
get "entityData"(): $CompoundTag
get "pos"(): $BlockPos
get "centerX"(): double
get "centerZ"(): double
get "dimensionKey"(): $ResourceKey<($Level)>
set "blockState"(value: $BlockState$$Type)
get "typeData"(): $Map<(StringJS), (any)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "key"(): $ResourceKey<($Block)>
get "id"(): StringJS
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $LevelBlock implements $LevelBlock$$Interface {
 "getDrops"(entity: $Entity$$Type, heldItem: $ItemStack$$Type): $List<($ItemStack)>
 "getDrops"(): $List<($ItemStack)>
 "setEntityData"(tag: $CompoundTag$$Type): void
 "getCenterY"(): double
 "spawnLightning"(effectOnly: boolean, player: $ServerPlayer$$Type): void
 "spawnLightning"(): void
 "spawnLightning"(effectOnly: boolean): void
 "getPlayersInRadius"(radius: double): $EntityArrayList
 "getPlayersInRadius"(): $EntityArrayList
 "getDown"(): $LevelBlock
 "getUp"(): $LevelBlock
 "getNorth"(): $LevelBlock
 "getSouth"(): $LevelBlock
 "getWest"(): $LevelBlock
 "getEast"(): $LevelBlock
 "getEntityId"(): StringJS
 "mergeEntityData"(tag: $CompoundTag$$Type): void
 "getLight"(): integer
 "getSkyLight"(): integer
 "getBlockLight"(): integer
 "getCanSeeSky"(): boolean
 "spawnFireworks"(fireworks: $Fireworks$$Type, lifetime: integer): void
 "popItem"(item: $ItemStack$$Type): void
 "popItemFromFace"(item: $ItemStack$$Type, dir: $Direction$$Type): void
 "getBiomeId"(): $ResourceLocation
 "toBlockStateString"(): StringJS
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "getItem"(): $ItemStack
 "getDimension"(): $ResourceLocation
 "getLevel"(): $Level
 "getEntity"(): $BlockEntity
 "getY"(): integer
 "offset"(f: $Direction$$Type): $LevelBlock
 "offset"(x: integer, y: integer, z: integer): $LevelBlock
 "offset"(f: $Direction$$Type, d: integer): $LevelBlock
 "set"(block: $Block$$Type, properties: $Map$$Type<(never), (never)>, flags: integer): void
 "set"(block: $Block$$Type): void
 "set"(block: $Block$$Type, properties: $Map$$Type<(never), (never)>): void
 "getProperties"(): $Map<(StringJS), (StringJS)>
 "getX"(): integer
 "getZ"(): integer
 "getBlockState"(): $BlockState
 "getInventory"(facing: $Direction$$Type): $InventoryKJS
 "getInventory"(): $InventoryKJS
 "getBlock"(): $Block
 "getEntityData"(): $CompoundTag
 "getPos"(): $BlockPos
 "explode"(properties: $ExplosionProperties$$Type): $Explosion
 "getCenterX"(): double
 "getCenterZ"(): double
 "getDimensionKey"(): $ResourceKey<($Level)>
 "setBlockState"(state: $BlockState$$Type): void
 "setBlockState"(state: $BlockState$$Type, flags: integer): void
 "canSeeSkyFromBelowWater"(): boolean
 "getTypeData"(): $Map<(StringJS), (any)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getRegistry"(): $Registry<($Block)>
 "asHolder"(): $Holder<($Block)>
 "getKey"(): $ResourceKey<($Block)>
 "getId"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelBlock$$Type = ($LevelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelBlock$$Original = $LevelBlock;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent$Callback" {
import {$ChestMenuInventoryClickEvent, $ChestMenuInventoryClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent"

export interface $ChestMenuInventoryClickEvent$Callback$$Interface {

(event: $ChestMenuInventoryClickEvent): void
}

export class $ChestMenuInventoryClickEvent$Callback implements $ChestMenuInventoryClickEvent$Callback$$Interface {
 "onClick"(event: $ChestMenuInventoryClickEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuInventoryClickEvent$Callback$$Type = ((event: $ChestMenuInventoryClickEvent) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuInventoryClickEvent$Callback$$Original = $ChestMenuInventoryClickEvent$Callback;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeMappingRegistry" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"

export class $RecipeMappingRegistry implements $KubeEvent$$Interface {
constructor(storage: $RecipeSchemaStorage$$Type)

public "register"(name: StringJS, type: $ResourceLocation$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeMappingRegistry$$Type = ($RecipeMappingRegistry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeMappingRegistry$$Original = $RecipeMappingRegistry;}
declare module "dev.latvian.mods.kubejs.core.ClientPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction} from "net.minecraft.core.Direction"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$PlayerKJS$$Interface} from "dev.latvian.mods.kubejs.core.PlayerKJS"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ClientPlayerKJS$$Interface extends $PlayerKJS$$Interface {

(): $AttachedData$$Type<($Player$$Type)>
get "stats"(): $PlayerStatsJS
get "miningBlock"(): boolean
set "statusMessage"(value: $Component$$Type)
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "craftingGrid"(): $InventoryKJS
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "selectedSlot"(): integer
get "fake"(): boolean
set "selectedSlot"(value: integer)
get "mouseItem"(): $ItemStack
set "mouseItem"(value: $ItemStack$$Type)
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "saturation"(): float
set "saturation"(value: float)
set "xp"(value: integer)
get "xp"(): integer
set "xpLevel"(value: integer)
get "xpLevel"(): integer
get "openInventory"(): $AbstractContainerMenu
get "profile"(): $GameProfile
get "player"(): boolean
get "defaultMovementSpeed"(): double
set "defaultMovementSpeed"(value: double)
get "reachDistance"(): double
get "living"(): boolean
set "maxHealth"(value: float)
get "undead"(): boolean
get "potionEffects"(): $EntityPotionEffectsJS
get "mainHandItem"(): $ItemStack
set "mainHandItem"(value: $ItemStack$$Type)
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
get "headArmorItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
set "chestArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
set "legsArmorItem"(value: $ItemStack$$Type)
get "feetArmorItem"(): $ItemStack
set "feetArmorItem"(value: $ItemStack$$Type)
get "totalMovementSpeed"(): double
set "movementSpeedAddition"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
get "data"(): $AttachedData<($Player)>
get "name"(): $Component
get "displayName"(): $Component
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "server"(): $MinecraftServer
get "block"(): $LevelBlock
get "nbt"(): $CompoundTag
set "nbt"(value: $CompoundTag$$Type)
get "scriptType"(): $ScriptType
get "type"(): StringJS
get "item"(): $ItemStack
get "frame"(): boolean
get "monster"(): boolean
get "animal"(): boolean
get "ambientCreature"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
set "x"(value: double)
set "y"(value: double)
set "z"(value: double)
get "motionX"(): double
set "motionX"(value: double)
get "motionY"(): double
set "motionY"(value: double)
get "motionZ"(): double
set "motionZ"(value: double)
get "passengers"(): $EntityArrayList
get "teamId"(): StringJS
get "facing"(): $Direction
set "activePostShader"(value: $ResourceLocation$$Type)
get "persistentData"(): $CompoundTag
}

export class $ClientPlayerKJS implements $ClientPlayerKJS$$Interface {
 "isSelf"(): boolean
 "self"(): $Entity
 "notify"(notification: $NotificationToastData$$Type): void
 "getStats"(): $PlayerStatsJS
 "isMiningBlock"(): boolean
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "getCraftingGrid"(): $InventoryKJS
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "getSelectedSlot"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "isFake"(): boolean
 "sendInventoryUpdate"(): void
 "give"(item: $ItemStack$$Type): void
 "giveInHand"(item: $ItemStack$$Type): void
 "setSelectedSlot"(index: integer): void
 "getMouseItem"(): $ItemStack
 "setMouseItem"(item: $ItemStack$$Type): void
 "addFood"(f: integer, m: float): void
 "getFoodLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "getSaturation"(): float
 "setSaturation"(saturation: float): void
 "addExhaustion"(exhaustion: float): void
 "addXP"(xp: integer): void
 "addXPLevels"(l: integer): void
 "setXp"(xp: integer): void
 "getXp"(): integer
 "setXpLevel"(l: integer): void
 "getXpLevel"(): integer
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "spawn"(): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "damageHeldItem"(): void
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "getDefaultMovementSpeed"(): double
 "setDefaultMovementSpeed"(speed: double): void
 "getReachDistance"(): double
 "rayTrace"(): $KubeRayTraceResult
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "setMaxHealth"(hp: float): void
 "isUndead"(): boolean
 "getPotionEffects"(): $EntityPotionEffectsJS
 "swing"(): void
 "swing"(hand: $InteractionHand$$Type): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "getMainHandItem"(): $ItemStack
 "setMainHandItem"(item: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setOffHandItem"(item: $ItemStack$$Type): void
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "getTotalMovementSpeed"(): double
 "setMovementSpeedAddition"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "tell"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "getServer"(): $MinecraftServer
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "getNbt"(): $CompoundTag
 "setNbt"(nbt: $CompoundTag$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "getType"(): StringJS
 "getItem"(): $ItemStack
 "isFrame"(): boolean
 "isMonster"(): boolean
 "isAnimal"(): boolean
 "isAmbientCreature"(): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setX"(x: double): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "getMotionX"(): double
 "setMotionX"(x: double): void
 "getMotionY"(): double
 "setMotionY"(y: double): void
 "getMotionZ"(): double
 "setMotionZ"(z: double): void
 "setRotation"(yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "getTeamId"(): StringJS
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "getFacing"(): $Direction
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "attack"(hp: float): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientPlayerKJS$$Original = $ClientPlayerKJS;}
declare module "dev.latvian.mods.kubejs.script.ScriptFile" {
import {$ScriptFileInfo, $ScriptFileInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptFileInfo"
import {$ScriptPack, $ScriptPack$$Type} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$Comparable$$Interface} from "java.lang.Comparable"
import {$List} from "java.util.List"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptFile implements $Comparable$$Interface<($ScriptFile)> {
 "lastModified": long
 "lines": (StringJS)[]
readonly "pack": $ScriptPack
readonly "info": $ScriptFileInfo

constructor(pack: $ScriptPack$$Type, info: $ScriptFileInfo$$Type)

public "skipLoading"(): StringJS
public "getProperty"(s: StringJS, def: StringJS): StringJS
public "compareTo"(o: $ScriptFile$$Type): integer
public "compareTo"(o: any): integer
public "load"(): void
public "getProperties"(s: StringJS): $List<(StringJS)>
public "getPriority"(): integer
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptFile$$Type = ($ScriptFile);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptFile$$Original = $ScriptFile;}
declare module "dev.latvian.mods.kubejs.event.EventTargetType" {
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$EventTargetType$Transformer$$Type} from "dev.latvian.mods.kubejs.event.EventTargetType$Transformer"
import {$Enum} from "java.lang.Enum"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"

export class $EventTargetType<T> {
static readonly "STRING": $EventTargetType<(StringJS)>
static readonly "ID": $EventTargetType<($ResourceLocation)>
readonly "type": $Class<(T)>
static readonly "REGISTRY": $EventTargetType<($ResourceKey<($Registry<(never)>)>)>

public "toString"(factory: $EventTargetType$Transformer$$Type): $EventTargetType<(T)>
public "identity"(): $EventTargetType<(T)>
public static "create"<T>(type: $Class$$Type<(T)>): $EventTargetType<(T)>
public "transformer"(factory: $EventTargetType$Transformer$$Type): $EventTargetType<(T)>
public "validator"(validator: $Predicate$$Type<(any)>): $EventTargetType<(T)>
public static "fromEnum"<T extends $Enum<(object)>>(type: $Class$$Type<(T)>): $EventTargetType<(T)>
public static "registryKey"<T>(registry: $ResourceKey$$Type<($Registry<(T)>)>, type: $Class$$Type<(never)>): $EventTargetType<($ResourceKey<(T)>)>
public "describeType"(describeType: $TypeInfo$$Type): $EventTargetType<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventTargetType$$Type<T> = ($EventTargetType<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventTargetType$$Original<T> = $EventTargetType<(T)>;}
declare module "dev.latvian.mods.kubejs.net.NetworkKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a network packet is received.
 * 
 * Note that the behaviour of this event is depending on the **script type**.
 * 
 * In `server_scripts`, this event is invoked on the server side when a packet is received from a client.
 * 
 * In `client_scripts`, this event is invoked on the client side when a packet is received from the server.
 */
export class $NetworkKubeEvent implements $KubePlayerEvent$$Interface {
constructor(p: $Player$$Type, c: StringJS, d: $CompoundTag$$Type)

/**
 * The data of the packet.
 */
public "getData"(): $CompoundTag
/**
 * The player that sent the packet. Always `Minecraft.player` in `client_scripts`.
 */
public "getEntity"(): $LivingEntity
/**
 * The channel of the packet.
 */
public "getChannel"(): StringJS
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "data"(): $CompoundTag
get "entity"(): $LivingEntity
get "channel"(): StringJS
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkKubeEvent$$Type = ($NetworkKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetworkKubeEvent$$Original = $NetworkKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.RecipesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Pattern} from "java.util.regex.Pattern"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DocumentedRecipes} from "moe.wolfgirl.probejs.generated.DocumentedRecipes"
import {$Shaped} from "moe.wolfgirl.probejs.generated.schema.kubejs.Shaped"
import {$List$$Type} from "java.util.List"
import {$ServerScriptManager$$Type} from "dev.latvian.mods.kubejs.server.ServerScriptManager"
import {$Stonecutting} from "moe.wolfgirl.probejs.generated.schema.minecraft.Stonecutting"
import {$RecipeSchemaStorage} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeFunction} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$Stream} from "java.util.stream.Stream"
import {$SmithingTransform} from "moe.wolfgirl.probejs.generated.schema.minecraft.SmithingTransform"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Collection} from "java.util.Collection"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Smelting} from "moe.wolfgirl.probejs.generated.schema.minecraft.Smelting"
import {$Blasting} from "moe.wolfgirl.probejs.generated.schema.minecraft.Blasting"
import {$CampfireCooking} from "moe.wolfgirl.probejs.generated.schema.minecraft.CampfireCooking"
import {$Shapeless} from "moe.wolfgirl.probejs.generated.schema.kubejs.Shapeless"
import {$Smoking} from "moe.wolfgirl.probejs.generated.schema.minecraft.Smoking"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$SmithingTrim} from "moe.wolfgirl.probejs.generated.schema.minecraft.SmithingTrim"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$ResourceManager, $ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"

export class $RecipesKubeEvent implements $KubeEvent$$Interface {
readonly "smithingTrim": (template: $Ingredient$$Type, base: $Ingredient$$Type, addition: $Ingredient$$Type) => $SmithingTrim
readonly "addedRecipes": $Collection<($KubeRecipe)>
readonly "stonecutting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type) => $Stonecutting
readonly "shaped": (result: $ItemStack$$Type, pattern: $List$$Type<(StringJS)>, key: $Map$$Type<(character), ($Ingredient$$Type)>) => $Shaped
readonly "registries": $RegistryAccessContainer
readonly "removedRecipes": $Collection<($KubeRecipe)>
readonly "recipeSchemaStorage": $RecipeSchemaStorage
readonly "campfireCooking": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $CampfireCooking
readonly "shapeless": (result: $ItemStack$$Type, ingredients: $List$$Type<($Ingredient$$Type)>) => $Shapeless
readonly "blasting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $Blasting
readonly "smithing": (result: $ItemStack$$Type, template: $Ingredient$$Type, base: $Ingredient$$Type, addition: $Ingredient$$Type) => $SmithingTransform
readonly "ops": $RegistryOpsContainer
static readonly "CREATE_RECIPE_SKIP_ERROR": $Pattern
readonly "originalRecipes": $Map<($ResourceLocation), ($KubeRecipe)>
readonly "smoking": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $Smoking
static readonly "POST_SKIP_ERROR": $Pattern
readonly "resourceManager": $ResourceManager
readonly "smelting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $Smelting

constructor(manager: $ServerScriptManager$$Type, resourceManager: $ResourceManager$$Type)

public "takeId"(recipe: $KubeRecipe$$Type, prefix: StringJS, ids: StringJS): $ResourceLocation
public "getRecipeFunction"(id: StringJS): $RecipeTypeFunction
public "replaceInput"(filter: $RecipeFilter$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): void
public "replaceOutput"(filter: $RecipeFilter$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): void
public "addRecipe"(r: $KubeRecipe$$Type, json: boolean): $KubeRecipe
public "getRecipes"(): $DocumentedRecipes
public "recipeStream"(filter: $RecipeFilter$$Type): $Stream<($KubeRecipe)>
public "forEachRecipe"(filter: $RecipeFilter$$Type, consumer: $Consumer$$Type<($KubeRecipe)>): void
public "containsRecipe"(filter: $RecipeFilter$$Type): boolean
public "findRecipeIds"(filter: $RecipeFilter$$Type): $Collection<($ResourceLocation)>
public "printAllTypes"(): void
public "printExamples"(type: StringJS): void
public "countRecipes"(filter: $RecipeFilter$$Type): integer
public "findRecipes"(filter: $RecipeFilter$$Type): $Collection<($KubeRecipe)>
public "stage"(filter: $RecipeFilter$$Type, stage: StringJS): void
public "remove"(filter: $RecipeFilter$$Type): void
public "custom"(json: $JsonObject$$Type): $KubeRecipe
public "printTypes"(): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "recipes"(): $DocumentedRecipes
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipesKubeEvent$$Type = ($RecipesKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipesKubeEvent$$Original = $RecipesKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.special.ShapelessKubeJSRecipe$SerializerKJS" {
import {$ShapelessKubeJSRecipe} from "dev.latvian.mods.kubejs.recipe.special.ShapelessKubeJSRecipe"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$RecipeSerializer, $RecipeSerializer$$Type, $RecipeSerializer$$Interface} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $ShapelessKubeJSRecipe$SerializerKJS implements $RecipeSerializer$$Interface<($ShapelessKubeJSRecipe)> {
static readonly "CODEC": $MapCodec<($ShapelessKubeJSRecipe)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ShapelessKubeJSRecipe)>

constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ShapelessKubeJSRecipe)>
public "codec"(): $MapCodec<($ShapelessKubeJSRecipe)>
public static "register"<S extends $RecipeSerializer<(object)>, T extends $Recipe<(object)>>(arg0: StringJS, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapelessKubeJSRecipe$SerializerKJS$$Type = ($ShapelessKubeJSRecipe$SerializerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShapelessKubeJSRecipe$SerializerKJS$$Original = $ShapelessKubeJSRecipe$SerializerKJS;}
declare module "dev.latvian.mods.kubejs.core.BlockBuilderProvider" {
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockBuilderProvider$$Interface {
get "blockBuilder"(): $BlockBuilder
}

export class $BlockBuilderProvider implements $BlockBuilderProvider$$Interface {
 "getBlockBuilder"(): $BlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBuilderProvider$$Type = ($BlockBuilderProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBuilderProvider$$Original = $BlockBuilderProvider;}
declare module "dev.latvian.mods.kubejs.registry.BuilderBase" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Supplier$$Interface} from "java.util.function.Supplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $BuilderBase<T> implements $Supplier$$Interface<(T)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "getTranslationKeyGroup"(): StringJS
public "getBuilderTranslationKey"(): StringJS
/**
 * Combined method of formattedDisplayName().displayName(name).
 */
public "formattedDisplayName"(name: $Component$$Type): this
/**
 * Makes displayName() override language files.
 */
public "formattedDisplayName"(): this
/**
 * Adds a tag to this object, e.g. `minecraft:stone`.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): this
public "get"(): T
public "toString"(): StringJS
/**
 * Sets the display name for this object, e.g. `Stone`.
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$$Type): this
/**
 * Sets the translation key for this object, e.g. `block.minecraft.stone`.
 */
public "translationKey"(key: StringJS): this
get "translationKeyGroup"(): StringJS
get "builderTranslationKey"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuilderBase$$Type<T> = ($BuilderBase<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuilderBase$$Original<T> = $BuilderBase<(T)>;}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$SurviveCallback" {
import {$LevelReader, $LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $CropBlockBuilder$SurviveCallback$$Interface {

(state: $BlockState, reader: $LevelReader, pos: $BlockPos): boolean
}

export class $CropBlockBuilder$SurviveCallback implements $CropBlockBuilder$SurviveCallback$$Interface {
 "survive"(state: $BlockState$$Type, reader: $LevelReader$$Type, pos: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$SurviveCallback$$Type = ((state: $BlockState, reader: $LevelReader, pos: $BlockPos) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CropBlockBuilder$SurviveCallback$$Original = $CropBlockBuilder$SurviveCallback;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Info" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Record} from "java.lang.Record"

export class $ItemData$Info extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$Info)>

constructor(filter: $Ingredient$$Type, info: $List$$Type<($Component$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Ingredient
public "info"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$Info$$Type = ({"filter"?: $Ingredient$$Type, "info"?: $List$$Type<($Component$$Type)>}) | ([filter?: $Ingredient$$Type, info?: $List$$Type<($Component$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$Info$$Original = $ItemData$Info;}
declare module "dev.latvian.mods.kubejs.item.FoodEatenKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity eats food.
 */
export class $FoodEatenKubeEvent implements $KubeEntityEvent$$Interface {
constructor(e: $LivingEntity$$Type, is: $ItemStack$$Type)

/**
 * The food that was eaten.
 */
public "getItem"(): $ItemStack
/**
 * The entity that ate the food.
 */
public "getEntity"(): $Entity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoodEatenKubeEvent$$Type = ($FoodEatenKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoodEatenKubeEvent$$Original = $FoodEatenKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.FluidIngredientKJS" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Codec} from "com.mojang.serialization.Codec"
import {$FluidMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$SizedFluidIngredient} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FluidIngredientKJS$$Interface extends $WithCodec$$Interface, $FluidMatch$$Interface {
get "codec"(): $Codec<(never)>
}

export class $FluidIngredientKJS implements $FluidIngredientKJS$$Interface {
 "withAmount"(amount: integer): $SizedFluidIngredient
 "matches"(cx: $RecipeMatchContext$$Type, s: $FluidStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $FluidIngredient$$Type, exact: boolean): boolean
 "self"(): $FluidIngredient
 "getCodec"(): $Codec<(never)>
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredientKJS$$Type = ($FluidIngredientKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidIngredientKJS$$Original = $FluidIngredientKJS;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DirectionWrapper" {
import {$Map} from "java.util.Map"
import {$Direction} from "net.minecraft.core.Direction"
import {$EnumSet} from "java.util.EnumSet"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $DirectionWrapper$$Interface {
}

export class $DirectionWrapper implements $DirectionWrapper$$Interface {
static readonly "ALL": $Map<(StringJS), ($Direction)>
static readonly "DOWN": $Direction
static readonly "ALL_SET": $EnumSet<($Direction)>
static readonly "south": $Direction
static readonly "north": $Direction
static readonly "WEST": $Direction
static readonly "down": $Direction
static readonly "east": $Direction
static readonly "NORTH": $Direction
static readonly "west": $Direction
static readonly "EMPTY_SET": $EnumSet<($Direction)>
static readonly "VALUES": ($Direction)[]
static readonly "up": $Direction
static readonly "UP": $Direction
static readonly "SOUTH": $Direction
static readonly "NONE": ($Direction)[]
static readonly "EAST": $Direction

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionWrapper$$Type = ($DirectionWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectionWrapper$$Original = $DirectionWrapper;}
declare module "dev.latvian.mods.kubejs.block.custom.SlabBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $SlabBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "SLAB_TAGS": ($ResourceLocation)[]

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlabBlockBuilder$$Type = ($SlabBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlabBlockBuilder$$Original = $SlabBlockBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$NameCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $ItemBuilder$NameCallback$$Interface {

(itemStack: $ItemStack): $Component$$Type
}

export class $ItemBuilder$NameCallback implements $ItemBuilder$NameCallback$$Interface {
 "apply"(itemStack: $ItemStack$$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$NameCallback$$Type = ((itemStack: $ItemStack) => $Component$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$NameCallback$$Original = $ItemBuilder$NameCallback;}
declare module "dev.latvian.mods.kubejs.item.custom.ItemToolTierRegistryKubeEvent" {
import {$MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$Map, $Map$$Type} from "java.util.Map"
import {$KubeStartupEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"
import {$Record} from "java.lang.Record"
import {$Consumer$$Type} from "java.util.function.Consumer"

/**
 * Invoked when the game is starting up and the item tool tiers are being registered.
 */
export class $ItemToolTierRegistryKubeEvent extends $Record implements $KubeStartupEvent$$Interface {
constructor(tiers: $Map$$Type<(StringJS), ($Tier$$Type)>)

public "addBasedOnExisting"(id: StringJS, existing: StringJS, tier: $Consumer$$Type<($MutableToolTier)>): void
public "addExisting"(id: StringJS, tier: $Tier$$Type): void
public "tiers"(): $Map<(StringJS), ($Tier)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
/**
 * Adds a new tool tier.
 */
public "add"(id: StringJS, tier: $Consumer$$Type<($MutableToolTier)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemToolTierRegistryKubeEvent$$Type = ({"tiers"?: $Map$$Type<(StringJS), ($Tier$$Type)>}) | ([tiers?: $Map$$Type<(StringJS), ($Tier$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemToolTierRegistryKubeEvent$$Original = $ItemToolTierRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.registry.AdditionalObjectRegistry" {
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"

export interface $AdditionalObjectRegistry$$Interface {

(registry: $ResourceKey<($Registry<(T)>)>, builder: $BuilderBase<(T)>): void
}

export class $AdditionalObjectRegistry implements $AdditionalObjectRegistry$$Interface {
 "add"<T>(registry: $ResourceKey$$Type<($Registry<(T)>)>, builder: $BuilderBase$$Type<(T)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdditionalObjectRegistry$$Type = ((registry: $ResourceKey<($Registry<(T)>)>, builder: $BuilderBase<(T)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AdditionalObjectRegistry$$Original = $AdditionalObjectRegistry;}
declare module "dev.latvian.mods.kubejs.util.ClassWrapper" {
import {$CustomJavaToJsWrapper$$Interface} from "dev.latvian.mods.rhino.util.CustomJavaToJsWrapper"
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$Record} from "java.lang.Record"

export class $ClassWrapper<T> extends $Record implements $CustomJavaToJsWrapper$$Interface {
constructor(wrappedClass: $Class$$Type<(T)>)

public "wrappedClass"(): $Class<(T)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "convertJavaToJs"(scope: $Scriptable$$Type, staticType: $TypeInfo$$Type): $Scriptable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassWrapper$$Type<T> = ({"wrappedClass"?: $Class$$Type<(T)>}) | ([wrappedClass?: $Class$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClassWrapper$$Original<T> = $ClassWrapper<(T)>;}
declare module "dev.latvian.mods.kubejs.level.WrappedSpawner" {
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Either$$Type} from "com.mojang.datafixers.util.Either"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$Record} from "java.lang.Record"

export class $WrappedSpawner extends $Record {
constructor(entity: $Entity$$Type, block: $LevelBlock$$Type)

public "entity"(): $Entity
public "isWorldgen"(): boolean
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"(spawner: $Either$$Type<($BlockEntity$$Type), ($Entity$$Type)>): $WrappedSpawner
public "block"(): $LevelBlock
get "worldgen"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedSpawner$$Type = ({"entity"?: $Entity$$Type, "block"?: $LevelBlock$$Type}) | ([entity?: $Entity$$Type, block?: $LevelBlock$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WrappedSpawner$$Original = $WrappedSpawner;}
declare module "dev.latvian.mods.kubejs.entity.BeforeLivingEntityHurtKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$LivingDamageEvent$Pre$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDamageEvent$Pre"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before an entity is hurt by a damage source.
 */
export class $BeforeLivingEntityHurtKubeEvent implements $KubeLivingEntityEvent$$Interface {
constructor(event: $LivingDamageEvent$Pre$$Type)

public "setDamage"(damage: float): void
/**
 * The damage source.
 */
public "getSource"(): $DamageSource
/**
 * The entity that was hurt.
 */
public "getEntity"(): $LivingEntity
/**
 * The amount of damage.
 */
public "getDamage"(): float
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
set "damage"(value: float)
get "source"(): $DamageSource
get "entity"(): $LivingEntity
get "damage"(): float
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeforeLivingEntityHurtKubeEvent$$Type = ($BeforeLivingEntityHurtKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeforeLivingEntityHurtKubeEvent$$Original = $BeforeLivingEntityHurtKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.custom.WallBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $WallBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "WALL_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallBlockBuilder$$Type = ($WallBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallBlockBuilder$$Original = $WallBlockBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.AddInformationKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $AddInformationKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(filter: F, info: $List<($Component)>): void
}

export class $AddInformationKubeEvent<E, F> implements $AddInformationKubeEvent$$Interface {
 "add"(filter: F, info: $List$$Type<($Component$$Type)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddInformationKubeEvent$$Type<E, F> = ((filter: any, info: $List<($Component)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AddInformationKubeEvent$$Original<E, F> = $AddInformationKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.block.BlockBuilder" {
import {$BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$BlockRightClickedKubeEvent$$Type} from "dev.latvian.mods.kubejs.block.BlockRightClickedKubeEvent"
import {$MapColor$$Type} from "net.minecraft.world.level.material.MapColor"
import {$AfterEntityFallenOnBlockCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.AfterEntityFallenOnBlockCallback"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockBehaviour$Properties} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$NoteBlockInstrument$$Type} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$BlockDropSupplier$$Type} from "dev.latvian.mods.kubejs.block.drop.BlockDropSupplier"
import {$KubeDataGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function$$Type} from "java.util.function.Function"
import {$EntitySteppedOnBlockCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback"
import {$ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$CanBeReplacedCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.CanBeReplacedCallback"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockTintFunction$$Type} from "dev.latvian.mods.kubejs.block.BlockTintFunction"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback, $RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BlockEntityInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateRotateCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateRotateCallback"
import {$BlockStateModifyPlacementCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyPlacementCallback"
import {$BlockExplodedCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockExplodedCallback"
import {$ModelledBuilderBase} from "dev.latvian.mods.kubejs.registry.ModelledBuilderBase"
import {$BlockStateMirrorCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateMirrorCallback"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$EntityFallenOnBlockCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.EntityFallenOnBlockCallback"
import {$Registry} from "net.minecraft.core.Registry"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BlockStateModifyCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockBuilder extends $ModelledBuilderBase<($Block)> {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

public static "createShape"(boxes: $List$$Type<($AABB$$Type)>): $VoxelShape
/**
 * Makes the block require a tool to have drops when broken.
 */
public "requiresTool"(): this
/**
 * Makes the block require a tool to have drops when broken.
 */
public "requiresTool"(f: boolean): this
/**
 * Sets the hardness of the block. Defaults to 1.5.
 * 
 * Setting this to -1 will make the block unbreakable like bedrock.
 */
public "hardness"(h: float): this
public "transformObject"(obj: $Block$$Type): $Block
/**
 * Sets the blast resistance of the block. Defaults to 3.
 */
public "resistance"(r: float): this
/**
 * Set if the block can be replaced by something else.
 */
public "canBeReplaced"(callbackJS: $Predicate$$Type<($CanBeReplacedCallback)>): this
/**
 * Makes the block transparent.
 */
public "transparent"(b: boolean): this
/**
 * Makes the block unbreakable.
 */
public "unbreakable"(): this
/**
 * Sets the light level of the block. Defaults to 0 (no light).
 */
public "lightLevel"(light: float): this
/**
 * Set how fast you can walk on the block.
 * 
 * Any value above 1 will make you walk insanely fast as your speed is multiplied by this value each tick.
 * 
 * Recommended values are between 0.1 and 1, useful for mimicking soul sand or ice.
 */
public "speedFactor"(f: float): this
/**
 * Set how high you can jump on the block.
 */
public "jumpFactor"(f: float): this
/**
 * Sets the block's sound type. Defaults to wood.
 */
public "soundType"(m: $SoundType$$Type): this
/**
 * Sets random tick callback for this black.
 */
public "randomTick"(randomTickCallback: $Consumer$$Type<($RandomTickCallback)>): this
/**
 * Sets the block's map color. Defaults to NONE.
 */
public "mapColor"(m: $MapColor$$Type): this
/**
 * Makes the block suffocating.
 */
public "suffocating"(b: boolean): this
/**
 * Set the default state of the block.
 */
public "defaultState"(callbackJS: $Consumer$$Type<($BlockStateModifyCallback)>): this
/**
 * Set the callback used for determining how the block rotates
 */
public "rotateState"(callbackJS: $Consumer$$Type<($BlockStateRotateCallback)>): this
public "generateLootTable"(generator: $KubeDataGenerator$$Type): $LootTable
/**
 * 
 * @deprecated
 */
public "generateLootTable"(): $LootTable
/**
 * Set how slippery the block is.
 */
public "slipperiness"(f: float): this
/**
 * Makes the block not be solid.
 */
public "notSolid"(): this
/**
 * Makes mobs not spawn on the block.
 */
public "noValidSpawns"(b: boolean): this
/**
 * Makes the block view blocking.
 */
public "viewBlocking"(b: boolean): this
public "copyPropertiesFrom"(block: $Block$$Type): this
/**
 * Checks if the block can be waterlogged.
 */
public "canBeWaterlogged"(): boolean
/**
 * Helper method for setting the render type of the block to `cutout` correctly.
 */
public "defaultCutout"(): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tagBoth"(tag: ($ResourceLocation$$Type)[]): this
/**
 * Tags the block with the given tag.
 */
public "tagBlock"(tag: ($ResourceLocation$$Type)[]): this
/**
 * Set how this block bounces/moves entities that land on top of this. Do not use this to modify the block, use fallOn instead!
 * Use ctx.bounce(height) or ctx.setVelocity(x, y, z) to change the entities velocity.
 */
public "afterFallenOn"(callbackJS: $Consumer$$Type<($AfterEntityFallenOnBlockCallback)>): this
public "noSoundType"(): this
public "woodSoundType"(): this
public "stoneSoundType"(): this
public "gravelSoundType"(): this
public "grassSoundType"(): this
public "sandSoundType"(): this
public "cropSoundType"(): this
public "glassSoundType"(): this
/**
 * Sets the block's map color dynamically per block state. If unset, defaults to NONE.
 */
public "dynamicMapColor"(m: $Function$$Type<($BlockState), (any)>): this
/**
 * Set the block to have no corresponding item.
 */
public "noItem"(): this
/**
 * 
 * @deprecated
 */
public "setWaterlogged"(waterlogged: boolean): this
/**
 * 
 * @deprecated
 */
public "getWaterlogged"(): boolean
/**
 * Clears all drops for the block.
 */
public "noDrops"(): this
/**
 * Helper method for setting the render type of the block to `translucent` correctly.
 */
public "defaultTranslucent"(): this
/**
 * Set what happens when an entity steps on the block
 * This is called every tick for every entity standing on the block, so be careful what you do here.
 */
public "steppedOn"(callbackJS: $Consumer$$Type<($EntitySteppedOnBlockCallback)>): this
/**
 * Set what happens when an entity falls on the block. Do not use this for moving them, use bounce instead!
 */
public "fallenOn"(callbackJS: $Consumer$$Type<($EntityFallenOnBlockCallback)>): this
/**
 * Bounces entities that land on this block by bounciness * their fall velocity.
 * Do not make bounciness negative, as that is a recipe for a long and laggy trip to the void
 */
public "bounciness"(bounciness: float): this
/**
 * Set the callback used for determining how the block is mirrored
 */
public "mirrorState"(callbackJS: $Consumer$$Type<($BlockStateMirrorCallback)>): this
/**
 * Tags the item with the given tag.
 */
public "tagItem"(tag: ($ResourceLocation$$Type)[]): this
/**
 * Set how this block reacts after an explosion. Note the block has already been destroyed at this point
 */
public "exploded"(callbackJS: $Consumer$$Type<($BlockExplodedCallback)>): this
/**
 * Makes the block a redstone conductor.
 */
public "redstoneConductor"(b: boolean): this
/**
 * Modifies the block's item representation.
 */
public "item"(i: $Consumer$$Type<($ItemBuilder)>): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
/**
 * Sets the block should be a full block or not, like cactus or doors.
 */
public "fullBlock"(f: boolean): this
public "createProperties"(): $BlockBehaviour$Properties
/**
 * Add a blockstate property to the block.
 * 
 * For example, facing, lit, etc.
 */
public "property"(property: $Property$$Type<(never)>): this
/**
 * Set the color of a specific layer of the block.
 */
public "color"(index: integer, color: $BlockTintFunction$$Type): this
/**
 * Set the color of a specific layer of the block.
 */
public "color"(color: $BlockTintFunction$$Type): this
/**
 * Set the shape of the block.
 */
public "box"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double): this
/**
 * Set the shape of the block.
 */
public "box"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double, scale16: boolean): this
/**
 * Sets the display name for this object, e.g. `Stone`.
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$$Type): $BuilderBase<($Block)>
/**
 * Sets the opacity of the block. Opaque blocks do not let light through.
 */
public "opaque"(o: boolean): this
/**
 * Note block instrument.
 */
public "instrument"(i: $NoteBlockInstrument$$Type): this
/**
 * Makes the block can be waterlogged.
 */
public "waterlogged"(): this
/**
 * Set the callback for determining the blocks state when placed.
 */
public "placementState"(callbackJS: $Consumer$$Type<($BlockStateModifyPlacementCallback)>): this
/**
 * Change drops of this block
 */
public "drops"(drops: $BlockDropSupplier$$Type): this
/**
 * Makes the block not collide with entities.
 */
public "noCollision"(): this
/**
 * Sets the render type of the block. Can be `cutout`, `cutout_mipped`, `translucent`, or `basic`.
 */
public "renderType"(l: $BlockRenderType$$Type): this
/**
 * Creates a Block Entity for this block
 */
public "blockEntity"(callback: $Consumer$$Type<($BlockEntityInfo)>): this
/**
 * Set the callback used for right-clicking on the block
 */
public "rightClick"(callbackJS: $Consumer$$Type<($BlockRightClickedKubeEvent)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBuilder$$Type = ($BlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBuilder$$Original = $BlockBuilder;}
declare module "dev.latvian.mods.kubejs.component.AttributeModifierFunctions" {
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$List$$Type} from "java.util.List"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export interface $AttributeModifierFunctions$$Interface {

(): $ItemAttributeModifiers$$Type
get "attributeModifiers"(): $ItemAttributeModifiers
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
get "baseAttackDamage"(): double
get "baseAttackSpeed"(): double
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "attackSpeed"(value: double)
set "attackDamage"(value: double)
get "attackDamage"(): double
get "attackSpeed"(): double
set "baseAttackSpeed"(value: double)
set "baseAttackDamage"(value: double)
}

export class $AttributeModifierFunctions implements $AttributeModifierFunctions$$Interface {
 "getAttributeModifiers"(): $ItemAttributeModifiers
 "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "getBaseAttackDamage"(): double
 "getBaseAttackSpeed"(): double
 "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
 "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
 "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
 "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
 "setAttackSpeed"(speed: double): void
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
 "setAttackDamage"(dmg: double): void
 "getAttackDamage"(): double
 "getAttackSpeed"(): double
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
 "setBaseAttackSpeed"(speed: double): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
 "setBaseAttackDamage"(dmg: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeModifierFunctions$$Type = (() => $ItemAttributeModifiers$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttributeModifierFunctions$$Original = $AttributeModifierFunctions;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeScriptContext" {
import {$Context} from "dev.latvian.mods.rhino.Context"
import {$ErrorStack} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeValidationContext$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$RecipeMatchContext$$Interface} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$WithScriptContext$$Interface} from "dev.latvian.mods.kubejs.script.WithScriptContext"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$KubeRecipeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.KubeRecipeContext"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeScriptContext$$Interface extends $WithScriptContext$$Interface, $RecipeValidationContext$$Interface, $KubeRecipeContext$$Interface, $RecipeMatchContext$$Interface {
}

export class $RecipeScriptContext implements $RecipeScriptContext$$Interface {
 "cx"(): $Context
 "errors"(): $ErrorStack
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
 "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeScriptContext$$Type = ($RecipeScriptContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeScriptContext$$Original = $RecipeScriptContext;}
declare module "dev.latvian.mods.kubejs.color.KubeColor" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$TextColor} from "net.minecraft.network.chat.TextColor"

export interface $KubeColor$$Interface extends $SpecialEquality$$Interface {

(): integer
get "rgb"(): integer
get "argb"(): integer
get "fireworkRGB"(): integer
}

export class $KubeColor implements $KubeColor$$Interface {
static readonly "CODEC": $Codec<($KubeColor)>
static readonly "OPTIONAL_STREAM_CODEC": $StreamCodec<($ByteBuf), ($Optional<($KubeColor)>)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($KubeColor)>

 "getRgb"(): integer
 "getArgb"(): integer
 "getFireworkRGB"(): integer
 "toHexString"(): StringJS
 "serialize"(): StringJS
 "specialEquals"(o: any, shallow: boolean): boolean
 "createTextColor"(): $TextColor
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeColor$$Type = (("") | ("light_blue_dye") | ("blue_dye") | ("purple_dye") | ("dark_red") | ("lightgraydye") | ("dark_aqua") | ("none") | ("green_dye") | ("blackdye") | ("dark_blue") | ("red") | ("pink_dye") | ("aqua") | ("white") | ("white_dye") | ("dark_gray") | ("light_purple") | ("brown_dye") | ("black") | ("darkpurple") | ("lightbluedye") | ("limedye") | ("magenta_dye") | ("-") | ("lime_dye") | ("yellowdye") | ("graydye") | ("purpledye") | ("dark_purple") | ("orange_dye") | ("darkgray") | ("browndye") | ("yellow") | ("bluedye") | ("pinkdye") | ("cyandye") | ("gold") | ("gray") | ("blue") | ("darkblue") | ("transparent") | ("red_dye") | ("darkred") | ("greendye") | ("reddye") | ("gray_dye") | ("orangedye") | ("yellow_dye") | ("black_dye") | ("magentadye") | ("green") | ("light_gray_dye") | ("darkgreen") | ("dark_green") | ("lightpurple") | ("darkaqua") | ("cyan_dye") | ("whitedye")) | (`#${string}`) | (integer) | (() => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeColor$$Original = $KubeColor;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.AABBWrapper" {
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB} from "net.minecraft.world.phys.AABB"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $AABBWrapper$$Interface {
}

export class $AABBWrapper implements $AABBWrapper$$Interface {
static readonly "CUBE": $AABB
static readonly "EMPTY": $AABB

static "ofBlocks"(pos1: $BlockPos$$Type, pos2: $BlockPos$$Type): $AABB
static "ofBlock"(pos: $BlockPos$$Type): $AABB
static "wrap"(o: any): $AABB
static "of"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double): $AABB
static "ofSize"(vec3: $Vec3$$Type, x: double, y: double, z: double): $AABB
static "ofSize"(x: double, y: double, z: double): $AABB
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AABBWrapper$$Type = ($AABBWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AABBWrapper$$Original = $AABBWrapper;}
declare module "dev.latvian.mods.kubejs.util.RegistryAccessContainer" {
import {$OpsContainer} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$DynamicOps} from "com.mojang.serialization.DynamicOps"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$DamageSources} from "net.minecraft.world.damagesource.DamageSources"
import {$Holder} from "net.minecraft.core.Holder"
import {$RegistryWrapper} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.RegistryWrapper"
import {$RegistryAccess$Frozen, $RegistryAccess$Frozen$$Type} from "net.minecraft.core.RegistryAccess$Frozen"
import {$CachedItemTagLookup} from "dev.latvian.mods.kubejs.recipe.CachedItemTagLookup"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$ICondition$IContext$$Interface} from "net.neoforged.neoforge.common.conditions.ICondition$IContext"
import {$CachedTagLookup$Entry} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup$Entry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$CachedTagLookup} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"

export class $RegistryAccessContainer extends $RegistryOpsContainer implements $ICondition$IContext$$Interface {
static "current": $RegistryAccessContainer
 "cachedBlockTags": $CachedTagLookup<($Block)>
 "cachedFluidTags": $CachedTagLookup<($Fluid)>
 "cachedItemTags": $CachedItemTagLookup
static readonly "BUILTIN": $RegistryAccessContainer
readonly "cachedRegistryTags": $Map<($ResourceKey<(never)>), ($CachedTagLookup$Entry<(never)>)>
static readonly "DEFAULT": $OpsContainer

constructor(access: $RegistryAccess$Frozen$$Type)

public static "of"(): $RegistryAccessContainer
public "access"(): $RegistryAccess$Frozen
public "getAllTags"<T>(key: $ResourceKey$$Type<($Registry<(T)>)>): $Map<($ResourceLocation), ($Collection<($Holder<(T)>)>)>
public "damageSources"(): $DamageSources
public "cacheTags"<T>(registry: $Registry$$Type<(T)>, map: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>): void
public "wrapRegistry"(id: $ResourceLocation$$Type): $RegistryWrapper<(never)>
public "itemStackParseCache"(): $Map<(StringJS), ($ItemStack)>
public "getTag"<T>(arg0: $TagKey$$Type<(T)>): $Collection<($Holder<(T)>)>
public "java"(): $DynamicOps
public "json"(): $DynamicOps
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryAccessContainer$$Type = ($RegistryAccessContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryAccessContainer$$Original = $RegistryAccessContainer;}
declare module "dev.latvian.mods.kubejs.item.MutableToolTier" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Tool} from "net.minecraft.world.item.component.Tool"
import {$Tier, $Tier$$Type, $Tier$$Interface} from "net.minecraft.world.item.Tier"

export class $MutableToolTier implements $Tier$$Interface {
readonly "parent": $Tier

constructor(p: $Tier$$Type)

public "getEnchantmentValue"(): integer
public "getUses"(): integer
public "getIncorrectBlocksForDrops"(): $TagKey<($Block)>
public "getVanillaRepairIngredient"(): $Ingredient
public "setUses"(i: integer): void
public "getIncorrectBlocksForDropsTag"(): $ResourceLocation
public "setEnchantmentValue"(i: integer): void
public "setRepairIngredient"(arg0: $Ingredient$$Type): void
public "setIncorrectBlocksForDropsTag"(tag: $ResourceLocation$$Type): void
public "setAttackDamageBonus"(f: float): void
public "setSpeed"(f: float): void
public "getSpeed"(): float
public "getAttackDamageBonus"(): float
public "createToolProperties"(arg0: $TagKey$$Type<($Block)>): $Tool
get "enchantmentValue"(): integer
get "uses"(): integer
get "incorrectBlocksForDrops"(): $TagKey<($Block)>
get "vanillaRepairIngredient"(): $Ingredient
set "uses"(value: integer)
get "incorrectBlocksForDropsTag"(): $ResourceLocation
set "enchantmentValue"(value: integer)
set "repairIngredient"(value: $Ingredient$$Type)
set "incorrectBlocksForDropsTag"(value: $ResourceLocation$$Type)
set "attackDamageBonus"(value: float)
set "speed"(value: float)
get "speed"(): float
get "attackDamageBonus"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableToolTier$$Type = ($MutableToolTier);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MutableToolTier$$Original = $MutableToolTier;}
declare module "dev.latvian.mods.kubejs.block.FarmlandTrampledKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockEvent$FarmlandTrampleEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$FarmlandTrampleEvent"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity attempts to trample farmland.
 */
export class $FarmlandTrampledKubeEvent implements $KubeEntityEvent$$Interface {
constructor(event: $BlockEvent$FarmlandTrampleEvent$$Type)

/**
 * The farmland block.
 */
public "getBlock"(): $LevelBlock
/**
 * The level that the farmland and the entity are in.
 */
public "getLevel"(): $Level
/**
 * The entity that is attempting to trample the farmland.
 */
public "getEntity"(): $Entity
/**
 * The distance of the entity from the block.
 */
public "getDistance"(): float
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "block"(): $LevelBlock
get "level"(): $Level
get "entity"(): $Entity
get "distance"(): float
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FarmlandTrampledKubeEvent$$Type = ($FarmlandTrampledKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FarmlandTrampledKubeEvent$$Original = $FarmlandTrampledKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityTickKubeEvent" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $BlockEntityTickKubeEvent implements $KubeLevelEvent$$Interface {
constructor(entity: $KubeBlockEntity$$Type)

public "getCycle"(): integer
public "getTick"(): integer
public "getBlock"(): $LevelBlock
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "cycle"(): integer
get "tick"(): integer
get "block"(): $LevelBlock
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityTickKubeEvent$$Type = ($BlockEntityTickKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityTickKubeEvent$$Original = $BlockEntityTickKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeKey" {
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$ComponentRole, $ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$SequencedSet} from "java.util.SequencedSet"
import {$Codec} from "com.mojang.serialization.Codec"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"

export class $RecipeKey<T> {
 "excluded": boolean
readonly "codec": $Codec<(T)>
readonly "component": $RecipeComponent<(T)>
readonly "typeInfo": $TypeInfo
readonly "role": $ComponentRole
readonly "names": $SequencedSet<(StringJS)>
readonly "name": StringJS

constructor(component: $RecipeComponent$$Type<(T)>, name: StringJS, role: $ComponentRole$$Type)

public "alwaysWrite"(): $RecipeKey<(T)>
public "getPrimaryFunctionName"(): StringJS
public "getValidFunctionNames"(): $List<(StringJS)>
public "noFunctions"(): $RecipeKey<(T)>
public "defaultOptional"(): $RecipeKey<(T)>
public "exclude"(): $RecipeKey<(T)>
public "functionNames"(names: $List$$Type<(StringJS)>): $RecipeKey<(T)>
public "functionNames"(...names: (StringJS)[]): $RecipeKey<(T)>
public "toString"(): StringJS
public "hashCode"(): integer
public "optional"(): boolean
public "optional"(value: T): $RecipeKey<(T)>
public "optional"(value: $RecipeOptional$$Type<(T)>): $RecipeKey<(T)>
public "toJson"(storage: $RecipeSchemaStorage$$Type, type: $RecipeSchemaType$$Type, ops: $DynamicOps$$Type<($JsonElement$$Type)>): $JsonObject
public "alt"(name: StringJS): $RecipeKey<(T)>
public "alt"(...names: (StringJS)[]): $RecipeKey<(T)>
get "primaryFunctionName"(): StringJS
get "validFunctionNames"(): $List<(StringJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeKey$$Type<T> = ($RecipeKey<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeKey$$Original<T> = $RecipeKey<(T)>;}
declare module "dev.latvian.mods.kubejs.event.KubeStartupEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $KubeStartupEvent$$Interface extends $KubeEvent$$Interface {
}

export class $KubeStartupEvent implements $KubeStartupEvent$$Interface {
static readonly "BASIC": $KubeStartupEvent

/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeStartupEvent$$Type = ($KubeStartupEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeStartupEvent$$Original = $KubeStartupEvent;}
declare module "dev.latvian.mods.kubejs.core.SizedIngredientKJS" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ItemMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$SizedIngredient} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $SizedIngredientKJS$$Interface extends $Replaceable$$Interface, $IngredientSupplierKJS$$Interface, $ItemMatch$$Interface {
}

export class $SizedIngredientKJS implements $SizedIngredientKJS$$Interface {
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "kjs$asIngredient"(): $Ingredient
 "kjs$toFlatJson"(): $JsonElement
 "kjs$toNestedJson"(): $JsonElement
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, item: $ItemStack$$Type, exact: boolean): boolean
 "kjs$self"(): $SizedIngredient
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedIngredientKJS$$Type = ($SizedIngredientKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SizedIngredientKJS$$Original = $SizedIngredientKJS;}
declare module "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS" {
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScheduledEvents, $ScheduledEvents$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$ScheduledEvents$ScheduledEvent} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MinecraftEnvironmentKJS$$Interface extends $MessageSenderKJS$$Interface {

(): $ScheduledEvents$$Type
get "scheduledEvents"(): $ScheduledEvents
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export class $MinecraftEnvironmentKJS implements $MinecraftEnvironmentKJS$$Interface {
 "getScheduledEvents"(): $ScheduledEvents
 "schedule"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeating"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeatingInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "tell"(message: $Component$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftEnvironmentKJS$$Type = (() => $ScheduledEvents$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecraftEnvironmentKJS$$Original = $MinecraftEnvironmentKJS;}
declare module "dev.latvian.mods.kubejs.stages.StageCreationEvent" {
import {$ICancellableEvent$$Interface} from "net.neoforged.bus.api.ICancellableEvent"
import {$PlayerEvent} from "net.neoforged.neoforge.event.entity.player.PlayerEvent"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"

export class $StageCreationEvent extends $PlayerEvent implements $ICancellableEvent$$Interface {
public "getPlayerStages"(): $Stages
public "setPlayerStages"(s: $Stages$$Type): void
public "setCanceled"(arg0: boolean): void
public "isCanceled"(): boolean
public "getEntity"(): $Entity
get "playerStages"(): $Stages
set "playerStages"(value: $Stages$$Type)
set "canceled"(value: boolean)
get "canceled"(): boolean
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StageCreationEvent$$Type = ($StageCreationEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StageCreationEvent$$Original = $StageCreationEvent;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Group" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record} from "java.lang.Record"

export class $FluidData$Group extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$Group)>

constructor(filter: $FluidIngredient$$Type, groupId: $ResourceLocation$$Type, description: $Component$$Type)

public "groupId"(): $ResourceLocation
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "description"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$Group$$Type = ({"filter"?: $FluidIngredient$$Type, "groupId"?: $ResourceLocation$$Type, "description"?: $Component$$Type}) | ([filter?: $FluidIngredient$$Type, groupId?: $ResourceLocation$$Type, description?: $Component$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$Group$$Original = $FluidData$Group;}
declare module "dev.latvian.mods.kubejs.script.KubeJSContextFactory" {
import {$ContextFactory} from "dev.latvian.mods.rhino.ContextFactory"
import {$ScriptManager, $ScriptManager$$Type} from "dev.latvian.mods.kubejs.script.ScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSContextFactory extends $ContextFactory {
readonly "manager": $ScriptManager

constructor(manager: $ScriptManager$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSContextFactory$$Type = ($KubeJSContextFactory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSContextFactory$$Original = $KubeJSContextFactory;}
declare module "dev.latvian.mods.kubejs.recipe.special.ShapedKubeJSRecipe$SerializerKJS" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ShapedKubeJSRecipe} from "dev.latvian.mods.kubejs.recipe.special.ShapedKubeJSRecipe"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$RecipeSerializer, $RecipeSerializer$$Type, $RecipeSerializer$$Interface} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $ShapedKubeJSRecipe$SerializerKJS implements $RecipeSerializer$$Interface<($ShapedKubeJSRecipe)> {
static readonly "CODEC": $MapCodec<($ShapedKubeJSRecipe)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ShapedKubeJSRecipe)>

constructor()

public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), ($ShapedKubeJSRecipe)>
public "codec"(): $MapCodec<($ShapedKubeJSRecipe)>
public static "register"<S extends $RecipeSerializer<(object)>, T extends $Recipe<(object)>>(arg0: StringJS, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedKubeJSRecipe$SerializerKJS$$Type = ($ShapedKubeJSRecipe$SerializerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShapedKubeJSRecipe$SerializerKJS$$Original = $ShapedKubeJSRecipe$SerializerKJS;}
declare module "dev.latvian.mods.kubejs.player.PlayerChatReceivedKubeEvent" {
import {$ServerChatEvent$$Type} from "net.neoforged.neoforge.event.ServerChatEvent"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $PlayerChatReceivedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(event: $ServerChatEvent$$Type)

public "getEntity"(): $Player
public "getMessage"(): StringJS
public "getComponent"(): $Component
public "setComponent"(component: $Component$$Type): void
public "getUsername"(): StringJS
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "entity"(): $Player
get "message"(): StringJS
get "component"(): $Component
set "component"(value: $Component$$Type)
get "username"(): StringJS
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerChatReceivedKubeEvent$$Type = ($PlayerChatReceivedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerChatReceivedKubeEvent$$Original = $PlayerChatReceivedKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.SlotFilter" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Record} from "java.lang.Record"

export class $SlotFilter extends $Record {
static readonly "CODEC": $Codec<($SlotFilter)>
static readonly "TYPE_INFO": $TypeInfo
static readonly "EMPTY": $SlotFilter
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($SlotFilter)>

constructor(item: $Ingredient$$Type, index: integer)

public "checkFilter"(index: integer, stack: $ItemStack$$Type): boolean
public "item"(): $Ingredient
public "index"(): integer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "wrap"(o: any, target: $TypeInfo$$Type): $SlotFilter
public static "of"(ingredient: $Ingredient$$Type, index: integer): $SlotFilter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotFilter$$Type = ({"item"?: $Ingredient$$Type, "index"?: integer}) | ([item?: $Ingredient$$Type, index?: integer]) | ((integer) | ($Ingredient$$Type) | ({"item"?: $Ingredient$$Type, "index"?: integer}) | ([item?: $Ingredient$$Type, index?: integer]));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlotFilter$$Original = $SlotFilter;}
declare module "dev.latvian.mods.kubejs.misc.VillagerTypeBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$VillagerType} from "net.minecraft.world.entity.npc.VillagerType"

export class $VillagerTypeBuilder extends $BuilderBase<($VillagerType)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerTypeBuilder$$Type = ($VillagerTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VillagerTypeBuilder$$Original = $VillagerTypeBuilder;}
declare module "dev.latvian.mods.kubejs.block.BlockPickedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when player middle-clicks on a block.
 */
export class $BlockPickedKubeEvent implements $KubePlayerEvent$$Interface {
readonly "level": $Level
readonly "block": $LevelBlock
readonly "player": $Player

constructor(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, player: $Player$$Type, hitResult: $HitResult$$Type)

public "getLevel"(): $Level
public "getEntity"(): $LivingEntity
public "getTarget"(): $KubeRayTraceResult
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "entity"(): $LivingEntity
get "target"(): $KubeRayTraceResult
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPickedKubeEvent$$Type = ($BlockPickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPickedKubeEvent$$Original = $BlockPickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $VariantBlockStateGenerator$Model {
constructor()

public "uvlock"(): $VariantBlockStateGenerator$Model
public "model"(s: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
public "x"(x: integer): $VariantBlockStateGenerator$Model
public "y"(y: integer): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Model$$Type = ($VariantBlockStateGenerator$Model);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VariantBlockStateGenerator$Model$$Original = $VariantBlockStateGenerator$Model;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Hoe" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Hoe extends $DiggerItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
static readonly "HOE_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
static readonly "HOE_MODEL": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Hoe$$Type = ($DiggerItemBuilder$Hoe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Hoe$$Original = $DiggerItemBuilder$Hoe;}
declare module "dev.latvian.mods.kubejs.player.InventoryChangedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player's inventory changes.
 */
export class $InventoryChangedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(p: $Player$$Type, is: $ItemStack$$Type, s: integer)

/**
 * Gets the item that was changed.
 */
public "getItem"(): $ItemStack
/**
 * Gets the player that changed their inventory.
 */
public "getEntity"(): $LivingEntity
/**
 * Gets the slot that was changed.
 */
public "getSlot"(): integer
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "slot"(): integer
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryChangedKubeEvent$$Type = ($InventoryChangedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryChangedKubeEvent$$Original = $InventoryChangedKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType$Unit" {
import {$RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $RecipeComponentType$Unit<T> extends $RecipeComponentType<(T)> {
public "isUnit"(): boolean
public "instance"(): $RecipeComponent<(T)>
public "mapCodec"(ctx: $RecipeTypeRegistryContext$$Type): $MapCodec<($RecipeComponent<(never)>)>
get "unit"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentType$Unit$$Type<T> = ($RecipeComponentType$Unit<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentType$Unit$$Original<T> = $RecipeComponentType$Unit<(T)>;}
declare module "dev.latvian.mods.kubejs.misc.VillagerProfessionBuilder" {
import {$VillagerProfession} from "net.minecraft.world.entity.npc.VillagerProfession"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $VillagerProfessionBuilder extends $BuilderBase<($VillagerProfession)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "poiType"(t: $ResourceLocation$$Type): this
public "workSound"(t: $SoundEvent$$Type): this
public "secondaryPoi"(t: ($Block$$Type)[]): this
public "requestedItems"(t: ($Item$$Type)[]): this
public "poiTypeTag"(t: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerProfessionBuilder$$Type = ($VillagerProfessionBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VillagerProfessionBuilder$$Original = $VillagerProfessionBuilder;}
declare module "dev.latvian.mods.kubejs.core.SizedFluidIngredientKJS" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$FluidMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$SizedFluidIngredient} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $SizedFluidIngredientKJS$$Interface extends $Replaceable$$Interface, $FluidMatch$$Interface {
}

export class $SizedFluidIngredientKJS implements $SizedFluidIngredientKJS$$Interface {
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "toFlatJson"(): $JsonElement
 "toNestedJson"(): $JsonElement
 "matches"(cx: $RecipeMatchContext$$Type, s: $FluidStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $FluidIngredient$$Type, exact: boolean): boolean
 "self"(): $SizedFluidIngredient
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedFluidIngredientKJS$$Type = ($SizedFluidIngredientKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SizedFluidIngredientKJS$$Original = $SizedFluidIngredientKJS;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent" {
import {$ChestMenuSlot, $ChestMenuSlot$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuClickEvent {
readonly "button": integer
readonly "slot": $ChestMenuSlot
readonly "type": $ClickType

constructor(slot: $ChestMenuSlot$$Type, type: $ClickType$$Type, button: integer)

public "setHandled"(): void
get "handled"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickEvent$$Type = ($ChestMenuClickEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuClickEvent$$Original = $ChestMenuClickEvent;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper" {
import {$EventPriority$$Type} from "net.neoforged.bus.api.EventPriority"
import {$Event, $Event$$Type} from "net.neoforged.bus.api.Event"
import {$Class$$Type} from "java.lang.Class"
import {$Consumer$$Type} from "java.util.function.Consumer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $NativeEventWrapper$$Interface {
}

export class $NativeEventWrapper implements $NativeEventWrapper$$Interface {
static "onEvent"<T extends typeof $Event<(unknown)>>(eventClass: T, consumer: (event: InstanceType<(T)>) => void): void
static "onEvent"<T extends typeof $Event<(unknown)>>(priority: $EventPriority$$Type, eventClass: T, consumer: (event: InstanceType<(T)>) => void): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeEventWrapper$$Type = ($NativeEventWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NativeEventWrapper$$Original = $NativeEventWrapper;}
declare module "dev.latvian.mods.kubejs.core.FireworkRocketEntityKJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FireworkRocketEntityKJS$$Interface {

(lifetime: integer): void
set "lifetimeKJS"(value: integer)
}

export class $FireworkRocketEntityKJS implements $FireworkRocketEntityKJS$$Interface {
 "setLifetimeKJS"(lifetime: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireworkRocketEntityKJS$$Type = ((lifetime: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FireworkRocketEntityKJS$$Original = $FireworkRocketEntityKJS;}
declare module "dev.latvian.mods.kubejs.block.BlockLeftClickedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Direction} from "net.minecraft.core.Direction"
import {$PlayerInteractEvent$LeftClickBlock$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$LeftClickBlock"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player left clicks on a block.
 */
export class $BlockLeftClickedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(event: $PlayerInteractEvent$LeftClickBlock$$Type)

/**
 * The face of the block that was left clicked.
 */
public "getFacing"(): $Direction
/**
 * The item that was used to left click the block.
 */
public "getItem"(): $ItemStack
/**
 * The block that was left clicked.
 */
public "getBlock"(): $LevelBlock
/**
 * The player that left clicked the block.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "facing"(): $Direction
get "item"(): $ItemStack
get "block"(): $LevelBlock
get "entity"(): $LivingEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLeftClickedKubeEvent$$Type = ($BlockLeftClickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockLeftClickedKubeEvent$$Original = $BlockLeftClickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$FlowingFluid} from "net.minecraft.world.level.material.FlowingFluid"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FlowingFluidBuilder extends $BuilderBase<($FlowingFluid)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "fluidBuilder": $FluidBuilder
readonly "id": $ResourceLocation

constructor(b: $FluidBuilder$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlowingFluidBuilder$$Type = ($FlowingFluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlowingFluidBuilder$$Original = $FlowingFluidBuilder;}
declare module "dev.latvian.mods.kubejs.event.EventHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$EventGroup} from "dev.latvian.mods.kubejs.event.EventGroup"
import {$BaseFunction} from "dev.latvian.mods.rhino.BaseFunction"
import {$IEventHandler$$Type} from "dev.latvian.mods.kubejs.event.IEventHandler"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TargetedEventHandler} from "dev.latvian.mods.kubejs.event.TargetedEventHandler"
import {$Supplier} from "java.util.function.Supplier"
import {$ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$Class} from "java.lang.Class"
import {$ScriptTypePredicate} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$EventTargetType$$Type} from "dev.latvian.mods.kubejs.event.EventTargetType"
import {$EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"
import {$EventResult} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventHandler extends $BaseFunction {
static readonly "DONTENUM": integer
readonly "eventType": $Supplier<($Class<($KubeEvent)>)>
readonly "scriptTypePredicate": $ScriptTypePredicate
static readonly "CONST": integer
readonly "name": StringJS
static readonly "UNINITIALIZED_CONST": integer
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "PERMANENT": integer
readonly "group": $EventGroup

public "hasResult"(): $EventHandler
public "requiredTarget"<E>(type: $EventTargetType$$Type<(E)>): $TargetedEventHandler<(E)>
public "supportsTarget"<E>(type: $EventTargetType$$Type<(E)>): $TargetedEventHandler<(E)>
public "forEachListener"(type: $ScriptType$$Type, callback: $Consumer$$Type<($EventHandlerContainer)>): void
public "hasListeners"(): boolean
public "post"(event: $KubeEvent$$Type): $EventResult
public "post"(scriptType: $ScriptTypeHolder$$Type, event: $KubeEvent$$Type): $EventResult
public "toString"(): StringJS
public "listen"(type: $ScriptType$$Type, extraId: any, handler: $IEventHandler$$Type): void
public "call"(scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[]): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "getPrototype"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "getParentScope"(): $Scriptable
public "setParentScope"(arg0: $Scriptable$$Type): void
public "getAllIds"(): (any)[]
public "getIds"(): (any)[]
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
get "parentScope"(): $Scriptable
set "parentScope"(value: $Scriptable$$Type)
get "allIds"(): (any)[]
get "ids"(): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandler$$Type = ($EventHandler);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventHandler$$Original = $EventHandler;}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$SlotFilter, $SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$IngredientAction, $IngredientAction$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$Record} from "java.lang.Record"

export class $IngredientActionHolder extends $Record {
static readonly "LIST_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($List<($IngredientActionHolder)>)>
static readonly "CODEC": $Codec<($IngredientActionHolder)>
static readonly "LIST_CODEC": $Codec<($List<($IngredientActionHolder)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientActionHolder)>

constructor(action: $IngredientAction$$Type, filter: $SlotFilter$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $SlotFilter
public "action"(): $IngredientAction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientActionHolder$$Type = ({"filter"?: $SlotFilter$$Type, "action"?: $IngredientAction$$Type}) | ([filter?: $SlotFilter$$Type, action?: $IngredientAction$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientActionHolder$$Original = $IngredientActionHolder;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext" {
import {$ErrorStack, $ErrorStack$$Type} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeMatchContext$$Interface} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$KubeRecipeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.KubeRecipeContext"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeValidationContext$$Interface extends $KubeRecipeContext$$Interface, $RecipeMatchContext$$Interface {

(): $ErrorStack$$Type
}

export class $RecipeValidationContext implements $RecipeValidationContext$$Interface {
 "errors"(): $ErrorStack
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
 "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeValidationContext$$Type = (() => $ErrorStack$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeValidationContext$$Original = $RecipeValidationContext;}
declare module "dev.latvian.mods.kubejs.block.custom.ButtonOrPressurePlateBuilder" {
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"

export interface $ButtonOrPressurePlateBuilder$$Interface {
}

export class $ButtonOrPressurePlateBuilder implements $ButtonOrPressurePlateBuilder$$Interface {
 "ticksToStayPressed"(ticks: $TickDuration$$Type): this
 "behaviour"(behaviour: $BlockSetType$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonOrPressurePlateBuilder$$Type = ($ButtonOrPressurePlateBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ButtonOrPressurePlateBuilder$$Original = $ButtonOrPressurePlateBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.component.ComponentRole" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $ComponentRole extends $Enum<($ComponentRole)> implements $StringRepresentable$$Interface {
static readonly "OTHER": $ComponentRole
static readonly "INPUT": $ComponentRole
static readonly "CODEC": $Codec<($ComponentRole)>
static readonly "OUTPUT": $ComponentRole

public "isOutput"(): boolean
public "isInput"(): boolean
public "isOther"(): boolean
public static "values"(): ($ComponentRole)[]
public static "valueOf"(name: StringJS): $ComponentRole
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "output"(): boolean
get "input"(): boolean
get "other"(): boolean
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentRole$$Type = (("input") | ("output") | ("other"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentRole$$Original = $ComponentRole;}
declare module "dev.latvian.mods.kubejs.item.custom.ShearsItemBuilder" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ShearsItemBuilder extends $ItemBuilder {
 "sourceLine": $SourceLine
static readonly "SHEAR_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "speedBaseline"(f: float): this
public static "isCustomShears"(stack: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShearsItemBuilder$$Type = ($ShearsItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShearsItemBuilder$$Original = $ShearsItemBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor" {
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipePostProcessorType} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessorType"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"

export interface $RecipePostProcessor$$Interface {
}

export class $RecipePostProcessor implements $RecipePostProcessor$$Interface {
 "process"(ctx: $RecipeValidationContext$$Type, recipe: $KubeRecipe$$Type): void
 "type"(): $RecipePostProcessorType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipePostProcessor$$Type = ($RecipePostProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipePostProcessor$$Original = $RecipePostProcessor;}
declare module "dev.latvian.mods.kubejs.core.PlayerSelector" {
import {$UUID$$Type} from "java.util.UUID"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $PlayerSelector$$Interface {

(server: $MinecraftServer): $ServerPlayer$$Type
}

export class $PlayerSelector implements $PlayerSelector$$Interface {
static "fuzzyName"(name: StringJS): $PlayerSelector
 "or"(fallback: $PlayerSelector$$Type): $PlayerSelector
static "name"(name: StringJS): $PlayerSelector
static "wrap"(o: any): $PlayerSelector
static "identity"(player: $ServerPlayer$$Type): $PlayerSelector
static "uuid"(uuid: $UUID$$Type): $PlayerSelector
 "getPlayer"(server: $MinecraftServer$$Type): $ServerPlayer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerSelector$$Type = (StringJS) | ((server: $MinecraftServer) => $ServerPlayer$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerSelector$$Original = $PlayerSelector;}
declare module "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder" {
import {$BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$FluidType} from "net.neoforged.neoforge.fluids.FluidType"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$SoundAction$$Type} from "net.neoforged.neoforge.common.SoundAction"

export class $FluidTypeBuilder extends $BuilderBase<($FluidType)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "descriptionId"(descriptionId: StringJS): this
public "temperature"(temperature: integer): this
public "rarity"(rarity: $Rarity$$Type): this
public "canDrown"(canDrown: boolean): this
public "fallDistanceModifier"(fallDistanceModifier: float): this
public "canConvertToSource"(canConvertToSource: boolean): this
public "supportsBoating"(supportsBoating: boolean): this
public "pathType"(pathType: $PathType$$Type): this
public "adjacentPathType"(adjacentPathType: $PathType$$Type): this
public "lightLevel"(lightLevel: integer): this
public "viscosity"(viscosity: integer): this
public "stillTexture"(stillTexture: $ResourceLocation$$Type): this
public "flowingTexture"(flowingTexture: $ResourceLocation$$Type): this
public "screenOverlayTexture"(screenOverlayTexture: $ResourceLocation$$Type): this
public "blockOverlayTexture"(blockOverlayTexture: $ResourceLocation$$Type): this
public "density"(density: integer): this
public "sound"(action: $SoundAction$$Type, sound: $SoundEvent$$Type): this
public "addDripstoneDripping"(chance: float, dripParticle: $ParticleOptions$$Type, cauldron: $Block$$Type, fillSound: $SoundEvent$$Type): this
public "motionScale"(motionScale: double): this
public "canPushEntity"(canPushEntity: boolean): this
public "canSwim"(canSwim: boolean): this
public "canExtinguish"(canExtinguish: boolean): this
public "canHydrate"(canHydrate: boolean): this
public "renderType"(renderType: $BlockRenderType$$Type): this
public "tint"(tint: $KubeColor$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTypeBuilder$$Type = ($FluidTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTypeBuilder$$Original = $FluidTypeBuilder;}
declare module "dev.latvian.mods.kubejs.registry.CustomBuilderObject" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CustomBuilderObject extends $BuilderBase {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type, object: $Supplier$$Type<(any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomBuilderObject$$Type = ($CustomBuilderObject);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomBuilderObject$$Original = $CustomBuilderObject;}
declare module "dev.latvian.mods.kubejs.script.WithScriptContext" {
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WithScriptContext$$Interface {

(): $Context$$Type
}

export class $WithScriptContext implements $WithScriptContext$$Interface {
 "cx"(): $Context
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithScriptContext$$Type = (() => $Context$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithScriptContext$$Original = $WithScriptContext;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData" {
import {$ItemData, $ItemData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CategoryData, $CategoryData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.CategoryData"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$FluidData, $FluidData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData"
import {$Record} from "java.lang.Record"

export class $RecipeViewerData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($RecipeViewerData)>

constructor(removedCategories: $List$$Type<($ResourceLocation$$Type)>, removedGlobalRecipes: $List$$Type<($ResourceLocation$$Type)>, categoryData: $List$$Type<($CategoryData$$Type)>, itemData: $ItemData$$Type, fluidData: $FluidData$$Type)

public "removedGlobalRecipes"(): $List<($ResourceLocation)>
public "categoryData"(): $List<($CategoryData)>
public "removedCategories"(): $List<($ResourceLocation)>
public "itemData"(): $ItemData
public "fluidData"(): $FluidData
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $RecipeViewerData
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeViewerData$$Type = ({"fluidData"?: $FluidData$$Type, "removedGlobalRecipes"?: $List$$Type<($ResourceLocation$$Type)>, "removedCategories"?: $List$$Type<($ResourceLocation$$Type)>, "categoryData"?: $List$$Type<($CategoryData$$Type)>, "itemData"?: $ItemData$$Type}) | ([fluidData?: $FluidData$$Type, removedGlobalRecipes?: $List$$Type<($ResourceLocation$$Type)>, removedCategories?: $List$$Type<($ResourceLocation$$Type)>, categoryData?: $List$$Type<($CategoryData$$Type)>, itemData?: $ItemData$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeViewerData$$Original = $RecipeViewerData;}
declare module "dev.latvian.mods.kubejs.core.ItemEntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$EntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemEntityKJS$$Interface extends $EntityKJS$$Interface {
get "lifespan"(): integer
set "lifespan"(value: integer)
get "defaultPickUpDelay"(): void
get "noPickUpDelay"(): void
get "infinitePickUpDelay"(): void
get "noDespawn"(): void
get "ticksUntilDespawn"(): integer
set "ticksUntilDespawn"(value: integer)
get "item"(): $ItemStack
get "name"(): $Component
get "displayName"(): $Component
get "living"(): boolean
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "server"(): $MinecraftServer
get "block"(): $LevelBlock
get "nbt"(): $CompoundTag
set "nbt"(value: $CompoundTag$$Type)
get "scriptType"(): $ScriptType
get "type"(): StringJS
get "profile"(): $GameProfile
get "player"(): boolean
get "frame"(): boolean
get "monster"(): boolean
get "animal"(): boolean
get "ambientCreature"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
set "x"(value: double)
set "y"(value: double)
set "z"(value: double)
get "motionX"(): double
set "motionX"(value: double)
get "motionY"(): double
set "motionY"(value: double)
get "motionZ"(): double
set "motionZ"(value: double)
get "passengers"(): $EntityArrayList
get "teamId"(): StringJS
get "facing"(): $Direction
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $ItemEntityKJS implements $ItemEntityKJS$$Interface {
 "getLifespan"(): integer
 "setLifespan"(lifespan: integer): void
 "setDefaultPickUpDelay"(): void
 "setNoPickUpDelay"(): void
 "setInfinitePickUpDelay"(): void
 "setNoDespawn"(): void
 "getTicksUntilDespawn"(): integer
 "setTicksUntilDespawn"(ticks: integer): void
 "self"(): $Entity
 "getItem"(): $ItemStack
 "tell"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "getServer"(): $MinecraftServer
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "getNbt"(): $CompoundTag
 "setNbt"(nbt: $CompoundTag$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "getType"(): StringJS
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "isFrame"(): boolean
 "isMonster"(): boolean
 "isAnimal"(): boolean
 "isAmbientCreature"(): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setX"(x: double): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "getMotionX"(): double
 "setMotionX"(x: double): void
 "getMotionY"(): double
 "setMotionY"(y: double): void
 "getMotionZ"(): double
 "setMotionZ"(z: double): void
 "setRotation"(yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "getTeamId"(): StringJS
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "getFacing"(): $Direction
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "spawn"(): void
 "attack"(hp: float): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEntityKJS$$Type = ($ItemEntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemEntityKJS$$Original = $ItemEntityKJS;}
declare module "dev.latvian.mods.kubejs.player.StageChangedEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $StageChangedEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, stages: $Stages$$Type, stage: StringJS)

public "getEntity"(): $LivingEntity
public "getPlayerStages"(): $Stages
public "getStage"(): StringJS
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "entity"(): $LivingEntity
get "playerStages"(): $Stages
get "stage"(): StringJS
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StageChangedEvent$$Type = ($StageChangedEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StageChangedEvent$$Original = $StageChangedEvent;}
declare module "dev.latvian.mods.kubejs.player.KubeJSInventoryListener" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ContainerListener$$Interface} from "net.minecraft.world.inventory.ContainerListener"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"

export class $KubeJSInventoryListener implements $ContainerListener$$Interface {
readonly "player": $Player

constructor(p: $Player$$Type)

public "slotChanged"(container: $AbstractContainerMenu$$Type, index: integer, stack: $ItemStack$$Type): void
public "dataChanged"(container: $AbstractContainerMenu$$Type, id: integer, value: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSInventoryListener$$Type = ($KubeJSInventoryListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSInventoryListener$$Original = $KubeJSInventoryListener;}
declare module "dev.latvian.mods.kubejs.entity.CheckLivingEntitySpawnKubeEvent" {
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$MobSpawnType, $MobSpawnType$$Type} from "net.minecraft.world.entity.MobSpawnType"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Either$$Type} from "com.mojang.datafixers.util.Either"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$WrappedSpawner} from "dev.latvian.mods.kubejs.level.WrappedSpawner"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before an entity is spawned into the world.
 * 
 * Only entities from a `BaseSpawner` or world generation will trigger this event.
 */
export class $CheckLivingEntitySpawnKubeEvent implements $KubeLivingEntityEvent$$Interface {
readonly "x": double
readonly "y": double
readonly "z": double

constructor(entity: $LivingEntity$$Type, level: $Level$$Type, x: double, y: double, z: double, type: $MobSpawnType$$Type, spawnerEither: $Either$$Type<($BlockEntity$$Type), ($Entity$$Type)>)

/**
 * The spawner that spawned the entity.
 */
public "getSpawner"(): $WrappedSpawner
/**
 * The block the entity is being spawned on.
 */
public "getBlock"(): $LevelBlock
/**
 * The level the entity is being spawned into.
 */
public "getLevel"(): $Level
/**
 * The entity being spawned.
 */
public "getEntity"(): $Entity
/**
 * The type of spawn.
 */
public "getType"(): $MobSpawnType
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "spawner"(): $WrappedSpawner
get "block"(): $LevelBlock
get "level"(): $Level
get "entity"(): $Entity
get "type"(): $MobSpawnType
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CheckLivingEntitySpawnKubeEvent$$Type = ($CheckLivingEntitySpawnKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CheckLivingEntitySpawnKubeEvent$$Original = $CheckLivingEntitySpawnKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.BlockEntityRendererRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityRendererProvider$$Type} from "net.minecraft.client.renderer.blockentity.BlockEntityRendererProvider"
import {$EntityRenderersEvent$RegisterRenderers$$Type} from "net.neoforged.neoforge.client.event.EntityRenderersEvent$RegisterRenderers"
import {$Minecraft} from "net.minecraft.client.Minecraft"

export class $BlockEntityRendererRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $EntityRenderersEvent$RegisterRenderers$$Type)

public "register"(type: $BlockEntityType$$Type<(never)>, renderer: $BlockEntityRendererProvider$$Type): void
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityRendererRegistryKubeEvent$$Type = ($BlockEntityRendererRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityRendererRegistryKubeEvent$$Original = $BlockEntityRendererRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.drop.BlockDropSupplier" {
import {$BlockDrops, $BlockDrops$$Type} from "dev.latvian.mods.kubejs.block.drop.BlockDrops"

export interface $BlockDropSupplier$$Interface {

(): $BlockDrops$$Type
}

export class $BlockDropSupplier implements $BlockDropSupplier$$Interface {
static readonly "NO_DROPS": $BlockDropSupplier

 "get"(): $BlockDrops
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDropSupplier$$Type = (() => $BlockDrops$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockDropSupplier$$Original = $BlockDropSupplier;}
declare module "dev.latvian.mods.kubejs.item.custom.SmithingTemplateItemBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $SmithingTemplateItemBuilder extends $ItemBuilder {
 "ingredientsText": $Component
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "appliesToText": $Component
readonly "ingredientsSlotEmptyIcons": $List<($ResourceLocation)>
 "appliesToSlotDescriptionText": $Component
readonly "appliesToEmptyIcons": $List<($ResourceLocation)>
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "ingredientSlotDescriptionText": $Component

constructor(i: $ResourceLocation$$Type)

/**
 * Sets the description text that shows in the item tooltip to describe what ingredients can be added.
 * Using 'Ingots & Crystals' or 'Netherite Ingot' will use the vanilla language keys so it is translated into other languages automatically.
 * THIS IS PURELY VISUAL
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientsText` field.
 */
public "ingredients"(text: StringJS): this
/**
 * Sets the description text that shows in the item tooltip to describe what it can be applied to.
 * Using 'Armor' or 'Diamond Equipment' will use the vanilla language keys so it is translated into other languages automatically.
 * THIS IS PURELY VISUAL
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientsText` field.
 */
public "appliesTo"(text: StringJS): this
/**
 * Adds an ingot, dust, diamond, emerald, quartz, lapis lazuli and amethyst shard icons to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "ingotAndCrystalIcons"(): this
/**
 * Adds a dust, diamond, emerald, quartz, lapis lazuli and amethyst shard icons to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "crystalIcons"(): this
/**
 * Adds an ingot to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "ingotIcon"(): this
/**
 * Adds a dust to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "dustIcon"(): this
/**
 * Adds an amethyst shard to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "shardIcon"(): this
/**
 * Adds a diamond to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "diamondIcon"(): this
/**
 * Adds an emerald to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "emeraldIcon"(): this
/**
 * Adds a quartz to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "quartzIcon"(): this
/**
 * Adds a lapis lazuli to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "lapisIcon"(): this
/**
 * Adds a sword to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "swordIcon"(): this
/**
 * Adds a shovel to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "shovelIcon"(): this
/**
 * Adds a axe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "axeIcon"(): this
/**
 * Adds a pickaxe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "pickaxeIcon"(): this
/**
 * Adds a hoe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "hoeIcon"(): this
/**
 * Adds a helmet to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "helmetIcon"(): this
/**
 * Adds a chestplate to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "chestplateIcon"(): this
/**
 * Adds leggings to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "leggingsIcon"(): this
/**
 * Adds boots to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "bootsIcon"(): this
/**
 * Adds the specified texture location to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "addIngredientsSlotIcon"(location: $ResourceLocation$$Type): this
/**
 * Adds the specified texture location to the list of base slot icons that the smithing table cycles through when this smithing template is put in.
 */
public "addAppliesToSlotIcon"(location: $ResourceLocation$$Type): this
/**
 * Sets the description text that shows when you hover over the base item slot when this item is put in smithing table as a template.
 * Using 'Add a piece of armor' or 'Add diamond armor, weapon, or tool' will use the vanilla language keys so it is translated into other languages automatically.
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `appliesToSlotDescriptionText` field.
 */
public "appliesToSlotDescription"(text: StringJS): this
/**
 * Sets the description text that shows when you hover over the ingredient slot when this item is put in smithing table as a template.
 * Using 'Add ingot or crystal' or 'Add Netherite Ingot' will use the vanilla language keys so it is translated into other languages automatically.
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientSlotDescriptionText` field.
 */
public "ingredientsSlotDescription"(text: StringJS): this
/**
 * Adds all armor icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "armorIcons"(): this
/**
 * Adds all armor and basic tool icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "equipmentIcons"(): this
/**
 * Adds all basic tool icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "toolIcons"(): this
/**
 * Sets the name for this smithing template.
 * Note that the normal display name for all smithing templates is the same and cannot be changed, this instead sets the name in the tooltip (see vanilla smithing templates for what this looks like).
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$$Type): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmithingTemplateItemBuilder$$Type = ($SmithingTemplateItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmithingTemplateItemBuilder$$Original = $SmithingTemplateItemBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemPickedUpKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player picks up an item. Cancelling (in `ItemEvents.canPickUp`) will prevent the item from being picked up.
 */
export class $ItemPickedUpKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, entity: $ItemEntity$$Type, stack: $ItemStack$$Type)

/**
 * The item entity that was picked up.
 */
public "getItemEntity"(): $ItemEntity
/**
 * The item that was picked up.
 */
public "getItem"(): $ItemStack
/**
 * The player that picked up the item.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "itemEntity"(): $ItemEntity
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPickedUpKubeEvent$$Type = ($ItemPickedUpKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemPickedUpKubeEvent$$Original = $ItemPickedUpKubeEvent;}
declare module "dev.latvian.mods.kubejs.text.action.TextAction" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$TooltipActionType} from "dev.latvian.mods.kubejs.text.action.TooltipActionType"
import {$Map} from "java.util.Map"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

export interface $TextAction$$Interface {
}

export class $TextAction implements $TextAction$$Interface {
static readonly "MAP": $Map<(integer), ($TooltipActionType<(never)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($TextAction)>

 "type"(): $TooltipActionType<(never)>
 "apply"(lines: $List$$Type<($Component$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextAction$$Type = ($TextAction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextAction$$Original = $TextAction;}
declare module "dev.latvian.mods.kubejs.fluid.FluidBuilder" {
import {$BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$FluidBucketItemBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$FlowingFluid} from "net.minecraft.world.level.material.FlowingFluid"
import {$FluidBlockBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$FluidTypeBuilder, $FluidTypeBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$FlowingFluidBuilder} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$BaseFlowingFluid$Properties} from "net.neoforged.neoforge.fluids.BaseFlowingFluid$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FluidBuilder extends $BuilderBase<($FlowingFluid)> {
static readonly "WATER_COLOR": $KubeColor
 "bucketItem": $FluidBucketItemBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "flowingFluid": $FlowingFluidBuilder
 "sourceLine": $SourceLine
 "fluidType": $FluidTypeBuilder
 "block": $FluidBlockBuilder
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "stillTexture"(id: $ResourceLocation$$Type): this
public "flowingTexture"(id: $ResourceLocation$$Type): this
public "noBlock"(): this
public "noBucket"(): this
public "explosionResistance"(explosionResistance: float): this
public "tickRate"(tickRate: integer): this
public "slopeFindDistance"(slopeFindDistance: integer): this
public "levelDecreasePerBlock"(levelDecreasePerBlock: integer): this
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase<($FlowingFluid)>
public "type"(builder: $Consumer$$Type<($FluidTypeBuilder)>): this
public "createProperties"(): $BaseFlowingFluid$Properties
public "displayName"(name: $Component$$Type): $BuilderBase<($FlowingFluid)>
public "translucent"(): this
public "renderType"(l: $BlockRenderType$$Type): this
public "tint"(c: $KubeColor$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBuilder$$Type = ($FluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidBuilder$$Original = $FluidBuilder;}
declare module "dev.latvian.mods.kubejs.player.ChestKubeEvent" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container} from "net.minecraft.world.Container"
import {$InventoryKubeEvent} from "dev.latvian.mods.kubejs.player.InventoryKubeEvent"
import {$AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"

/**
 * Invoked when a player opens a chest.
 * 
 * Same as `PlayerEvents.inventoryOpened`, but only for chests.
 */
export class $ChestKubeEvent extends $InventoryKubeEvent {
constructor(player: $Player$$Type, menu: $AbstractContainerMenu$$Type)

/**
 * Gets the chest block.
 */
public "getBlock"(): $LevelBlock
/**
 * Gets the chest inventory.
 */
public "getInventory"(): $Container
/**
 * Gets the player that opened or closed the container.
 */
public "getEntity"(): $LivingEntity
get "block"(): $LevelBlock
get "inventory"(): $Container
get "entity"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestKubeEvent$$Type = ($ChestKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestKubeEvent$$Original = $ChestKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.JsonIO" {
import {$Map} from "java.util.Map"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$DataOutputStream$$Type} from "java.io.DataOutputStream"
import {$Path$$Type} from "java.nio.file.Path"
import {$JsonArray} from "com.google.gson.JsonArray"

export class $JsonIO {
constructor()

public static "getJsonHashString"(json: $JsonElement$$Type): StringJS
public static "toPrettyString"(json: $JsonElement$$Type): StringJS
public static "parseRaw"(string: StringJS): $JsonElement
public static "writeJsonHash"(stream: $DataOutputStream$$Type, element: $JsonElement$$Type): void
public static "getJsonHashBytes"(json: $JsonElement$$Type): (byte)[]
public static "readString"(path: $Path$$Type): StringJS
public static "toString"(json: $JsonElement$$Type): StringJS
public static "toArray"(element: $JsonElement$$Type): $JsonArray
public static "write"(path: $Path$$Type, json: $JsonElement$$Type): void
public static "read"(path: $Path$$Type): $Map<(never), (never)>
public static "parse"(string: StringJS): any
public static "toPrimitive"(element: $JsonElement$$Type): any
public static "toObject"(json: $JsonElement$$Type): any
public static "readJson"(path: $Path$$Type): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonIO$$Type = ($JsonIO);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JsonIO$$Original = $JsonIO;}
declare module "dev.latvian.mods.kubejs.client.KubeSessionData" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$List} from "java.util.List"
import {$KubeServerData$$Type} from "dev.latvian.mods.kubejs.net.KubeServerData"
import {$ClientPacketListener$$Type} from "net.minecraft.client.multiplayer.ClientPacketListener"
import {$Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$ItemTooltipData} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$RecipeViewerData} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"

export class $KubeSessionData {
 "activePostShader": $ResourceLocation
 "itemTooltips": $List<($ItemTooltipData)>
 "recipeViewerData": $RecipeViewerData

constructor()

public static "of"(mc: $Minecraft$$Type): $KubeSessionData
public static "of"(listener: $ClientPacketListener$$Type): $KubeSessionData
public "sync"(data: $KubeServerData$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeSessionData$$Type = ($KubeSessionData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeSessionData$$Original = $KubeSessionData;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$DataComponentSubtypes" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record} from "java.lang.Record"

export class $FluidData$DataComponentSubtypes extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$DataComponentSubtypes)>

constructor(filter: $FluidIngredient$$Type, components: $List$$Type<($DataComponentType$$Type<(never)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "components"(): $List<($DataComponentType<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$DataComponentSubtypes$$Type = ({"filter"?: $FluidIngredient$$Type, "components"?: $List$$Type<($DataComponentType$$Type<(never)>)>}) | ([filter?: $FluidIngredient$$Type, components?: $List$$Type<($DataComponentType$$Type<(never)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$DataComponentSubtypes$$Original = $FluidData$DataComponentSubtypes;}
declare module "dev.latvian.mods.kubejs.recipe.KubeRecipe" {
import {$CustomJavaToJsWrapper$$Interface} from "dev.latvian.mods.rhino.util.CustomJavaToJsWrapper"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeSchema} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$List} from "java.util.List"
import {$RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeLikeKJS$$Interface} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$RecipeComponentValue} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeFunction} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$ErrorStack$$Type} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$IngredientAction$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $KubeRecipe implements $RecipeLikeKJS$$Interface, $CustomJavaToJsWrapper$$Interface {
 "newRecipe": boolean
 "sourceLine": $SourceLine
 "originalJson": $JsonObject
 "removed": boolean
 "creationError": boolean
static readonly "TYPE_INFO": $TypeInfo
 "json": $JsonObject
static readonly "CHANGED_MARKER": StringJS
 "type": $RecipeTypeFunction
 "changed": boolean

constructor()

public "afterLoaded"(cx: $RecipeValidationContext$$Type): void
public "afterLoaded"(stack: $ErrorStack$$Type): void
public "inputValues"(): ($RecipeComponentValue<(never)>)[]
public "outputValues"(): ($RecipeComponentValue<(never)>)[]
public "getSerializationTypeFunction"(): $RecipeTypeFunction
public "getFromToString"(): StringJS
public "ingredientAction"(filter: $SlotFilter$$Type, action: $IngredientAction$$Type): $KubeRecipe
public "damageIngredient"(filter: $SlotFilter$$Type, damage: integer): $KubeRecipe
public "damageIngredient"(filter: $SlotFilter$$Type): $KubeRecipe
public "serializeChanges"(): $KubeRecipe
public "getOriginalRecipeResult"(): $ItemStack
public "getOriginalRecipeIngredients"(): $List<($Ingredient)>
public "replaceIngredient"(filter: $SlotFilter$$Type, item: $ItemStack$$Type): $KubeRecipe
public "customIngredientAction"(filter: $SlotFilter$$Type, id: StringJS): $KubeRecipe
public "keepIngredient"(filter: $SlotFilter$$Type): $KubeRecipe
public "consumeIngredient"(filter: $SlotFilter$$Type): $KubeRecipe
public "initValues"(save: boolean): void
public "getOriginalRecipe"(): $Recipe<(never)>
public "getTypeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
public "getSerializer"(): $RecipeSerializer<(never)>
/**
 * 
 * @deprecated
 */
public "getGroup"(): StringJS
/**
 * 
 * @deprecated
 */
public "getOrCreateId"(): $ResourceLocation
/**
 * 
 * @deprecated
 */
public "getSchema"(): $RecipeSchema
public "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "modifyResult"(id: StringJS): $KubeRecipe
public "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "stage"(s: StringJS): $KubeRecipe
public "group"(g: StringJS): $KubeRecipe
public "remove"(): void
public "get"(key: StringJS): any
public "toString"(): StringJS
public "getValue"<T>(key: $RecipeKey$$Type<(T)>): T
public "validate"(cx: $RecipeValidationContext$$Type): void
public "merge"(j: $JsonObject$$Type): $KubeRecipe
public "id"(id: $ResourceLocation$$Type): $KubeRecipe
public "set"(key: StringJS, value: any): $KubeRecipe
public "getId"(): StringJS
public "save"(): void
public "setValue"<T>(key: $RecipeKey$$Type<(T)>, value: T): $KubeRecipe
public "getPath"(): StringJS
public "deserialize"(merge: boolean): void
public "serialize"(): void
public "convertJavaToJs"(scope: $Scriptable$$Type, staticType: $TypeInfo$$Type): $Scriptable
public "hasChanged"(): boolean
public "getMod"(): StringJS
public "getType"(): $ResourceLocation
get "serializationTypeFunction"(): $RecipeTypeFunction
get "fromToString"(): StringJS
get "originalRecipeResult"(): $ItemStack
get "originalRecipeIngredients"(): $List<($Ingredient)>
get "originalRecipe"(): $Recipe<(never)>
get "typeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
get "serializer"(): $RecipeSerializer<(never)>
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "path"(): StringJS
get "mod"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipe$$Type = ($KubeRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRecipe$$Original = $KubeRecipe;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback" {
import {$ChestMenuClickEvent, $ChestMenuClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent"

export interface $ChestMenuClickEvent$Callback$$Interface {

(event: $ChestMenuClickEvent): void
}

export class $ChestMenuClickEvent$Callback implements $ChestMenuClickEvent$Callback$$Interface {
 "onClick"(event: $ChestMenuClickEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickEvent$Callback$$Type = ((event: $ChestMenuClickEvent) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuClickEvent$Callback$$Original = $ChestMenuClickEvent$Callback;}
declare module "dev.latvian.mods.kubejs.net.SyncServerDataPayload" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PacketFlow$$Type} from "net.minecraft.network.protocol.PacketFlow"
import {$FriendlyByteBuf} from "net.minecraft.network.FriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$KubeServerData, $KubeServerData$$Type} from "dev.latvian.mods.kubejs.net.KubeServerData"
import {$CustomPacketPayload$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$Type"
import {$StreamDecoder$$Type} from "net.minecraft.network.codec.StreamDecoder"
import {$CustomPacketPayload, $CustomPacketPayload$$Interface} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload"
import {$IPayloadContext$$Type} from "net.neoforged.neoforge.network.handling.IPayloadContext"
import {$StreamMemberEncoder$$Type} from "net.minecraft.network.codec.StreamMemberEncoder"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$ServerboundCustomPayloadPacket} from "net.minecraft.network.protocol.common.ServerboundCustomPayloadPacket"
import {$ClientboundCustomPayloadPacket} from "net.minecraft.network.protocol.common.ClientboundCustomPayloadPacket"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ConnectionProtocol$$Type} from "net.minecraft.network.ConnectionProtocol"
import {$CustomPacketPayload$TypeAndCodec$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$TypeAndCodec"
import {$CustomPacketPayload$FallbackProvider$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$FallbackProvider"
import {$Record} from "java.lang.Record"

export class $SyncServerDataPayload extends $Record implements $CustomPacketPayload$$Interface {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($SyncServerDataPayload)>

constructor(data: $KubeServerData$$Type)

public "type"(): $CustomPacketPayload$Type<(never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "data"(): $KubeServerData
public "handle"(ctx: $IPayloadContext$$Type): void
public static "codec"<B extends $FriendlyByteBuf>(arg0: $CustomPacketPayload$FallbackProvider$$Type<(B)>, arg1: $List$$Type<($CustomPacketPayload$TypeAndCodec$$Type<(B), (never)>)>, arg2: $ConnectionProtocol$$Type, arg3: $PacketFlow$$Type): $StreamCodec<(B), ($CustomPacketPayload)>
public static "codec"<B extends $ByteBuf, T extends $CustomPacketPayload>(arg0: $StreamMemberEncoder$$Type<(B), (T)>, arg1: $StreamDecoder$$Type<(B), (T)>): $StreamCodec<(B), (T)>
public "toVanillaClientbound"(): $ClientboundCustomPayloadPacket
public "toVanillaServerbound"(): $ServerboundCustomPayloadPacket
public static "createType"<T extends $CustomPacketPayload>(arg0: StringJS): $CustomPacketPayload$Type<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SyncServerDataPayload$$Type = ({"data"?: $KubeServerData$$Type}) | ([data?: $KubeServerData$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SyncServerDataPayload$$Original = $SyncServerDataPayload;}
declare module "dev.latvian.mods.kubejs.generator.KubeDataGenerator" {
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$VillagerProfession$$Type} from "net.minecraft.world.entity.npc.VillagerProfession"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$VirtualDataMapFile$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile"
import {$DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$VillagerType$$Type} from "net.minecraft.world.entity.npc.VillagerType"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export interface $KubeDataGenerator$$Interface extends $KubeResourceGenerator$$Interface {
get "registries"(): $RegistryAccessContainer
}

export class $KubeDataGenerator implements $KubeDataGenerator$$Interface {
 "setCompostable"(items: $ItemPredicate$$Type, chance: float, canVillagerCompost: boolean): void
 "removeCompostable"(items: $ItemPredicate$$Type): void
 "setFurnaceFuel"(items: $ItemPredicate$$Type, ticks: $TickDuration$$Type): void
 "removeFurnaceFuel"(items: $ItemPredicate$$Type): void
 "setMonsterRoomMobs"(entityType: $EntityType$$Type<(never)>, weight: integer): void
 "setOxidizable"(from: $Block$$Type, to: $Block$$Type): void
 "setParrotImitation"(type: $EntityType$$Type<(never)>, sound: $SoundEvent$$Type): void
 "setRaidHeroGifts"(profession: $VillagerProfession$$Type, lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setVibrationFrequency"(gameEvent: $GameEvent$$Type, frequency: integer): void
 "setVillagerType"(biome: $ResourceKey$$Type<($Biome)>, villagerType: $VillagerType$$Type): void
 "setWaxable"(from: $Block$$Type, to: $Block$$Type): void
 "dataMap"<R, T>(type: $DataMapType$$Type<(R), (T)>, consumer: $Consumer$$Type<($VirtualDataMapFile<(R), (T)>)>): void
 "flush"(): void
 "add"(data: $GeneratedData$$Type): void
 "text"(id: $ResourceLocation$$Type, content: StringJS): void
 "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
 "getRegistries"(): $RegistryAccessContainer
 "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeDataGenerator$$Type = ($KubeDataGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeDataGenerator$$Original = $KubeDataGenerator;}
declare module "dev.latvian.mods.kubejs.misc.PoiTypeBuilder" {
import {$PoiType} from "net.minecraft.world.entity.ai.village.poi.PoiType"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PoiTypeBuilder extends $BuilderBase<($PoiType)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "maxTickets"(i: integer): this
public "validRange"(i: integer): this
public "blocks"(r: ($BlockState$$Type)[]): this
public "block"(r: $Block$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoiTypeBuilder$$Type = ($PoiTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PoiTypeBuilder$$Original = $PoiTypeBuilder;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Element" {
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$ModelGenerator$Face$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Face"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ModelGenerator$Element {
constructor()

public "faces"(sides: ($Direction$$Type)[], face: $Consumer$$Type<($ModelGenerator$Face)>): void
public "allFaces"(face: $Consumer$$Type<($ModelGenerator$Face)>): void
public "size"(b: $AABB$$Type): $ModelGenerator$Element
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Element$$Type = ($ModelGenerator$Element);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$Element$$Original = $ModelGenerator$Element;}
declare module "dev.latvian.mods.kubejs.util.NBTIOWrapper" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Path$$Type} from "java.nio.file.Path"

export interface $NBTIOWrapper$$Interface {
}

export class $NBTIOWrapper implements $NBTIOWrapper$$Interface {
static "write"(path: $Path$$Type, nbt: $CompoundTag$$Type): void
static "read"(path: $Path$$Type): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTIOWrapper$$Type = ($NBTIOWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NBTIOWrapper$$Original = $NBTIOWrapper;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$HurtEnemyContext" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Record} from "java.lang.Record"

export class $ItemBuilder$HurtEnemyContext extends $Record {
constructor(getItem: $ItemStack$$Type, getTarget: $LivingEntity$$Type, getAttacker: $LivingEntity$$Type)

public "getAttacker"(): $LivingEntity
public "getItem"(): $ItemStack
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getTarget"(): $LivingEntity
get "attacker"(): $LivingEntity
get "item"(): $ItemStack
get "target"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$HurtEnemyContext$$Type = ({"getItem"?: $ItemStack$$Type, "getTarget"?: $LivingEntity$$Type, "getAttacker"?: $LivingEntity$$Type}) | ([getItem?: $ItemStack$$Type, getTarget?: $LivingEntity$$Type, getAttacker?: $LivingEntity$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$HurtEnemyContext$$Original = $ItemBuilder$HurtEnemyContext;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction" {
import {$Pattern} from "java.util.regex.Pattern"
import {$BaseFunction} from "dev.latvian.mods.rhino.BaseFunction"
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$WrappedJS$$Interface} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$ErrorStack$$Type} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$KubeRecipe} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipesKubeEvent, $RecipesKubeEvent$$Type} from "dev.latvian.mods.kubejs.recipe.RecipesKubeEvent"
import {$DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $RecipeTypeFunction extends $BaseFunction implements $WrappedJS$$Interface {
static readonly "DONTENUM": integer
static readonly "CONST": integer
readonly "idString": StringJS
readonly "schemaType": $RecipeSchemaType
static readonly "UNINITIALIZED_CONST": integer
readonly "serializerKey": $ResourceKey<($RecipeSerializer<(never)>)>
static readonly "SKIP_ERROR": $Pattern
readonly "id": $ResourceLocation
readonly "event": $RecipesKubeEvent
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "PERMANENT": integer

constructor(event: $RecipesKubeEvent$$Type, schemaType: $RecipeSchemaType$$Type)

public "createRecipe"(sourceLine: $SourceLine$$Type, stack: $ErrorStack$$Type, args: (any)[]): $KubeRecipe
public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "call"(scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args0: (any)[]): $KubeRecipe
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "getPrototype"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "getParentScope"(): $Scriptable
public "setParentScope"(arg0: $Scriptable$$Type): void
public "getAllIds"(): (any)[]
public "getIds"(): (any)[]
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
get "parentScope"(): $Scriptable
set "parentScope"(value: $Scriptable$$Type)
get "allIds"(): (any)[]
get "ids"(): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeFunction$$Type = ($RecipeTypeFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeTypeFunction$$Original = $RecipeTypeFunction;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder" {
import {$ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export class $ArmorItemBuilder extends $ItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

public "material"(material: $Holder$$Type<($ArmorMaterial)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$$Type = ($ArmorItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$$Original = $ArmorItemBuilder;}
declare module "dev.latvian.mods.kubejs.server.tag.TagKubeEvent" {
import {$EventExceptionHandler} from "dev.latvian.mods.kubejs.event.EventExceptionHandler"
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Map} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Set} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$TagWrapper} from "dev.latvian.mods.kubejs.server.tag.TagWrapper"

export class $TagKubeEvent implements $KubeEvent$$Interface {
readonly "registryKey": $ResourceKey<(never)>
 "totalRemoved": integer
static readonly "SOURCE": StringJS
readonly "vanillaRegistry": $Registry<(never)>
 "totalAdded": integer
static readonly "TAG_EVENT_HANDLER": $EventExceptionHandler
readonly "tags": $Map<($ResourceLocation), ($TagWrapper)>

constructor(registryKey: $ResourceKey$$Type<(never)>, vr: $Registry$$Type<(never)>)

public "getElementIds"(): $Set<($ResourceLocation)>
public "removeAllTagsFrom"(...ids: (any)[]): void
public "remove"(tag: $ResourceLocation$$Type, ...filters: (any)[]): $TagWrapper
public "get"(id: $ResourceLocation$$Type): $TagWrapper
public "add"(tag: $ResourceLocation$$Type, ...filters: (any)[]): $TagWrapper
public "getType"(): $ResourceLocation
public "removeAll"(tag: $ResourceLocation$$Type): $TagWrapper
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "elementIds"(): $Set<($ResourceLocation)>
get "type"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagKubeEvent$$Type = ($TagKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagKubeEvent$$Original = $TagKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.IngredientSupplierKJS" {
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IngredientSupplierKJS$$Interface {
}

export class $IngredientSupplierKJS implements $IngredientSupplierKJS$$Interface {
 "kjs$asIngredient"(): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientSupplierKJS$$Type = ($IngredientSupplierKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientSupplierKJS$$Original = $IngredientSupplierKJS;}
declare module "dev.latvian.mods.kubejs.player.PlayerAdvancementKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$AdvancementNode, $AdvancementNode$$Type} from "net.minecraft.advancements.AdvancementNode"
import {$Level} from "net.minecraft.world.level.Level"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player gets an advancement.
 */
export class $PlayerAdvancementKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $ServerPlayer$$Type, advancementNode: $AdvancementNode$$Type)

/**
 * Returns the advancement that was obtained.
 */
public "getAdvancement"(): $AdvancementNode
/**
 * Returns the player that got the advancement.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "advancement"(): $AdvancementNode
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerAdvancementKubeEvent$$Type = ($PlayerAdvancementKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerAdvancementKubeEvent$$Original = $PlayerAdvancementKubeEvent;}
declare module "dev.latvian.mods.kubejs.command.ArgumentTypeWrappers" {
import {$CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$ArgumentType} from "com.mojang.brigadier.arguments.ArgumentType"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Enum} from "java.lang.Enum"
import {$CommandRegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent"
import {$ArgumentTypeWrapper, $ArgumentTypeWrapper$$Interface} from "dev.latvian.mods.kubejs.command.ArgumentTypeWrapper"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"

export class $ArgumentTypeWrappers extends $Enum<($ArgumentTypeWrappers)> implements $ArgumentTypeWrapper$$Interface {
static readonly "ROTATION": $ArgumentTypeWrappers
static readonly "VEC2_CENTERED": $ArgumentTypeWrappers
static readonly "FLOAT": $ArgumentTypeWrappers
static readonly "PARTICLE": $ArgumentTypeWrappers
static readonly "INT_RANGE": $ArgumentTypeWrappers
static readonly "BLOCK_STATE": $ArgumentTypeWrappers
static readonly "NBT_TAG": $ArgumentTypeWrappers
static readonly "NBT_PATH": $ArgumentTypeWrappers
static readonly "ANGLE": $ArgumentTypeWrappers
static readonly "ITEM_PREDICATE": $ArgumentTypeWrappers
static readonly "BLOCK_POS_LOADED": $ArgumentTypeWrappers
static readonly "BLOCK_POS": $ArgumentTypeWrappers
static readonly "MESSAGE": $ArgumentTypeWrappers
static readonly "ITEM_SLOT": $ArgumentTypeWrappers
static readonly "ENTITY": $ArgumentTypeWrappers
static readonly "BLOCK_PREDICATE": $ArgumentTypeWrappers
static readonly "DIMENSION": $ArgumentTypeWrappers
static readonly "VEC2": $ArgumentTypeWrappers
static readonly "COLOR": $ArgumentTypeWrappers
static readonly "VEC3": $ArgumentTypeWrappers
static readonly "ITEM_STACK": $ArgumentTypeWrappers
static readonly "SWIZZLE": $ArgumentTypeWrappers
static readonly "OBJECTIVE": $ArgumentTypeWrappers
static readonly "DOUBLE": $ArgumentTypeWrappers
static readonly "ENTITIES": $ArgumentTypeWrappers
static readonly "UUID": $ArgumentTypeWrappers
static readonly "INTEGER": $ArgumentTypeWrappers
static readonly "LONG": $ArgumentTypeWrappers
static readonly "WORD": $ArgumentTypeWrappers
static readonly "VEC3_CENTERED": $ArgumentTypeWrappers
static readonly "TIME": $ArgumentTypeWrappers
static readonly "GREEDY_STRING": $ArgumentTypeWrappers
static readonly "NBT_COMPOUND": $ArgumentTypeWrappers
static readonly "BOOLEAN": $ArgumentTypeWrappers
static readonly "PLAYER": $ArgumentTypeWrappers
static readonly "RESOURCE_LOCATION": $ArgumentTypeWrappers
static readonly "FLOAT_RANGE": $ArgumentTypeWrappers
static readonly "PLAYERS": $ArgumentTypeWrappers
static readonly "GAME_PROFILE": $ArgumentTypeWrappers
static readonly "COLUMN_POS": $ArgumentTypeWrappers
static readonly "STRING": $ArgumentTypeWrappers
static readonly "COMPONENT": $ArgumentTypeWrappers
static readonly "ENTITY_ANCHOR": $ArgumentTypeWrappers

public static "printAll"(): void
public "getResult"(context: $CommandContext$$Type<($CommandSourceStack$$Type)>, input: StringJS): any
public static "values"(): ($ArgumentTypeWrappers)[]
public static "valueOf"(name: StringJS): $ArgumentTypeWrappers
public "time"(minRequired: integer): $ArgumentTypeWrapper
public "create"(event: $CommandRegistryKubeEvent$$Type): $ArgumentType<(never)>
public static "registry"<T>(event: $CommandRegistryKubeEvent$$Type, reg: $ResourceLocation$$Type): $ArgumentTypeWrapper
public static "byName"(name: $ResourceLocation$$Type): typeof never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentTypeWrappers$$Type = (("boolean") | ("float") | ("double") | ("integer") | ("long") | ("string") | ("greedy_string") | ("word") | ("entity") | ("entities") | ("player") | ("players") | ("game_profile") | ("block_pos") | ("block_pos_loaded") | ("column_pos") | ("vec3") | ("vec2") | ("vec3_centered") | ("vec2_centered") | ("block_state") | ("block_predicate") | ("item_stack") | ("item_predicate") | ("color") | ("component") | ("message") | ("nbt_compound") | ("nbt_tag") | ("nbt_path") | ("particle") | ("angle") | ("rotation") | ("swizzle") | ("item_slot") | ("resource_location") | ("entity_anchor") | ("int_range") | ("float_range") | ("dimension") | ("time") | ("uuid") | ("objective"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArgumentTypeWrappers$$Original = $ArgumentTypeWrappers;}
declare module "dev.latvian.mods.kubejs.entity.EntitySpawnedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity is about to be added to the world.
 * 
 * This event also fires for existing entities when they are loaded from a save.
 */
export class $EntitySpawnedKubeEvent implements $KubeEntityEvent$$Interface {
constructor(entity: $Entity$$Type, level: $Level$$Type)

/**
 * The level the entity is being added to.
 */
public "getLevel"(): $Level
/**
 * The entity being added to the world.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySpawnedKubeEvent$$Type = ($EntitySpawnedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySpawnedKubeEvent$$Original = $EntitySpawnedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicate" {
import {$LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$BlockPredicate$$Interface} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockEntityPredicateDataCheck$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicateDataCheck"

export class $BlockEntityPredicate implements $BlockPredicate$$Interface {
constructor(i: $ResourceLocation$$Type)

public "toString"(): StringJS
public "data"(cd: $BlockEntityPredicateDataCheck$$Type): $BlockEntityPredicate
public "check"(block: $LevelBlock$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityPredicate$$Type = ($BlockEntityPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityPredicate$$Original = $BlockEntityPredicate;}
declare module "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$RecipeMatchContext, $RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"

export interface $RecipeFilter$$Interface extends $Predicate$$Interface<($RecipeMatchContext)> {

(cx: $RecipeMatchContext): boolean
}

export class $RecipeFilter implements $RecipeFilter$$Interface {
 "test"(cx: $RecipeMatchContext$$Type): boolean
 "test"(cx: any): boolean
static "wrap"(o: any): $RecipeFilter
 "or"(arg0: $Predicate$$Type<($RecipeMatchContext)>): $Predicate<($RecipeMatchContext)>
static "isEqual"<T>(arg0: any): $Predicate<($RecipeMatchContext)>
 "negate"(): $Predicate<($RecipeMatchContext)>
 "and"(arg0: $Predicate$$Type<($RecipeMatchContext)>): $Predicate<($RecipeMatchContext)>
static "not"<T>(arg0: $Predicate$$Type<($RecipeMatchContext)>): $Predicate<($RecipeMatchContext)>
}
export type RecipeFilterObject = {"or"?: $RecipeFilter$$Type, "not"?: $RecipeFilter$$Type, "id"?: Special.RecipeId, "type"?: Special.RecipeSerializer, "group"?: StringJS, "mod"?: Special.Mod, "input"?: $Ingredient$$Type, "output"?: $ItemStack$$Type};
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFilter$$Type = (RegExp) | ("*") | ("-") | (($RecipeFilter$$Type)[]) | (RecipeFilterObject) | ((cx: $RecipeMatchContext) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeFilter$$Original = $RecipeFilter;}
declare module "dev.latvian.mods.kubejs.util.TickDuration" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$TemporalUnit, $TemporalUnit$$Type} from "java.time.temporal.TemporalUnit"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List} from "java.util.List"
import {$TemporalAmount$$Interface} from "java.time.temporal.TemporalAmount"
import {$Temporal, $Temporal$$Type} from "java.time.temporal.Temporal"
import {$Record} from "java.lang.Record"

export class $TickDuration extends $Record implements $TemporalAmount$$Interface {
static readonly "ZERO": $TickDuration
static readonly "CODEC": $Codec<($TickDuration)>
static readonly "SECONDS_CODEC": $Codec<($TickDuration)>
static readonly "MINUTES_CODEC": $Codec<($TickDuration)>
static readonly "TYPE_INFO": $TypeInfo
static readonly "HOURS_CODEC": $Codec<($TickDuration)>

constructor(ticks: long)

public "intTicks"(): integer
public "addTo"(temporal: $Temporal$$Type): $Temporal
public "subtractFrom"(temporal: $Temporal$$Type): $Temporal
public "getUnits"(): $List<($TemporalUnit)>
public "get"(unit: $TemporalUnit$$Type): long
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "wrap"(from: any): $TickDuration
public static "of"(ticks: long): $TickDuration
public "ticks"(): long
get "units"(): $List<($TemporalUnit)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickDuration$$Type = ({"ticks"?: long}) | ([ticks?: long]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TickDuration$$Original = $TickDuration;}
declare module "dev.latvian.mods.kubejs.block.callback.AfterEntityFallenOnBlockCallback" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$EntitySteppedOnBlockCallback} from "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $AfterEntityFallenOnBlockCallback extends $EntitySteppedOnBlockCallback {
constructor(blockGetter: $BlockGetter$$Type, entity: $Entity$$Type)

/**
 * Returns the Vec3 of the entity's velocity. Use .x, .y and .z to get the respective components of that
 */
public "getVelocity"(): $Vec3
/**
 * Sets the entity's velocity
 */
public "setVelocity"(x: float, y: float, z: float): void
/**
 * Sets the entity's velocity
 */
public "setVelocity"(vec: $Vec3$$Type): void
/**
 * Bounce the entity upwards by bounciness * their fall velocity.
 * Do not make bounciness negative, as that is a recipe for a long and laggy trip to the void
 */
public "bounce"(bounciness: float): void
get "velocity"(): $Vec3
set "velocity"(value: $Vec3$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterEntityFallenOnBlockCallback$$Type = ($AfterEntityFallenOnBlockCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AfterEntityFallenOnBlockCallback$$Original = $AfterEntityFallenOnBlockCallback;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeNamespace, $RecipeNamespace$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $RecipeSchemaType {
readonly "schema": $RecipeSchema
 "parent": $RecipeSchemaType
readonly "serializerType": StringJS
readonly "namespace": $RecipeNamespace
readonly "serializerKey": $ResourceKey<($RecipeSerializer<(never)>)>
readonly "id": $ResourceLocation

constructor(namespace: $RecipeNamespace$$Type, id: $ResourceLocation$$Type, schema: $RecipeSchema$$Type)

public "getSerializer"(): $RecipeSerializer<(never)>
public "toString"(): StringJS
get "serializer"(): $RecipeSerializer<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaType$$Type = ($RecipeSchemaType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchemaType$$Original = $RecipeSchemaType;}
declare module "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent" {
import {$ParticleProvider$$Type} from "net.minecraft.client.particle.ParticleProvider"
import {$RegisterParticleProvidersEvent$$Type} from "net.neoforged.neoforge.client.event.RegisterParticleProvidersEvent"
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$ParticleType$$Type} from "net.minecraft.core.particles.ParticleType"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$KubeAnimatedParticle$$Type} from "dev.latvian.mods.kubejs.client.KubeAnimatedParticle"
import {$ParticleOptions} from "net.minecraft.core.particles.ParticleOptions"
import {$ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type} from "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ParticleProviderRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $RegisterParticleProvidersEvent$$Type)

public "register"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>, spriteProvider: $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type<(T)>): void
public "register"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>, particle: $Consumer$$Type<($KubeAnimatedParticle)>): void
public "register"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>): void
public "registerSpecial"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>, provider: $ParticleProvider$$Type<(T)>): void
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleProviderRegistryKubeEvent$$Type = ($ParticleProviderRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleProviderRegistryKubeEvent$$Original = $ParticleProviderRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer" {
import {$HighlightRenderer$Mode} from "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$Mode"
import {$IntOpenHashSet} from "it.unimi.dsi.fastutil.ints.IntOpenHashSet"
import {$Long2IntMap} from "it.unimi.dsi.fastutil.longs.Long2IntMap"
import {$KeyMapping} from "net.minecraft.client.KeyMapping"
import {$HighlightRenderer$ShaderChain} from "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$ShaderChain"
import {$Slot} from "net.minecraft.world.inventory.Slot"
import {$AbstractContainerScreen$$Type} from "net.minecraft.client.gui.screens.inventory.AbstractContainerScreen"
import {$GuiGraphics$$Type} from "net.minecraft.client.gui.GuiGraphics"
import {$Reference2IntMap} from "it.unimi.dsi.fastutil.objects.Reference2IntMap"
import {$RenderLevelStageEvent$$Type} from "net.neoforged.neoforge.client.event.RenderLevelStageEvent"
import {$ShaderInstance} from "net.minecraft.client.renderer.ShaderInstance"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Set} from "java.util.Set"
import {$Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$Entity} from "net.minecraft.world.entity.Entity"

export class $HighlightRenderer {
readonly "highlightedEntities": $Reference2IntMap<($Entity)>
 "color": $KubeColor
static "INSTANCE": $HighlightRenderer
readonly "hoveredSlots": $Set<($Slot)>
static "keyMapping": $KeyMapping
readonly "uniqueColors": $IntOpenHashSet
 "highlightShader": $ShaderInstance
 "mode": $HighlightRenderer$Mode
 "worldChain": $HighlightRenderer$ShaderChain
 "actualKey": boolean
 "guiChain": $HighlightRenderer$ShaderChain
 "cancelBlockHighlight": boolean
readonly "highlightedBlocks": $Long2IntMap

constructor()

public "hudPostDraw"(mc: $Minecraft$$Type, graphics: $GuiGraphics$$Type, delta: float): void
public "tickPre"(mc: $Minecraft$$Type): void
public "clearBuffers"(mc: $Minecraft$$Type): void
public "renderAfterEntities"(mc: $Minecraft$$Type, event: $RenderLevelStageEvent$$Type): void
public "renderAfterLevel"(mc: $Minecraft$$Type, event: $RenderLevelStageEvent$$Type): void
public "screen"(mc: $Minecraft$$Type, graphics: $GuiGraphics$$Type, screen: $AbstractContainerScreen$$Type<(never)>, mx: integer, my: integer, delta: float): void
public "loadPostChains"(mc: $Minecraft$$Type): void
public "resizePostChains"(width: integer, height: integer): void
public "updateDepth"(mc: $Minecraft$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightRenderer$$Type = ($HighlightRenderer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightRenderer$$Original = $HighlightRenderer;}
declare module "dev.latvian.mods.kubejs.script.ScriptTypePredicate" {
import {$List} from "java.util.List"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptTypePredicate$$Interface extends $Predicate$$Interface<($ScriptType)> {

(type: $ScriptType): boolean
get "validTypes"(): $List<($ScriptType)>
}

export class $ScriptTypePredicate implements $ScriptTypePredicate$$Interface {
static readonly "ALL": $ScriptTypePredicate
static readonly "STARTUP_OR_CLIENT": $ScriptTypePredicate
static readonly "COMMON": $ScriptTypePredicate
static readonly "STARTUP_OR_SERVER": $ScriptTypePredicate

 "test"(type: $ScriptType$$Type): boolean
 "test"(type: any): boolean
 "getValidTypes"(): $List<($ScriptType)>
 "or"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
static "isEqual"<T>(arg0: any): $Predicate<($ScriptType)>
 "negate"(): $Predicate<($ScriptType)>
 "and"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
static "not"<T>(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptTypePredicate$$Type = ((type: $ScriptType) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptTypePredicate$$Original = $ScriptTypePredicate;}
declare module "dev.latvian.mods.kubejs.item.ItemPredicate" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemStackSet} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set} from "java.util.Set"
import {$Stream} from "java.util.stream.Stream"

export interface $ItemPredicate$$Interface extends $Predicate$$Interface<($ItemStack)>, $IngredientSupplierKJS$$Interface {

(itemStack: $ItemStack): boolean
get "stacks"(): $ItemStackSet
get "stackArray"(): ($ItemStack)[]
get "displayStacks"(): $ItemStackSet
get "itemStream"(): $Stream<($Item)>
get "itemTypes"(): $Set<($Item)>
get "itemIds"(): $Set<(StringJS)>
get "first"(): $ItemStack
get "wildcard"(): boolean
}

export class $ItemPredicate implements $ItemPredicate$$Interface {
static readonly "ALL": $ItemPredicate
static readonly "TYPE_INFO": $TypeInfo
static readonly "NONE": $ItemPredicate

 "asIngredient"(): $Ingredient
 "canBeUsedForMatching"(): boolean
 "getStacks"(): $ItemStackSet
 "getStackArray"(): ($ItemStack)[]
 "testItem"(item: $Item$$Type): boolean
 "getDisplayStacks"(): $ItemStackSet
 "getItemStream"(): $Stream<($Item)>
 "getItemTypes"(): $Set<($Item)>
 "getItemIds"(): $Set<(StringJS)>
 "getFirst"(): $ItemStack
 "test"(itemStack: $ItemStack$$Type): boolean
 "test"(itemStack: any): boolean
static "wrap"(from: any): $ItemPredicate
 "isWildcard"(): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPredicate$$Type = ($Ingredient$$Type) | ("*") | ("-") | ((item: $ItemStack) => boolean) | ((itemStack: $ItemStack) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemPredicate$$Original = $ItemPredicate;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NBTWrapper" {
import {$CollectionTag} from "net.minecraft.nbt.CollectionTag"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Map$$Type} from "java.util.Map"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$List$$Type} from "java.util.List"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ListTag} from "net.minecraft.nbt.ListTag"
import {$OrderedCompoundTag} from "dev.latvian.mods.kubejs.util.OrderedCompoundTag"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $NBTWrapper$$Interface {
}

export class $NBTWrapper implements $NBTWrapper$$Interface {
static "isTagCollection"(o: any): boolean
static "isTagCompound"(o: any): boolean
static "wrapCompound"(v: any): $CompoundTag
static "wrapListTag"(list: any): $ListTag
static "byteTag"(v: byte): $Tag
static "shortTag"(v: short): $Tag
static "intTag"(v: integer): $Tag
static "longTag"(v: long): $Tag
static "floatTag"(v: float): $Tag
static "doubleTag"(v: double): $Tag
static "intArrayTag"(v: (integer)[]): $Tag
static "longArrayTag"(v: (long)[]): $Tag
static "byteArrayTag"(v: (byte)[]): $Tag
static "toTag"(tag: $Tag$$Type): $Tag
static "stringTag"(v: StringJS): $Tag
static "wrap"(v: any): $Tag
static "i"(v: integer): $Tag
static "b"(v: byte): $Tag
static "ba"(v: (byte)[]): $Tag
static "s"(v: short): $Tag
static "f"(v: float): $Tag
static "l"(v: long): $Tag
static "d"(v: double): $Tag
static "read"(buf: $FriendlyByteBuf$$Type): $OrderedCompoundTag
static "ia"(v: (integer)[]): $Tag
static "toJson"(t: $Tag$$Type): $JsonElement
static "la"(v: (long)[]): $Tag
static "wrapCollection"(v: any): $CollectionTag<(never)>
static "listTag"(): $Tag
static "listTag"(list: $List$$Type<(never)>): $Tag
static "compoundTag"(): $Tag
static "compoundTag"(map: $Map$$Type<(never), (never)>): $Tag
static "fromTag"(t: $Tag$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTWrapper$$Type = ($NBTWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NBTWrapper$$Original = $NBTWrapper;}
declare module "dev.latvian.mods.kubejs.core.ServerPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction} from "net.minecraft.core.Direction"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$PlayerKJS$$Interface} from "dev.latvian.mods.kubejs.core.PlayerKJS"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ChestMenuData$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuData"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$KubeJSGUI$$Type} from "dev.latvian.mods.kubejs.gui.KubeJSGUI"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container} from "net.minecraft.world.Container"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ServerPlayerKJS$$Interface extends $PlayerKJS$$Interface {

(): $AttachedData$$Type<($Player$$Type)>
set "creativeMode"(value: boolean)
get "op"(): boolean
get "spawnLocation"(): $LevelBlock
set "spawnLocation"(value: $LevelBlock$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "stats"(): $PlayerStatsJS
get "miningBlock"(): boolean
set "selectedSlot"(value: integer)
set "mouseItem"(value: $ItemStack$$Type)
set "statusMessage"(value: $Component$$Type)
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "craftingGrid"(): $InventoryKJS
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "selectedSlot"(): integer
get "fake"(): boolean
get "mouseItem"(): $ItemStack
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "saturation"(): float
set "saturation"(value: float)
set "xp"(value: integer)
get "xp"(): integer
set "xpLevel"(value: integer)
get "xpLevel"(): integer
get "openInventory"(): $AbstractContainerMenu
get "profile"(): $GameProfile
get "player"(): boolean
get "defaultMovementSpeed"(): double
set "defaultMovementSpeed"(value: double)
get "reachDistance"(): double
get "living"(): boolean
set "maxHealth"(value: float)
get "undead"(): boolean
get "potionEffects"(): $EntityPotionEffectsJS
get "mainHandItem"(): $ItemStack
set "mainHandItem"(value: $ItemStack$$Type)
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
get "headArmorItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
set "chestArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
set "legsArmorItem"(value: $ItemStack$$Type)
get "feetArmorItem"(): $ItemStack
set "feetArmorItem"(value: $ItemStack$$Type)
get "totalMovementSpeed"(): double
set "movementSpeedAddition"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
get "data"(): $AttachedData<($Player)>
get "name"(): $Component
get "displayName"(): $Component
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "server"(): $MinecraftServer
get "block"(): $LevelBlock
get "nbt"(): $CompoundTag
set "nbt"(value: $CompoundTag$$Type)
get "scriptType"(): $ScriptType
get "type"(): StringJS
get "item"(): $ItemStack
get "frame"(): boolean
get "monster"(): boolean
get "animal"(): boolean
get "ambientCreature"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
set "x"(value: double)
set "y"(value: double)
set "z"(value: double)
get "motionX"(): double
set "motionX"(value: double)
get "motionY"(): double
set "motionY"(value: double)
get "motionZ"(): double
set "motionZ"(value: double)
get "passengers"(): $EntityArrayList
get "teamId"(): StringJS
get "facing"(): $Direction
get "persistentData"(): $CompoundTag
}

export class $ServerPlayerKJS implements $ServerPlayerKJS$$Interface {
 "kick"(reason: $Component$$Type): void
 "kick"(): void
 "openInventoryGUI"(inventory: $InventoryKJS$$Type, title: $Component$$Type, columns: integer, rows: integer): void
 "openInventoryGUI"(inventory: $InventoryKJS$$Type, title: $Component$$Type, columns: integer): void
 "openInventoryGUI"(inventory: $InventoryKJS$$Type, title: $Component$$Type): void
 "openChestGUI"(title: $Component$$Type, rows: integer, gui: $Consumer$$Type<($ChestMenuData)>): void
 "openChestGUI"(gui: $Consumer$$Type<($KubeJSGUI)>): void
 "captureInventory"(autoRestore: boolean): $Container
 "setCreativeMode"(mode: boolean): void
 "isOp"(): boolean
 "ban"(banner: StringJS, reason: StringJS, expiresInMillis: long): void
 "isAdvancementDone"(id: $ResourceLocation$$Type): boolean
 "unlockAdvancement"(id: $ResourceLocation$$Type): void
 "revokeAdvancement"(id: $ResourceLocation$$Type): void
 "getSpawnLocation"(): $LevelBlock
 "setSpawnLocation"(c: $LevelBlock$$Type): void
 "heal"(): void
 "self"(): $Player
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "notify"(builder: $NotificationToastData$$Type): void
 "getStats"(): $PlayerStatsJS
 "isMiningBlock"(): boolean
 "setSelectedSlot"(index: integer): void
 "setMouseItem"(item: $ItemStack$$Type): void
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "setStatusMessage"(message: $Component$$Type): void
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "getCraftingGrid"(): $InventoryKJS
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "getSelectedSlot"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "isFake"(): boolean
 "sendInventoryUpdate"(): void
 "give"(item: $ItemStack$$Type): void
 "giveInHand"(item: $ItemStack$$Type): void
 "getMouseItem"(): $ItemStack
 "addFood"(f: integer, m: float): void
 "getFoodLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "getSaturation"(): float
 "setSaturation"(saturation: float): void
 "addExhaustion"(exhaustion: float): void
 "addXP"(xp: integer): void
 "addXPLevels"(l: integer): void
 "setXp"(xp: integer): void
 "getXp"(): integer
 "setXpLevel"(l: integer): void
 "getXpLevel"(): integer
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "spawn"(): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "damageHeldItem"(): void
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "getDefaultMovementSpeed"(): double
 "setDefaultMovementSpeed"(speed: double): void
 "getReachDistance"(): double
 "rayTrace"(): $KubeRayTraceResult
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "setMaxHealth"(hp: float): void
 "isUndead"(): boolean
 "getPotionEffects"(): $EntityPotionEffectsJS
 "swing"(): void
 "swing"(hand: $InteractionHand$$Type): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "getMainHandItem"(): $ItemStack
 "setMainHandItem"(item: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setOffHandItem"(item: $ItemStack$$Type): void
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "getTotalMovementSpeed"(): double
 "setMovementSpeedAddition"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "tell"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "getServer"(): $MinecraftServer
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "getNbt"(): $CompoundTag
 "setNbt"(nbt: $CompoundTag$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "getType"(): StringJS
 "getItem"(): $ItemStack
 "isFrame"(): boolean
 "isMonster"(): boolean
 "isAnimal"(): boolean
 "isAmbientCreature"(): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setX"(x: double): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "getMotionX"(): double
 "setMotionX"(x: double): void
 "getMotionY"(): double
 "setMotionY"(y: double): void
 "getMotionZ"(): double
 "setMotionZ"(z: double): void
 "setRotation"(yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "getTeamId"(): StringJS
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "getFacing"(): $Direction
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "attack"(hp: float): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerPlayerKJS$$Original = $ServerPlayerKJS;}
declare module "dev.latvian.mods.kubejs.block.callback.CanBeReplacedCallback" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand} from "net.minecraft.world.InteractionHand"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CanBeReplacedCallback {
constructor(blockPlaceContext: $BlockPlaceContext$$Type, state: $BlockState$$Type)

public "canBeReplaced"(): boolean
public "getClickedPos"(): $BlockPos
public "getClickedFace"(): $Direction
public "isInside"(): boolean
public "getClickLocation"(): $Vec3
public "getHorizontalDirection"(): $Direction
public "getNearestLookingDirections"(): ($Direction)[]
public "getNearestLookingDirection"(): $Direction
public "getHand"(): $InteractionHand
public "getNearestLookingVerticalDirection"(): $Direction
public "getFluidStateAtClickedPos"(): $FluidState
public "isClickedPosIn"(fluid: $Fluid$$Type): boolean
public "getClickedBlock"(): $LevelBlock
public "getItem"(): $ItemStack
public "getLevel"(): $Level
public "getRotation"(): float
public "isSecondaryUseActive"(): boolean
public "getPlayer"(): $Player
get "clickedPos"(): $BlockPos
get "clickedFace"(): $Direction
get "inside"(): boolean
get "clickLocation"(): $Vec3
get "horizontalDirection"(): $Direction
get "nearestLookingDirections"(): ($Direction)[]
get "nearestLookingDirection"(): $Direction
get "hand"(): $InteractionHand
get "nearestLookingVerticalDirection"(): $Direction
get "fluidStateAtClickedPos"(): $FluidState
get "clickedBlock"(): $LevelBlock
get "item"(): $ItemStack
get "level"(): $Level
get "rotation"(): float
get "secondaryUseActive"(): boolean
get "player"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanBeReplacedCallback$$Type = ($CanBeReplacedCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CanBeReplacedCallback$$Original = $CanBeReplacedCallback;}
declare module "dev.latvian.mods.kubejs.entity.AfterLivingEntityHurtKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingDamageEvent$Post$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDamageEvent$Post"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked after an entity is hurt by a damage source.
 */
export class $AfterLivingEntityHurtKubeEvent implements $KubeLivingEntityEvent$$Interface {
constructor(event: $LivingDamageEvent$Post$$Type)

/**
 * The damage source.
 */
public "getSource"(): $DamageSource
/**
 * The entity that was hurt.
 */
public "getEntity"(): $Entity
/**
 * The amount of damage.
 */
public "getDamage"(): float
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "source"(): $DamageSource
get "entity"(): $Entity
get "damage"(): float
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterLivingEntityHurtKubeEvent$$Type = ($AfterLivingEntityHurtKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AfterLivingEntityHurtKubeEvent$$Original = $AfterLivingEntityHurtKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.KubeJSPluginEvent" {
import {$Event} from "net.neoforged.bus.api.Event"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSPluginEvent extends $Event {
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSPluginEvent$$Type = ($KubeJSPluginEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSPluginEvent$$Original = $KubeJSPluginEvent;}
declare module "dev.latvian.mods.kubejs.client.ParticleGenerator" {
import {$List$$Type} from "java.util.List"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $ParticleGenerator {
constructor()

public "textures"(textures: $List$$Type<(StringJS)>): $ParticleGenerator
public "texture"(texture: StringJS): $ParticleGenerator
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleGenerator$$Type = ($ParticleGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleGenerator$$Original = $ParticleGenerator;}
declare module "dev.latvian.mods.kubejs.block.drop.BlockDrops" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$NumberProvider, $NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Record} from "java.lang.Record"

export class $BlockDrops extends $Record {
static readonly "EMPTY": $BlockDrops

constructor(items: ($ItemStack$$Type)[], rolls: $NumberProvider$$Type)

public "rolls"(): $NumberProvider
public "items"(): ($ItemStack)[]
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "createDefault"(item: $ItemStack$$Type): $BlockDrops
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDrops$$Type = ({"items"?: ($ItemStack$$Type)[], "rolls"?: $NumberProvider$$Type}) | ([items?: ($ItemStack$$Type)[], rolls?: $NumberProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockDrops$$Original = $BlockDrops;}
declare module "dev.latvian.mods.kubejs.core.LevelKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$UUID$$Type} from "java.util.UUID"
import {$WithAttachedData$$Interface} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$ScriptTypeHolder$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityGetterKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityGetterKJS"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LevelKJS$$Interface extends $WithAttachedData$$Interface<($Level)>, $ScriptTypeHolder$$Interface, $EntityGetterKJS$$Interface {

(): $AttachedData$$Type<($Level$$Type)>
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "side"(): $ScriptType
get "dimension"(): $ResourceLocation
get "overworld"(): boolean
set "time"(value: long)
get "data"(): $AttachedData<($Level)>
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "displayName"(): $Component
get "entities"(): $EntityArrayList
}

export class $LevelKJS implements $LevelKJS$$Interface {
 "self"(): $EntityGetter
 "tell"(message: $Component$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getName"(): $Component
 "getBlock"(pos: $BlockPos$$Type): $LevelBlock
 "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
 "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
 "getSide"(): $ScriptType
 "getDimension"(): $ResourceLocation
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
 "isOverworld"(): boolean
 "setTime"(time: long): void
 "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
 "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
 "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "getData"(): $AttachedData<($Level)>
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getDisplayName"(): $Component
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelKJS$$Original = $LevelKJS;}
declare module "dev.latvian.mods.kubejs.util.IntBounds" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Record} from "java.lang.Record"

export class $IntBounds extends $Record {
static readonly "OPTIONAL": $IntBounds
static readonly "CODEC": $Codec<($IntBounds)>
static readonly "MAP_CODEC": $MapCodec<($IntBounds)>
static readonly "DEFAULT": $IntBounds
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($IntBounds)>

constructor(min: integer, max: integer)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "min"(): integer
public "max"(): integer
public static "of"(min: integer, max: integer): $IntBounds
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntBounds$$Type = ({"max"?: integer, "min"?: integer}) | ([max?: integer, min?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IntBounds$$Original = $IntBounds;}
declare module "dev.latvian.mods.kubejs.core.FluidKJS" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$FluidLike, $FluidLike$$Interface} from "dev.latvian.mods.kubejs.fluid.FluidLike"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FluidKJS$$Interface extends $RegistryObjectKJS$$Interface<($Fluid)>, $FluidLike$$Interface {
get "fluid"(): $Fluid
get "amount"(): integer
get "registryId"(): $ResourceKey<($Registry<($Fluid)>)>
get "registry"(): $Registry<($Fluid)>
get "empty"(): boolean
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($Fluid)>)>
get "tags"(): $List<($ResourceLocation)>
get "key"(): $ResourceKey<($Fluid)>
get "id"(): StringJS
}

export class $FluidKJS implements $FluidKJS$$Interface {
 "getFluid"(): $Fluid
 "getAmount"(): integer
 "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
 "getRegistry"(): $Registry<($Fluid)>
 "isEmpty"(): boolean
 "asHolder"(): $Holder<($Fluid)>
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "getTagKeys"(): $List<($TagKey<($Fluid)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getKey"(): $ResourceKey<($Fluid)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
 "copy"(amount: integer): $FluidLike
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidKJS$$Type = ($FluidKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidKJS$$Original = $FluidKJS;}
declare module "dev.latvian.mods.kubejs.core.LivingEntityKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$EntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LivingEntityKJS$$Interface extends $EntityKJS$$Interface {
get "defaultMovementSpeed"(): double
set "defaultMovementSpeed"(value: double)
get "reachDistance"(): double
get "living"(): boolean
set "maxHealth"(value: float)
get "undead"(): boolean
get "potionEffects"(): $EntityPotionEffectsJS
get "mainHandItem"(): $ItemStack
set "mainHandItem"(value: $ItemStack$$Type)
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
get "headArmorItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
set "chestArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
set "legsArmorItem"(value: $ItemStack$$Type)
get "feetArmorItem"(): $ItemStack
set "feetArmorItem"(value: $ItemStack$$Type)
get "totalMovementSpeed"(): double
set "movementSpeedAddition"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
get "name"(): $Component
get "displayName"(): $Component
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "server"(): $MinecraftServer
get "block"(): $LevelBlock
get "nbt"(): $CompoundTag
set "nbt"(value: $CompoundTag$$Type)
get "scriptType"(): $ScriptType
get "type"(): StringJS
get "profile"(): $GameProfile
get "player"(): boolean
get "item"(): $ItemStack
get "frame"(): boolean
get "monster"(): boolean
get "animal"(): boolean
get "ambientCreature"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
set "x"(value: double)
set "y"(value: double)
set "z"(value: double)
get "motionX"(): double
set "motionX"(value: double)
get "motionY"(): double
set "motionY"(value: double)
get "motionZ"(): double
set "motionZ"(value: double)
get "passengers"(): $EntityArrayList
get "teamId"(): StringJS
get "facing"(): $Direction
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $LivingEntityKJS implements $LivingEntityKJS$$Interface {
static readonly "KJS_PLAYER_CUSTOM_SPEED": $ResourceLocation

 "self"(): $Entity
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "damageHeldItem"(): void
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "getDefaultMovementSpeed"(): double
 "setDefaultMovementSpeed"(speed: double): void
 "getReachDistance"(): double
 "rayTrace"(): $KubeRayTraceResult
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "setMaxHealth"(hp: float): void
 "isUndead"(): boolean
 "getPotionEffects"(): $EntityPotionEffectsJS
 "swing"(): void
 "swing"(hand: $InteractionHand$$Type): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "getMainHandItem"(): $ItemStack
 "setMainHandItem"(item: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setOffHandItem"(item: $ItemStack$$Type): void
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "getTotalMovementSpeed"(): double
 "setMovementSpeedAddition"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "getServer"(): $MinecraftServer
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "getNbt"(): $CompoundTag
 "setNbt"(nbt: $CompoundTag$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "getType"(): StringJS
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "getItem"(): $ItemStack
 "isFrame"(): boolean
 "isMonster"(): boolean
 "isAnimal"(): boolean
 "isAmbientCreature"(): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setX"(x: double): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "getMotionX"(): double
 "setMotionX"(x: double): void
 "getMotionY"(): double
 "setMotionY"(y: double): void
 "getMotionZ"(): double
 "setMotionZ"(z: double): void
 "setRotation"(yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "getTeamId"(): StringJS
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "getFacing"(): $Direction
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "spawn"(): void
 "attack"(hp: float): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityKJS$$Type = ($LivingEntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LivingEntityKJS$$Original = $LivingEntityKJS;}
declare module "dev.latvian.mods.kubejs.level.SimpleLevelKubeEvent" {
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $SimpleLevelKubeEvent implements $KubeLevelEvent$$Interface {
constructor(l: $Level$$Type)

public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleLevelKubeEvent$$Type = ($SimpleLevelKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleLevelKubeEvent$$Original = $SimpleLevelKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional" {
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"

export interface $RecipeOptional$$Interface<T> {

(type: $RecipeSchemaType): T
get "informativeValue"(): T
get "default"(): boolean
}

export class $RecipeOptional<T> implements $RecipeOptional$$Interface {
static readonly "DEFAULT": $RecipeOptional<(never)>

 "getInformativeValue"(): T
 "isDefault"(): boolean
 "getDefaultValue"(type: $RecipeSchemaType$$Type): T
static "unit"<T>(value: T): $RecipeOptional<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeOptional$$Type<T> = ((type: $RecipeSchemaType) => T);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeOptional$$Original<T> = $RecipeOptional<(T)>;}
declare module "dev.latvian.mods.kubejs.script.data.GeneratedDataStage" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Map} from "java.util.Map"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$EventTargetType} from "dev.latvian.mods.kubejs.event.EventTargetType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $GeneratedDataStage extends $Enum<($GeneratedDataStage)> implements $StringRepresentable$$Interface {
static readonly "BEFORE_MODS": $GeneratedDataStage
static readonly "TARGET": $EventTargetType<($GeneratedDataStage)>
static readonly "REGISTRIES": $GeneratedDataStage
static readonly "LAST": $GeneratedDataStage
readonly "displayName": StringJS
static readonly "INTERNAL": $GeneratedDataStage
static readonly "AFTER_MODS": $GeneratedDataStage
static readonly "FOR_SCRIPTS": ($GeneratedDataStage)[]

public static "values"(): ($GeneratedDataStage)[]
public static "valueOf"(name: StringJS): $GeneratedDataStage
public "getSerializedName"(): StringJS
public static "forScripts"<T>(factory: $Function$$Type<($GeneratedDataStage), (T)>): $Map<($GeneratedDataStage), (T)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedDataStage$$Type = (("internal") | ("registries") | ("before_mods") | ("after_mods") | ("last"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeneratedDataStage$$Original = $GeneratedDataStage;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Axe" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Axe extends $DiggerItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
static readonly "AXE_MODEL": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "AXE_TAGS": ($ResourceLocation)[]

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Axe$$Type = ($DiggerItemBuilder$Axe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Axe$$Original = $DiggerItemBuilder$Axe;}
declare module "dev.latvian.mods.kubejs.component.ComponentFunctions" {
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$Map$$Type} from "java.util.Map"
import {$UUID$$Type} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export interface $ComponentFunctions$$Interface {
get "componentMap"(): $DataComponentMap
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "componentString"(): StringJS
set "customData"(value: $CompoundTag$$Type)
get "customData"(): $CompoundTag
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customModelData"(value: integer)
get "additionalTooltipHidden"(): void
get "tooltipHidden"(): void
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "lockCode"(value: StringJS)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
}

export class $ComponentFunctions implements $ComponentFunctions$$Interface {
 "resetComponents"(): this
 "patch"(components: $DataComponentPatch$$Type): this
 "set"(components: $DataComponentMap$$Type): this
 "set"(component: $DataComponentType$$Type<(never)>, value: any): this
 "getComponentMap"(): $DataComponentMap
 "remove"(type: $DataComponentType$$Type<(never)>): this
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): this
 "getComponentString"(): StringJS
 "setCustomData"(tag: $CompoundTag$$Type): void
 "getCustomData"(): $CompoundTag
 "setRarity"(rarity: $Rarity$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setCustomModelData"(data: integer): void
 "setAdditionalTooltipHidden"(): void
 "setTooltipHidden"(): void
 "setGlintOverride"(override: boolean): void
 "setDyedColor"(color: $KubeColor$$Type): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "setLockCode"(lock: StringJS): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentFunctions$$Type = ($ComponentFunctions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentFunctions$$Original = $ComponentFunctions;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue" {
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$WrappedJS$$Interface} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$Comparable} from "java.lang.Comparable"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$Map$Entry, $Map$Entry$$Type, $Map$Entry$$Interface} from "java.util.Map$Entry"

export class $RecipeComponentValue<T> implements $WrappedJS$$Interface, $Map$Entry$$Interface<($RecipeKey<(T)>), (T)> {
static readonly "EMPTY_ARRAY": ($RecipeComponentValue<(never)>)[]
readonly "index": integer
 "value": T
readonly "key": $RecipeKey<(T)>

constructor(key: $RecipeKey$$Type<(T)>, index: integer)

public "shouldWrite"(): boolean
public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getValue"(): T
public "replace"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "matches"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, sourceLine: $SourceLine$$Type): void
public "getKey"(): $RecipeKey<(T)>
public "write"(): void
public "setValue"(newValue: T): T
public "copy"(): $RecipeComponentValue<(T)>
public "getIndex"(): integer
public static "copyOf"<K, V>(arg0: $Map$Entry$$Type<($RecipeKey$$Type<(T)>), (T)>): $Map$Entry<($RecipeKey<(T)>), (T)>
public static "comparingByKey"<K, V>(arg0: $Comparator$$Type<($RecipeKey<(T)>)>): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByKey"<K extends $Comparable<(object)>, V>(): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByValue"<K, V extends $Comparable<(object)>>(): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByValue"<K, V>(arg0: $Comparator$$Type<(T)>): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentValue$$Type<T> = ($RecipeComponentValue<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentValue$$Original<T> = $RecipeComponentValue<(T)>;}
declare module "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $ShapedBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type, ...suffixes: (StringJS)[])

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedBlockBuilder$$Type = ($ShapedBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShapedBlockBuilder$$Original = $ShapedBlockBuilder;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityEventCallback" {
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"

export interface $BlockEntityEventCallback$$Interface {

(entity: $KubeBlockEntity, data: integer): void
}

export class $BlockEntityEventCallback implements $BlockEntityEventCallback$$Interface {
 "accept"(entity: $KubeBlockEntity$$Type, data: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityEventCallback$$Type = ((entity: $KubeBlockEntity, data: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityEventCallback$$Original = $BlockEntityEventCallback;}
declare module "dev.latvian.mods.kubejs.recipe.KubeRecipeContext" {
import {$RecipeLikeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.RecipeLikeContext"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $KubeRecipeContext$$Interface extends $RecipeLikeContext$$Interface {
}

export class $KubeRecipeContext implements $KubeRecipeContext$$Interface {
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
 "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipeContext$$Type = ($KubeRecipeContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRecipeContext$$Original = $KubeRecipeContext;}
declare module "dev.latvian.mods.kubejs.server.tag.TagWrapper" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List, $List$$Type} from "java.util.List"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$TagKubeEvent, $TagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"

export class $TagWrapper {
readonly "entries": $List<($TagLoader$EntryWithSource)>
readonly "id": $ResourceLocation
readonly "event": $TagKubeEvent

constructor(e: $TagKubeEvent$$Type, i: $ResourceLocation$$Type, t: $List$$Type<($TagLoader$EntryWithSource$$Type)>)

public "getObjectIds"(): $List<($ResourceLocation)>
public "remove"(...filters: (any)[]): $TagWrapper
public "toString"(): StringJS
public "add"(...filters: (any)[]): $TagWrapper
public "removeAll"(): $TagWrapper
get "objectIds"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagWrapper$$Type = ($TagWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagWrapper$$Original = $TagWrapper;}
declare module "dev.latvian.mods.kubejs.recipe.match.FluidMatch" {
import {$ReplacementMatch, $ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

export interface $FluidMatch$$Interface extends $ReplacementMatch$$Interface {
}

export class $FluidMatch implements $FluidMatch$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, stack: $FluidStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, ingredient: $FluidIngredient$$Type, exact: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidMatch$$Type = ($FluidMatch);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidMatch$$Original = $FluidMatch;}
declare module "dev.latvian.mods.kubejs.item.ItemStackKey" {
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemStackKey {
readonly "patch": $DataComponentPatch
readonly "item": $Item
static "EMPTY": $ItemStackKey

constructor(item: $Item$$Type, patch: $DataComponentPatch$$Type)

public "equals"(obj: any): boolean
public "hashCode"(): integer
public static "of"(stack: $ItemStack$$Type): $ItemStackKey
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackKey$$Type = ($ItemStackKey);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemStackKey$$Original = $ItemStackKey;}
declare module "dev.latvian.mods.kubejs.core.LocalClientPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction} from "net.minecraft.core.Direction"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$ClientPlayerKJS$$Interface} from "dev.latvian.mods.kubejs.core.ClientPlayerKJS"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LocalClientPlayerKJS$$Interface extends $ClientPlayerKJS$$Interface {

(): $AttachedData$$Type<($Player$$Type)>
set "activePostShader"(value: $ResourceLocation$$Type)
get "stats"(): $PlayerStatsJS
get "miningBlock"(): boolean
get "minecraft"(): $Minecraft
set "statusMessage"(value: $Component$$Type)
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "craftingGrid"(): $InventoryKJS
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "selectedSlot"(): integer
get "fake"(): boolean
set "selectedSlot"(value: integer)
get "mouseItem"(): $ItemStack
set "mouseItem"(value: $ItemStack$$Type)
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "saturation"(): float
set "saturation"(value: float)
set "xp"(value: integer)
get "xp"(): integer
set "xpLevel"(value: integer)
get "xpLevel"(): integer
get "openInventory"(): $AbstractContainerMenu
get "profile"(): $GameProfile
get "player"(): boolean
get "defaultMovementSpeed"(): double
set "defaultMovementSpeed"(value: double)
get "reachDistance"(): double
get "living"(): boolean
set "maxHealth"(value: float)
get "undead"(): boolean
get "potionEffects"(): $EntityPotionEffectsJS
get "mainHandItem"(): $ItemStack
set "mainHandItem"(value: $ItemStack$$Type)
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
get "headArmorItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
set "chestArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
set "legsArmorItem"(value: $ItemStack$$Type)
get "feetArmorItem"(): $ItemStack
set "feetArmorItem"(value: $ItemStack$$Type)
get "totalMovementSpeed"(): double
set "movementSpeedAddition"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
get "data"(): $AttachedData<($Player)>
get "name"(): $Component
get "displayName"(): $Component
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "server"(): $MinecraftServer
get "block"(): $LevelBlock
get "nbt"(): $CompoundTag
set "nbt"(value: $CompoundTag$$Type)
get "scriptType"(): $ScriptType
get "type"(): StringJS
get "item"(): $ItemStack
get "frame"(): boolean
get "monster"(): boolean
get "animal"(): boolean
get "ambientCreature"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
set "x"(value: double)
set "y"(value: double)
set "z"(value: double)
get "motionX"(): double
set "motionX"(value: double)
get "motionY"(): double
set "motionY"(value: double)
get "motionZ"(): double
set "motionZ"(value: double)
get "passengers"(): $EntityArrayList
get "teamId"(): StringJS
get "facing"(): $Direction
get "persistentData"(): $CompoundTag
}

export class $LocalClientPlayerKJS implements $LocalClientPlayerKJS$$Interface {
 "isSelf"(): boolean
 "self"(): $LivingEntity
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "notify"(notification: $NotificationToastData$$Type): void
 "getStats"(): $PlayerStatsJS
 "isMiningBlock"(): boolean
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "getMinecraft"(): $Minecraft
 "setStatusMessage"(message: $Component$$Type): void
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "getCraftingGrid"(): $InventoryKJS
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "getSelectedSlot"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "isFake"(): boolean
 "sendInventoryUpdate"(): void
 "give"(item: $ItemStack$$Type): void
 "giveInHand"(item: $ItemStack$$Type): void
 "setSelectedSlot"(index: integer): void
 "getMouseItem"(): $ItemStack
 "setMouseItem"(item: $ItemStack$$Type): void
 "addFood"(f: integer, m: float): void
 "getFoodLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "getSaturation"(): float
 "setSaturation"(saturation: float): void
 "addExhaustion"(exhaustion: float): void
 "addXP"(xp: integer): void
 "addXPLevels"(l: integer): void
 "setXp"(xp: integer): void
 "getXp"(): integer
 "setXpLevel"(l: integer): void
 "getXpLevel"(): integer
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "spawn"(): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "damageHeldItem"(): void
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "getDefaultMovementSpeed"(): double
 "setDefaultMovementSpeed"(speed: double): void
 "getReachDistance"(): double
 "rayTrace"(): $KubeRayTraceResult
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "setMaxHealth"(hp: float): void
 "isUndead"(): boolean
 "getPotionEffects"(): $EntityPotionEffectsJS
 "swing"(): void
 "swing"(hand: $InteractionHand$$Type): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "getMainHandItem"(): $ItemStack
 "setMainHandItem"(item: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setOffHandItem"(item: $ItemStack$$Type): void
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "getTotalMovementSpeed"(): double
 "setMovementSpeedAddition"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "getServer"(): $MinecraftServer
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "getNbt"(): $CompoundTag
 "setNbt"(nbt: $CompoundTag$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "getType"(): StringJS
 "getItem"(): $ItemStack
 "isFrame"(): boolean
 "isMonster"(): boolean
 "isAnimal"(): boolean
 "isAmbientCreature"(): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setX"(x: double): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "getMotionX"(): double
 "setMotionX"(x: double): void
 "getMotionY"(): double
 "setMotionY"(y: double): void
 "getMotionZ"(): double
 "setMotionZ"(z: double): void
 "setRotation"(yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "getTeamId"(): StringJS
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "getFacing"(): $Direction
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "attack"(hp: float): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LocalClientPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LocalClientPlayerKJS$$Original = $LocalClientPlayerKJS;}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator" {
import {$JsonObject} from "com.google.gson.JsonObject"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$SoundsGenerator$SoundGen$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen"

export class $SoundsGenerator {
constructor()

public "addSound"(path: StringJS, consumer: $Consumer$$Type<($SoundsGenerator$SoundGen)>): void
public "addSound"(path: StringJS, consumer: $Consumer$$Type<($SoundsGenerator$SoundGen)>, overlayExisting: boolean): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$$Type = ($SoundsGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundsGenerator$$Original = $SoundsGenerator;}
declare module "dev.latvian.mods.kubejs.core.WithPersistentData" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WithPersistentData$$Interface extends $MessageSenderKJS$$Interface {
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export class $WithPersistentData implements $WithPersistentData$$Interface {
 "getPersistentData"(): $CompoundTag
 "tell"(message: $Component$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithPersistentData$$Type = ($WithPersistentData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithPersistentData$$Original = $WithPersistentData;}
declare module "dev.latvian.mods.kubejs.entity.KubeRayTraceResult" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Direction} from "net.minecraft.core.Direction"
import {$HitResult$Type} from "net.minecraft.world.phys.HitResult$Type"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $KubeRayTraceResult {
readonly "hit": $Vec3
readonly "fromEntity": $Entity
readonly "distance": double
readonly "facing": $Direction
readonly "block": $LevelBlock
readonly "type": $HitResult$Type
readonly "entity": $Entity

constructor(from: $Entity$$Type, result: $HitResult$$Type)
constructor(from: $Entity$$Type, result: $HitResult$$Type, d: double)

public "getHitX"(): double
public "getHitY"(): double
public "getHitZ"(): double
get "hitX"(): double
get "hitY"(): double
get "hitZ"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRayTraceResult$$Type = ($KubeRayTraceResult);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRayTraceResult$$Original = $KubeRayTraceResult;}
declare module "dev.latvian.mods.kubejs.script.ScriptTypeHolder" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptTypeHolder$$Interface {

(): $ScriptType$$Type
}

export class $ScriptTypeHolder implements $ScriptTypeHolder$$Interface {
 "kjs$getScriptType"(): $ScriptType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptTypeHolder$$Type = (() => $ScriptType$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptTypeHolder$$Original = $ScriptTypeHolder;}
declare module "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$BlockModificationKubeEvent$BlockModifications$$Type} from "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent$BlockModifications"
import {$BlockStatePredicate$$Type} from "dev.latvian.mods.kubejs.block.state.BlockStatePredicate"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $BlockModificationKubeEvent implements $KubeEvent$$Interface {
constructor()

/**
 * Modifies blocks that match the given predicate.
 * 
 * **NOTE**: tag predicates are not supported at this time.
 */
public "modify"(predicate: $BlockStatePredicate$$Type, c: $Consumer$$Type<($BlockModificationKubeEvent$BlockModifications)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModificationKubeEvent$$Type = ($BlockModificationKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockModificationKubeEvent$$Original = $BlockModificationKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KeyEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$KubeJSKeybinds$KubeKey$$Type} from "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KubeKey"
import {$ClientPlayerKubeEvent} from "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent"

export class $KubeJSKeybinds$KeyEvent extends $ClientPlayerKubeEvent {
constructor(player: $LocalPlayer$$Type, key: $KubeJSKeybinds$KubeKey$$Type)

public "getEntity"(): $Player
get "entity"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSKeybinds$KeyEvent$$Type = ($KubeJSKeybinds$KeyEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSKeybinds$KeyEvent$$Original = $KubeJSKeybinds$KeyEvent;}
declare module "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent$BlockModifications" {
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Record} from "java.lang.Record"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $BlockModificationKubeEvent$BlockModifications extends $Record {
constructor(block: $Block$$Type)

public "setRequiresTool"(v: boolean): void
public "setHasCollision"(v: boolean): void
public "setExplosionResistance"(v: float): void
public "setIsRandomlyTicking"(v: boolean): void
public "setRandomTickCallback"(callback: $Consumer$$Type<($RandomTickCallback)>): void
public "setSoundType"(v: $SoundType$$Type): void
public "setFriction"(v: float): void
public "setSpeedFactor"(v: float): void
public "setJumpFactor"(v: float): void
public "setDestroySpeed"(v: float): void
public "setLightEmission"(v: integer): void
public "setNameKey"(key: StringJS): void
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "block"(): $Block
set "requiresTool"(value: boolean)
set "hasCollision"(value: boolean)
set "explosionResistance"(value: float)
set "isRandomlyTicking"(value: boolean)
set "randomTickCallback"(value: $Consumer$$Type<($RandomTickCallback)>)
set "soundType"(value: $SoundType$$Type)
set "friction"(value: float)
set "speedFactor"(value: float)
set "jumpFactor"(value: float)
set "destroySpeed"(value: float)
set "lightEmission"(value: integer)
set "nameKey"(value: StringJS)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModificationKubeEvent$BlockModifications$$Type = ({"block"?: $Block$$Type}) | ([block?: $Block$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockModificationKubeEvent$BlockModifications$$Original = $BlockModificationKubeEvent$BlockModifications;}
declare module "dev.latvian.mods.kubejs.core.DataSenderKJS" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $DataSenderKJS$$Interface {
}

export class $DataSenderKJS implements $DataSenderKJS$$Interface {
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "sendData"(channel: StringJS): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataSenderKJS$$Type = ($DataSenderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataSenderKJS$$Original = $DataSenderKJS;}
declare module "dev.latvian.mods.kubejs.core.ItemFrameEntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$EntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemFrameEntityKJS$$Interface extends $EntityKJS$$Interface {
get "item"(): $ItemStack
get "frame"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "living"(): boolean
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "server"(): $MinecraftServer
get "block"(): $LevelBlock
get "nbt"(): $CompoundTag
set "nbt"(value: $CompoundTag$$Type)
get "scriptType"(): $ScriptType
get "type"(): StringJS
get "profile"(): $GameProfile
get "player"(): boolean
get "monster"(): boolean
get "animal"(): boolean
get "ambientCreature"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
set "x"(value: double)
set "y"(value: double)
set "z"(value: double)
get "motionX"(): double
set "motionX"(value: double)
get "motionY"(): double
set "motionY"(value: double)
get "motionZ"(): double
set "motionZ"(value: double)
get "passengers"(): $EntityArrayList
get "teamId"(): StringJS
get "facing"(): $Direction
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $ItemFrameEntityKJS implements $ItemFrameEntityKJS$$Interface {
 "self"(): $Entity
 "getItem"(): $ItemStack
 "isFrame"(): boolean
 "tell"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "getServer"(): $MinecraftServer
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "getNbt"(): $CompoundTag
 "setNbt"(nbt: $CompoundTag$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "getType"(): StringJS
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "isMonster"(): boolean
 "isAnimal"(): boolean
 "isAmbientCreature"(): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setX"(x: double): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "getMotionX"(): double
 "setMotionX"(x: double): void
 "getMotionY"(): double
 "setMotionY"(y: double): void
 "getMotionZ"(): double
 "setMotionZ"(z: double): void
 "setRotation"(yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "getTeamId"(): StringJS
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "getFacing"(): $Direction
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "spawn"(): void
 "attack"(hp: float): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFrameEntityKJS$$Type = ($ItemFrameEntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemFrameEntityKJS$$Original = $ItemFrameEntityKJS;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$FluidData$Group, $FluidData$Group$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Group"
import {$FluidData$Info, $FluidData$Info$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Info"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$FluidData$DataComponentSubtypes, $FluidData$DataComponentSubtypes$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$DataComponentSubtypes"
import {$Record} from "java.lang.Record"

export class $FluidData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData)>

constructor(addedEntries: $List$$Type<($FluidStack$$Type)>, removedEntries: $List$$Type<($FluidIngredient$$Type)>, completelyRemovedEntries: $List$$Type<($FluidIngredient$$Type)>, groupedEntries: $List$$Type<($FluidData$Group$$Type)>, info: $List$$Type<($FluidData$Info$$Type)>, dataComponentSubtypes: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>)

public "groupedEntries"(): $List<($FluidData$Group)>
public "removedEntries"(): $List<($FluidIngredient)>
public "completelyRemovedEntries"(): $List<($FluidIngredient)>
public "addedEntries"(): $List<($FluidStack)>
public "dataComponentSubtypes"(): $List<($FluidData$DataComponentSubtypes)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $FluidData
public "info"(): $List<($FluidData$Info)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$$Type = ({"dataComponentSubtypes"?: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>, "removedEntries"?: $List$$Type<($FluidIngredient$$Type)>, "groupedEntries"?: $List$$Type<($FluidData$Group$$Type)>, "completelyRemovedEntries"?: $List$$Type<($FluidIngredient$$Type)>, "info"?: $List$$Type<($FluidData$Info$$Type)>, "addedEntries"?: $List$$Type<($FluidStack$$Type)>}) | ([dataComponentSubtypes?: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>, removedEntries?: $List$$Type<($FluidIngredient$$Type)>, groupedEntries?: $List$$Type<($FluidData$Group$$Type)>, completelyRemovedEntries?: $List$$Type<($FluidIngredient$$Type)>, info?: $List$$Type<($FluidData$Info$$Type)>, addedEntries?: $List$$Type<($FluidStack$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$$Original = $FluidData;}
declare module "dev.latvian.mods.kubejs.util.RotationAxis" {
import {$Enum} from "java.lang.Enum"
import {$Vector3f} from "org.joml.Vector3f"
import {$Quaternionf} from "org.joml.Quaternionf"

export class $RotationAxis extends $Enum<($RotationAxis)> {
static readonly "ZN": $RotationAxis
static readonly "YN": $RotationAxis
readonly "vec": $Vector3f
static readonly "XN": $RotationAxis
static readonly "ZP": $RotationAxis
static readonly "YP": $RotationAxis
static readonly "XP": $RotationAxis

public "deg"(f: float): $Quaternionf
public static "values"(): ($RotationAxis)[]
public static "valueOf"(name: StringJS): $RotationAxis
public "rad"(f: float): $Quaternionf
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotationAxis$$Type = (("xn") | ("xp") | ("yn") | ("yp") | ("zn") | ("zp"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RotationAxis$$Original = $RotationAxis;}
declare module "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo" {
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecordTypeInfo} from "dev.latvian.mods.rhino.type.RecordTypeInfo"
import {$Record} from "java.lang.Record"

export class $ReplacementMatchInfo extends $Record {
static readonly "TYPE_INFO": $RecordTypeInfo
static readonly "NONE": $ReplacementMatchInfo

constructor(match: $ReplacementMatch$$Type, exact: boolean, componentType: ($RecipeComponent$$Type<(never)>)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "componentType"(): $Optional<($RecipeComponent<(never)>)>
public static "wrap"(o: any, target: $TypeInfo$$Type): $ReplacementMatchInfo
public "match"(): $ReplacementMatch
public "exact"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementMatchInfo$$Type = ({"componentType"?: ($RecipeComponent$$Type<(never)>)?, "exact"?: boolean, "match"?: $ReplacementMatch$$Type}) | ([componentType?: ($RecipeComponent$$Type<(never)>)?, exact?: boolean, match?: $ReplacementMatch$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplacementMatchInfo$$Original = $ReplacementMatchInfo;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeLikeContext" {
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeLikeContext$$Interface {
}

export class $RecipeLikeContext implements $RecipeLikeContext$$Interface {
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
 "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeLikeContext$$Type = ($RecipeLikeContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeLikeContext$$Original = $RecipeLikeContext;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.ItemWrapper" {
import {$DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Collection} from "java.util.Collection"
import {$Map} from "java.util.Map"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$UUID$$Type} from "java.util.UUID"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$List} from "java.util.List"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$ItemAbility} from "net.neoforged.neoforge.common.ItemAbility"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"

/**
 * Various item related helper methods
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemWrapper$$Interface {
public static get "typeToStackMap"(): $Map<($ResourceLocation), ($Collection<($ItemStack)>)>
public static get "list"(): $List<($ItemStack)>
public static get "empty"(): $ItemStack
public static get "typeList"(): $List<(StringJS)>
}

export class $ItemWrapper implements $ItemWrapper$$Interface {
static readonly "ITEM_TYPE_INFO": $TypeInfo
static readonly "EMPTY_ARRAY": ($ItemStack)[]
static readonly "TYPE_INFO": $TypeInfo

static "findItem"(s: StringJS): $DataResult<($Item)>
static "getTypeToStackMap"(): $Map<($ResourceLocation), ($Collection<($ItemStack)>)>
static "playerHeadFromBase64"(uuid: $UUID$$Type, textureBase64: StringJS): $ItemStack
static "playerHeadFromUrl"(url: StringJS): $ItemStack
static "wrapItemAbility"(object: any): $ItemAbility
/**
 * Checks if the passed in object is an ItemStack.
 * Note that this does not mean it will not function as an ItemStack if passed to something that requests one.
 */
static "isItem"(o: any): boolean
static "playerHead"(name: StringJS): $ItemStack
static "playerHeadFromSkinHash"(hash: StringJS): $ItemStack
static "isItemStackLike"(from: any): boolean
static "parseJson"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, json: $JsonElement$$Type): $DataResult<($ItemStack)>
static "getVariants"(item: $ItemStack$$Type): $Collection<($ItemStack)>
/**
 * Gets an Item from an item id
 */
static "getItem"(id: $ResourceLocation$$Type): $Item
static "parseString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($ItemStack)>
/**
 * Returns an ItemStack of the input, with the specified count and data components
 */
static "of"(arg0: $ItemStack$$Type, count: integer, components: $DataComponentMap$$Type): $ItemStack
/**
 * Returns an ItemStack of the input
 */
static "of"(arg0: $ItemStack$$Type): $ItemStack
/**
 * Returns an ItemStack of the input, with the specified count
 */
static "of"(arg0: $ItemStack$$Type, count: integer): $ItemStack
/**
 * Returns an ItemStack of the input, with the specified data components
 */
static "of"(arg0: $ItemStack$$Type, components: $DataComponentMap$$Type): $ItemStack
static "read"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<($ItemStack)>
/**
 * Gets an items id from the Item
 */
static "getId"(item: $Item$$Type): $ResourceLocation
/**
 * Checks if the provided item id exists in the registry
 */
static "exists"(id: $ResourceLocation$$Type): boolean
/**
 * Get a list of most items in the game. Items not in a creative tab are ignored
 */
static "getList"(): $List<($ItemStack)>
/**
 * Get the item that represents air/an empty slot
 */
static "getEmpty"(): $ItemStack
/**
 * Get a list of all the item ids in the game
 */
static "getTypeList"(): $List<(StringJS)>
/**
 * Returns a Firework with the input properties
 */
static "fireworks"(fireworks: $Fireworks$$Type): $Fireworks
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemWrapper$$Type = ($ItemWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemWrapper$$Original = $ItemWrapper;}
declare module "dev.latvian.mods.kubejs.client.EntityRendererRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$EntityRenderersEvent$RegisterRenderers$$Type} from "net.neoforged.neoforge.client.event.EntityRenderersEvent$RegisterRenderers"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$EntityRendererProvider$$Type} from "net.minecraft.client.renderer.entity.EntityRendererProvider"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $EntityRendererRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $EntityRenderersEvent$RegisterRenderers$$Type)

public "register"(type: $EntityType$$Type<(never)>, renderer: $EntityRendererProvider$$Type): void
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRendererRegistryKubeEvent$$Type = ($EntityRendererRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityRendererRegistryKubeEvent$$Original = $EntityRendererRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemModelPropertiesKubeEvent" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeStartupEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$ClampedItemPropertyFunction$$Type} from "net.minecraft.client.renderer.item.ClampedItemPropertyFunction"

export class $ItemModelPropertiesKubeEvent implements $KubeStartupEvent$$Interface {
constructor()

/**
 * Register a model property for an item. Model properties are used to change the appearance of an item in the world.
 * 
 * More about model properties: https://minecraft.wiki/w/Tutorials/Models#Item_predicates
 */
public "register"(ingredient: $Ingredient$$Type, overwriteId: $ResourceLocation$$Type, callback: $ClampedItemPropertyFunction$$Type): void
/**
 * Register a model property for all items.
 */
public "registerAll"(overwriteId: $ResourceLocation$$Type, callback: $ClampedItemPropertyFunction$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModelPropertiesKubeEvent$$Type = ($ItemModelPropertiesKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemModelPropertiesKubeEvent$$Original = $ItemModelPropertiesKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.ScriptType" {
import {$KubeJSFileWatcherThread} from "dev.latvian.mods.kubejs.script.KubeJSFileWatcherThread"
import {$Map} from "java.util.Map"
import {$Enum} from "java.lang.Enum"
import {$List} from "java.util.List"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$NativeEventWrapper$Listeners} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper$Listeners"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$NativeEventWrapper$Listeners$Key} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper$Listeners$Key"
import {$ScriptTypeHolder$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$ScriptTypePredicate, $ScriptTypePredicate$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$Path} from "java.nio.file.Path"
import {$ConsoleJS} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$ClassFilter} from "dev.latvian.mods.kubejs.plugin.ClassFilter"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptType extends $Enum<($ScriptType)> implements $ScriptTypePredicate$$Interface, $ScriptTypeHolder$$Interface {
readonly "console": $ConsoleJS
readonly "path": $Path
readonly "nativeEventListeners": $Map<($NativeEventWrapper$Listeners$Key), ($NativeEventWrapper$Listeners)>
static readonly "SERVER": $ScriptType
 "fileWatcherThread": $KubeJSFileWatcherThread
static readonly "VALUES": ($ScriptType)[]
static readonly "STARTUP": $ScriptType
readonly "classFilter": $Lazy<($ClassFilter)>
static readonly "CLIENT": $ScriptType
readonly "nameStrip": StringJS

public "isServer"(): boolean
public "negate"(): $ScriptTypePredicate
public static "values"(): ($ScriptType)[]
public "test"(type: any): boolean
public "test"(type: $ScriptType$$Type): boolean
public static "valueOf"(name: StringJS): $ScriptType
public "isClient"(): boolean
public "kjs$getScriptType"(): $ScriptType
public "getLogFile"(): $Path
public "isStartup"(): boolean
public "getValidTypes"(): $List<($ScriptType)>
public "or"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public static "isEqual"<T>(arg0: any): $Predicate<($ScriptType)>
public "and"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public static "not"<T>(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
get "server"(): boolean
get "client"(): boolean
get "logFile"(): $Path
get "startup"(): boolean
get "validTypes"(): $List<($ScriptType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptType$$Type = (("startup") | ("server") | ("client"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptType$$Original = $ScriptType;}
declare module "dev.latvian.mods.kubejs.item.custom.SwordItemBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$HandheldItemBuilder} from "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $SwordItemBuilder extends $HandheldItemBuilder {
static readonly "SWORD_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "SWORD_MODEL": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SwordItemBuilder$$Type = ($SwordItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SwordItemBuilder$$Original = $SwordItemBuilder;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$HandheldItemBuilder} from "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem, $DiggerItem$$Type} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder extends $HandheldItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type, d: float, s: float, f: $BiFunction$$Type<($Tier), ($Item$Properties), ($DiggerItem$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$$Type = ($DiggerItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$$Original = $DiggerItemBuilder;}
declare module "dev.latvian.mods.kubejs.core.MinecraftClientKJS" {
import {$TextureAtlasSprite} from "net.minecraft.client.renderer.texture.TextureAtlasSprite"
import {$Screen, $Screen$$Type} from "net.minecraft.client.gui.screens.Screen"
import {$ScheduledEvents, $ScheduledEvents$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$KeyMapping$$Type} from "net.minecraft.client.KeyMapping"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MinecraftEnvironmentKJS$$Interface} from "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS"
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function} from "java.util.function.Function"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$ScheduledEvents$ScheduledEvent} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MinecraftClientKJS$$Interface extends $MinecraftEnvironmentKJS$$Interface {

(): $ScheduledEvents$$Type
get "title"(): StringJS
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "currentScreen"(): $Screen
set "currentScreen"(value: $Screen$$Type)
set "title"(value: StringJS)
get "currentWorldName"(): StringJS
get "shiftDown"(): boolean
get "ctrlDown"(): boolean
get "altDown"(): boolean
get "blockTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
get "particleTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
get "scheduledEvents"(): $ScheduledEvents
get "displayName"(): $Component
}

export class $MinecraftClientKJS implements $MinecraftClientKJS$$Interface {
 "self"(): $Minecraft
 "getTitle"(): StringJS
 "tell"(message: $Component$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "isKeyDown"(keyName: StringJS): boolean
 "isKeyDown"(key: integer): boolean
 "getName"(): $Component
 "getCurrentScreen"(): $Screen
 "setCurrentScreen"(gui: $Screen$$Type): void
 "setTitle"(t: StringJS): void
 "getCurrentWorldName"(): StringJS
 "isKeyBindDown"(id: StringJS): boolean
 "getKeyBindPressedTicks"(id: StringJS): integer
 "isKeyMappingDown"(key: $KeyMapping$$Type): boolean
 "isShiftDown"(): boolean
 "isCtrlDown"(): boolean
 "isAltDown"(): boolean
 "getBlockTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
 "getParticleTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
 "getScheduledEvents"(): $ScheduledEvents
 "schedule"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeating"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeatingInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftClientKJS$$Type = (() => $ScheduledEvents$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecraftClientKJS$$Original = $MinecraftClientKJS;}
declare module "dev.latvian.mods.kubejs.misc.PaintingVariantBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$PaintingVariant} from "net.minecraft.world.entity.decoration.PaintingVariant"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $PaintingVariantBuilder extends $BuilderBase<($PaintingVariant)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "assetId"(assetId: $ResourceLocation$$Type): this
public "size"(width: integer, height: integer): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaintingVariantBuilder$$Type = ($PaintingVariantBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PaintingVariantBuilder$$Original = $PaintingVariantBuilder;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabIconSupplier" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"

export interface $CreativeTabIconSupplier$$Interface {

(): $ItemStack$$Type
get "icon"(): $ItemStack
}

export class $CreativeTabIconSupplier implements $CreativeTabIconSupplier$$Interface {
static readonly "DEFAULT": $CreativeTabIconSupplier

 "getIcon"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabIconSupplier$$Type = (() => $ItemStack$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabIconSupplier$$Original = $CreativeTabIconSupplier;}
declare module "dev.latvian.mods.kubejs.util.OrderedCompoundTag" {
import {$TagType} from "net.minecraft.nbt.TagType"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$DataOutput$$Type} from "java.io.DataOutput"

export class $OrderedCompoundTag extends $CompoundTag {
static readonly "CODEC": $Codec<($CompoundTag)>
readonly "tagMap": $Map<(StringJS), ($Tag)>
static readonly "TYPE": $TagType<($CompoundTag)>
readonly "tags": $Map<(StringJS), ($Tag)>

constructor(map: $Map$$Type<(StringJS), ($Tag$$Type)>)
constructor()

public "write"(dataOutput: $DataOutput$$Type): void
public "copy"(): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrderedCompoundTag$$Type = ($OrderedCompoundTag);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OrderedCompoundTag$$Original = $OrderedCompoundTag;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuData" {
import {$ChestMenuSlot, $ChestMenuSlot$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container} from "net.minecraft.world.Container"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$ClickType$$Type} from "net.minecraft.world.inventory.ClickType"
import {$Runnable} from "java.lang.Runnable"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$ChestMenuInventoryClickEvent$Callback} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent$Callback"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ChestMenuData {
 "capturedInventory": $Container
readonly "slots": ($ChestMenuSlot)[]
 "mouseItem": $ItemStack
 "anyClicked": $ChestMenuClickEvent$Callback
 "closed": $Runnable
 "inventoryClicked": $ChestMenuInventoryClickEvent$Callback
 "title": $Component
readonly "rows": integer
 "playerSlots": boolean
readonly "player": $ServerPlayer

constructor(player: $ServerPlayer$$Type, title: $Component$$Type, rows: integer)

public "handleClick"(index: integer, type: $ClickType$$Type, button: integer): void
public "slot"(x: integer, y: integer, slot: $Consumer$$Type<($ChestMenuSlot)>): void
public "slot"(x0: integer, y0: integer, x1: integer, y1: integer, slot: $Consumer$$Type<($ChestMenuSlot)>): void
public "getSlot"(x: integer, y: integer): $ChestMenuSlot
public "sync"(): void
public "button"(x: integer, y: integer, stack: $ItemStack$$Type, displayName: $Component$$Type, leftClicked: $ChestMenuClickEvent$Callback$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuData$$Type = ($ChestMenuData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuData$$Original = $ChestMenuData;}
declare module "dev.latvian.mods.kubejs.registry.ModelledBuilderBase" {
import {$ModelGenerator$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator"
import {$Map$$Type} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ModelledBuilderBase<T> extends $BuilderBase<(T)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

/**
 * Sets the parent model.
 */
public "parentModel"(id: $ResourceLocation$$Type): this
/**
 * Replaces default model with custom generator.
 */
public "modelGenerator"(generator: $Consumer$$Type<($ModelGenerator)>): this
/**
 * Directly set the texture map.
 */
public "textures"(map: $Map$$Type<(StringJS), (StringJS)>): this
/**
 * Sets the texture by given key.
 */
public "texture"(key: (StringJS)[], tex: StringJS): this
/**
 * Sets the texture.
 */
public "texture"(tex: StringJS): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelledBuilderBase$$Type<T> = ($ModelledBuilderBase<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelledBuilderBase$$Original<T> = $ModelledBuilderBase<(T)>;}
declare module "dev.latvian.mods.kubejs.block.entity.FluidTankAttachment$Factory" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $FluidTankAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(capacity: integer, inputFilter: ($FluidIngredient$$Type)?)

public "inputFilter"(): $Optional<($FluidIngredient)>
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "capacity"(): integer
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankAttachment$Factory$$Type = ({"capacity"?: integer, "inputFilter"?: ($FluidIngredient$$Type)?}) | ([capacity?: integer, inputFilter?: ($FluidIngredient$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTankAttachment$Factory$$Original = $FluidTankAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RegistryAwareSchema" {
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RegistryAwareSchema$$Interface {

(cx: $RegistryAccessContainer): $RecipeSchema$$Type
}

export class $RegistryAwareSchema implements $RegistryAwareSchema$$Interface {
 "create"(cx: $RegistryAccessContainer$$Type): $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryAwareSchema$$Type = ((cx: $RegistryAccessContainer) => $RecipeSchema$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryAwareSchema$$Original = $RegistryAwareSchema;}
declare module "dev.latvian.mods.kubejs.block.BlockTintFunction$Fixed" {
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockTintFunction, $BlockTintFunction$$Interface} from "dev.latvian.mods.kubejs.block.BlockTintFunction"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Record} from "java.lang.Record"

export class $BlockTintFunction$Fixed extends $Record implements $BlockTintFunction$$Interface {
constructor(color: $KubeColor$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "color"(): $KubeColor
public "getColor"(state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, index: integer): $KubeColor
public static "wrap"(o: any): $BlockTintFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunction$Fixed$$Type = ({"color"?: $KubeColor$$Type}) | ([color?: $KubeColor$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockTintFunction$Fixed$$Original = $BlockTintFunction$Fixed;}
declare module "dev.latvian.mods.kubejs.core.DiggerItemKJS" {
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $DiggerItemKJS$$Interface {

(): $TagKey$$Type<($Block$$Type)>
}

export class $DiggerItemKJS implements $DiggerItemKJS$$Interface {
 "kjs$getMineableTag"(): $TagKey<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemKJS$$Type = (() => $TagKey$$Type<($Block$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemKJS$$Original = $DiggerItemKJS;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper" {
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Iterator} from "java.util.Iterator"
import {$Map} from "java.util.Map"
import {$Spliterator} from "java.util.Spliterator"
import {$RegistryWrapper$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.RegistryWrapper"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$DataMapWrapper$Data, $DataMapWrapper$Data$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper$Data"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$DataMapType, $DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Stream} from "java.util.stream.Stream"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $DataMapWrapper<T, A> extends $Record implements $Iterable$$Interface<($DataMapWrapper$Data<(T), (A)>)> {
constructor(registry: $Registry$$Type<(T)>, type: $DataMapType$$Type<(T), (A)>)

public "byKey"(): $Map<($ResourceKey<(T)>), (A)>
public static "typeOf"<T>(registry: $RegistryWrapper$$Type<(T)>, id: $ResourceLocation$$Type): $DataMapType<(T), (never)>
public static "typeOf"(registry: $ResourceLocation$$Type, id: $ResourceLocation$$Type): $DataMapType<(never), (never)>
public "get"(item: T): A
public "type"(): $DataMapType<(T), (A)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "iterator"(): $Iterator<($DataMapWrapper$Data<(T), (A)>)>
public static "of"(registry: $ResourceLocation$$Type, id: $ResourceLocation$$Type): $DataMapWrapper<(never), (never)>
public static "of"<T>(registry: $RegistryWrapper$$Type<(T)>, id: $ResourceLocation$$Type): $DataMapWrapper<(T), (never)>
public "keys"(): $Stream<(T)>
public "registry"(): $Registry<(T)>
public "spliterator"(): $Spliterator<($DataMapWrapper$Data<(T), (A)>)>
public "forEach"(arg0: $Consumer$$Type<($DataMapWrapper$Data<(T), (A)>)>): void
[Symbol.iterator](): IterableIterator<$DataMapWrapper$Data<(T), (A)>>;
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataMapWrapper$$Type<T, A> = ({"registry"?: $Registry$$Type<(T)>, "type"?: $DataMapType$$Type<(T), (A)>}) | ([registry?: $Registry$$Type<(T)>, type?: $DataMapType$$Type<(T), (A)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataMapWrapper$$Original<T, A> = $DataMapWrapper<(T), (A)>;}
declare module "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$CommandBuildContext, $CommandBuildContext$$Type} from "net.minecraft.commands.CommandBuildContext"
import {$LiteralArgumentBuilder$$Type} from "com.mojang.brigadier.builder.LiteralArgumentBuilder"
import {$ArgumentTypeWrappers} from "dev.latvian.mods.kubejs.command.ArgumentTypeWrappers"
import {$Commands} from "net.minecraft.commands.Commands"
import {$CommandDispatcher, $CommandDispatcher$$Type} from "com.mojang.brigadier.CommandDispatcher"
import {$SharedSuggestionProvider} from "net.minecraft.commands.SharedSuggestionProvider"
import {$LiteralCommandNode} from "com.mojang.brigadier.tree.LiteralCommandNode"
import {$CommandSourceStack, $CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$Commands$CommandSelection, $Commands$CommandSelection$$Type} from "net.minecraft.commands.Commands$CommandSelection"

export class $CommandRegistryKubeEvent implements $KubeEvent$$Interface {
readonly "selection": $Commands$CommandSelection
readonly "context": $CommandBuildContext
readonly "dispatcher": $CommandDispatcher<($CommandSourceStack)>

constructor(dispatcher: $CommandDispatcher$$Type<($CommandSourceStack$$Type)>, context: $CommandBuildContext$$Type, selection: $Commands$CommandSelection$$Type)

public "isForSinglePlayer"(): boolean
public "isForMultiPlayer"(): boolean
public "getBuiltinSuggestions"(): typeof $SharedSuggestionProvider
public "register"(command: $LiteralArgumentBuilder$$Type<($CommandSourceStack$$Type)>): $LiteralCommandNode<($CommandSourceStack)>
public "getArguments"(): typeof $ArgumentTypeWrappers
public "getRegistry"(): $CommandBuildContext
public "getCommands"(): typeof $Commands
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "forSinglePlayer"(): boolean
get "forMultiPlayer"(): boolean
get "builtinSuggestions"(): typeof $SharedSuggestionProvider
get "arguments"(): typeof $ArgumentTypeWrappers
get "registry"(): $CommandBuildContext
get "commands"(): typeof $Commands
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandRegistryKubeEvent$$Type = ($CommandRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandRegistryKubeEvent$$Original = $CommandRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.TinyMap$Entry" {
import {$Record} from "java.lang.Record"

export class $TinyMap$Entry<K, V> extends $Record {
constructor(key: K, value: V)

public "value"(): V
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "key"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinyMap$Entry$$Type<K, V> = ({"key"?: K, "value"?: V}) | ([key?: K, value?: V]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TinyMap$Entry$$Original<K, V> = $TinyMap$Entry<(K), (V)>;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo" {
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$CustomCapabilityAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.CustomCapabilityAttachment$Factory"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$FluidTankAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.FluidTankAttachment$Factory"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$BlockEntityAttachmentHandler$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentHandler"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InventoryAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.InventoryAttachment$Factory"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Set$$Type} from "java.util.Set"
import {$EnergyStorageAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.EnergyStorageAttachment$Factory"
import {$BlockEntityEventCallback$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityEventCallback"

export class $BlockEntityInfo implements $BlockEntityAttachmentHandler$$Interface {
constructor(blockBuilder: $BlockBuilder$$Type)

public "serverTicking"(): void
public "clientTicking"(): void
public "tickFrequency"(frequency: integer): void
public "enableSync"(): void
public "rightClickOpensInventory"(id: StringJS): void
public "rightClickFillsTank"(id: StringJS): void
public "ticking"(): void
public "tickOffset"(offset: integer): void
public "initialData"(data: $CompoundTag$$Type): void
public "toString"(): StringJS
public "eventHandler"(eventId: integer, callback: $BlockEntityEventCallback$$Type): void
public "attachCustomCapability"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capability: $BlockCapability$$Type<(never), (never)>, dataFactory: $Supplier$$Type<(never)>): void
public "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer): void
public "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, inputFilter: $FluidIngredient$$Type): void
public "attach"<T extends Attachments>(id: StringJS, type: T, directions: $Set$$Type<($Direction$$Type)>, args: AttachmentMap[T]): void
public "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer): void
public "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer, inputFilter: $ItemPredicate$$Type): void
public "energyStorage"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, maxReceive: integer, maxExtract: integer, autoOutput: integer): void
}
export type AttachmentMap = {"kubejs:energy_storage": $EnergyStorageAttachment$Factory$$Type;
"kubejs:inventory": $InventoryAttachment$Factory$$Type;
"kubejs:custom_capability": $CustomCapabilityAttachment$Factory$$Type;
"kubejs:fluid_tank": $FluidTankAttachment$Factory$$Type};
export type Attachments = keyof AttachmentMap;
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityInfo$$Type = ($BlockEntityInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityInfo$$Original = $BlockEntityInfo;}
declare module "dev.latvian.mods.kubejs.recipe.AfterRecipesLoadedKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$ReloadableServerResources$$Type} from "net.minecraft.server.ReloadableServerResources"
import {$RecipeLikeKJS$$Type} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $AfterRecipesLoadedKubeEvent implements $KubeEvent$$Interface {
constructor(resources: $ReloadableServerResources$$Type)

public "forEachRecipe"(filter: $RecipeFilter$$Type, consumer: $Consumer$$Type<($RecipeLikeKJS)>): void
public "countRecipes"(filter: $RecipeFilter$$Type): integer
public "remove"(filter: $RecipeFilter$$Type): integer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterRecipesLoadedKubeEvent$$Type = ($AfterRecipesLoadedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AfterRecipesLoadedKubeEvent$$Original = $AfterRecipesLoadedKubeEvent;}
declare module "dev.latvian.mods.kubejs.misc.ParticleTypeBuilder" {
import {$StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ParticleType} from "net.minecraft.core.particles.ParticleType"
import {$Registry} from "net.minecraft.core.Registry"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export class $ParticleTypeBuilder extends $BuilderBase<($ParticleType<(never)>)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "streamCodec"(s: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), ($ParticleOptions$$Type)>): this
public "textures"(textures: $List$$Type<(StringJS)>): this
public "texture"(texture: StringJS): this
public "codec"(c: $MapCodec$$Type<($ParticleOptions$$Type)>): this
public "overrideLimiter"(o: boolean): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleTypeBuilder$$Type = ($ParticleTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleTypeBuilder$$Original = $ParticleTypeBuilder;}
declare module "dev.latvian.mods.kubejs.script.ScriptPackInfo" {
import {$ScriptFileInfo} from "dev.latvian.mods.kubejs.script.ScriptFileInfo"
import {$List} from "java.util.List"
import {$Component} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptPackInfo {
readonly "displayName": $Component
readonly "namespace": StringJS
readonly "pathStart": StringJS
readonly "scripts": $List<($ScriptFileInfo)>

constructor(n: StringJS, p: StringJS)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptPackInfo$$Type = ($ScriptPackInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptPackInfo$$Original = $ScriptPackInfo;}
declare module "dev.latvian.mods.kubejs.event.IEventHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $IEventHandler$$Interface {

(event: $KubeEvent): any
}

export class $IEventHandler implements $IEventHandler$$Interface {
 "onEvent"(event: $KubeEvent$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEventHandler$$Type = ((event: $KubeEvent) => any);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IEventHandler$$Original = $IEventHandler;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.CategoryData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$Record} from "java.lang.Record"

export class $CategoryData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($CategoryData)>

constructor(category: $ResourceLocation$$Type)
constructor(category: $ResourceLocation$$Type, removedRecipes: $List$$Type<($ResourceLocation$$Type)>)

public "removedRecipes"(): $List<($ResourceLocation)>
public "category"(): $ResourceLocation
public "lock"(): $CategoryData
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CategoryData$$Type = ({"removedRecipes"?: $List$$Type<($ResourceLocation$$Type)>, "category"?: $ResourceLocation$$Type}) | ([removedRecipes?: $List$$Type<($ResourceLocation$$Type)>, category?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CategoryData$$Original = $CategoryData;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$BuildingMaterialProperties$Blocks, $BuildingMaterialProperties$Blocks$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties$Blocks"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$TickDuration, $TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$Record} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $BuildingMaterialProperties extends $Record {
static readonly "TYPE_INFO": $TypeInfo

constructor(blocks: $BuildingMaterialProperties$Blocks$$Type, baseBlock: (boolean)?, baseBlockSuffix: (boolean)?, properties: $Consumer$$Type<($BlockBuilder)>, behaviour: ($BlockSetType$$Type)?, ticksToStayPressed: ($TickDuration$$Type)?)

public "baseBlockSuffix"(): $Optional<(boolean)>
public "ticksToStayPressed"(): $Optional<($TickDuration)>
public "behaviour"(): $Optional<($BlockSetType)>
public "baseBlock"(): $Optional<(boolean)>
public "blocks"(): $BuildingMaterialProperties$Blocks
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "properties"(): $Consumer<($BlockBuilder)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuildingMaterialProperties$$Type = ({"baseBlockSuffix"?: (boolean)?, "blocks"?: $BuildingMaterialProperties$Blocks$$Type, "properties"?: $Consumer$$Type<($BlockBuilder$$Type)>, "baseBlock"?: (boolean)?, "behaviour"?: ($BlockSetType$$Type)?, "ticksToStayPressed"?: ($TickDuration$$Type)?}) | ([baseBlockSuffix?: (boolean)?, blocks?: $BuildingMaterialProperties$Blocks$$Type, properties?: $Consumer$$Type<($BlockBuilder$$Type)>, baseBlock?: (boolean)?, behaviour?: ($BlockSetType$$Type)?, ticksToStayPressed?: ($TickDuration$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuildingMaterialProperties$$Original = $BuildingMaterialProperties;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockExplodedCallback" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockExplodedCallback {
constructor(level: $Level$$Type, pos: $BlockPos$$Type, explosion: $Explosion$$Type)

public "getRadius"(): float
public "getIgniter"(): $LivingEntity
public "getAffectedPlayers"(): $List<($Player)>
public "getExplosion"(): $Explosion
public "getBlock"(): $LevelBlock
public "getLevel"(): $Level
public "getCause"(): $Entity
public "getBlockState"(): $BlockState
get "radius"(): float
get "igniter"(): $LivingEntity
get "affectedPlayers"(): $List<($Player)>
get "explosion"(): $Explosion
get "block"(): $LevelBlock
get "level"(): $Level
get "cause"(): $Entity
get "blockState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockExplodedCallback$$Type = ($BlockExplodedCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockExplodedCallback$$Original = $BlockExplodedCallback;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveEntriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $RemoveEntriesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(filter: F): void
}

export class $RemoveEntriesKubeEvent<E, F> implements $RemoveEntriesKubeEvent$$Interface {
 "remove"(filter: F): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveEntriesKubeEvent$$Type<E, F> = ((filter: any) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoveEntriesKubeEvent$$Original<E, F> = $RemoveEntriesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.event.EventResult$Type" {
import {$Enum} from "java.lang.Enum"
import {$EventExit} from "dev.latvian.mods.kubejs.event.EventExit"

export class $EventResult$Type extends $Enum<($EventResult$Type)> {
static readonly "INTERRUPT_TRUE": $EventResult$Type
static readonly "PASS": $EventResult$Type
static readonly "INTERRUPT_FALSE": $EventResult$Type
static readonly "INTERRUPT_DEFAULT": $EventResult$Type
static readonly "ERROR": $EventResult$Type

public "exit"(value: any): $EventExit
public static "values"(): ($EventResult$Type)[]
public static "valueOf"(name: StringJS): $EventResult$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventResult$Type$$Type = (("error") | ("pass") | ("interrupt_default") | ("interrupt_false") | ("interrupt_true"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventResult$Type$$Original = $EventResult$Type;}
declare module "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch" {
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"

export interface $ReplacementMatch$$Interface {
}

export class $ReplacementMatch implements $ReplacementMatch$$Interface {
static readonly "NONE": $ReplacementMatch

static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementMatch$$Type = ($Ingredient$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplacementMatch$$Original = $ReplacementMatch;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemTintFunction$$Type} from "dev.latvian.mods.kubejs.item.ItemTintFunction"
import {$JukeboxSong$$Type} from "net.minecraft.world.item.JukeboxSong"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$ItemBuilder$ReleaseUsingCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$ReleaseUsingCallback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function$$Type} from "java.util.function.Function"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$FoodBuilder$$Type} from "dev.latvian.mods.kubejs.item.FoodBuilder"
import {$ItemBuilder$HurtEnemyContext$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$HurtEnemyContext"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ItemBuilder$FinishUsingCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$FinishUsingCallback"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ItemBuilder$NameCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$NameCallback"
import {$Collection$$Type} from "java.util.Collection"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$ToIntBiFunction$$Type} from "java.util.function.ToIntBiFunction"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$ModelledBuilderBase} from "dev.latvian.mods.kubejs.registry.ModelledBuilderBase"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$UseAnim$$Type} from "net.minecraft.world.item.UseAnim"
import {$ItemBuilder$UseCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$UseCallback"
import {$Registry} from "net.minecraft.core.Registry"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ItemBuilder extends $ModelledBuilderBase<($Item)> {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

public "transformObject"(obj: $Item$$Type): $Item
/**
 * The duration when the item is used.
 * 
 * For example, when eating food, this is the time it takes to eat the food.
 * This can change the eating speed, or be used for other things (like making a custom bow).
 */
public "useDuration"(useDuration: $ToIntBiFunction$$Type<($ItemStack), ($LivingEntity)>): this
/**
 * Sets the item's rarity.
 */
public "rarity"(v: $Rarity$$Type): this
/**
 * Makes the item glow like enchanted, even if it's not enchanted.
 */
public "glow"(v: boolean): this
/**
 * Determines the width of the item's durability bar. Defaulted to vanilla behavior.
 * 
 * The function should return a value between 0 and 13 (max width of the bar).
 */
public "barWidth"(barWidth: $ToIntFunction$$Type<($ItemStack)>): this
/**
 * Determines the color of the item's durability bar. Defaulted to vanilla behavior.
 */
public "barColor"(barColor: $Function$$Type<($ItemStack), ($KubeColor$$Type)>): this
/**
 * When players finish using the item.
 * 
 * This is called only when `useDuration` ticks have passed.
 * 
 * For example, when eating food, this is called when the player has finished eating the food, so hunger is restored.
 */
public "finishUsing"(finishUsing: $ItemBuilder$FinishUsingCallback$$Type): this
/**
 * Sets the item's burn time. Default is 0 (Not a fuel).
 */
public "burnTime"(v: $TickDuration$$Type): this
/**
 * Sets the item's max damage. Default is 0 (No durability).
 */
public "maxDamage"(v: integer): this
/**
 * Makes the item fire resistant like netherite tools.
 */
public "fireResistant"(): this
/**
 * Makes the item fire resistant like netherite tools (or not).
 */
public "fireResistant"(isFireResistant: boolean): this
public "jukeboxPlayable"(song: $ResourceKey$$Type<($JukeboxSong)>, showInTooltip: boolean): this
public "jukeboxPlayable"(song: $ResourceKey$$Type<($JukeboxSong)>): this
/**
 * Adds subtypes to the item. The function should return a collection of item stacks, each with a different subtype.
 * 
 * Each subtype will appear as a separate item in JEI and the creative inventory.
 */
public "subtypes"(fn: $Function$$Type<($ItemStack), ($Collection$$Type<($ItemStack$$Type)>)>): this
public "createItemProperties"(): $Item$Properties
/**
 * Makes the item not stackable, equivalent to setting the item's max stack size to 1.
 */
public "unstackable"(): this
/**
 * Determines the animation of the item when used, e.g. eating food.
 */
public "useAnimation"(animation: $UseAnim$$Type): this
public "disableRepair"(): this
/**
 * Sets the item's container item, e.g. a bucket for a milk bucket.
 */
public "containerItem"(id: $ResourceLocation$$Type): this
/**
 * Sets the item's max stack size. Default is 64.
 */
public "maxStackSize"(v: integer): this
/**
 * Sets the item's name dynamically.
 */
public "name"(name: $ItemBuilder$NameCallback$$Type): this
/**
 * 
 * @deprecated
 */
public "group"(g: StringJS): this
public "component"<T>(type: $DataComponentType$$Type<(T)>, value: T): this
/**
 * Colorizes item's texture of the given index. Index is used when you have multiple layers, e.g. a crushed ore (of rock + ore).
 */
public "color"(index: integer, color: $ItemTintFunction$$Type): this
/**
 * Colorizes item's texture of the given index. Useful for coloring items, like GT ores ore dusts.
 */
public "color"(callback: $ItemTintFunction$$Type): this
/**
 * Determines if player will start using the item.
 * 
 * For example, when eating food, returning true will make the player start eating the food.
 */
public "use"(use: $ItemBuilder$UseCallback$$Type): this
/**
 * Set the food nutrition and saturation of the item.
 */
public "food"(nutrition: integer, saturation: float): this
/**
 * Set the food properties of the item.
 */
public "food"(b: $Consumer$$Type<($FoodBuilder)>): this
/**
 * When players did not finish using the item but released the right mouse button halfway through.
 * 
 * An example is the bow, where the arrow is shot when the player releases the right mouse button.
 * 
 * To ensure the bow won't finish using, Minecraft sets the `useDuration` to a very high number (1h).
 */
public "releaseUsing"(releaseUsing: $ItemBuilder$ReleaseUsingCallback$$Type): this
/**
 * Gets called when the item is used to hurt an entity.
 * 
 * For example, when using a sword to hit a mob, this is called.
 */
public "hurtEnemy"(context: $Predicate$$Type<($ItemBuilder$HurtEnemyContext)>): this
/**
 * Adds a tooltip to the item.
 */
public "tooltip"(text: $Component$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$$Type = ($ItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$$Original = $ItemBuilder;}
declare module "dev.latvian.mods.kubejs.util.MobEffectUtil" {
import {$MobEffectInstance, $MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"

export class $MobEffectUtil {
constructor()

/**
 * Creates an instance for the given effect, duration and amplifier
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type, amplifier: integer): $MobEffectInstance
/**
 * Creates an instance for the given effect, duration, amplifier, ambient, and visible to the HUD
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type, amplifier: integer, ambient: boolean, visible: boolean): $MobEffectInstance
/**
 * Creates an instance for the given effect, duration, amplifier, ambient, visible to the HUD, and to show the icon on the sceen
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean): $MobEffectInstance
/**
 * Creates an instance for the given effect and duration (in ticks)
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type): $MobEffectInstance
/**
 * Creates an instance for the given effect. Default duration and amplifier is 0
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>): $MobEffectInstance
/**
 * Copies an existing MobEffectInstance
 */
public static "of"(oldInstance: $MobEffectInstance$$Type): $MobEffectInstance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectUtil$$Type = ($MobEffectUtil);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobEffectUtil$$Original = $MobEffectUtil;}
declare module "dev.latvian.mods.kubejs.player.PlayerRespawnedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player respawns.
 * 
 * The reason of respawn can be either death or returning from the end.
 */
export class $PlayerRespawnedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $ServerPlayer$$Type, endConquered: boolean)

public "isEndConquered"(): boolean
/**
 * Gets the player that respawned.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "endConquered"(): boolean
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerRespawnedKubeEvent$$Type = ($PlayerRespawnedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerRespawnedKubeEvent$$Original = $PlayerRespawnedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.custom.PressurePlateBlockBuilder" {
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Consumer} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ButtonOrPressurePlateBuilder$$Interface} from "dev.latvian.mods.kubejs.block.custom.ButtonOrPressurePlateBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

export class $PressurePlateBlockBuilder extends $ShapedBlockBuilder implements $ButtonOrPressurePlateBuilder$$Interface {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
static readonly "PRESSURE_PLATE_TAGS": ($ResourceLocation)[]
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "ticksToStayPressed"(ticks: $TickDuration$$Type): $BlockBuilder
public "behaviour"(behaviour: $BlockSetType$$Type): $BlockBuilder
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressurePlateBlockBuilder$$Type = ($PressurePlateBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PressurePlateBlockBuilder$$Original = $PressurePlateBlockBuilder;}
declare module "dev.latvian.mods.kubejs.text.action.TextActionBuilder" {
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

export class $TextActionBuilder {
constructor()

public "removeLine"(line: integer): void
public "removeText"(match: $Component$$Type): void
public "removeExactText"(match: $Component$$Type): void
public "insert"(line: integer, text: $List$$Type<($Component$$Type)>): void
public "clear"(): void
public "add"(text: $List$$Type<($Component$$Type)>): void
public "dynamic"(id: StringJS): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextActionBuilder$$Type = ($TextActionBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextActionBuilder$$Original = $TextActionBuilder;}
declare module "dev.latvian.mods.kubejs.server.tag.PreTagWrapper" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List} from "java.util.List"
import {$PreTagKubeEvent, $PreTagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent"
import {$TagLoader$EntryWithSource} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$TagWrapper} from "dev.latvian.mods.kubejs.server.tag.TagWrapper"
import {$TagKubeEvent} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"

export class $PreTagWrapper extends $TagWrapper {
readonly "preEvent": $PreTagKubeEvent
readonly "entries": $List<($TagLoader$EntryWithSource)>
readonly "id": $ResourceLocation
readonly "event": $TagKubeEvent

constructor(e: $PreTagKubeEvent$$Type, i: $ResourceLocation$$Type)

public "getObjectIds"(): $List<($ResourceLocation)>
public "remove"(...filters: (any)[]): $TagWrapper
public "add"(...filters: (any)[]): $TagWrapper
public "removeAll"(): $TagWrapper
get "objectIds"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreTagWrapper$$Type = ($PreTagWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PreTagWrapper$$Original = $PreTagWrapper;}
declare module "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent$ItemModifications" {
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ComponentFunctions} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID$$Type} from "java.util.UUID"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$List$$Type} from "java.util.List"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Map$$Type} from "java.util.Map"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ItemComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ItemComponentFunctions"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Record} from "java.lang.Record"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export class $ItemModificationKubeEvent$ItemModifications extends $Record implements $ItemComponentFunctions$$Interface {
constructor(item: $Item$$Type)

public "setCraftingRemainder"(item: $Item$$Type): void
public "getComponentMap"(): $DataComponentMap
public "setTier"(builder: $Consumer$$Type<($MutableToolTier)>): void
public "disableRepair"(): void
public "setBurnTime"(i: $TickDuration$$Type): void
public "setNameKey"(key: StringJS): void
public "item"(): $Item
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "setFood"(foodProperties: $FoodProperties$$Type): void
public "setFood"(nutrition: integer, saturation: float): void
public "setMaxStackSize"(size: integer): void
public "setMaxDamage"(maxDamage: integer): void
public "setDamage"(damage: integer): void
public "setUnbreakable"(): void
public "setItemName"(component: $Component$$Type): void
public "setRepairCost"(repairCost: integer): void
public "setFireResistant"(): void
public "setTool"(tool: $Tool$$Type): void
public "setMapItemColor"(color: $KubeColor$$Type): void
public "setChargedProjectiles"(items: $List$$Type<($ItemStack$$Type)>): void
public "setBundleContents"(items: $List$$Type<($ItemStack$$Type)>): void
public "setBucketEntityData"(tag: $CompoundTag$$Type): void
public "setBlockEntityData"(tag: $CompoundTag$$Type): void
public "setInstrument"(instrument: $Holder$$Type<($Instrument)>): void
public "setUnbreakableWithTooltip"(): void
public "setFireworkExplosion"(explosion: $FireworkExplosion$$Type): void
public "setFireworks"(fireworks: $Fireworks$$Type): void
public "setNoteBlockSound"(id: $ResourceLocation$$Type): void
public "getAttributeModifiers"(): $ItemAttributeModifiers
public "resetComponents"(): $ComponentFunctions
public "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
public "set"(components: $DataComponentMap$$Type): $ComponentFunctions
public "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
public "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
public "get"<T>(type: $DataComponentType$$Type<(T)>): T
public "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
public "getComponentString"(): StringJS
public "setCustomData"(tag: $CompoundTag$$Type): void
public "getCustomData"(): $CompoundTag
public "setRarity"(rarity: $Rarity$$Type): void
public "setCustomName"(name: $Component$$Type): void
public "getCustomName"(): $Component
public "setLore"(lines: $List$$Type<($Component$$Type)>): void
public "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
public "setCustomModelData"(data: integer): void
public "setAdditionalTooltipHidden"(): void
public "setTooltipHidden"(): void
public "setGlintOverride"(override: boolean): void
public "setDyedColor"(color: $KubeColor$$Type): void
public "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
public "setPotionContents"(contents: $PotionContents$$Type): void
public "setPotionId"(potion: $Holder$$Type<($Potion)>): void
public "setEntityData"(tag: $CompoundTag$$Type): void
public "setProfile"(name: StringJS, uuid: $UUID$$Type): void
public "setProfile"(profile: $GameProfile$$Type): void
public "setBaseColor"(color: $DyeColor$$Type): void
public "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
public "setLockCode"(lock: StringJS): void
public "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
public "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
public "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
public "getBaseAttackDamage"(): double
public "getBaseAttackSpeed"(): double
public "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
public "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
public "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
public "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
public "setAttackSpeed"(speed: double): void
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
public "setAttackDamage"(dmg: double): void
public "getAttackDamage"(): double
public "getAttackSpeed"(): double
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
public "setBaseAttackSpeed"(speed: double): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
public "setBaseAttackDamage"(dmg: double): void
set "craftingRemainder"(value: $Item$$Type)
get "componentMap"(): $DataComponentMap
set "tier"(value: $Consumer$$Type<($MutableToolTier)>)
set "burnTime"(value: $TickDuration$$Type)
set "nameKey"(value: StringJS)
set "food"(value: $FoodProperties$$Type)
set "maxStackSize"(value: integer)
set "maxDamage"(value: integer)
set "damage"(value: integer)
get "unbreakable"(): void
set "itemName"(value: $Component$$Type)
set "repairCost"(value: integer)
get "fireResistant"(): void
set "tool"(value: $Tool$$Type)
set "mapItemColor"(value: $KubeColor$$Type)
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "bucketEntityData"(value: $CompoundTag$$Type)
set "blockEntityData"(value: $CompoundTag$$Type)
set "instrument"(value: $Holder$$Type<($Instrument)>)
get "unbreakableWithTooltip"(): void
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
set "fireworks"(value: $Fireworks$$Type)
set "noteBlockSound"(value: $ResourceLocation$$Type)
get "attributeModifiers"(): $ItemAttributeModifiers
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "componentString"(): StringJS
set "customData"(value: $CompoundTag$$Type)
get "customData"(): $CompoundTag
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customModelData"(value: integer)
get "additionalTooltipHidden"(): void
get "tooltipHidden"(): void
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "lockCode"(value: StringJS)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
get "baseAttackDamage"(): double
get "baseAttackSpeed"(): double
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "attackSpeed"(value: double)
set "attackDamage"(value: double)
get "attackDamage"(): double
get "attackSpeed"(): double
set "baseAttackSpeed"(value: double)
set "baseAttackDamage"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModificationKubeEvent$ItemModifications$$Type = ({"item"?: $Item$$Type}) | ([item?: $Item$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemModificationKubeEvent$ItemModifications$$Original = $ItemModificationKubeEvent$ItemModifications;}
declare module "dev.latvian.mods.kubejs.script.data.ExportablePackResources" {
import {$PackLocationInfo} from "net.minecraft.server.packs.PackLocationInfo"
import {$KnownPack} from "net.minecraft.server.packs.repository.KnownPack"
import {$Optional} from "java.util.Optional"
import {$MetadataSectionSerializer$$Type} from "net.minecraft.server.packs.metadata.MetadataSectionSerializer"
import {$PackResources$$Interface} from "net.minecraft.server.packs.PackResources"
import {$IoSupplier} from "net.minecraft.server.packs.resources.IoSupplier"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PackType$$Type} from "net.minecraft.server.packs.PackType"
import {$PackResources$ResourceOutput$$Type} from "net.minecraft.server.packs.PackResources$ResourceOutput"
import {$Set} from "java.util.Set"
import {$InputStream} from "java.io.InputStream"
import {$Path$$Type} from "java.nio.file.Path"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ExportablePackResources$$Interface extends $PackResources$$Interface {
get "hidden"(): boolean
}

export class $ExportablePackResources implements $ExportablePackResources$$Interface {
 "export"(root: $Path$$Type): void
 "exportPath"(): StringJS
 "getResource"(arg0: $PackType$$Type, arg1: $ResourceLocation$$Type): $IoSupplier<($InputStream)>
 "location"(): $PackLocationInfo
 "close"(): void
 "listResources"(arg0: $PackType$$Type, arg1: StringJS, arg2: StringJS, arg3: $PackResources$ResourceOutput$$Type): void
 "getNamespaces"(arg0: $PackType$$Type): $Set<(StringJS)>
 "knownPackInfo"(): $Optional<($KnownPack)>
 "getRootResource"(...arg0: (StringJS)[]): $IoSupplier<($InputStream)>
 "getMetadataSection"<T>(arg0: $MetadataSectionSerializer$$Type<(T)>): T
 "packId"(): StringJS
 "isHidden"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExportablePackResources$$Type = ($ExportablePackResources);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExportablePackResources$$Original = $ExportablePackResources;}
declare module "dev.latvian.mods.kubejs.core.InventoryKJS" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container} from "net.minecraft.world.Container"
import {$List} from "java.util.List"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Level$$Type} from "net.minecraft.world.level.Level"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $InventoryKJS$$Interface {
get "empty"(): boolean
get "mutable"(): boolean
get "slots"(): integer
get "width"(): integer
get "height"(): integer
get "changed"(): void
get "allItems"(): $List<($ItemStack)>
}

export class $InventoryKJS implements $InventoryKJS$$Interface {
 "isEmpty"(): boolean
 "isMutable"(): boolean
 "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
 "getSlots"(): integer
 "getStackInSlot"(slot: integer): $ItemStack
 "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
 "getSlotLimit"(slot: integer): integer
 "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
 "clear"(): void
 "clear"(match: $ItemPredicate$$Type): void
 "find"(match: $ItemPredicate$$Type): integer
 "find"(): integer
 "count"(match: $ItemPredicate$$Type): integer
 "count"(): integer
 "countNonEmpty"(): integer
 "countNonEmpty"(match: $ItemPredicate$$Type): integer
 "getWidth"(): integer
 "getHeight"(): integer
 "getBlock"(level: $Level$$Type): $LevelBlock
 "setChanged"(): void
 "getAllItems"(): $List<($ItemStack)>
 "asContainer"(): $Container
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryKJS$$Type = ($InventoryKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryKJS$$Original = $InventoryKJS;}
declare module "dev.latvian.mods.kubejs.util.WithCodec" {
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$JsonSerializable$$Interface} from "dev.latvian.mods.kubejs.util.JsonSerializable"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$NBTSerializable$$Interface} from "dev.latvian.mods.kubejs.util.NBTSerializable"

export interface $WithCodec$$Interface extends $NBTSerializable$$Interface, $JsonSerializable$$Interface {

(): $Codec$$Type<(never)>
get "codec"(): $Codec<(never)>
}

export class $WithCodec implements $WithCodec$$Interface {
 "toJson"(): $JsonElement
 "getCodec"(): $Codec<(never)>
 "toNBT"(): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithCodec$$Type = (() => $Codec$$Type<(never)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithCodec$$Original = $WithCodec;}
declare module "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FluidBucketItemBuilder extends $ItemBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
readonly "fluidBuilder": $FluidBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(b: $FluidBuilder$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBucketItemBuilder$$Type = ($FluidBucketItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidBucketItemBuilder$$Original = $FluidBucketItemBuilder;}
declare module "dev.latvian.mods.kubejs.core.RecipeManagerKJS" {
import {$ReloadableServerResourceHolderKJS$$Interface} from "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeManagerKJS$$Interface extends $ReloadableServerResourceHolderKJS$$Interface {
}

export class $RecipeManagerKJS implements $RecipeManagerKJS$$Interface {
 "kjs$getRecipeIdMap"(): $Map<($ResourceLocation), ($RecipeHolder<(never)>)>
 "kjs$replaceRecipes"(byName: $Map$$Type<($ResourceLocation$$Type), ($RecipeHolder$$Type<(never)>)>): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
 "kjs$setResources"(resources: $ReloadableServerResourcesKJS$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeManagerKJS$$Type = ($RecipeManagerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeManagerKJS$$Original = $RecipeManagerKJS;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Face" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $ModelGenerator$Face {
readonly "side": $Direction

constructor(side: $Direction$$Type)

public "tintindex"(i: integer): $ModelGenerator$Face
public "tex"(t: StringJS): $ModelGenerator$Face
public "uv"(u0: double, v0: double, u1: double, v1: double): $ModelGenerator$Face
public "toJson"(): $JsonObject
public "cull"(): $ModelGenerator$Face
public "cull"(d: $Direction$$Type): $ModelGenerator$Face
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Face$$Type = ($ModelGenerator$Face);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$Face$$Original = $ModelGenerator$Face;}
declare module "dev.latvian.mods.kubejs.util.AttachedData" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$HashMap} from "java.util.HashMap"

export class $AttachedData<T> extends $HashMap<(StringJS), (any)> {
constructor(p: T)

public "add"(key: StringJS, data: any): void
public "getParent"(): T
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
get "parent"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedData$$Type<T> = ($AttachedData<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttachedData$$Original<T> = $AttachedData<(T)>;}
declare module "dev.latvian.mods.kubejs.item.ItemClickedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks with an item **without targeting anything**.
 * 
 * Not to be confused with `BlockEvents.rightClick` or `ItemEvents.entityInteracted`.
 */
export class $ItemClickedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, hand: $InteractionHand$$Type, item: $ItemStack$$Type)

/**
 * The hand that the item was clicked with.
 */
public "getHand"(): $InteractionHand
/**
 * The item that was clicked with.
 */
public "getItem"(): $ItemStack
/**
 * The player that clicked with the item.
 */
public "getEntity"(): $LivingEntity
/**
 * The ray trace result of the click.
 */
public "getTarget"(): $KubeRayTraceResult
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "hand"(): $InteractionHand
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "target"(): $KubeRayTraceResult
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemClickedKubeEvent$$Type = ($ItemClickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemClickedKubeEvent$$Original = $ItemClickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.entity.AttributeBuilder" {
import {$List} from "java.util.List"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$AttributeBuilder$Range} from "dev.latvian.mods.kubejs.entity.AttributeBuilder$Range"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$Registry} from "net.minecraft.core.Registry"
import {$Attribute$Sentiment$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute$Sentiment"
import {$Either} from "com.mojang.datafixers.util.Either"
import {$Attribute, $Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $AttributeBuilder extends $BuilderBase<($Attribute)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "predicateList": $List<($Predicate<($EntityType<(never)>)>)>
 "defaultValue": $Either<($AttributeBuilder$Range), (boolean)>
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "transformObject"(attribute: $Attribute$$Type): $Attribute
public "negativeSentiment"(): this
public "neutralSentiment"(): this
public "attachToPlayers"(): this
public "attachToMonsters"(): this
public "attachToCategory"(category: $MobCategory$$Type): this
public "sentiment"(sentiment: $Attribute$Sentiment$$Type): this
public "syncable"(watch: boolean): this
public "attachTo"(entityType: $Predicate$$Type<($EntityType<(never)>)>): this
public "range"(defaultValue: double, min: double, max: double): this
public "bool"(defaultValue: boolean): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeBuilder$$Type = ($AttributeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttributeBuilder$$Original = $AttributeBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.IngredientWrapper" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$SizedIngredient} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * Various Ingredient related helper methods
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IngredientWrapper$$Interface {
}

export class $IngredientWrapper implements $IngredientWrapper$$Interface {
/**
 * An ingredient that matches everything
 */
static readonly "all": $Ingredient
static readonly "TYPE_INFO": $TypeInfo
/**
 * A completely empty ingredient that will only match air
 */
static readonly "none": $Ingredient

static "isIngredientLike"(from: any): boolean
/**
 * Checks if the passed in object is an Ingredient.
 * Note that this does not mean it will not function as an Ingredient if passed to something that requests one.
 */
static "isIngredient"(o: any): boolean
/**
 * Returns an ingredient that accepts the given set of items under the given component filter.
 */
static "withData"(base: $HolderSet$$Type<($Item)>, data: $DataComponentMap$$Type): $Ingredient
/**
 * Returns an ingredient that accepts the given set of items under the given (optionally strict) component filter.
 */
static "withData"(base: $HolderSet$$Type<($Item)>, data: $DataComponentMap$$Type, strict: boolean): $Ingredient
static "tagKeyOf"(arg0: $Ingredient$$Type): $TagKey<($Item)>
static "containsAnyTag"(arg0: $Ingredient$$Type): boolean
static "parseJson"(json: $JsonElement$$Type): $DataResult<($Ingredient)>
static "parseString"(s: StringJS): $DataResult<($Ingredient)>
/**
 * Returns an ingredient of the input
 */
static "of"(ingredient: $Ingredient$$Type): $Ingredient
/**
 * Returns an ingredient of the input, with the specified count
 */
static "of"(ingredient: $Ingredient$$Type, count: integer): $SizedIngredient
static "first"(ingredient: $Ingredient$$Type): $ItemStack
static "read"(reader: $StringReader$$Type): $DataResult<($Ingredient)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientWrapper$$Type = ($IngredientWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientWrapper$$Original = $IngredientWrapper;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickHandler" {
import {$ChestMenuClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"
import {$Record} from "java.lang.Record"

export class $ChestMenuClickHandler extends $Record {
constructor(type: $ClickType$$Type, button: integer, callback: $ChestMenuClickEvent$Callback$$Type, autoHandle: boolean)

public "autoHandle"(): boolean
public "callback"(): $ChestMenuClickEvent$Callback
public "type"(): $ClickType
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "test"(event: $ChestMenuClickEvent$$Type): boolean
public "button"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickHandler$$Type = ({"autoHandle"?: boolean, "button"?: integer, "type"?: $ClickType$$Type, "callback"?: $ChestMenuClickEvent$Callback$$Type}) | ([autoHandle?: boolean, button?: integer, type?: $ClickType$$Type, callback?: $ChestMenuClickEvent$Callback$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuClickHandler$$Original = $ChestMenuClickHandler;}
declare module "dev.latvian.mods.kubejs.recipe.component.ComponentValueMap" {
import {$Reference2ObjectOpenHashMap} from "it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ObjectSet} from "it.unimi.dsi.fastutil.objects.ObjectSet"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Function} from "java.util.function.Function"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$Set} from "java.util.Set"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"

export class $ComponentValueMap extends $Reference2ObjectOpenHashMap<($RecipeKey<(never)>), (any)> {
constructor(init: integer)

public "getValue"<T>(cx: $RecipeScriptContext$$Type, key: $RecipeKey$$Type<(T)>): T
public "keySet"(): $Set
public "reference2ObjectEntrySet"(): $ObjectSet
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentValueMap$$Type = ($ComponentValueMap);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentValueMap$$Original = $ComponentValueMap;}
declare module "dev.latvian.mods.kubejs.core.BlockProviderKJS" {
import {$Map} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockProviderKJS$$Interface extends $RegistryObjectKJS$$Interface<($Block)> {

(): $Block$$Type
get "typeData"(): $Map<(StringJS), (any)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "key"(): $ResourceKey<($Block)>
get "id"(): StringJS
get "block"(): $Block
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockProviderKJS implements $BlockProviderKJS$$Interface {
 "getTypeData"(): $Map<(StringJS), (any)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getRegistry"(): $Registry<($Block)>
 "asHolder"(): $Holder<($Block)>
 "getKey"(): $ResourceKey<($Block)>
 "getId"(): StringJS
 "getBlock"(): $Block
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockProviderKJS$$Type = (() => $Block$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockProviderKJS$$Original = $BlockProviderKJS;}
declare module "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder" {
import {$MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier$$Type} from "net.minecraft.world.item.Tier"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $HandheldItemBuilder extends $ItemBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type, d: float, s: float)

public "tier"(t: $Tier$$Type): this
/**
 * Sets the attack damage bonus of the tool.
 */
public "attackDamageBonus"(f: float): this
/**
 * Sets the base attack damage of the tool. Different tools have different baselines.
 * 
 * For example, a sword has a baseline of 3, while an axe has a baseline of 6.
 * 
 * The actual damage is the sum of the baseline and the attackDamageBonus from tier.
 */
public "attackDamageBaseline"(f: float): this
/**
 * Sets the base attack speed of the tool. Different tools have different baselines.
 * 
 * For example, a sword has a baseline of -2.4, while an axe has a baseline of -3.1.
 * 
 * The actual speed is the sum of the baseline and the speed from tier + 4 (bare hand).
 */
public "speedBaseline"(f: float): this
/**
 * Modifies the tool tier.
 */
public "modifyTier"(callback: $Consumer$$Type<($MutableToolTier)>): this
/**
 * Sets the attack speed of the tool.
 */
public "speed"(f: float): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandheldItemBuilder$$Type = ($HandheldItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HandheldItemBuilder$$Original = $HandheldItemBuilder;}
declare module "dev.latvian.mods.kubejs.core.BlockKJS" {
import {$Map} from "java.util.Map"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$BlockBuilderProvider$$Interface} from "dev.latvian.mods.kubejs.core.BlockBuilderProvider"
import {$List} from "java.util.List"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder} from "net.minecraft.core.Holder"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBehaviourKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockBehaviourKJS"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockKJS$$Interface extends $BlockBuilderProvider$$Interface, $BlockBehaviourKJS$$Interface, $Replaceable$$Interface {
set "blockBuilder"(value: $BlockBuilder$$Type)
set "nameKey"(value: StringJS)
get "blockStates"(): $List<($BlockState)>
set "destroySpeed"(value: float)
set "lightEmission"(value: integer)
set "requiresTool"(value: boolean)
get "block"(): $Block
get "blockBuilder"(): $BlockBuilder
set "hasCollision"(value: boolean)
set "explosionResistance"(value: float)
set "isRandomlyTicking"(value: boolean)
set "randomTickCallback"(value: $Consumer$$Type<($RandomTickCallback)>)
set "soundType"(value: $SoundType$$Type)
set "friction"(value: float)
set "speedFactor"(value: float)
set "jumpFactor"(value: float)
get "typeData"(): $Map<(StringJS), (any)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "key"(): $ResourceKey<($Block)>
get "id"(): StringJS
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockKJS implements $BlockKJS$$Interface {
 "setBlockBuilder"(b: $BlockBuilder$$Type): void
 "setNameKey"(key: StringJS): void
 "getBlockStates"(): $List<($BlockState)>
 "setDestroySpeed"(v: float): void
 "setLightEmission"(v: integer): void
 "setRequiresTool"(v: boolean): void
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getBlock"(): $Block
 "getBlockBuilder"(): $BlockBuilder
 "setHasCollision"(v: boolean): void
 "setExplosionResistance"(v: float): void
 "setIsRandomlyTicking"(v: boolean): void
 "setRandomTickCallback"(callback: $Consumer$$Type<($RandomTickCallback)>): void
 "setSoundType"(v: $SoundType$$Type): void
 "setFriction"(v: float): void
 "setSpeedFactor"(v: float): void
 "setJumpFactor"(v: float): void
 "getTypeData"(): $Map<(StringJS), (any)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getRegistry"(): $Registry<($Block)>
 "asHolder"(): $Holder<($Block)>
 "getKey"(): $ResourceKey<($Block)>
 "getId"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockKJS$$Type = ($BlockKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockKJS$$Original = $BlockKJS;}
declare module "dev.latvian.mods.kubejs.util.RegistryOpsContainer" {
import {$OpsContainer} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$DynamicOps} from "com.mojang.serialization.DynamicOps"
import {$RegistryOps, $RegistryOps$$Type} from "net.minecraft.resources.RegistryOps"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"

export class $RegistryOpsContainer extends $OpsContainer {
static readonly "DEFAULT": $OpsContainer

constructor(nbt: $RegistryOps$$Type<($Tag$$Type)>, json: $RegistryOps$$Type<($JsonElement$$Type)>, java: $RegistryOps$$Type<(any)>)

public "java"(): $DynamicOps
public "json"(): $DynamicOps
public "nbt"(): $RegistryOps<($Tag)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryOpsContainer$$Type = ($RegistryOpsContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryOpsContainer$$Original = $RegistryOpsContainer;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.SubtypeInterpreter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $SubtypeInterpreter$$Interface {

(entry: any): any
}

export class $SubtypeInterpreter implements $SubtypeInterpreter$$Interface {
 "apply"(entry: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SubtypeInterpreter$$Type = ((entry: any) => any);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SubtypeInterpreter$$Original = $SubtypeInterpreter;}
declare module "dev.latvian.mods.kubejs.entity.AttributeBuilder$Range" {
import {$Record} from "java.lang.Record"

export class $AttributeBuilder$Range extends $Record {
constructor(defaultValue: double, min: double, max: double)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "min"(): double
public "max"(): double
public "defaultValue"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeBuilder$Range$$Type = ({"min"?: double, "max"?: double, "defaultValue"?: double}) | ([min?: double, max?: double, defaultValue?: double]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttributeBuilder$Range$$Original = $AttributeBuilder$Range;}
declare module "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$IntBounds, $IntBounds$$Type} from "dev.latvian.mods.kubejs.util.IntBounds"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type, $RecipeComponent$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$CustomObjectRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$EitherRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$Record} from "java.lang.Record"

export class $ListRecipeComponent<T> extends $Record implements $RecipeComponent$$Interface<($List<(T)>)> {
static readonly "TYPE": $RecipeComponentType<(never)>

constructor(component: $RecipeComponent$$Type<(T)>, canWriteSelf: boolean, listTypeInfo: $TypeInfo$$Type, listCodec: $Codec$$Type<($List$$Type<(T)>)>, conditional: boolean, bounds: $IntBounds$$Type, spread: ($RecipeComponent$$Type<(never)>)?, spreadWrap: ($RecipeComponent$$Type<(never)>)?)

public "spreadWrap"(): $Optional<($RecipeComponent<(never)>)>
public "listTypeInfo"(): $TypeInfo
public static "wrap0"<T>(cx: $RecipeScriptContext$$Type, component: $RecipeComponent$$Type<(T)>, from: any): $List<(T)>
public "asConditional"(): $ListRecipeComponent<(T)>
public "withSpread"(spread: ($RecipeComponent$$Type<(never)>)?): $ListRecipeComponent<(T)>
public "canWriteSelf"(): boolean
public "orSelf"(): $ListRecipeComponent<(T)>
public "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: $List$$Type<(T)>): void
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: any): void
public "listCodec"(): $Codec<($List<(T)>)>
public "allowEmpty"(): boolean
public "withBounds"(bounds: $IntBounds$$Type): $ListRecipeComponent<(T)>
public "type"(): $RecipeComponentType<(never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "wrap"(cx: $RecipeScriptContext$$Type, from: any): $List<(T)>
public "isEmpty"(value: any): boolean
public "isEmpty"(value: $List$$Type<(T)>): boolean
public "replace"(cx: $RecipeScriptContext$$Type, original: any, match: $ReplacementMatchInfo$$Type, arg3: any): any
public "replace"(cx: $RecipeScriptContext$$Type, original: $List$$Type<(T)>, match: $ReplacementMatchInfo$$Type, arg3: any): $List<(T)>
public "matches"(cx: $RecipeMatchContext$$Type, value: any, match: $ReplacementMatchInfo$$Type): boolean
public "matches"(cx: $RecipeMatchContext$$Type, value: $List$$Type<(T)>, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, value: any): void
public "validate"(ctx: $RecipeValidationContext$$Type, value: $List$$Type<(T)>): void
public "component"(): $RecipeComponent<(T)>
public "bounds"(): $IntBounds
public "typeInfo"(): $TypeInfo
public static "create"<L>(component: $RecipeComponent$$Type<(L)>, canWriteSelf: boolean, conditional: boolean, bounds: $IntBounds$$Type, spread: ($RecipeComponent$$Type<(never)>)?): $ListRecipeComponent<(L)>
public static "create"<L>(component: $RecipeComponent$$Type<(L)>, canWriteSelf: boolean, conditional: boolean): $ListRecipeComponent<(L)>
public "spread"(value: $List$$Type<(T)>): $List<(never)>
public "spread"(value: any): $List
public "spread"(): $Optional<($RecipeComponent<(never)>)>
public "codec"(): $Codec<($List<(T)>)>
public "conditional"(): boolean
public "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<(T)>)>, json: $JsonObject$$Type): void
public "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<(T)>)>, json: $JsonObject$$Type): void
public "outputKey"(name: StringJS): $RecipeKey<($List<(T)>)>
public "asListOrSelf"(): $ListRecipeComponent<($List<(T)>)>
public "asConditionalList"(): $ListRecipeComponent<($List<(T)>)>
public "asConditionalListOrSelf"(): $ListRecipeComponent<($List<(T)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($List<(T)>)>)>
public "withCodec"(codec: $Codec$$Type<($List$$Type<(T)>)>): $RecipeComponent<($List<(T)>)>
public "inputKey"(name: StringJS): $RecipeKey<($List<(T)>)>
public "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($List<(T)>), (O)>
public "isIgnored"(): boolean
public "toString"(ops: $OpsContainer$$Type, value: $List$$Type<(T)>): StringJS
public static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
public static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<($List<(T)>)>
public "asList"(): $ListRecipeComponent<($List<(T)>)>
public "createBuilder"(): $RecipeComponentBuilder
public "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($List<(T)>)>)>
public "otherKey"(name: StringJS): $RecipeKey<($List<(T)>)>
get "ignored"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListRecipeComponent$$Type<T> = ({"component"?: $RecipeComponent$$Type<(T)>, "spreadWrap"?: ($RecipeComponent$$Type<(never)>)?, "spread"?: ($RecipeComponent$$Type<(never)>)?, "bounds"?: $IntBounds$$Type, "listTypeInfo"?: $TypeInfo$$Type, "conditional"?: boolean, "listCodec"?: $Codec$$Type<($List$$Type<(T)>)>, "canWriteSelf"?: boolean}) | ([component?: $RecipeComponent$$Type<(T)>, spreadWrap?: ($RecipeComponent$$Type<(never)>)?, spread?: ($RecipeComponent$$Type<(never)>)?, bounds?: $IntBounds$$Type, listTypeInfo?: $TypeInfo$$Type, conditional?: boolean, listCodec?: $Codec$$Type<($List$$Type<(T)>)>, canWriteSelf?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ListRecipeComponent$$Original<T> = $ListRecipeComponent<(T)>;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Leggings" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorItemBuilder$Leggings extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "LEGGING_TAGS": ($ResourceLocation)[]
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Leggings$$Type = ($ArmorItemBuilder$Leggings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Leggings$$Original = $ArmorItemBuilder$Leggings;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.RegistryWrapper" {
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Map} from "java.util.Map"
import {$Spliterator} from "java.util.Spliterator"
import {$List} from "java.util.List"
import {$DataMapWrapper} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ListIterator} from "java.util.ListIterator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$HolderSetWrapper} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.HolderSetWrapper"
import {$Set} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $RegistryWrapper<T> extends $Record implements $Iterable$$Interface<(T)> {
constructor(registry: $Registry$$Type<(T)>, unknownKey: $ResourceKey$$Type<(T)>)

public "getEntrySet"(): $Set<($Map$Entry<($ResourceLocation), (T)>)>
public "unknownKey"(): $ResourceKey<(T)>
public "getDataMap"(id: $ResourceLocation$$Type): $DataMapWrapper<(T), (never)>
public "getValueMap"(): $Map<($ResourceLocation), (T)>
public "getValues"(): $List<(T)>
public "getValues"(filter: any): $HolderSetWrapper<(T)>
public "getKeys"(): $Set<($ResourceLocation)>
public "get"(id: $ResourceLocation$$Type): T
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "iterator"(): $ListIterator<(T)>
public static "of"(id: $ResourceLocation$$Type): $RegistryWrapper<(never)>
public "contains"(id: $ResourceLocation$$Type): boolean
public "getKey"(value: T): $ResourceKey<(T)>
public static "access"(): $RegistryAccessContainer
public "getId"(value: T): $ResourceLocation
public "containsValue"(value: T): boolean
public "registry"(): $Registry<(T)>
public "getRandom"(): T
public "getRandom"(random: $RandomSource$$Type): T
public "spliterator"(): $Spliterator<(T)>
public "forEach"(arg0: $Consumer$$Type<(T)>): void
[Symbol.iterator](): IterableIterator<T>;
get "entrySet"(): $Set<($Map$Entry<($ResourceLocation), (T)>)>
get "valueMap"(): $Map<($ResourceLocation), (T)>
get "values"(): $List<(T)>
get "keys"(): $Set<($ResourceLocation)>
get "random"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryWrapper$$Type<T> = ({"registry"?: $Registry$$Type<(T)>, "unknownKey"?: $ResourceKey$$Type<(T)>}) | ([registry?: $Registry$$Type<(T)>, unknownKey?: $ResourceKey$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryWrapper$$Original<T> = $RegistryWrapper<(T)>;}
declare module "dev.latvian.mods.kubejs.core.PlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$WithAttachedData$$Interface} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$Direction} from "net.minecraft.core.Direction"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LivingEntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.LivingEntityKJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$DataSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $PlayerKJS$$Interface extends $LivingEntityKJS$$Interface, $DataSenderKJS$$Interface, $WithAttachedData$$Interface<($Player)> {

(): $AttachedData$$Type<($Player$$Type)>
set "statusMessage"(value: $Component$$Type)
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "craftingGrid"(): $InventoryKJS
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "selectedSlot"(): integer
get "stats"(): $PlayerStatsJS
get "miningBlock"(): boolean
get "fake"(): boolean
set "selectedSlot"(value: integer)
get "mouseItem"(): $ItemStack
set "mouseItem"(value: $ItemStack$$Type)
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "saturation"(): float
set "saturation"(value: float)
set "xp"(value: integer)
get "xp"(): integer
set "xpLevel"(value: integer)
get "xpLevel"(): integer
get "openInventory"(): $AbstractContainerMenu
get "profile"(): $GameProfile
get "player"(): boolean
get "defaultMovementSpeed"(): double
set "defaultMovementSpeed"(value: double)
get "reachDistance"(): double
get "living"(): boolean
set "maxHealth"(value: float)
get "undead"(): boolean
get "potionEffects"(): $EntityPotionEffectsJS
get "mainHandItem"(): $ItemStack
set "mainHandItem"(value: $ItemStack$$Type)
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
get "headArmorItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
set "chestArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
set "legsArmorItem"(value: $ItemStack$$Type)
get "feetArmorItem"(): $ItemStack
set "feetArmorItem"(value: $ItemStack$$Type)
get "totalMovementSpeed"(): double
set "movementSpeedAddition"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
get "data"(): $AttachedData<($Player)>
get "name"(): $Component
get "displayName"(): $Component
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "server"(): $MinecraftServer
get "block"(): $LevelBlock
get "nbt"(): $CompoundTag
set "nbt"(value: $CompoundTag$$Type)
get "scriptType"(): $ScriptType
get "type"(): StringJS
get "item"(): $ItemStack
get "frame"(): boolean
get "monster"(): boolean
get "animal"(): boolean
get "ambientCreature"(): boolean
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
set "x"(value: double)
set "y"(value: double)
set "z"(value: double)
get "motionX"(): double
set "motionX"(value: double)
get "motionY"(): double
set "motionY"(value: double)
get "motionZ"(): double
set "motionZ"(value: double)
get "passengers"(): $EntityArrayList
get "teamId"(): StringJS
get "facing"(): $Direction
set "activePostShader"(value: $ResourceLocation$$Type)
get "persistentData"(): $CompoundTag
}

export class $PlayerKJS implements $PlayerKJS$$Interface {
 "self"(): $LivingEntity
 "setStatusMessage"(message: $Component$$Type): void
 "getStages"(): $Stages
 "getInventory"(): $InventoryKJS
 "getCraftingGrid"(): $InventoryKJS
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "getSelectedSlot"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "notify"(builder: $NotificationToastData$$Type): void
 "getStats"(): $PlayerStatsJS
 "isMiningBlock"(): boolean
 "isFake"(): boolean
 "sendInventoryUpdate"(): void
 "give"(item: $ItemStack$$Type): void
 "giveInHand"(item: $ItemStack$$Type): void
 "setSelectedSlot"(index: integer): void
 "getMouseItem"(): $ItemStack
 "setMouseItem"(item: $ItemStack$$Type): void
 "addFood"(f: integer, m: float): void
 "getFoodLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "getSaturation"(): float
 "setSaturation"(saturation: float): void
 "addExhaustion"(exhaustion: float): void
 "addXP"(xp: integer): void
 "addXPLevels"(l: integer): void
 "setXp"(xp: integer): void
 "getXp"(): integer
 "setXpLevel"(l: integer): void
 "getXpLevel"(): integer
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "spawn"(): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "damageHeldItem"(): void
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "getDefaultMovementSpeed"(): double
 "setDefaultMovementSpeed"(speed: double): void
 "getReachDistance"(): double
 "rayTrace"(): $KubeRayTraceResult
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "isLiving"(): boolean
 "setMaxHealth"(hp: float): void
 "isUndead"(): boolean
 "getPotionEffects"(): $EntityPotionEffectsJS
 "swing"(): void
 "swing"(hand: $InteractionHand$$Type): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "getMainHandItem"(): $ItemStack
 "setMainHandItem"(item: $ItemStack$$Type): void
 "getOffHandItem"(): $ItemStack
 "setOffHandItem"(item: $ItemStack$$Type): void
 "getHeadArmorItem"(): $ItemStack
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "getFeetArmorItem"(): $ItemStack
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "getTotalMovementSpeed"(): double
 "setMovementSpeedAddition"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "tell"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "getServer"(): $MinecraftServer
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "getNbt"(): $CompoundTag
 "setNbt"(nbt: $CompoundTag$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "getType"(): StringJS
 "getItem"(): $ItemStack
 "isFrame"(): boolean
 "isMonster"(): boolean
 "isAnimal"(): boolean
 "isAmbientCreature"(): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setX"(x: double): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "getMotionX"(): double
 "setMotionX"(x: double): void
 "getMotionY"(): double
 "setMotionY"(y: double): void
 "getMotionZ"(): double
 "setMotionZ"(z: double): void
 "setRotation"(yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "getTeamId"(): StringJS
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "getFacing"(): $Direction
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "attack"(hp: float): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerKJS$$Original = $PlayerKJS;}
declare module "dev.latvian.mods.kubejs.core.CustomIngredientKJS" {
import {$ItemStackSet} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$ItemPredicate, $ItemPredicate$$Interface} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set} from "java.util.Set"
import {$Stream} from "java.util.stream.Stream"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $CustomIngredientKJS$$Interface extends $ItemPredicate$$Interface {

(itemStack: $ItemStack): boolean
get "items"(): $Stream<($ItemStack)>
get "stackArray"(): ($ItemStack)[]
get "displayStacks"(): $ItemStackSet
get "stacks"(): $ItemStackSet
get "itemStream"(): $Stream<($Item)>
get "itemTypes"(): $Set<($Item)>
get "itemIds"(): $Set<(StringJS)>
get "first"(): $ItemStack
get "wildcard"(): boolean
}

export class $CustomIngredientKJS implements $CustomIngredientKJS$$Interface {
 "asIngredient"(): $Ingredient
 "getItems"(): $Stream<($ItemStack)>
 "canBeUsedForMatching"(): boolean
 "getStackArray"(): ($ItemStack)[]
 "getDisplayStacks"(): $ItemStackSet
 "getStacks"(): $ItemStackSet
 "testItem"(item: $Item$$Type): boolean
 "getItemStream"(): $Stream<($Item)>
 "getItemTypes"(): $Set<($Item)>
 "getItemIds"(): $Set<(StringJS)>
 "getFirst"(): $ItemStack
 "test"(itemStack: $ItemStack$$Type): boolean
 "test"(itemStack: any): boolean
static "wrap"(from: any): $ItemPredicate
 "isWildcard"(): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomIngredientKJS$$Type = ((itemStack: $ItemStack) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomIngredientKJS$$Original = $CustomIngredientKJS;}
declare module "dev.latvian.mods.kubejs.client.KeybindRegistryKubeEvent$Builder" {
import {$KeyModifier$$Type} from "net.neoforged.neoforge.client.settings.KeyModifier"
import {$KeyConflictContext$$Type} from "net.neoforged.neoforge.client.settings.KeyConflictContext"
import {$InputConstants$Type$$Type} from "com.mojang.blaze3d.platform.InputConstants$Type"

export class $KeybindRegistryKubeEvent$Builder {
public "defaultKey"(keyName: StringJS): $KeybindRegistryKubeEvent$Builder
public "category"(category: StringJS): $KeybindRegistryKubeEvent$Builder
public "modifier"(modifier: $KeyModifier$$Type): $KeybindRegistryKubeEvent$Builder
public "gui"(): $KeybindRegistryKubeEvent$Builder
public "inputType"(inputType: $InputConstants$Type$$Type): $KeybindRegistryKubeEvent$Builder
public "inGame"(): $KeybindRegistryKubeEvent$Builder
public "conflictContext"(keyConflictContext: $KeyConflictContext$$Type): $KeybindRegistryKubeEvent$Builder
public "scanCodeInputType"(): $KeybindRegistryKubeEvent$Builder
public "mouseInputType"(): $KeybindRegistryKubeEvent$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeybindRegistryKubeEvent$Builder$$Type = ($KeybindRegistryKubeEvent$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KeybindRegistryKubeEvent$Builder$$Original = $KeybindRegistryKubeEvent$Builder;}
declare module "dev.latvian.mods.kubejs.recipe.special.ShapelessKubeJSRecipe" {
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$IngredientActionHolder, $IngredientActionHolder$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"
import {$List, $List$$Type} from "java.util.List"
import {$ShapelessRecipe, $ShapelessRecipe$$Type} from "net.minecraft.world.item.crafting.ShapelessRecipe"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$KubeJSCraftingRecipe$$Interface} from "dev.latvian.mods.kubejs.recipe.special.KubeJSCraftingRecipe"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $ShapelessKubeJSRecipe extends $ShapelessRecipe implements $KubeJSCraftingRecipe$$Interface {
readonly "result": $ItemStack
readonly "ingredients": $NonNullList<($Ingredient)>
readonly "group": StringJS

constructor(original: $ShapelessRecipe$$Type, ingredientActions: $List$$Type<($IngredientActionHolder$$Type)>, modifyResult: StringJS, stage: StringJS)

public "kjs$getIngredientActions"(): $List<($IngredientActionHolder)>
public "kjs$getModifyResult"(): StringJS
public "kjs$getStage"(): StringJS
public "assemble"(input: $CraftingInput$$Type, registryAccess: $HolderLookup$Provider$$Type): $ItemStack
public "assemble"(input: $RecipeInput$$Type, registryAccess: $HolderLookup$Provider$$Type): $ItemStack
public "getRemainingItems"(input: $RecipeInput$$Type): $NonNullList
public "getRemainingItems"(input: $CraftingInput$$Type): $NonNullList<($ItemStack)>
public "getSerializer"(): $RecipeSerializer<(never)>
public "kjs$getRemainingItems"(input: $CraftingInput$$Type): $NonNullList<($ItemStack)>
public "kjs$assemble"(input: $CraftingInput$$Type, registryAccess: $HolderLookup$Provider$$Type): $ItemStack
get "serializer"(): $RecipeSerializer<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapelessKubeJSRecipe$$Type = ($ShapelessKubeJSRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShapelessKubeJSRecipe$$Original = $ShapelessKubeJSRecipe;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent" {
import {$Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuInventoryClickEvent {
readonly "button": integer
readonly "type": $ClickType

constructor(slot: $Slot$$Type, type: $ClickType$$Type, button: integer)

public "setItem"(item: $ItemStack$$Type): void
public "getItem"(): $ItemStack
public "getIndex"(): integer
set "item"(value: $ItemStack$$Type)
get "item"(): $ItemStack
get "index"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuInventoryClickEvent$$Type = ($ChestMenuInventoryClickEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuInventoryClickEvent$$Original = $ChestMenuInventoryClickEvent;}
declare module "dev.latvian.mods.kubejs.core.EntityTypeKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder} from "net.minecraft.core.Holder"
import {$EntityType} from "net.minecraft.world.entity.EntityType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityTypeKJS$$Interface extends $RegistryObjectKJS$$Interface<($EntityType<(never)>)> {
get "registryId"(): $ResourceKey<($Registry<($EntityType<(never)>)>)>
get "registry"(): $Registry<($EntityType<(never)>)>
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($EntityType<(never)>)>)>
get "tags"(): $List<($ResourceLocation)>
get "key"(): $ResourceKey<($EntityType<(never)>)>
get "id"(): StringJS
}

export class $EntityTypeKJS implements $EntityTypeKJS$$Interface {
 "getRegistryId"(): $ResourceKey<($Registry<($EntityType<(never)>)>)>
 "getRegistry"(): $Registry<($EntityType<(never)>)>
 "asHolder"(): $Holder<($EntityType<(never)>)>
 "getIdLocation"(): $ResourceLocation
 "getMod"(): StringJS
 "getTagKeys"(): $List<($TagKey<($EntityType<(never)>)>)>
 "getTags"(): $List<($ResourceLocation)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getKey"(): $ResourceKey<($EntityType<(never)>)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTypeKJS$$Type = ($EntityTypeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityTypeKJS$$Original = $EntityTypeKJS;}
declare module "dev.latvian.mods.kubejs.client.LangKubeEvent$Key" {
import {$Record} from "java.lang.Record"

export class $LangKubeEvent$Key extends $Record {
constructor(namespace: StringJS, lang: StringJS, key: StringJS)

public "namespace"(): StringJS
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "key"(): StringJS
public "lang"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LangKubeEvent$Key$$Type = ({"namespace"?: StringJS, "key"?: StringJS, "lang"?: StringJS}) | ([namespace?: StringJS, key?: StringJS, lang?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LangKubeEvent$Key$$Original = $LangKubeEvent$Key;}
declare module "dev.latvian.mods.kubejs.block.custom.DoorBlockBuilder" {
import {$KubeDataGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $DoorBlockBuilder extends $ShapedBlockBuilder {
static readonly "DOOR_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "WOODEN_DOOR_TAGS": ($ResourceLocation)[]

constructor(i: $ResourceLocation$$Type)

public "behaviour"(wt: $BlockSetType$$Type): this
public "wooden"(): this
public "generateLootTable"(generator: $KubeDataGenerator$$Type): $LootTable
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoorBlockBuilder$$Type = ($DoorBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoorBlockBuilder$$Original = $DoorBlockBuilder;}
declare module "dev.latvian.mods.kubejs.core.ClientLevelKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$LevelKJS$$Interface} from "dev.latvian.mods.kubejs.core.LevelKJS"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$KubeAnimatedParticle} from "dev.latvian.mods.kubejs.client.KubeAnimatedParticle"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ClientLevelKJS$$Interface extends $LevelKJS$$Interface {

(): $AttachedData$$Type<($Level$$Type)>
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "side"(): $ScriptType
get "dimension"(): $ResourceLocation
get "overworld"(): boolean
set "time"(value: long)
get "data"(): $AttachedData<($Level)>
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "displayName"(): $Component
get "entities"(): $EntityArrayList
}

export class $ClientLevelKJS implements $ClientLevelKJS$$Interface {
 "self"(): $EntityGetter
 "kubeParticle"(x: double, y: double, z: double, spriteSet: $SpriteSet$$Type): $KubeAnimatedParticle
 "tell"(message: $Component$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getName"(): $Component
 "getBlock"(pos: $BlockPos$$Type): $LevelBlock
 "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
 "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
 "getSide"(): $ScriptType
 "getDimension"(): $ResourceLocation
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
 "isOverworld"(): boolean
 "setTime"(time: long): void
 "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
 "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
 "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "getData"(): $AttachedData<($Level)>
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getDisplayName"(): $Component
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientLevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientLevelKJS$$Original = $ClientLevelKJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType" {
import {$RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$Function$$Type} from "java.util.function.Function"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeComponentCodecFactory$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentCodecFactory"
import {$RecipeComponentType$Unit} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType$Unit"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $RecipeComponentType<T> {
constructor(id: $ResourceLocation$$Type)

public "outputKey"(name: StringJS): $RecipeKey<(T)>
public "isUnit"(): boolean
public "inputKey"(name: StringJS): $RecipeKey<(T)>
public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<(T)>
public "instance"(): $RecipeComponent<(T)>
public static "unit"<T>(id: $ResourceLocation$$Type, instanceGetter: $Function$$Type<($RecipeComponentType<(T)>), ($RecipeComponent$$Type<(T)>)>): $RecipeComponentType$Unit<(T)>
public static "unit"<T>(id: $ResourceLocation$$Type, instance: $RecipeComponent$$Type<(T)>): $RecipeComponentType$Unit<(T)>
public static "dynamic"<CT extends $RecipeComponent<(object)>>(id: $ResourceLocation$$Type, codecFactory: $RecipeComponentCodecFactory$$Type<(CT)>): $RecipeComponentType<(never)>
public static "dynamic"<CT extends $RecipeComponent<(object)>>(id: $ResourceLocation$$Type, mapCodec: $MapCodec$$Type<(CT)>): $RecipeComponentType<(never)>
public "otherKey"(name: StringJS): $RecipeKey<(T)>
public "mapCodec"(ctx: $RecipeTypeRegistryContext$$Type): $MapCodec<($RecipeComponent<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentType$$Type<T> = ($RecipeComponentType<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentType$$Original<T> = $RecipeComponentType<(T)>;}
declare module "dev.latvian.mods.kubejs.player.InventoryKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player opens or closes a container.
 */
export class $InventoryKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, menu: $AbstractContainerMenu$$Type)

/**
 * Gets the container that was opened or closed.
 */
public "getInventoryContainer"(): $AbstractContainerMenu
/**
 * Gets the player that opened or closed the container.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "inventoryContainer"(): $AbstractContainerMenu
get "entity"(): $LivingEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryKubeEvent$$Type = ($InventoryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryKubeEvent$$Original = $InventoryKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.entity.CustomCapabilityAttachment$Factory" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $CustomCapabilityAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(type: $BlockCapability$$Type<(never), (never)>, dataFactory: $Supplier$$Type<(never)>)

public "dataFactory"(): $Supplier<(never)>
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "type"(): $BlockCapability<(never), (never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomCapabilityAttachment$Factory$$Type = ({"dataFactory"?: $Supplier$$Type<(never)>, "type"?: $BlockCapability$$Type<(never), (never)>}) | ([dataFactory?: $Supplier$$Type<(never)>, type?: $BlockCapability$$Type<(never), (never)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomCapabilityAttachment$Factory$$Original = $CustomCapabilityAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key" {
import {$RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$Record} from "java.lang.Record"

export class $CustomObjectRecipeComponent$Key extends $Record {
constructor(name: StringJS, component: $RecipeComponent$$Type<(never)>, optional: boolean)
constructor(name: StringJS, component: $RecipeComponent$$Type<(never)>, optional: boolean, alwaysWrite: boolean)
constructor(name: StringJS, component: $RecipeComponent$$Type<(never)>)

public "alwaysWrite"(): boolean
public "name"(): StringJS
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "component"(): $RecipeComponent<(never)>
public "optional"(): boolean
public static "createCodec"(ctx: $RecipeTypeRegistryContext$$Type): $Codec<($CustomObjectRecipeComponent$Key)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomObjectRecipeComponent$Key$$Type = ({"alwaysWrite"?: boolean, "optional"?: boolean, "name"?: StringJS, "component"?: $RecipeComponent$$Type<(never)>}) | ([alwaysWrite?: boolean, optional?: boolean, name?: StringJS, component?: $RecipeComponent$$Type<(never)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomObjectRecipeComponent$Key$$Original = $CustomObjectRecipeComponent$Key;}
declare module "dev.latvian.mods.kubejs.block.BlockTintFunction" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$BlockAndTintGetter, $BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockTintFunction$Fixed} from "dev.latvian.mods.kubejs.block.BlockTintFunction$Fixed"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockTintFunction$$Interface {

(state: $BlockState, level: $BlockAndTintGetter, pos: $BlockPos, index: integer): $KubeColor$$Type
}

export class $BlockTintFunction implements $BlockTintFunction$$Interface {
static readonly "REDSTONE": $BlockTintFunction
static readonly "BIRCH_FOLIAGE": $BlockTintFunction$Fixed
static readonly "TYPE_INFO": $TypeInfo
static readonly "GRASS": $BlockTintFunction
static readonly "MANGROVE_FOLIAGE": $BlockTintFunction$Fixed
static readonly "FOLIAGE": $BlockTintFunction
static readonly "EVERGREEN_FOLIAGE": $BlockTintFunction$Fixed
static readonly "REDSTONE_COLORS": ($KubeColor)[]
static readonly "DEFAULT_FOLIAGE_COLOR": $KubeColor
static readonly "WATER": $BlockTintFunction

static "wrap"(o: any): $BlockTintFunction
 "getColor"(state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, index: integer): $KubeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunction$$Type = (($BlockTintFunction$$Type)[]) | (StringJS) | ((state: $BlockState, level: $BlockAndTintGetter, pos: $BlockPos, index: integer) => $KubeColor$$Type) | ((state: $BlockState, level: $BlockAndTintGetter, pos: $BlockPos, index: integer) => $KubeColor$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockTintFunction$$Original = $BlockTintFunction;}
declare module "dev.latvian.mods.kubejs.block.custom.CardinalBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $CardinalBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CardinalBlockBuilder$$Type = ($CardinalBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CardinalBlockBuilder$$Original = $CardinalBlockBuilder;}
declare module "dev.latvian.mods.kubejs.misc.PotionBuilder" {
import {$MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$Potion} from "net.minecraft.world.item.alchemy.Potion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"

export class $PotionBuilder extends $BuilderBase<($Potion)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, visible: boolean): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean, hiddenEffect: $MobEffectInstance$$Type): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer): this
public "effect"(effect: $Holder$$Type<($MobEffect)>): this
public "addEffect"(effect: $MobEffectInstance$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionBuilder$$Type = ($PotionBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotionBuilder$$Original = $PotionBuilder;}
declare module "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS" {
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ReloadableServerResourceHolderKJS$$Interface {
}

export class $ReloadableServerResourceHolderKJS implements $ReloadableServerResourceHolderKJS$$Interface {
 "kjs$getResources"(): $ReloadableServerResourcesKJS
 "kjs$setResources"(resources: $ReloadableServerResourcesKJS$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReloadableServerResourceHolderKJS$$Type = ($ReloadableServerResourceHolderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReloadableServerResourceHolderKJS$$Original = $ReloadableServerResourceHolderKJS;}
declare module "dev.latvian.mods.kubejs.recipe.CompostableRecipesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$VirtualDataMapFile, $VirtualDataMapFile$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile"
import {$Compostable, $Compostable$$Type} from "net.neoforged.neoforge.registries.datamaps.builtin.Compostable"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Record} from "java.lang.Record"

export class $CompostableRecipesKubeEvent extends $Record implements $KubeEvent$$Interface {
constructor(compostables: $VirtualDataMapFile$$Type<($Item$$Type), ($Compostable$$Type)>)

public "addReplace"(match: $ItemPredicate$$Type, f: float, villager: boolean): void
public "addReplace"(match: $ItemPredicate$$Type, f: float): void
public "compostables"(): $VirtualDataMapFile<($Item), ($Compostable)>
public "remove"(match: $ItemPredicate$$Type): void
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "replaceAll"(): void
public "add"(match: $ItemPredicate$$Type, f: float): void
public "add"(match: $ItemPredicate$$Type, f: float, villager: boolean): void
public "removeAll"(): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompostableRecipesKubeEvent$$Type = ({"compostables"?: $VirtualDataMapFile$$Type<($Item$$Type), ($Compostable$$Type)>}) | ([compostables?: $VirtualDataMapFile$$Type<($Item$$Type), ($Compostable$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CompostableRecipesKubeEvent$$Original = $CompostableRecipesKubeEvent;}
declare module "dev.latvian.mods.kubejs.player.PlayerStatsJS" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Stat, $Stat$$Type} from "net.minecraft.stats.Stat"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$StatsCounter$$Type} from "net.minecraft.stats.StatsCounter"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $PlayerStatsJS {
readonly "player": $Player

constructor(p: $Player$$Type, s: $StatsCounter$$Type)

public "getDamageTaken"(): integer
public static "wrapStat"(o: any): $Stat<(never)>
public "getPlayTime"(): integer
public "getTimeSinceDeath"(): integer
public "getTimeSinceRest"(): integer
public "getTimeCrouchTime"(): integer
public "getJumps"(): integer
public "getWalkDistance"(): integer
public "getSprintDistance"(): integer
public "getSwimDistance"(): integer
public "getCrouchDistance"(): integer
public "getDamageDealt"(): integer
public "getDamageDealt_absorbed"(): integer
public "getDamageDealt_resisted"(): integer
public "getDamageBlocked_by_shield"(): integer
public "getDamageAbsorbed"(): integer
public "getDamageResisted"(): integer
public "getDeaths"(): integer
public "getMobKills"(): integer
public "getAnimalsBred"(): integer
public "getPlayerKills"(): integer
public "getFishCaught"(): integer
public "getBlocksMined"(block: $Block$$Type): integer
public "getItemsCrafted"(item: $Item$$Type): integer
public "getItemsUsed"(item: $Item$$Type): integer
public "getItemsBroken"(item: $Item$$Type): integer
public "getItemsPickedUp"(item: $Item$$Type): integer
public "getItemsDropped"(item: $Item$$Type): integer
public "getKilled"(entity: $EntityType$$Type<(never)>): integer
public "getKilledBy"(entity: $EntityType$$Type<(never)>): integer
public "get"(stat: $Stat$$Type<(never)>): integer
public "add"(stat: $Stat$$Type<(never)>, value: integer): void
public "set"(stat: $Stat$$Type<(never)>, value: integer): void
get "damageTaken"(): integer
get "playTime"(): integer
get "timeSinceDeath"(): integer
get "timeSinceRest"(): integer
get "timeCrouchTime"(): integer
get "jumps"(): integer
get "walkDistance"(): integer
get "sprintDistance"(): integer
get "swimDistance"(): integer
get "crouchDistance"(): integer
get "damageDealt"(): integer
get "damageDealt_absorbed"(): integer
get "damageDealt_resisted"(): integer
get "damageBlocked_by_shield"(): integer
get "damageAbsorbed"(): integer
get "damageResisted"(): integer
get "deaths"(): integer
get "mobKills"(): integer
get "animalsBred"(): integer
get "playerKills"(): integer
get "fishCaught"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerStatsJS$$Type = ($PlayerStatsJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerStatsJS$$Original = $PlayerStatsJS;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.AddEntriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $AddEntriesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(items: E): void
}

export class $AddEntriesKubeEvent<E, F> implements $AddEntriesKubeEvent$$Interface {
 "add"(items: E): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddEntriesKubeEvent$$Type<E, F> = ((items: (any)[]) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AddEntriesKubeEvent$$Original<E, F> = $AddEntriesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.component.ItemComponentFunctions" {
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ComponentFunctions, $ComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID$$Type} from "java.util.UUID"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$List$$Type} from "java.util.List"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Map$$Type} from "java.util.Map"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$AttributeModifierFunctions$$Interface} from "dev.latvian.mods.kubejs.component.AttributeModifierFunctions"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export interface $ItemComponentFunctions$$Interface extends $ComponentFunctions$$Interface, $AttributeModifierFunctions$$Interface {
set "food"(value: $FoodProperties$$Type)
set "maxStackSize"(value: integer)
set "maxDamage"(value: integer)
set "damage"(value: integer)
get "unbreakable"(): void
set "itemName"(value: $Component$$Type)
set "repairCost"(value: integer)
get "fireResistant"(): void
set "tool"(value: $Tool$$Type)
set "mapItemColor"(value: $KubeColor$$Type)
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "bucketEntityData"(value: $CompoundTag$$Type)
set "blockEntityData"(value: $CompoundTag$$Type)
set "instrument"(value: $Holder$$Type<($Instrument)>)
get "unbreakableWithTooltip"(): void
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
set "fireworks"(value: $Fireworks$$Type)
set "noteBlockSound"(value: $ResourceLocation$$Type)
get "attributeModifiers"(): $ItemAttributeModifiers
get "componentMap"(): $DataComponentMap
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "componentString"(): StringJS
set "customData"(value: $CompoundTag$$Type)
get "customData"(): $CompoundTag
set "rarity"(value: $Rarity$$Type)
set "customName"(value: $Component$$Type)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customModelData"(value: integer)
get "additionalTooltipHidden"(): void
get "tooltipHidden"(): void
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "lockCode"(value: StringJS)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
get "baseAttackDamage"(): double
get "baseAttackSpeed"(): double
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "attackSpeed"(value: double)
set "attackDamage"(value: double)
get "attackDamage"(): double
get "attackSpeed"(): double
set "baseAttackSpeed"(value: double)
set "baseAttackDamage"(value: double)
}

export class $ItemComponentFunctions implements $ItemComponentFunctions$$Interface {
 "setFood"(foodProperties: $FoodProperties$$Type): void
 "setFood"(nutrition: integer, saturation: float): void
 "setMaxStackSize"(size: integer): void
 "setMaxDamage"(maxDamage: integer): void
 "setDamage"(damage: integer): void
 "setUnbreakable"(): void
 "setItemName"(component: $Component$$Type): void
 "setRepairCost"(repairCost: integer): void
 "setFireResistant"(): void
 "setTool"(tool: $Tool$$Type): void
 "setMapItemColor"(color: $KubeColor$$Type): void
 "setChargedProjectiles"(items: $List$$Type<($ItemStack$$Type)>): void
 "setBundleContents"(items: $List$$Type<($ItemStack$$Type)>): void
 "setBucketEntityData"(tag: $CompoundTag$$Type): void
 "setBlockEntityData"(tag: $CompoundTag$$Type): void
 "setInstrument"(instrument: $Holder$$Type<($Instrument)>): void
 "setUnbreakableWithTooltip"(): void
 "setFireworkExplosion"(explosion: $FireworkExplosion$$Type): void
 "setFireworks"(fireworks: $Fireworks$$Type): void
 "setNoteBlockSound"(id: $ResourceLocation$$Type): void
 "getAttributeModifiers"(): $ItemAttributeModifiers
 "resetComponents"(): $ComponentFunctions
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): $ComponentFunctions
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "getComponentMap"(): $DataComponentMap
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "getComponentString"(): StringJS
 "setCustomData"(tag: $CompoundTag$$Type): void
 "getCustomData"(): $CompoundTag
 "setRarity"(rarity: $Rarity$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "getCustomName"(): $Component
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setCustomModelData"(data: integer): void
 "setAdditionalTooltipHidden"(): void
 "setTooltipHidden"(): void
 "setGlintOverride"(override: boolean): void
 "setDyedColor"(color: $KubeColor$$Type): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "setLockCode"(lock: StringJS): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
 "getBaseAttackDamage"(): double
 "getBaseAttackSpeed"(): double
 "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
 "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
 "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
 "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
 "setAttackSpeed"(speed: double): void
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
 "setAttackDamage"(dmg: double): void
 "getAttackDamage"(): double
 "getAttackSpeed"(): double
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
 "setBaseAttackSpeed"(speed: double): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
 "setBaseAttackDamage"(dmg: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemComponentFunctions$$Type = ($ItemComponentFunctions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemComponentFunctions$$Original = $ItemComponentFunctions;}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundInstance" {
import {$JsonElement} from "com.google.gson.JsonElement"

export class $SoundsGenerator$SoundInstance {
constructor(fileLocation: StringJS)

public "asReferenceToEvent"(): $SoundsGenerator$SoundInstance
public "attenuationDistance"(i: integer): $SoundsGenerator$SoundInstance
public "stream"(): $SoundsGenerator$SoundInstance
public "stream"(b: boolean): $SoundsGenerator$SoundInstance
public "toJson"(): $JsonElement
public "weight"(i: integer): $SoundsGenerator$SoundInstance
public "preload"(): $SoundsGenerator$SoundInstance
public "preload"(b: boolean): $SoundsGenerator$SoundInstance
public "volume"(f: float): $SoundsGenerator$SoundInstance
public "pitch"(f: float): $SoundsGenerator$SoundInstance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$SoundInstance$$Type = ($SoundsGenerator$SoundInstance);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundsGenerator$SoundInstance$$Original = $SoundsGenerator$SoundInstance;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.ParticleOptionsWrapper" {
import {$DustParticleOptions} from "net.minecraft.core.particles.DustParticleOptions"
import {$RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ParticleOptionsWrapper$$Interface {
}

export class $ParticleOptionsWrapper implements $ParticleOptionsWrapper$$Interface {
static readonly "ERROR": $DustParticleOptions

static "wrap"(registries: $RegistryAccessContainer$$Type, o: any): $ParticleOptions
static "create"(options: $ParticleOptions$$Type): $ParticleOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleOptionsWrapper$$Type = ($ParticleOptionsWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleOptionsWrapper$$Original = $ParticleOptionsWrapper;}
declare module "dev.latvian.mods.kubejs.event.EventHandlerContainer" {
import {$EventHandler$$Type} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ConsoleJS$$Type} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$IEventHandler, $IEventHandler$$Type} from "dev.latvian.mods.kubejs.event.IEventHandler"
import {$EventResult} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventHandlerContainer {
readonly "handler": $IEventHandler
readonly "line": integer
readonly "source": StringJS
readonly "target": any

constructor(target: any, handler: $IEventHandler$$Type, source: StringJS, line: integer)

public "toString"(): StringJS
public static "isEmpty"(array: ($EventHandlerContainer$$Type)[]): boolean
public "add"(extraId: any, handler: $IEventHandler$$Type, source: StringJS, line: integer): void
public "handle"(console: $ConsoleJS$$Type, handler: $EventHandler$$Type, event: $KubeEvent$$Type): $EventResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandlerContainer$$Type = ($EventHandlerContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventHandlerContainer$$Original = $EventHandlerContainer;}
declare module "dev.latvian.mods.kubejs.block.custom.TrapdoorBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $TrapdoorBlockBuilder extends $ShapedBlockBuilder {
static readonly "TRAPDOOR_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "behaviour"(wt: $BlockSetType$$Type): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrapdoorBlockBuilder$$Type = ($TrapdoorBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrapdoorBlockBuilder$$Original = $TrapdoorBlockBuilder;}
declare module "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS" {
import {$TagManager} from "net.minecraft.tags.TagManager"
import {$ServerScriptManager} from "dev.latvian.mods.kubejs.server.ServerScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ReloadableServerResourcesKJS$$Interface {
}

export class $ReloadableServerResourcesKJS implements $ReloadableServerResourcesKJS$$Interface {
 "kjs$getTagManager"(): $TagManager
 "kjs$getServerScriptManager"(): $ServerScriptManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReloadableServerResourcesKJS$$Type = ($ReloadableServerResourcesKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReloadableServerResourcesKJS$$Original = $ReloadableServerResourcesKJS;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo" {
import {$BlockEntityAttachmentFactory, $BlockEntityAttachmentFactory$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentType, $BlockEntityAttachmentType$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentType"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$EnumSet, $EnumSet$$Type} from "java.util.EnumSet"
import {$Record} from "java.lang.Record"

export class $BlockEntityAttachmentInfo extends $Record {
constructor(id: StringJS, type: $BlockEntityAttachmentType$$Type, index: integer, directions: $EnumSet$$Type<($Direction$$Type)>, factory: $BlockEntityAttachmentFactory$$Type)

public "directions"(): $EnumSet<($Direction)>
public "index"(): integer
public "type"(): $BlockEntityAttachmentType
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "factory"(): $BlockEntityAttachmentFactory
public "id"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentInfo$$Type = ({"factory"?: $BlockEntityAttachmentFactory$$Type, "directions"?: $EnumSet$$Type<($Direction$$Type)>, "type"?: $BlockEntityAttachmentType$$Type, "id"?: StringJS, "index"?: integer}) | ([factory?: $BlockEntityAttachmentFactory$$Type, directions?: $EnumSet$$Type<($Direction$$Type)>, type?: $BlockEntityAttachmentType$$Type, id?: StringJS, index?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentInfo$$Original = $BlockEntityAttachmentInfo;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper$Listeners$Key" {
import {$EventPriority, $EventPriority$$Type} from "net.neoforged.bus.api.EventPriority"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $NativeEventWrapper$Listeners$Key extends $Record {
constructor(eventClass: $Class$$Type<(never)>, priority: $EventPriority$$Type)

public "eventClass"(): $Class<(never)>
public "priority"(): $EventPriority
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeEventWrapper$Listeners$Key$$Type = ({"priority"?: $EventPriority$$Type, "eventClass"?: $Class$$Type<(never)>}) | ([priority?: $EventPriority$$Type, eventClass?: $Class$$Type<(never)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NativeEventWrapper$Listeners$Key$$Original = $NativeEventWrapper$Listeners$Key;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeConstructor" {
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$Map} from "java.util.Map"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ComponentValueMap$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentValueMap"
import {$KubeRecipe} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$RecipeOptional, $RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $RecipeConstructor {
readonly "keys": $List<($RecipeKey<(never)>)>
 "defaultValues": $Map<($RecipeKey<(never)>), ($RecipeOptional<(never)>)>
 "overrides": $Map<($RecipeKey<(never)>), ($RecipeOptional<(never)>)>

constructor(keys: $List$$Type<($RecipeKey$$Type<(never)>)>)
constructor(...keys: ($RecipeKey$$Type<(never)>)[])

public "overrideValue"<T>(key: $RecipeKey$$Type<(T)>, value: T): $RecipeConstructor
public "setValues"(cx: $RecipeScriptContext$$Type, schemaType: $RecipeSchemaType$$Type, from: $ComponentValueMap$$Type): void
public "toString"(ops: $OpsContainer$$Type): StringJS
public "toString"(): StringJS
public "defaultValue"<T>(key: $RecipeKey$$Type<(T)>, value: $RecipeOptional$$Type<(T)>): $RecipeConstructor
public "override"<T>(key: $RecipeKey$$Type<(T)>, value: $RecipeOptional$$Type<(T)>): $RecipeConstructor
public "create"(sourceLine: $SourceLine$$Type, type: $RecipeTypeFunction$$Type, schemaType: $RecipeSchemaType$$Type, from: $ComponentValueMap$$Type): $KubeRecipe
public "toJson"(type: $RecipeSchemaType$$Type, ops: $DynamicOps$$Type<($JsonElement$$Type)>): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeConstructor$$Type = ($RecipeConstructor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeConstructor$$Original = $RecipeConstructor;}
declare module "dev.latvian.mods.kubejs.item.ItemDestroyedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$PlayerDestroyItemEvent$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerDestroyItemEvent"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand} from "net.minecraft.world.InteractionHand"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $ItemDestroyedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(e: $PlayerDestroyItemEvent$$Type)

public "getHand"(): $InteractionHand
public "getItem"(): $ItemStack
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "hand"(): $InteractionHand
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDestroyedKubeEvent$$Type = ($ItemDestroyedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemDestroyedKubeEvent$$Original = $ItemDestroyedKubeEvent;}
declare module "dev.latvian.mods.kubejs.server.BasicCommandKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $BasicCommandKubeEvent implements $KubeEntityEvent$$Interface {
readonly "input": StringJS
readonly "id": StringJS

constructor(source: $CommandSourceStack$$Type, id: StringJS, input: StringJS)

public "respond"(text: $Component$$Type): void
public "respondLazily"(text: $Supplier$$Type<($Component$$Type)>, informAdmins: boolean): void
public "getBlock"(): $LevelBlock
public "getLevel"(): $Level
public "getEntity"(): $Entity
public "getId"(): StringJS
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "block"(): $LevelBlock
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicCommandKubeEvent$$Type = ($BasicCommandKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasicCommandKubeEvent$$Original = $BasicCommandKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.function.RecipeFunctionInstance" {
import {$ResolvedRecipeSchemaFunction, $ResolvedRecipeSchemaFunction$$Type} from "dev.latvian.mods.kubejs.recipe.schema.function.ResolvedRecipeSchemaFunction"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$Record} from "java.lang.Record"

export class $RecipeFunctionInstance extends $Record {
constructor(name: StringJS, arg1: $ResolvedRecipeSchemaFunction$$Type)
constructor(name: StringJS, arg1: $List$$Type<($RecipeComponent$$Type<(never)>)>, arg2: $ResolvedRecipeSchemaFunction$$Type)

public "name"(): StringJS
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "function"(): $ResolvedRecipeSchemaFunction
public "arguments"(): $List<($RecipeComponent<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFunctionInstance$$Type = ({"function"?: $ResolvedRecipeSchemaFunction$$Type, "arguments"?: $List$$Type<($RecipeComponent$$Type<(never)>)>, "name"?: StringJS}) | ([arg?: $ResolvedRecipeSchemaFunction$$Type, arg?: $List$$Type<($RecipeComponent$$Type<(never)>)>, name?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeFunctionInstance$$Original = $RecipeFunctionInstance;}
declare module "dev.latvian.mods.kubejs.recipe.special.KubeJSCraftingRecipe" {
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$IngredientActionHolder} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$List} from "java.util.List"
import {$RecipeType} from "net.minecraft.world.item.crafting.RecipeType"
import {$CraftingBookCategory} from "net.minecraft.world.item.crafting.CraftingBookCategory"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$CraftingRecipe$$Interface} from "net.minecraft.world.item.crafting.CraftingRecipe"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export interface $KubeJSCraftingRecipe$$Interface extends $CraftingRecipe$$Interface {
get "type"(): $RecipeType<(never)>
get "serializer"(): $RecipeSerializer<(never)>
get "ingredients"(): $NonNullList<($Ingredient)>
get "toastSymbol"(): $ItemStack
get "incomplete"(): boolean
get "group"(): StringJS
get "special"(): boolean
}

export class $KubeJSCraftingRecipe implements $KubeJSCraftingRecipe$$Interface {
static readonly "STAGE_KEY": StringJS
static readonly "MIRROR_KEY": StringJS
static readonly "INGREDIENT_ACTIONS_KEY": StringJS
static readonly "MODIFY_RESULT_KEY": StringJS

 "kjs$getRemainingItems"(input: $CraftingInput$$Type): $NonNullList<($ItemStack)>
 "kjs$assemble"(input: $CraftingInput$$Type, registryAccess: $HolderLookup$Provider$$Type): $ItemStack
 "kjs$getIngredientActions"(): $List<($IngredientActionHolder)>
 "kjs$getModifyResult"(): StringJS
 "kjs$getStage"(): StringJS
 "category"(): $CraftingBookCategory
 "getType"(): $RecipeType<(never)>
 "assemble"(arg0: $CraftingInput$$Type, arg1: $HolderLookup$Provider$$Type): $ItemStack
 "getRemainingItems"(arg0: $CraftingInput$$Type): $NonNullList<($ItemStack)>
 "getSerializer"(): $RecipeSerializer<(never)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
 "getResultItem"(arg0: $HolderLookup$Provider$$Type): $ItemStack
 "showNotification"(): boolean
 "getToastSymbol"(): $ItemStack
 "isIncomplete"(): boolean
 "matches"(arg0: $CraftingInput$$Type, arg1: $Level$$Type): boolean
 "getGroup"(): StringJS
 "isSpecial"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSCraftingRecipe$$Type = ($KubeJSCraftingRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSCraftingRecipe$$Original = $KubeJSCraftingRecipe;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Helmet" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorItemBuilder$Helmet extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
static readonly "HELMET_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Helmet$$Type = ($ArmorItemBuilder$Helmet);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Helmet$$Original = $ArmorItemBuilder$Helmet;}
declare module "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessorType" {
import {$RecipePostProcessor} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$RecipeTypeRegistryContext, $RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $RecipePostProcessorType<T extends $RecipePostProcessor> extends $Record {
static readonly "CODEC": $Codec<($RecipePostProcessorType<(never)>)>
static readonly "MAP": $Lazy<($Map<($ResourceLocation), ($RecipePostProcessorType<(never)>)>)>

constructor(id: $ResourceLocation$$Type, mapCodec: $Function$$Type<($RecipeTypeRegistryContext), ($MapCodec$$Type<(T)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "mapCodec"(): $Function<($RecipeTypeRegistryContext), ($MapCodec<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipePostProcessorType$$Type<T> = ({"id"?: $ResourceLocation$$Type, "mapCodec"?: $Function$$Type<($RecipeTypeRegistryContext$$Type), ($MapCodec$$Type<(T)>)>}) | ([id?: $ResourceLocation$$Type, mapCodec?: $Function$$Type<($RecipeTypeRegistryContext$$Type), ($MapCodec$$Type<(T)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipePostProcessorType$$Original<T> = $RecipePostProcessorType<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.match.ItemMatch" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ReplacementMatch, $ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"

export interface $ItemMatch$$Interface extends $ReplacementMatch$$Interface {
}

export class $ItemMatch implements $ItemMatch$$Interface {
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, item: $ItemStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMatch$$Type = ($ItemMatch);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemMatch$$Original = $ItemMatch;}
declare module "dev.latvian.mods.kubejs.client.ClientKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Minecraft} from "net.minecraft.client.Minecraft"

export interface $ClientKubeEvent$$Interface extends $KubeEvent$$Interface {
get "client"(): $Minecraft
}

export class $ClientKubeEvent implements $ClientKubeEvent$$Interface {
 "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientKubeEvent$$Type = ($ClientKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientKubeEvent$$Original = $ClientKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemStackSet" {
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Iterator} from "java.util.Iterator"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Spliterator} from "java.util.Spliterator"
import {$List} from "java.util.List"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Stream} from "java.util.stream.Stream"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ItemStackSet implements $Iterable$$Interface<($ItemStack)> {
constructor(initialSize: integer)
constructor(...items: ($ItemStack$$Type)[])
constructor()

public "addItem"(item: $Item$$Type): void
public "remove"(stack: $ItemStack$$Type): void
public "size"(): integer
public "isEmpty"(): boolean
public "add"(stack: $ItemStack$$Type): void
public "toArray"(): ($ItemStack)[]
public "iterator"(): $Iterator<($ItemStack)>
public "toList"(): $List<($ItemStack)>
public "stream"(): $Stream<($ItemStack)>
public "contains"(stack: $ItemStack$$Type): boolean
public "addAll"(other: $ItemStackSet$$Type): void
public static "merge"(first: $ItemStackSet$$Type, second: $ItemStackSet$$Type): $ItemStackSet
public "forEach"(action: $Consumer$$Type<($ItemStack)>): void
public "getFirst"(): $ItemStack
public "spliterator"(): $Spliterator<($ItemStack)>
[Symbol.iterator](): IterableIterator<$ItemStack>;
get "empty"(): boolean
get "first"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackSet$$Type = ($ItemStackSet);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemStackSet$$Original = $ItemStackSet;}
declare module "dev.latvian.mods.kubejs.util.JsonUtils" {
import {$JsonPrimitive} from "com.google.gson.JsonPrimitive"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$MapLike} from "com.mojang.serialization.MapLike"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$JsonArray} from "com.google.gson.JsonArray"

export interface $JsonUtils$$Interface {
}

export class $JsonUtils implements $JsonUtils$$Interface {
static readonly "MAP_LIKE": $MapLike<($JsonElement)>

static "objectOf"(map: any): $JsonObject
static "primitiveOf"(o: any): $JsonPrimitive
static "toPrettyString"(json: $JsonElement$$Type): StringJS
static "toString"(json: $JsonElement$$Type): StringJS
static "of"(o: any): $JsonElement
static "copy"(element: $JsonElement$$Type): $JsonElement
static "arrayOf"(array: any): $JsonArray
static "fromString"(string: StringJS): $JsonElement
static "toPrimitive"(element: $JsonElement$$Type): any
static "toObject"(json: $JsonElement$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonUtils$$Type = ($JsonUtils);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JsonUtils$$Original = $JsonUtils;}
declare module "dev.latvian.mods.kubejs.misc.MobEffectBuilder" {
import {$MobEffectBuilder$EffectEntityCallback$$Type} from "dev.latvian.mods.kubejs.misc.MobEffectBuilder$EffectEntityCallback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$MobEffectCategory$$Type} from "net.minecraft.world.effect.MobEffectCategory"
import {$MobEffect} from "net.minecraft.world.effect.MobEffect"

export class $MobEffectBuilder extends $BuilderBase<($MobEffect)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "getTranslationKeyGroup"(): StringJS
public "effectTick"(effectTick: $MobEffectBuilder$EffectEntityCallback$$Type): this
public "modifyAttribute"(attribute: $ResourceLocation$$Type, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): this
public "harmful"(): this
public "beneficial"(): this
public "category"(c: $MobEffectCategory$$Type): this
public "instant"(): this
public "instant"(instant: boolean): this
public "color"(col: $KubeColor$$Type): this
get "translationKeyGroup"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectBuilder$$Type = ($MobEffectBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobEffectBuilder$$Original = $MobEffectBuilder;}
declare module "dev.latvian.mods.kubejs.event.EventResult" {
import {$Context} from "dev.latvian.mods.rhino.Context"
import {$ICancellableEvent$$Type} from "net.neoforged.bus.api.ICancellableEvent"
import {$EventResult$Type} from "dev.latvian.mods.kubejs.event.EventResult$Type"
import {$TriState$$Type} from "net.neoforged.neoforge.common.util.TriState"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $EventResult {
static readonly "PASS": $EventResult

public "applyCancel"(event: $ICancellableEvent$$Type): boolean
public "applyTristate"(consumer: $Consumer$$Type<($TriState)>): void
public "interruptFalse"(): boolean
public "interruptTrue"(): boolean
public "interruptDefault"(): boolean
public "pass"(): boolean
public "cx"(): $Context
public "type"(): $EventResult$Type
public "value"(): any
public "override"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventResult$$Type = ($EventResult);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventResult$$Original = $EventResult;}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent" {
import {$ScheduledEvents} from "dev.latvian.mods.kubejs.util.ScheduledEvents"

export class $ScheduledEvents$ScheduledEvent {
 "timer": long
 "repeating": boolean
 "scheduledEvents": $ScheduledEvents
 "id": integer
 "endTime": long
 "ofTicks": boolean

constructor()

public "clear"(): void
public "reschedule"(): $ScheduledEvents$ScheduledEvent
public "reschedule"(timer: long): $ScheduledEvents$ScheduledEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$ScheduledEvent$$Type = ($ScheduledEvents$ScheduledEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduledEvents$ScheduledEvent$$Original = $ScheduledEvents$ScheduledEvent;}
declare module "dev.latvian.mods.kubejs.event.EventExit" {
import {$Exception} from "java.lang.Exception"
import {$EventResult, $EventResult$$Type} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventExit extends $Exception {
readonly "result": $EventResult

constructor(result: $EventResult$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventExit$$Type = ($EventExit);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventExit$$Original = $EventExit;}
declare module "dev.latvian.mods.kubejs.generator.KubeAssetGenerator" {
import {$ParticleGenerator$$Type} from "dev.latvian.mods.kubejs.client.ParticleGenerator"
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$SoundsGenerator$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator"
import {$Map$$Type} from "java.util.Map"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$VariantBlockStateGenerator$$Type} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ModelGenerator$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MultipartBlockStateGenerator$$Type} from "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$LoadedTexture, $LoadedTexture$$Type} from "dev.latvian.mods.kubejs.client.LoadedTexture"

export interface $KubeAssetGenerator$$Interface extends $KubeResourceGenerator$$Interface {
get "registries"(): $RegistryAccessContainer
}

export class $KubeAssetGenerator implements $KubeAssetGenerator$$Interface {
static readonly "HANDHELD_ITEM_MODEL": $ResourceLocation
static readonly "CUBE_BLOCK_MODEL": $ResourceLocation
static readonly "CUBE_ALL_BLOCK_MODEL": $ResourceLocation
static readonly "GENERATED_ITEM_MODEL": $ResourceLocation

 "sounds"(namespace: StringJS, consumer: $Consumer$$Type<($SoundsGenerator)>): void
 "blockModel"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($ModelGenerator)>): void
 "itemModel"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($ModelGenerator)>): void
 "texture"(target: $ResourceLocation$$Type, texture: $LoadedTexture$$Type): void
 "mask"(target: $ResourceLocation$$Type, mask: $ResourceLocation$$Type, input: $ResourceLocation$$Type): boolean
 "particle"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($ParticleGenerator)>): void
 "blockState"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($VariantBlockStateGenerator)>): void
 "loadTexture"(id: $ResourceLocation$$Type): $LoadedTexture
 "multipartState"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($MultipartBlockStateGenerator)>): void
 "defaultItemModel"(id: $ResourceLocation$$Type): void
 "defaultHandheldItemModel"(id: $ResourceLocation$$Type): void
 "stencil"(target: $ResourceLocation$$Type, stencil: $ResourceLocation$$Type, colors: $Map$$Type<($KubeColor$$Type), ($KubeColor$$Type)>): void
 "flush"(): void
 "add"(data: $GeneratedData$$Type): void
 "text"(id: $ResourceLocation$$Type, content: StringJS): void
 "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
 "getRegistries"(): $RegistryAccessContainer
 "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeAssetGenerator$$Type = ($KubeAssetGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeAssetGenerator$$Original = $KubeAssetGenerator;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.StringUtilsWrapper" {
import {$Pattern} from "java.util.regex.Pattern"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function$$Type} from "java.util.function.Function"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Set} from "java.util.Set"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $StringUtilsWrapper$$Interface {
}

export class $StringUtilsWrapper implements $StringUtilsWrapper$$Interface {
static readonly "ALWAYS_LOWER_CASE": $Set<(StringJS)>
static readonly "SNAKE_CASE_SPLIT": $Pattern
static readonly "EMPTY_STRING_ARRAY": (StringJS)[]

static "stripEventName"(s: StringJS): StringJS
/**
 * Returns the provided snake_case_string in camelCase
 */
static "snakeCaseToCamelCase"(string: StringJS): StringJS
/**
 * Returns the provided snake_case_string in Title Case
 */
static "snakeCaseToTitleCase"(string: StringJS): StringJS
static "stripIdForEvent"(id: $ResourceLocation$$Type): StringJS
static "getUniqueId"<T>(input: T, toJson: $Function$$Type<(T), ($JsonElement$$Type)>): StringJS
static "getUniqueId"(json: $JsonElement$$Type): StringJS
/**
 * Tries to parse the first parameter as an integer, and returns that. The second parameter is returned if parsing fails
 */
static "parseInt"(object: any, def: integer): integer
/**
 * Capitalises the first letter of the string. If ignoreSpecial is true, it will also capitalise articles and prepositions
 */
static "toTitleCase"(s: StringJS, ignoreSpecial: boolean): StringJS
/**
 * Capitalises the first letter of the string unless it is "a", "an", "the", "of", "on", "in", "and", "or", "but" or "for"
 */
static "toTitleCase"(s: StringJS): StringJS
/**
 * Tries to parse the first parameter as a double and returns that. The second parameter is returned if parsing fails
 */
static "parseDouble"(object: any, def: double): double
static "parseLong"(object: any, def: long): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringUtilsWrapper$$Type = ($StringUtilsWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StringUtilsWrapper$$Original = $StringUtilsWrapper;}
declare module "dev.latvian.mods.kubejs.util.FluidAmounts" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $FluidAmounts$$Interface {
}

export class $FluidAmounts implements $FluidAmounts$$Interface {
static readonly "B": long
static readonly "METAL_BLOCK": long
static readonly "MB": long
static readonly "BOTTLE": long
static readonly "BUCKET": long
static readonly "MILLIBUCKET": long
static readonly "INGOT": long
static readonly "NUGGET": long

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidAmounts$$Type = ($FluidAmounts);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidAmounts$$Original = $FluidAmounts;}
declare module "dev.latvian.mods.kubejs.web.KJSHTTPRequest" {
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Runnable$$Type} from "java.lang.Runnable"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$DataComponentPatch} from "net.minecraft.core.component.DataComponentPatch"
import {$HTTPResponse, $HTTPResponse$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPResponse"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$BlockableEventLoop, $BlockableEventLoop$$Type} from "net.minecraft.util.thread.BlockableEventLoop"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Throwable$$Type} from "java.lang.Throwable"
import {$HTTPRequest} from "dev.latvian.apps.tinyserver.http.HTTPRequest"
import {$HTTPPayload$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPPayload"

export class $KJSHTTPRequest extends $HTTPRequest {
readonly "eventLoop": $BlockableEventLoop<(never)>

constructor(eventLoop: $BlockableEventLoop$$Type<(never)>)

public "supplyInMainThread"<T>(task: $Supplier$$Type<(T)>): T
public "runInMainThread"(task: $Runnable$$Type): void
public "handleResponse"(payload: $HTTPPayload$$Type, response: $HTTPResponse$$Type, error: $Throwable$$Type): $HTTPResponse
public "id"(ns: StringJS, path: StringJS): $ResourceLocation
public "id"(): $ResourceLocation
public "components"(ops: $DynamicOps$$Type<($Tag$$Type)>): $DataComponentPatch
public "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KJSHTTPRequest$$Type = ($KJSHTTPRequest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KJSHTTPRequest$$Original = $KJSHTTPRequest;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.UUIDWrapper" {
import {$StringBuilder$$Type} from "java.lang.StringBuilder"
import {$UUID, $UUID$$Type} from "java.util.UUID"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $UUIDWrapper$$Interface {
}

export class $UUIDWrapper implements $UUIDWrapper$$Interface {
static "toString"(id: $UUID$$Type): StringJS
static "digits"(sb: $StringBuilder$$Type, val: long, digits: integer): void
static "fromString"(o: any): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UUIDWrapper$$Type = ($UUIDWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UUIDWrapper$$Original = $UUIDWrapper;}
declare module "dev.latvian.mods.kubejs.registry.RegistryKubeEvent" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$KubeStartupEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$List} from "java.util.List"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CustomBuilderObject} from "dev.latvian.mods.kubejs.registry.CustomBuilderObject"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$AdditionalObjectRegistry$$Interface} from "dev.latvian.mods.kubejs.registry.AdditionalObjectRegistry"

export class $RegistryKubeEvent<T> implements $KubeStartupEvent$$Interface, $AdditionalObjectRegistry$$Interface {
readonly "created": $List<($BuilderBase<(T)>)>

constructor(registryKey: $ResourceKey$$Type<($Registry<(T)>)>)

public "createCustom"(id: $ResourceLocation$$Type, object: () => T): $CustomBuilderObject
public "add"<R>(registry: $ResourceKey$$Type<($Registry<(R)>)>, builder: $BuilderBase$$Type<(R)>): void
public "create"(id: $ResourceLocation$$Type): $BuilderBase<(T)>
public "create"(id: $ResourceLocation$$Type, type: $ResourceLocation$$Type): $BuilderBase<(T)>
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryKubeEvent$$Type<T> = ($RegistryKubeEvent<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryKubeEvent$$Original<T> = $RegistryKubeEvent<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.schema.UnknownKubeRecipe" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$KubeRecipe} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$KubeRecipeFactory} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

export class $UnknownKubeRecipe extends $KubeRecipe {
 "newRecipe": boolean
static readonly "RECIPE_FACTORY": $KubeRecipeFactory
 "type": $RecipeTypeFunction
 "sourceLine": $SourceLine
 "originalJson": $JsonObject
 "removed": boolean
 "creationError": boolean
static readonly "TYPE_INFO": $TypeInfo
 "json": $JsonObject
static readonly "CHANGED_MARKER": StringJS
 "changed": boolean

constructor()

public "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "deserialize"(merge: boolean): void
public "serialize"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnknownKubeRecipe$$Type = ($UnknownKubeRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UnknownKubeRecipe$$Original = $UnknownKubeRecipe;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentCodecFactory" {
import {$RecipeTypeRegistryContext, $RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$RecipeComponentType, $RecipeComponentType$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export interface $RecipeComponentCodecFactory$$Interface<CT extends $RecipeComponent<(object)>> {

(type: $RecipeComponentType<(never)>, ctx: $RecipeTypeRegistryContext): $MapCodec$$Type<(CT)>
}

export class $RecipeComponentCodecFactory<CT extends $RecipeComponent<(object)>> implements $RecipeComponentCodecFactory$$Interface {
 "create"(type: $RecipeComponentType$$Type<(never)>, ctx: $RecipeTypeRegistryContext$$Type): $MapCodec<(CT)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentCodecFactory$$Type<CT> = ((type: $RecipeComponentType<(never)>, ctx: $RecipeTypeRegistryContext) => $MapCodec$$Type<(CT)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentCodecFactory$$Original<CT> = $RecipeComponentCodecFactory<(CT)>;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.GroupEntriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $GroupEntriesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(filter: F, groupId: $ResourceLocation, description: $Component): void
}

export class $GroupEntriesKubeEvent<E, F> implements $GroupEntriesKubeEvent$$Interface {
 "group"(filter: F, groupId: $ResourceLocation$$Type, description: $Component$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GroupEntriesKubeEvent$$Type<E, F> = ((filter: any, groupId: $ResourceLocation, description: $Component) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GroupEntriesKubeEvent$$Original<E, F> = $GroupEntriesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.EntitySelectorWrapper" {
import {$EntitySelector, $EntitySelector$$Type} from "net.minecraft.commands.arguments.selector.EntitySelector"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $EntitySelectorWrapper {
constructor()

public static "of"(selector: $EntitySelector$$Type): $EntitySelector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySelectorWrapper$$Type = ($EntitySelectorWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySelectorWrapper$$Original = $EntitySelectorWrapper;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabCallback" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$CreativeModeTab$TabVisibility$$Type} from "net.minecraft.world.item.CreativeModeTab$TabVisibility"

export interface $CreativeTabCallback$$Interface {
}

export class $CreativeTabCallback implements $CreativeTabCallback$$Interface {
 "addAfter"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
 "addBefore"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
 "remove"(filter: $ItemPredicate$$Type, removeParent: boolean, removeSearch: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabCallback$$Type = ($CreativeTabCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabCallback$$Original = $CreativeTabCallback;}
declare module "dev.latvian.mods.kubejs.core.WithAttachedData" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WithAttachedData$$Interface<T> extends $MessageSenderKJS$$Interface {

(): $AttachedData$$Type<(T)>
get "data"(): $AttachedData<(T)>
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export class $WithAttachedData<T> implements $WithAttachedData$$Interface {
 "getData"(): $AttachedData<(T)>
 "tell"(message: $Component$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommand"(command: StringJS): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithAttachedData$$Type<T> = (() => $AttachedData$$Type<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithAttachedData$$Original<T> = $WithAttachedData<(T)>;}
declare module "dev.latvian.mods.kubejs.script.ScriptsLoadedEvent" {
import {$Event} from "net.neoforged.bus.api.Event"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptsLoadedEvent extends $Event {
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptsLoadedEvent$$Type = ($ScriptsLoadedEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptsLoadedEvent$$Original = $ScriptsLoadedEvent;}
declare module "dev.latvian.mods.kubejs.recipe.special.SpecialRecipeSerializerManager$AfterPost" {
import {$Event} from "net.neoforged.bus.api.Event"

export class $SpecialRecipeSerializerManager$AfterPost extends $Event {
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialRecipeSerializerManager$AfterPost$$Type = ($SpecialRecipeSerializerManager$AfterPost);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpecialRecipeSerializerManager$AfterPost$$Original = $SpecialRecipeSerializerManager$AfterPost;}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen" {
import {$SoundsGenerator$SoundInstance$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundInstance"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $SoundsGenerator$SoundGen {
constructor()

public "sounds"(...sounds: (StringJS)[]): $SoundsGenerator$SoundGen
public "subtitle"(subtitle: StringJS): $SoundsGenerator$SoundGen
public "replace"(): $SoundsGenerator$SoundGen
public "replace"(b: boolean): $SoundsGenerator$SoundGen
public "toJson"(): $JsonObject
public "sound"(file: StringJS): $SoundsGenerator$SoundGen
public "sound"(file: StringJS, consumer: $Consumer$$Type<($SoundsGenerator$SoundInstance)>): $SoundsGenerator$SoundGen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$SoundGen$$Type = ($SoundsGenerator$SoundGen);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundsGenerator$SoundGen$$Original = $SoundsGenerator$SoundGen;}
declare module "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent" {
import {$EventExceptionHandler} from "dev.latvian.mods.kubejs.event.EventExceptionHandler"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$PreTagWrapper} from "dev.latvian.mods.kubejs.server.tag.PreTagWrapper"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$Set} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$TagKubeEvent} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"
import {$Consumer} from "java.util.function.Consumer"

export class $PreTagKubeEvent extends $TagKubeEvent {
readonly "registryKey": $ResourceKey<(never)>
 "totalRemoved": integer
 "invalid": boolean
static readonly "SOURCE": StringJS
readonly "vanillaRegistry": $Registry<(never)>
 "totalAdded": integer
static readonly "TAG_EVENT_HANDLER": $EventExceptionHandler
readonly "actions": $List<($Consumer<($TagKubeEvent)>)>
readonly "tags": $Map<($ResourceLocation), ($PreTagWrapper)>

constructor(registryKey: $ResourceKey$$Type<(never)>)

public "getElementIds"(): $Set<($ResourceLocation)>
public "removeAllTagsFrom"(...ignored: (any)[]): void
public static "handle"(tagEventHolders: $Map$$Type<($ResourceKey$$Type<(never)>), ($PreTagKubeEvent$$Type)>): void
get "elementIds"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreTagKubeEvent$$Type = ($PreTagKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PreTagKubeEvent$$Original = $PreTagKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.match.Replaceable" {
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"

export interface $Replaceable$$Interface {
}

export class $Replaceable implements $Replaceable$$Interface {
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Replaceable$$Type = ($Replaceable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Replaceable$$Original = $Replaceable;}
declare module "dev.latvian.mods.kubejs.recipe.CachedTagLookup$Entry" {
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$CachedTagLookup, $CachedTagLookup$$Type} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"
import {$Record} from "java.lang.Record"

export class $CachedTagLookup$Entry<T> extends $Record {
constructor(key: $ResourceKey$$Type<(T)>, registry: $Registry$$Type<(T)>, lookup: $CachedTagLookup$$Type<(T)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "lookup"(): $CachedTagLookup<(T)>
public "key"(): $ResourceKey<(T)>
public "registry"(): $Registry<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedTagLookup$Entry$$Type<T> = ({"registry"?: $Registry$$Type<(T)>, "key"?: $ResourceKey$$Type<(T)>, "lookup"?: $CachedTagLookup$$Type<(T)>}) | ([registry?: $Registry$$Type<(T)>, key?: $ResourceKey$$Type<(T)>, lookup?: $CachedTagLookup$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CachedTagLookup$Entry$$Original<T> = $CachedTagLookup$Entry<(T)>;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate$PropertyObject" {
import {$Record} from "java.lang.Record"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockIDPredicate$PropertyObject extends $Record {
constructor(property: $Property$$Type<(never)>, value: any)

public "value"(): any
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "property"(): $Property<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIDPredicate$PropertyObject$$Type = ({"property"?: $Property$$Type<(never)>, "value"?: any}) | ([property?: $Property$$Type<(never)>, value?: any]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockIDPredicate$PropertyObject$$Original = $BlockIDPredicate$PropertyObject;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map$$Type} from "java.util.Map"
import {$ModelGenerator$Override$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Override"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$ModelGenerator$Element$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Element"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ModelGenerator {
constructor()

public "textures"(map: $Map$$Type<(StringJS), (StringJS)>): void
public "texture"(name: (StringJS)[], texture: StringJS): void
public "parent"(s: $ResourceLocation$$Type): void
public "override"(model: $ResourceLocation$$Type, override: $Consumer$$Type<($ModelGenerator$Override)>): void
public "element"(consumer: $Consumer$$Type<($ModelGenerator$Element)>): void
public "toJson"(): $JsonObject
public "custom"(json: $Consumer$$Type<($JsonObject)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$$Type = ($ModelGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$$Original = $ModelGenerator;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot" {
import {$ChestMenuData, $ChestMenuData$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuData"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ChestMenuClickHandler} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickHandler"
import {$Map} from "java.util.Map"
import {$List} from "java.util.List"
import {$ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuSlot {
 "data": $Map<(StringJS), (any)>
readonly "clickHandlers": $List<($ChestMenuClickHandler)>
readonly "x": integer
readonly "index": integer
readonly "y": integer
 "inventorySlot": integer
readonly "gui": $ChestMenuData
 "inventory": $InventoryKJS

constructor(gui: $ChestMenuData$$Type, index: integer)

public "setItem"(stack: $ItemStack$$Type): void
public "clicked"(type: $ClickType$$Type, button: integer, callback: $ChestMenuClickEvent$Callback$$Type, autoHandle: boolean): void
public "resetClickHandlers"(): void
public "setLeftClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setRightClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setSwapped"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setMiddleClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setShiftLeftClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setShiftRightClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setDoubleClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "getItem"(): $ItemStack
public "setThrown"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "toString"(): StringJS
set "item"(value: $ItemStack$$Type)
set "leftClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "rightClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "swapped"(value: $ChestMenuClickEvent$Callback$$Type)
set "middleClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "shiftLeftClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "shiftRightClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "doubleClicked"(value: $ChestMenuClickEvent$Callback$$Type)
get "item"(): $ItemStack
set "thrown"(value: $ChestMenuClickEvent$Callback$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuSlot$$Type = ($ChestMenuSlot);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuSlot$$Original = $ChestMenuSlot;}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$ShapeBuilder" {
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$List} from "java.util.List"

export class $CropBlockBuilder$ShapeBuilder {
constructor(age: integer)

public "getShapes"(): $List<($VoxelShape)>
/**
 * Makes the block to have a box like beetroot for each stage.
 */
public "beetroot"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like carrot for each stage.
 */
public "carrot"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like potato for each stage.
 */
public "potato"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like wheat for each stage.
 */
public "wheat"(): $CropBlockBuilder$ShapeBuilder
/**
 * Describe the shape of the crop at a specific age.
 * min/max coordinates are double values between 0 and 16.
 */
public "shape"(age: integer, minX: double, minY: double, minZ: double, maxX: double, maxY: double, maxZ: double): $CropBlockBuilder$ShapeBuilder
get "shapes"(): $List<($VoxelShape)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$ShapeBuilder$$Type = ($CropBlockBuilder$ShapeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CropBlockBuilder$ShapeBuilder$$Original = $CropBlockBuilder$ShapeBuilder;}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $ExplosionKubeEvent implements $KubeLevelEvent$$Interface {
constructor(level: $Level$$Type, explosion: $Explosion$$Type)

public "getExploder"(): $LivingEntity
public "getPosition"(): $Vec3
public "getBlock"(): $LevelBlock
public "getLevel"(): $Level
public "getY"(): double
public "getX"(): double
public "getZ"(): double
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
get "exploder"(): $LivingEntity
get "position"(): $Vec3
get "block"(): $LevelBlock
get "level"(): $Level
get "y"(): double
get "x"(): double
get "z"(): double
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$$Type = ($ExplosionKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionKubeEvent$$Original = $ExplosionKubeEvent;}
