declare module "net.minecraft.world.level.levelgen.RandomState" {
import {$NoiseGeneratorSettings$$Type} from "net.minecraft.world.level.levelgen.NoiseGeneratorSettings"
import {$Climate$Sampler} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$HolderGetter$Provider$$Type} from "net.minecraft.core.HolderGetter$Provider"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$NormalNoise} from "net.minecraft.world.level.levelgen.synth.NormalNoise"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PositionalRandomFactory} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"
import {$SurfaceSystem} from "net.minecraft.world.level.levelgen.SurfaceSystem"
import {$NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"
import {$NoiseRouter} from "net.minecraft.world.level.levelgen.NoiseRouter"
import {$HolderGetter$$Type} from "net.minecraft.core.HolderGetter"

export class $RandomState {
public "sampler"(): $Climate$Sampler
public "surfaceSystem"(): $SurfaceSystem
public "router"(): $NoiseRouter
public "getOrCreateNoise"(arg0: $ResourceKey$$Type<($NormalNoise$NoiseParameters)>): $NormalNoise
public "getOrCreateRandomFactory"(arg0: $ResourceLocation$$Type): $PositionalRandomFactory
public "aquiferRandom"(): $PositionalRandomFactory
public "oreRandom"(): $PositionalRandomFactory
public static "create"(arg0: $NoiseGeneratorSettings$$Type, arg1: $HolderGetter$$Type<($NormalNoise$NoiseParameters$$Type)>, arg2: long): $RandomState
public static "create"(arg0: $HolderGetter$Provider$$Type, arg1: $ResourceKey$$Type<($NoiseGeneratorSettings)>, arg2: long): $RandomState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomState$$Type = ($RandomState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomState$$Original = $RandomState;}
declare module "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder" {
import {$AnyOfCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.AnyOfCondition$Builder"
import {$AllOfCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.AllOfCondition$Builder"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export interface $LootItemCondition$Builder$$Interface {

(): $LootItemCondition$$Type
}

export class $LootItemCondition$Builder implements $LootItemCondition$Builder$$Interface {
 "invert"(): $LootItemCondition$Builder
 "or"(arg0: $LootItemCondition$Builder$$Type): $AnyOfCondition$Builder
 "and"(arg0: $LootItemCondition$Builder$$Type): $AllOfCondition$Builder
 "build"(): $LootItemCondition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemCondition$Builder$$Type = (() => $LootItemCondition$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemCondition$Builder$$Original = $LootItemCondition$Builder;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$Marker$Type" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $DensityFunctions$Marker$Type extends $Enum<($DensityFunctions$Marker$Type)> implements $StringRepresentable$$Interface {
static readonly "CacheAllInCell": $DensityFunctions$Marker$Type
static readonly "CacheOnce": $DensityFunctions$Marker$Type
static readonly "FlatCache": $DensityFunctions$Marker$Type
static readonly "Interpolated": $DensityFunctions$Marker$Type
static readonly "Cache2D": $DensityFunctions$Marker$Type

public static "values"(): ($DensityFunctions$Marker$Type)[]
public static "valueOf"(arg0: StringJS): $DensityFunctions$Marker$Type
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$Marker$Type$$Type = (("interpolated") | ("flat_cache") | ("cache_2d") | ("cache_once") | ("cache_all_in_cell"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$Marker$Type$$Original = $DensityFunctions$Marker$Type;}
declare module "net.minecraft.world.level.dimension.end.EndDragonFight" {
import {$EndDragonFight$Data, $EndDragonFight$Data$$Type} from "net.minecraft.world.level.dimension.end.EndDragonFight$Data"
import {$DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$UUID} from "java.util.UUID"
import {$EndCrystal$$Type} from "net.minecraft.world.entity.boss.enderdragon.EndCrystal"
import {$EnderDragon$$Type} from "net.minecraft.world.entity.boss.enderdragon.EnderDragon"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"

export class $EndDragonFight {
static readonly "TIME_BETWEEN_PLAYER_SCANS": integer
static readonly "ARENA_TICKET_LEVEL": integer
static readonly "DRAGON_SPAWN_Y": integer

constructor(arg0: $ServerLevel$$Type, arg1: long, arg2: $EndDragonFight$Data$$Type, arg3: $BlockPos$$Type)
constructor(arg0: $ServerLevel$$Type, arg1: long, arg2: $EndDragonFight$Data$$Type)

public "saveData"(): $EndDragonFight$Data
public "tryRespawn"(): void
public "onCrystalDestroyed"(arg0: $EndCrystal$$Type, arg1: $DamageSource$$Type): void
public "getDragonUUID"(): $UUID
public "updateDragon"(arg0: $EnderDragon$$Type): void
public "setDragonKilled"(arg0: $EnderDragon$$Type): void
public "hasPreviouslyKilledDragon"(): boolean
public "getCrystalsAlive"(): integer
public "tick"(): void
public "addPlayer"(arg0: $ServerPlayer$$Type): void
public "removePlayer"(arg0: $ServerPlayer$$Type): void
public "resetSpikeCrystals"(): void
/**
 * 
 * @deprecated
 */
public "skipArenaLoadedCheck"(): void
/**
 * 
 * @deprecated
 */
public "removeAllGateways"(): void
get "dragonUUID"(): $UUID
set "dragonKilled"(value: $EnderDragon$$Type)
get "crystalsAlive"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndDragonFight$$Type = ($EndDragonFight);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndDragonFight$$Original = $EndDragonFight;}
declare module "net.minecraft.world.level.block.DropperBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$DispenserBlock} from "net.minecraft.world.level.block.DispenserBlock"
import {$Map} from "java.util.Map"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DropperBlock extends $DispenserBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DropperBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "DISPENSER_REGISTRY": $Map<($Item), ($DispenseItemBehavior)>
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "TRIGGERED": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($DropperBlock)>
public static "getDispenserRegistry"(): $Map<($Item), ($DispenseItemBehavior)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static get "dispenserRegistry"(): $Map<($Item), ($DispenseItemBehavior)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropperBlock$$Type = ($DropperBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DropperBlock$$Original = $DropperBlock;}
declare module "net.minecraft.world.level.levelgen.placement.PlacementModifierType" {
import {$CountOnEveryLayerPlacement} from "net.minecraft.world.level.levelgen.placement.CountOnEveryLayerPlacement"
import {$RarityFilter} from "net.minecraft.world.level.levelgen.placement.RarityFilter"
import {$BlockPredicateFilter} from "net.minecraft.world.level.levelgen.placement.BlockPredicateFilter"
import {$InSquarePlacement} from "net.minecraft.world.level.levelgen.placement.InSquarePlacement"
import {$HeightRangePlacement} from "net.minecraft.world.level.levelgen.placement.HeightRangePlacement"
import {$CountPlacement} from "net.minecraft.world.level.levelgen.placement.CountPlacement"
import {$NoiseBasedCountPlacement} from "net.minecraft.world.level.levelgen.placement.NoiseBasedCountPlacement"
import {$NoiseThresholdCountPlacement} from "net.minecraft.world.level.levelgen.placement.NoiseThresholdCountPlacement"
import {$SurfaceWaterDepthFilter} from "net.minecraft.world.level.levelgen.placement.SurfaceWaterDepthFilter"
import {$RandomOffsetPlacement} from "net.minecraft.world.level.levelgen.placement.RandomOffsetPlacement"
import {$HeightmapPlacement} from "net.minecraft.world.level.levelgen.placement.HeightmapPlacement"
import {$BiomeFilter} from "net.minecraft.world.level.levelgen.placement.BiomeFilter"
import {$FixedPlacement} from "net.minecraft.world.level.levelgen.placement.FixedPlacement"
import {$CarvingMaskPlacement} from "net.minecraft.world.level.levelgen.placement.CarvingMaskPlacement"
import {$EnvironmentScanPlacement} from "net.minecraft.world.level.levelgen.placement.EnvironmentScanPlacement"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$SurfaceRelativeThresholdFilter} from "net.minecraft.world.level.levelgen.placement.SurfaceRelativeThresholdFilter"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export interface $PlacementModifierType$$Interface<P extends $PlacementModifier> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenPlacementModifierType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenPlacementModifierTypeTag
}

export class $PlacementModifierType<P extends $PlacementModifier> implements $PlacementModifierType$$Interface {
static readonly "ENVIRONMENT_SCAN": $PlacementModifierType<($EnvironmentScanPlacement)>
static readonly "HEIGHT_RANGE": $PlacementModifierType<($HeightRangePlacement)>
static readonly "CARVING_MASK_PLACEMENT": $PlacementModifierType<($CarvingMaskPlacement)>
static readonly "RARITY_FILTER": $PlacementModifierType<($RarityFilter)>
static readonly "FIXED_PLACEMENT": $PlacementModifierType<($FixedPlacement)>
static readonly "SURFACE_RELATIVE_THRESHOLD_FILTER": $PlacementModifierType<($SurfaceRelativeThresholdFilter)>
static readonly "NOISE_THRESHOLD_COUNT": $PlacementModifierType<($NoiseThresholdCountPlacement)>
static readonly "BIOME_FILTER": $PlacementModifierType<($BiomeFilter)>
static readonly "HEIGHTMAP": $PlacementModifierType<($HeightmapPlacement)>
static readonly "BLOCK_PREDICATE_FILTER": $PlacementModifierType<($BlockPredicateFilter)>
static readonly "NOISE_BASED_COUNT": $PlacementModifierType<($NoiseBasedCountPlacement)>
static readonly "SURFACE_WATER_DEPTH_FILTER": $PlacementModifierType<($SurfaceWaterDepthFilter)>
static readonly "COUNT_ON_EVERY_LAYER": $PlacementModifierType<($CountOnEveryLayerPlacement)>
static readonly "IN_SQUARE": $PlacementModifierType<($InSquarePlacement)>
static readonly "RANDOM_OFFSET": $PlacementModifierType<($RandomOffsetPlacement)>
static readonly "COUNT": $PlacementModifierType<($CountPlacement)>

 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacementModifierType$$Type<P> = (Special.WorldgenPlacementModifierType) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacementModifierType$$Original<P> = $PlacementModifierType<(P)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $RootSystemConfiguration implements $FeatureConfiguration$$Interface {
readonly "hangingRootsVerticalSpan": integer
static readonly "CODEC": $Codec<($RootSystemConfiguration)>
readonly "allowedVerticalWaterForTree": integer
readonly "hangingRootPlacementAttempts": integer
readonly "rootReplaceable": $TagKey<($Block)>
readonly "rootStateProvider": $BlockStateProvider
readonly "requiredVerticalSpaceForTree": integer
readonly "rootPlacementAttempts": integer
readonly "allowedTreePosition": $BlockPredicate
readonly "hangingRootRadius": integer
readonly "hangingRootStateProvider": $BlockStateProvider
readonly "rootRadius": integer
readonly "rootColumnMaxHeight": integer
readonly "treeFeature": $Holder<($PlacedFeature)>

constructor(arg0: $Holder$$Type<($PlacedFeature)>, arg1: integer, arg2: integer, arg3: $TagKey$$Type<($Block)>, arg4: $BlockStateProvider$$Type, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: $BlockStateProvider$$Type, arg10: integer, arg11: integer, arg12: $BlockPredicate$$Type)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RootSystemConfiguration$$Type = ($RootSystemConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RootSystemConfiguration$$Original = $RootSystemConfiguration;}
declare module "net.minecraft.world.level.block.entity.JigsawBlockEntity$JointType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Component} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $JigsawBlockEntity$JointType extends $Enum<($JigsawBlockEntity$JointType)> implements $StringRepresentable$$Interface {
static readonly "ROLLABLE": $JigsawBlockEntity$JointType
static readonly "ALIGNED": $JigsawBlockEntity$JointType

public "getTranslatedName"(): $Component
public static "values"(): ($JigsawBlockEntity$JointType)[]
public static "valueOf"(arg0: StringJS): $JigsawBlockEntity$JointType
public static "byName"(arg0: StringJS): $Optional<($JigsawBlockEntity$JointType)>
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "translatedName"(): $Component
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JigsawBlockEntity$JointType$$Type = (("rollable") | ("aligned"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JigsawBlockEntity$JointType$$Original = $JigsawBlockEntity$JointType;}
declare module "net.minecraft.world.level.block.entity.LecternBlockEntity" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LecternBlockEntity extends $BlockEntity implements $Clearable$$Interface, $MenuProvider$$Interface {
static readonly "NUM_SLOTS": integer
static readonly "DATA_PAGE": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
static readonly "SLOT_BOOK": integer
static readonly "NUM_DATA": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getUpdatePacket"(): $Packet
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "clearContent"(): void
public "setBook"(arg0: $ItemStack$$Type, arg1: $Player$$Type): void
public "setBook"(arg0: $ItemStack$$Type): void
public "getBook"(): $ItemStack
public "getRedstoneSignal"(): integer
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "hasBook"(): boolean
public "modifyReturnValue$cjd000$camerapture$hasBook"(original: boolean): boolean
public "handler$cjd000$camerapture$createMenu"(i: integer, playerInventory: $Inventory$$Type, playerEntity: $Player$$Type, cir: $CallbackInfoReturnable$$Type): void
public "getDisplayName"(): $Component
public "setChanged"(): void
public "onlyOpCanSetNbt"(): boolean
public "getPage"(): integer
public static "tryClear"(arg0: any): void
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
get "updatePacket"(): $Packet
set "book"(value: $ItemStack$$Type)
get "book"(): $ItemStack
get "redstoneSignal"(): integer
get "displayName"(): $Component
get "changed"(): void
get "page"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LecternBlockEntity$$Type = ($LecternBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LecternBlockEntity$$Original = $LecternBlockEntity;}
declare module "net.minecraft.world.level.block.entity.BeehiveBlockEntity" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BeehiveBlockEntity$BeeReleaseStatus$$Type} from "net.minecraft.world.level.block.entity.BeehiveBlockEntity$BeeReleaseStatus"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BeehiveBlockEntity$Occupant$$Type} from "net.minecraft.world.level.block.entity.BeehiveBlockEntity$Occupant"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BeehiveBlockEntity extends $BlockEntity {
static readonly "MIN_OCCUPATION_TICKS_NECTARLESS": integer
static readonly "MAX_OCCUPANTS": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BeehiveBlockEntity$$Type): void
public "emptyAllLivingFromHive"(arg0: $Player$$Type, arg1: $BlockState$$Type, arg2: $BeehiveBlockEntity$BeeReleaseStatus$$Type): void
public "getOccupantCount"(): integer
public "isFireNearby"(): boolean
public "isSedated"(): boolean
public static "getHoneyLevel"(arg0: $BlockState$$Type): integer
public "addOccupant"(arg0: $Entity$$Type): void
public "storeBee"(arg0: $BeehiveBlockEntity$Occupant$$Type): void
public "isFull"(): boolean
public "isEmpty"(): boolean
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "setChanged"(): void
get "occupantCount"(): integer
get "fireNearby"(): boolean
get "sedated"(): boolean
get "full"(): boolean
get "empty"(): boolean
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeehiveBlockEntity$$Type = ($BeehiveBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeehiveBlockEntity$$Original = $BeehiveBlockEntity;}
declare module "net.minecraft.world.level.levelgen.NoiseRouter" {
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"

export class $NoiseRouter extends $Record {
static readonly "CODEC": $Codec<($NoiseRouter)>

constructor(arg0: $DensityFunction$$Type, arg1: $DensityFunction$$Type, arg2: $DensityFunction$$Type, arg3: $DensityFunction$$Type, arg4: $DensityFunction$$Type, arg5: $DensityFunction$$Type, arg6: $DensityFunction$$Type, arg7: $DensityFunction$$Type, arg8: $DensityFunction$$Type, arg9: $DensityFunction$$Type, arg10: $DensityFunction$$Type, arg11: $DensityFunction$$Type, arg12: $DensityFunction$$Type, arg13: $DensityFunction$$Type, arg14: $DensityFunction$$Type)

public "temperature"(): $DensityFunction
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $NoiseRouter
public "erosion"(): $DensityFunction
public "ridges"(): $DensityFunction
public "vegetation"(): $DensityFunction
public "continents"(): $DensityFunction
public "initialDensityWithoutJaggedness"(): $DensityFunction
public "finalDensity"(): $DensityFunction
public "barrierNoise"(): $DensityFunction
public "fluidLevelFloodednessNoise"(): $DensityFunction
public "fluidLevelSpreadNoise"(): $DensityFunction
public "lavaNoise"(): $DensityFunction
public "veinToggle"(): $DensityFunction
public "veinRidged"(): $DensityFunction
public "veinGap"(): $DensityFunction
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "depth"(): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseRouter$$Type = ({"vegetation"?: $DensityFunction$$Type, "depth"?: $DensityFunction$$Type, "ridges"?: $DensityFunction$$Type, "erosion"?: $DensityFunction$$Type, "fluidLevelSpreadNoise"?: $DensityFunction$$Type, "fluidLevelFloodednessNoise"?: $DensityFunction$$Type, "lavaNoise"?: $DensityFunction$$Type, "veinToggle"?: $DensityFunction$$Type, "initialDensityWithoutJaggedness"?: $DensityFunction$$Type, "continents"?: $DensityFunction$$Type, "veinGap"?: $DensityFunction$$Type, "veinRidged"?: $DensityFunction$$Type, "finalDensity"?: $DensityFunction$$Type, "temperature"?: $DensityFunction$$Type, "barrierNoise"?: $DensityFunction$$Type}) | ([vegetation?: $DensityFunction$$Type, depth?: $DensityFunction$$Type, ridges?: $DensityFunction$$Type, erosion?: $DensityFunction$$Type, fluidLevelSpreadNoise?: $DensityFunction$$Type, fluidLevelFloodednessNoise?: $DensityFunction$$Type, lavaNoise?: $DensityFunction$$Type, veinToggle?: $DensityFunction$$Type, initialDensityWithoutJaggedness?: $DensityFunction$$Type, continents?: $DensityFunction$$Type, veinGap?: $DensityFunction$$Type, veinRidged?: $DensityFunction$$Type, finalDensity?: $DensityFunction$$Type, temperature?: $DensityFunction$$Type, barrierNoise?: $DensityFunction$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseRouter$$Original = $NoiseRouter;}
declare module "net.minecraft.world.level.lighting.LayerLightEventListener" {
import {$LightEventListener$$Interface} from "net.minecraft.world.level.lighting.LightEventListener"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$DataLayer} from "net.minecraft.world.level.chunk.DataLayer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export interface $LayerLightEventListener$$Interface extends $LightEventListener$$Interface {
}

export class $LayerLightEventListener implements $LayerLightEventListener$$Interface {
 "getDataLayerData"(arg0: $SectionPos$$Type): $DataLayer
 "getLightValue"(arg0: $BlockPos$$Type): integer
 "hasLightWork"(): boolean
 "updateSectionStatus"(arg0: $SectionPos$$Type, arg1: boolean): void
 "updateSectionStatus"(arg0: $BlockPos$$Type, arg1: boolean): void
 "checkBlock"(arg0: $BlockPos$$Type): void
 "propagateLightSources"(arg0: $ChunkPos$$Type): void
 "runLightUpdates"(): integer
 "setLightEnabled"(arg0: $ChunkPos$$Type, arg1: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LayerLightEventListener$$Type = ($LayerLightEventListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LayerLightEventListener$$Original = $LayerLightEventListener;}
declare module "net.minecraft.world.level.block.state.properties.WoodType" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Stream} from "java.util.stream.Stream"
import {$Record} from "java.lang.Record"

export class $WoodType extends $Record {
static readonly "MANGROVE": $WoodType
static readonly "SPRUCE": $WoodType
static readonly "CHERRY": $WoodType
static readonly "CODEC": $Codec<($WoodType)>
static readonly "BAMBOO": $WoodType
static readonly "BIRCH": $WoodType
static readonly "ACACIA": $WoodType
static readonly "JUNGLE": $WoodType
static readonly "WARPED": $WoodType
static readonly "OAK": $WoodType
static readonly "CRIMSON": $WoodType
static readonly "DARK_OAK": $WoodType

constructor(arg0: StringJS, arg1: $BlockSetType$$Type)
constructor(arg0: StringJS, arg1: $BlockSetType$$Type, arg2: $SoundType$$Type, arg3: $SoundType$$Type, arg4: $SoundEvent$$Type, arg5: $SoundEvent$$Type)

public "soundType"(): $SoundType
public "fenceGateOpen"(): $SoundEvent
public "hangingSignSoundType"(): $SoundType
public "fenceGateClose"(): $SoundEvent
public "setType"(): $BlockSetType
public "name"(): StringJS
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public static "values"(): $Stream<($WoodType)>
public "hashCode"(): integer
public static "register"(arg0: $WoodType$$Type): $WoodType
get "type"(): $BlockSetType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WoodType$$Type = ({"soundType"?: $SoundType$$Type, "fenceGateOpen"?: $SoundEvent$$Type, "setType"?: $BlockSetType$$Type, "hangingSignSoundType"?: $SoundType$$Type, "name"?: StringJS, "fenceGateClose"?: $SoundEvent$$Type}) | ([soundType?: $SoundType$$Type, fenceGateOpen?: $SoundEvent$$Type, setType?: $BlockSetType$$Type, hangingSignSoundType?: $SoundType$$Type, name?: StringJS, fenceGateClose?: $SoundEvent$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WoodType$$Original = $WoodType;}
declare module "net.minecraft.world.level.levelgen.feature.LakeFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration, $LakeFeature$Configuration$$Type} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

/**
 * 
 * @deprecated
 */
export class $LakeFeature extends $Feature<($LakeFeature$Configuration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($LakeFeature$Configuration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($LakeFeature$Configuration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LakeFeature$$Type = ($LakeFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LakeFeature$$Original = $LakeFeature;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.BlockStateMatchTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateMatchTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($BlockStateMatchTest)>

constructor(arg0: $BlockState$$Type)

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateMatchTest$$Type = ($BlockStateMatchTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateMatchTest$$Original = $BlockStateMatchTest;}
declare module "net.minecraft.world.level.block.TrialSpawnerBlock" {
import {$TrialSpawnerState} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TrialSpawnerBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TrialSpawnerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "STATE": $EnumProperty<($TrialSpawnerState)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "OMINOUS": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($TrialSpawnerBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawnerBlock$$Type = ($TrialSpawnerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawnerBlock$$Original = $TrialSpawnerBlock;}
declare module "net.minecraft.world.level.levelgen.placement.BiomeFilter" {
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$PlacementFilter} from "net.minecraft.world.level.levelgen.placement.PlacementFilter"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $BiomeFilter extends $PlacementFilter {
static "CODEC": $MapCodec<($BiomeFilter)>

public "type"(): $PlacementModifierType<(never)>
public static "biome"(): $BiomeFilter
}
export type BiomeFilterObject = {"or"?: $BiomeFilter$$Type, "not"?: $BiomeFilter$$Type, "id"?: Special.Biome, "type"?: Special.Biome, "tag": Special.BiomeTag};
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeFilter$$Type = (Special.Biome) | (RegExp) | (($BiomeFilter$$Type)[]) | (BiomeFilterObject);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeFilter$$Original = $BiomeFilter;}
declare module "net.minecraft.world.level.material.WaterFluid$Source" {
import {$WaterFluid} from "net.minecraft.world.level.material.WaterFluid"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$Holder} from "net.minecraft.core.Holder"

export class $WaterFluid$Source extends $WaterFluid {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty

constructor()

public "isSource"(arg0: $FluidState$$Type): boolean
public "getAmount"(arg0: $FluidState$$Type): integer
public "asHolder"(): $Holder
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterFluid$Source$$Type = ($WaterFluid$Source);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WaterFluid$Source$$Original = $WaterFluid$Source;}
declare module "net.minecraft.world.level.block.RedstoneTorchBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BaseTorchBlock} from "net.minecraft.world.level.block.BaseTorchBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RedstoneTorchBlock extends $BaseTorchBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RedstoneTorchBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "RESTART_DELAY": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "MAX_RECENT_TOGGLES": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "RECENT_TOGGLE_TIMER": integer
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($RedstoneTorchBlock)>
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneTorchBlock$$Type = ($RedstoneTorchBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneTorchBlock$$Original = $RedstoneTorchBlock;}
declare module "net.minecraft.world.level.timers.TimerCallbacks" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TimerCallback, $TimerCallback$$Type} from "net.minecraft.world.level.timers.TimerCallback"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$TimerCallback$Serializer$$Type} from "net.minecraft.world.level.timers.TimerCallback$Serializer"

export class $TimerCallbacks<C> {
static readonly "SERVER_CALLBACKS": $TimerCallbacks<($MinecraftServer)>

constructor()

public "register"(arg0: $TimerCallback$Serializer$$Type<(C), (never)>): $TimerCallbacks<(C)>
public "deserialize"(arg0: $CompoundTag$$Type): $TimerCallback<(C)>
public "serialize"<T extends $TimerCallback<(object)>>(arg0: T): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimerCallbacks$$Type<C> = ($TimerCallbacks<(C)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TimerCallbacks$$Original<C> = $TimerCallbacks<(C)>;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.FancyTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $FancyTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($FancyTrunkPlacer)>
static readonly "MAX_HEIGHT": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FancyTrunkPlacer$$Type = ($FancyTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FancyTrunkPlacer$$Original = $FancyTrunkPlacer;}
declare module "net.minecraft.world.level.block.state.pattern.BlockPattern" {
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$BlockPatternExtended$$Interface} from "net.caffeinemc.mods.lithium.common.world.block_pattern_matching.BlockPatternExtended"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPattern$BlockPatternMatch} from "net.minecraft.world.level.block.state.pattern.BlockPattern$BlockPatternMatch"
import {$BlockInWorld, $BlockInWorld$$Type} from "net.minecraft.world.level.block.state.pattern.BlockInWorld"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LoadingCache} from "com.google.common.cache.LoadingCache"

export class $BlockPattern implements $BlockPatternExtended$$Interface {
constructor(arg0: ((($Predicate$$Type<($BlockInWorld$$Type)>)[])[])[])

public static "createLevelCache"(arg0: $LevelReader$$Type, arg1: boolean): $LoadingCache<($BlockPos), ($BlockInWorld)>
public "getWidth"(): integer
public "getHeight"(): integer
public "getPattern"(): ((($Predicate<($BlockInWorld)>)[])[])[]
public "matches"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $Direction$$Type): $BlockPattern$BlockPatternMatch
public "find"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): $BlockPattern$BlockPatternMatch
public "getDepth"(): integer
public "lithium$setRequiredBlock"(arg0: $Block$$Type, arg1: integer): void
get "width"(): integer
get "height"(): integer
get "pattern"(): ((($Predicate<($BlockInWorld)>)[])[])[]
get "depth"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPattern$$Type = ($BlockPattern);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPattern$$Original = $BlockPattern;}
declare module "net.minecraft.world.level.block.entity.vault.VaultClientData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $VaultClientData {
static readonly "ROTATION_SPEED": float

public "previousSpin"(): float
public "currentSpin"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultClientData$$Type = ($VaultClientData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultClientData$$Original = $VaultClientData;}
declare module "net.minecraft.world.level.block.HangingRootsBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HangingRootsBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($HangingRootsBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($HangingRootsBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HangingRootsBlock$$Type = ($HangingRootsBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HangingRootsBlock$$Original = $HangingRootsBlock;}
declare module "net.minecraft.world.level.block.GrowingPlantBodyBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$GrowingPlantBlock} from "net.minecraft.world.level.block.GrowingPlantBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $GrowingPlantBodyBlock extends $GrowingPlantBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GrowingPlantBodyBlock$$Type = ($GrowingPlantBodyBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GrowingPlantBodyBlock$$Original = $GrowingPlantBodyBlock;}
declare module "net.minecraft.world.level.levelgen.structure.pools.FeaturePoolElement" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$List} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructurePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplate$StructureBlockInfo} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $FeaturePoolElement extends $StructurePoolElement {
static readonly "CODEC": $MapCodec<($FeaturePoolElement)>

public "getShuffledJigsawBlocks"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: $RandomSource$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "place"(arg0: $StructureTemplateManager$$Type, arg1: $WorldGenLevel$$Type, arg2: $StructureManager$$Type, arg3: $ChunkGenerator$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type, arg6: $Rotation$$Type, arg7: $BoundingBox$$Type, arg8: $RandomSource$$Type, arg9: $LiquidSettings$$Type, arg10: boolean): boolean
public "toString"(): StringJS
public "getType"(): $StructurePoolElementType<(never)>
public "getSize"(arg0: $StructureTemplateManager$$Type, arg1: $Rotation$$Type): $Vec3i
public "getBoundingBox"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BoundingBox
get "type"(): $StructurePoolElementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeaturePoolElement$$Type = ($FeaturePoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeaturePoolElement$$Original = $FeaturePoolElement;}
declare module "net.minecraft.world.level.block.SculkVeinBlock" {
import {$SculkSpreader$$Type} from "net.minecraft.world.level.block.SculkSpreader"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$SculkSpreader$ChargeCursor$$Type} from "net.minecraft.world.level.block.SculkSpreader$ChargeCursor"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SculkBehaviour$$Interface} from "net.minecraft.world.level.block.SculkBehaviour"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Collection$$Type} from "java.util.Collection"
import {$MultifaceBlock} from "net.minecraft.world.level.block.MultifaceBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$MultifaceSpreader} from "net.minecraft.world.level.block.MultifaceSpreader"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SculkVeinBlock extends $MultifaceBlock implements $SculkBehaviour$$Interface, $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SculkVeinBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getSpreader"(): $MultifaceSpreader
public "attemptUseCharge"(arg0: $SculkSpreader$ChargeCursor$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type, arg4: $SculkSpreader$$Type, arg5: boolean): integer
public "getSameSpaceSpreader"(): $MultifaceSpreader
public static "regrow"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Collection$$Type<($Direction$$Type)>): boolean
public static "hasSubstrateAccess"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): boolean
public "onDischarged"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($SculkVeinBlock)>
public "canChangeBlockStateOnSpread"(): boolean
public "getSculkSpreadDelay"(): byte
public "depositCharge"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): boolean
public "attemptSpreadVein"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Collection$$Type<($Direction$$Type)>, arg4: boolean): boolean
public "updateDecayDelay"(arg0: integer): integer
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "spreader"(): $MultifaceSpreader
get "sameSpaceSpreader"(): $MultifaceSpreader
get "sculkSpreadDelay"(): byte
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkVeinBlock$$Type = ($SculkVeinBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkVeinBlock$$Original = $SculkVeinBlock;}
declare module "net.minecraft.world.level.block.VaultBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$VaultState} from "net.minecraft.world.level.block.entity.vault.VaultState"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $VaultBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($VaultBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "STATE": $Property<($VaultState)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "OMINOUS": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "useItemOn"(arg0: $ItemStack$$Type, arg1: $BlockState$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): $ItemInteractionResult
public "codec"(): $MapCodec<($VaultBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultBlock$$Type = ($VaultBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultBlock$$Original = $VaultBlock;}
declare module "net.minecraft.world.level.levelgen.structure.StructureStart" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$List} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StructurePiece} from "net.minecraft.world.level.levelgen.structure.StructurePiece"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$StructurePieceSerializationContext$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext"
import {$PiecesContainer$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"

export class $StructureStart {
static readonly "INVALID_START": $StructureStart
static readonly "INVALID_START_ID": StringJS

constructor(arg0: $Structure$$Type, arg1: $ChunkPos$$Type, arg2: integer, arg3: $PiecesContainer$$Type)

public "getPieces"(): $List<($StructurePiece)>
public "getChunkPos"(): $ChunkPos
public "canBeReferenced"(): boolean
public "getReferences"(): integer
public "placeInChunk"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BoundingBox$$Type, arg5: $ChunkPos$$Type): void
public "addReference"(): void
public "isValid"(): boolean
public "createTag"(arg0: $StructurePieceSerializationContext$$Type, arg1: $ChunkPos$$Type): $CompoundTag
public static "loadStaticStart"(arg0: $StructurePieceSerializationContext$$Type, arg1: $CompoundTag$$Type, arg2: long): $StructureStart
public "getBoundingBox"(): $BoundingBox
public "getStructure"(): $Structure
get "pieces"(): $List<($StructurePiece)>
get "chunkPos"(): $ChunkPos
get "references"(): integer
get "valid"(): boolean
get "boundingBox"(): $BoundingBox
get "structure"(): $Structure
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureStart$$Type = ($StructureStart);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureStart$$Original = $StructureStart;}
declare module "net.minecraft.world.level.block.SupportType" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Enum} from "java.lang.Enum"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SupportType extends $Enum<($SupportType)> {
static readonly "CENTER": $SupportType
static readonly "FULL": $SupportType
static readonly "RIGID": $SupportType

public "isSupporting"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public static "values"(): ($SupportType)[]
public static "valueOf"(arg0: StringJS): $SupportType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SupportType$$Type = (("full") | ("center") | ("rigid"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SupportType$$Original = $SupportType;}
declare module "net.minecraft.world.level.CollisionGetter" {
import {$Iterable} from "java.lang.Iterable"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$BlockGetter, $BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export interface $CollisionGetter$$Interface extends $BlockGetter$$Interface {
get "worldBorder"(): $WorldBorder
get "maxLightLevel"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $CollisionGetter implements $CollisionGetter$$Interface {
 "getWorldBorder"(): $WorldBorder
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getHeight"(): integer
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMinBuildHeight"(): integer
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollisionGetter$$Type = ($CollisionGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CollisionGetter$$Original = $CollisionGetter;}
declare module "net.minecraft.world.level.gameevent.PositionSourceType" {
import {$BlockPositionSource} from "net.minecraft.world.level.gameevent.BlockPositionSource"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PositionSource} from "net.minecraft.world.level.gameevent.PositionSource"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$EntityPositionSource} from "net.minecraft.world.level.gameevent.EntityPositionSource"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export interface $PositionSourceType$$Interface<T extends $PositionSource> {
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.PositionSourceType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.PositionSourceTypeTag
}

export class $PositionSourceType<T extends $PositionSource> implements $PositionSourceType$$Interface {
static readonly "ENTITY": $PositionSourceType<($EntityPositionSource)>
static readonly "BLOCK": $PositionSourceType<($BlockPositionSource)>

 "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
static "register"<S extends $PositionSourceType<(object)>, T extends $PositionSource>(arg0: StringJS, arg1: S): S
 "codec"(): $MapCodec<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PositionSourceType$$Type<T> = (Special.PositionSourceType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PositionSourceType$$Original<T> = $PositionSourceType<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.GeodeFeature" {
import {$GeodeConfiguration, $GeodeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $GeodeFeature extends $Feature<($GeodeConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($GeodeConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($GeodeConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeFeature$$Type = ($GeodeFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeodeFeature$$Original = $GeodeFeature;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ReplaceSphereConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($ReplaceSphereConfiguration)>
readonly "targetState": $BlockState
readonly "replaceState": $BlockState

constructor(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $IntProvider$$Type)

public "radius"(): $IntProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplaceSphereConfiguration$$Type = ($ReplaceSphereConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplaceSphereConfiguration$$Original = $ReplaceSphereConfiguration;}
declare module "net.minecraft.world.level.block.AbstractFurnaceBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractFurnaceBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractFurnaceBlock$$Type = ($AbstractFurnaceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractFurnaceBlock$$Original = $AbstractFurnaceBlock;}
declare module "net.minecraft.world.level.block.PoweredRailBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$RailShape} from "net.minecraft.world.level.block.state.properties.RailShape"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BaseRailBlock} from "net.minecraft.world.level.block.BaseRailBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $PoweredRailBlock extends $BaseRailBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PoweredRailBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $EnumProperty<($RailShape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)
constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: boolean)

public "getShapeProperty"(): $Property<($RailShape)>
public "isActivatorRail"(): boolean
public "codec"(): $MapCodec<($PoweredRailBlock)>
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "shapeProperty"(): $Property<($RailShape)>
get "activatorRail"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoweredRailBlock$$Type = ($PoweredRailBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PoweredRailBlock$$Original = $PoweredRailBlock;}
declare module "net.minecraft.world.level.validation.DirectoryValidator" {
import {$PathMatcher$$Type} from "java.nio.file.PathMatcher"
import {$List, $List$$Type} from "java.util.List"
import {$ForbiddenSymlinkInfo, $ForbiddenSymlinkInfo$$Type} from "net.minecraft.world.level.validation.ForbiddenSymlinkInfo"
import {$Path$$Type} from "java.nio.file.Path"

export class $DirectoryValidator {
constructor(arg0: $PathMatcher$$Type)

public "validateSymlink"(arg0: $Path$$Type): $List<($ForbiddenSymlinkInfo)>
public "validateSymlink"(arg0: $Path$$Type, arg1: $List$$Type<($ForbiddenSymlinkInfo$$Type)>): void
public "validateDirectory"(arg0: $Path$$Type, arg1: boolean): $List<($ForbiddenSymlinkInfo)>
public "validateKnownDirectory"(arg0: $Path$$Type, arg1: $List$$Type<($ForbiddenSymlinkInfo$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectoryValidator$$Type = ($DirectoryValidator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectoryValidator$$Original = $DirectoryValidator;}
declare module "net.minecraft.world.level.block.WeightedPressurePlateBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BasePressurePlateBlock} from "net.minecraft.world.level.block.BasePressurePlateBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $WeightedPressurePlateBlock extends $BasePressurePlateBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WeightedPressurePlateBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "POWER": $IntegerProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
readonly "maxWeight": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: integer, arg1: $BlockSetType$$Type, arg2: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($WeightedPressurePlateBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeightedPressurePlateBlock$$Type = ($WeightedPressurePlateBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeightedPressurePlateBlock$$Original = $WeightedPressurePlateBlock;}
declare module "net.minecraft.world.level.block.NetherWartBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NetherWartBlock extends $BushBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($NetherWartBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($NetherWartBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherWartBlock$$Type = ($NetherWartBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherWartBlock$$Original = $NetherWartBlock;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $RandomPatchConfiguration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($RandomPatchConfiguration)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $Holder$$Type<($PlacedFeature)>)

public "xzSpread"(): integer
public "ySpread"(): integer
public "tries"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "feature"(): $Holder<($PlacedFeature)>
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomPatchConfiguration$$Type = ({"feature"?: $Holder$$Type<($PlacedFeature)>, "tries"?: integer, "ySpread"?: integer, "xzSpread"?: integer}) | ([feature?: $Holder$$Type<($PlacedFeature)>, tries?: integer, ySpread?: integer, xzSpread?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomPatchConfiguration$$Original = $RandomPatchConfiguration;}
declare module "net.minecraft.world.level.storage.loot.providers.nbt.NbtProvider" {
import {$LootContextParam} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$Set} from "java.util.Set"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$LootNbtProviderType} from "net.minecraft.world.level.storage.loot.providers.nbt.LootNbtProviderType"

export interface $NbtProvider$$Interface {
get "referencedContextParams"(): $Set<($LootContextParam<(never)>)>
get "type"(): $LootNbtProviderType
}

export class $NbtProvider implements $NbtProvider$$Interface {
 "getReferencedContextParams"(): $Set<($LootContextParam<(never)>)>
 "get"(arg0: $LootContext$$Type): $Tag
 "getType"(): $LootNbtProviderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NbtProvider$$Type = ($NbtProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NbtProvider$$Original = $NbtProvider;}
declare module "net.minecraft.world.level.material.LavaFluid$Flowing" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LavaFluid} from "net.minecraft.world.level.material.LavaFluid"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$Holder} from "net.minecraft.core.Holder"

export class $LavaFluid$Flowing extends $LavaFluid {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
static readonly "MIN_LEVEL_CUTOFF": float
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty

constructor()

public "isSource"(arg0: $FluidState$$Type): boolean
public "getAmount"(arg0: $FluidState$$Type): integer
public "asHolder"(): $Holder
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LavaFluid$Flowing$$Type = ($LavaFluid$Flowing);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LavaFluid$Flowing$$Original = $LavaFluid$Flowing;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.AnyOfPredicate" {
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$CombiningPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.CombiningPredicate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AnyOfPredicate extends $CombiningPredicate {
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnyOfPredicate$$Type = ($AnyOfPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AnyOfPredicate$$Original = $AnyOfPredicate;}
declare module "net.minecraft.world.level.block.entity.SpawnerBlockEntity" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BaseSpawner} from "net.minecraft.world.level.BaseSpawner"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Spawner$$Interface} from "net.minecraft.world.level.Spawner"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $SpawnerBlockEntity extends $BlockEntity implements $Spawner$$Interface {
 "spawner": $BaseSpawner
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SpawnerBlockEntity$$Type): void
public "getUpdatePacket"(): $Packet
public "getSpawner"(): $BaseSpawner
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "setEntityId"(arg0: $EntityType$$Type<(never)>, arg1: $RandomSource$$Type): void
public static "clientTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SpawnerBlockEntity$$Type): void
public "onlyOpCanSetNbt"(): boolean
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public static "appendHoverText"(arg0: $ItemStack$$Type, arg1: $List$$Type<($Component$$Type)>, arg2: StringJS): void
public static "getSpawnEntityDisplayName"(arg0: $ItemStack$$Type, arg1: StringJS): $Component
get "updatePacket"(): $Packet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnerBlockEntity$$Type = ($SpawnerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpawnerBlockEntity$$Original = $SpawnerBlockEntity;}
declare module "net.minecraft.world.level.block.FungusBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ConfiguredFeature$$Type} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FungusBlock extends $BushBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FungusBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $ResourceKey$$Type<($ConfiguredFeature<(never), (never)>)>, arg1: $Block$$Type, arg2: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "codec"(): $MapCodec<($FungusBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FungusBlock$$Type = ($FungusBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FungusBlock$$Original = $FungusBlock;}
declare module "net.minecraft.world.level.levelgen.feature.DesertWellFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $DesertWellFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DesertWellFeature$$Type = ($DesertWellFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DesertWellFeature$$Original = $DesertWellFeature;}
declare module "net.minecraft.world.level.block.SculkSpreader" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$SculkSpreader$ChargeCursor} from "net.minecraft.world.level.block.SculkSpreader$ChargeCursor"
import {$List} from "java.util.List"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $SculkSpreader {
static readonly "MAX_DECAY_FACTOR": float
static readonly "SHRIEKER_PLACEMENT_RATE": integer
static readonly "MAX_CHARGE": integer
static readonly "MAX_GROWTH_RATE_RADIUS": integer

constructor(arg0: boolean, arg1: $TagKey$$Type<($Block)>, arg2: integer, arg3: integer, arg4: integer, arg5: integer)

public static "createLevelSpreader"(): $SculkSpreader
public "getCursors"(): $List<($SculkSpreader$ChargeCursor)>
public "chargeDecayRate"(): integer
public "noGrowthRadius"(): integer
public "additionalDecayRate"(): integer
public "growthSpawnCost"(): integer
public "isWorldGeneration"(): boolean
public "replaceableBlocks"(): $TagKey<($Block)>
public "updateCursors"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type, arg3: boolean): void
public static "createWorldGenSpreader"(): $SculkSpreader
public "addCursors"(arg0: $BlockPos$$Type, arg1: integer): void
public "load"(arg0: $CompoundTag$$Type): void
public "clear"(): void
public "save"(arg0: $CompoundTag$$Type): void
get "cursors"(): $List<($SculkSpreader$ChargeCursor)>
get "worldGeneration"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkSpreader$$Type = ($SculkSpreader);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkSpreader$$Original = $SculkSpreader;}
declare module "net.minecraft.world.level.block.ScaffoldingBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ScaffoldingBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "DISTANCE": $IntegerProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($ScaffoldingBlock)>
static readonly "STABILITY_MAX_DISTANCE": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "BOTTOM": $BooleanProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($ScaffoldingBlock)>
public static "getDistance"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): integer
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScaffoldingBlock$$Type = ($ScaffoldingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScaffoldingBlock$$Original = $ScaffoldingBlock;}
declare module "net.minecraft.world.level.block.CocoaBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CocoaBlock extends $HorizontalDirectionalBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CocoaBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "codec"(): $MapCodec<($CocoaBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CocoaBlock$$Type = ($CocoaBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CocoaBlock$$Original = $CocoaBlock;}
declare module "net.minecraft.world.level.block.HayBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$RotatedPillarBlock} from "net.minecraft.world.level.block.RotatedPillarBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HayBlock extends $RotatedPillarBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($HayBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($HayBlock)>
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HayBlock$$Type = ($HayBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HayBlock$$Original = $HayBlock;}
declare module "net.minecraft.world.level.block.StructureBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$GameMasterBlock$$Interface} from "net.minecraft.world.level.block.GameMasterBlock"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$StructureMode} from "net.minecraft.world.level.block.state.properties.StructureMode"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StructureBlock extends $BaseEntityBlock implements $GameMasterBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($StructureBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "MODE": $EnumProperty<($StructureMode)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($StructureBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureBlock$$Type = ($StructureBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureBlock$$Original = $StructureBlock;}
declare module "net.minecraft.world.level.block.ChorusPlantBlock" {
import {$PipeBlock} from "net.minecraft.world.level.block.PipeBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Map} from "java.util.Map"
import {$Direction} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ChorusPlantBlock extends $PipeBlock {
static readonly "DOWN": $BooleanProperty
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "SOUTH": $BooleanProperty
static readonly "UP": $BooleanProperty
static readonly "EAST": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ChorusPlantBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($BooleanProperty)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "getStateWithConnections"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
public "codec"(): $MapCodec<($ChorusPlantBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChorusPlantBlock$$Type = ($ChorusPlantBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChorusPlantBlock$$Original = $ChorusPlantBlock;}
declare module "net.minecraft.world.level.biome.FeatureSorter$StepFeatureData" {
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$List, $List$$Type} from "java.util.List"
import {$Record} from "java.lang.Record"

export class $FeatureSorter$StepFeatureData extends $Record {
constructor(arg0: $List$$Type<($PlacedFeature$$Type)>, arg1: $ToIntFunction$$Type<($PlacedFeature)>)

public "indexMapping"(): $ToIntFunction<($PlacedFeature)>
public "features"(): $List<($PlacedFeature)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeatureSorter$StepFeatureData$$Type = ({"indexMapping"?: $ToIntFunction$$Type<($PlacedFeature$$Type)>, "features"?: $List$$Type<($PlacedFeature$$Type)>}) | ([indexMapping?: $ToIntFunction$$Type<($PlacedFeature$$Type)>, features?: $List$$Type<($PlacedFeature$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeatureSorter$StepFeatureData$$Original = $FeatureSorter$StepFeatureData;}
declare module "net.minecraft.world.level.ColorResolver" {
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"

export interface $ColorResolver$$Interface {

(arg0: $Biome, arg1: double, arg2: double): integer
}

export class $ColorResolver implements $ColorResolver$$Interface {
 "getColor"(arg0: $Biome$$Type, arg1: double, arg2: double): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColorResolver$$Type = ((arg0: $Biome, arg1: double, arg2: double) => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ColorResolver$$Original = $ColorResolver;}
declare module "net.minecraft.world.level.material.Fluid" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$FluidKJS$$Interface} from "dev.latvian.mods.kubejs.core.FluidKJS"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Holder} from "net.minecraft.core.Holder"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$InjectedFluidExtension$$Interface} from "dev.architectury.extensions.injected.InjectedFluidExtension"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$PathType, $PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$Item} from "net.minecraft.world.item.Item"
import {$StateDefinition} from "net.minecraft.world.level.block.state.StateDefinition"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$FluidLike} from "dev.latvian.mods.kubejs.fluid.FluidLike"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidType} from "net.neoforged.neoforge.fluids.FluidType"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Registry} from "net.minecraft.core.Registry"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$IFluidExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IFluidExtension"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$Boat$$Type} from "net.minecraft.world.entity.vehicle.Boat"

export class $Fluid implements $IFluidExtension$$Interface, $InjectedFluidExtension$$Interface, $FluidKJS$$Interface {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>

public "isSource"(arg0: $FluidState$$Type): boolean
/**
 * 
 * @deprecated
 */
public "builtInRegistryHolder"(): $Holder$Reference<($Fluid)>
public "getTickDelay"(arg0: $LevelReader$$Type): integer
public "getOwnHeight"(arg0: $FluidState$$Type): float
public "getPickupSound"(): $Optional<($SoundEvent)>
public "asHolder"(): $Holder
public "isSame"(arg0: $Fluid$$Type): boolean
public "getHeight"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): float
public "getShape"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "toString"(): StringJS
/**
 * 
 * @deprecated
 */
public "is"(arg0: $TagKey$$Type<($Fluid)>): boolean
public "getBucket"(): $Item
public "getStateDefinition"(): $StateDefinition<($Fluid), ($FluidState)>
public "getKey"(): $ResourceKey
public "getFluidType"(): $FluidType
public "getId"(): StringJS
public "getAmount"(arg0: $FluidState$$Type): integer
public "defaultFluidState"(): $FluidState
public "canConvertToSource"(arg0: $FluidState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): boolean
public "supportsBoating"(arg0: $FluidState$$Type, arg1: $Boat$$Type): boolean
public "getBlockPathType"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type, arg4: boolean): $PathType
public "getAdjacentBlockPathType"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type, arg4: $PathType$$Type): $PathType
public "getExplosionResistance"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type): float
public "move"(arg0: $FluidState$$Type, arg1: $LivingEntity$$Type, arg2: $Vec3$$Type, arg3: double): boolean
public "canExtinguish"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "canHydrate"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockPos$$Type): boolean
public "arch$holder"(): $Holder<($Fluid)>
public "getFluid"(): $Fluid
public "getAmount"(): integer
public "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
public "getRegistry"(): $Registry<($Fluid)>
public "isEmpty"(): boolean
public "arch$registryName"(): $ResourceLocation
public "getIdLocation"(): $ResourceLocation
public "getMod"(): StringJS
public "getTagKeys"(): $List<($TagKey<($Fluid)>)>
public "getTags"(): $List<($ResourceLocation)>
public "hasTag"(tag: $ResourceLocation$$Type): boolean
public "specialEquals"(o: any, shallow: boolean): boolean
public "copy"(amount: integer): $FluidLike
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
get "pickupSound"(): $Optional<($SoundEvent)>
get "bucket"(): $Item
get "stateDefinition"(): $StateDefinition<($Fluid), ($FluidState)>
get "key"(): $ResourceKey
get "fluidType"(): $FluidType
get "id"(): StringJS
get "fluid"(): $Fluid
get "amount"(): integer
get "registryId"(): $ResourceKey<($Registry<($Fluid)>)>
get "registry"(): $Registry<($Fluid)>
get "empty"(): boolean
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($Fluid)>)>
get "tags"(): $List<($ResourceLocation)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.Fluid
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.FluidTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Fluid$$Type = (Special.Fluid);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Fluid$$Original = $Fluid;}
declare module "net.minecraft.world.level.block.WeatheringCopperBulbBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Enum} from "java.lang.Enum"
import {$Optional} from "java.util.Optional"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$WeatheringCopper$$Interface} from "net.minecraft.world.level.block.WeatheringCopper"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$CopperBulbBlock} from "net.minecraft.world.level.block.CopperBulbBlock"
import {$WeatheringCopper$WeatherState$$Type} from "net.minecraft.world.level.block.WeatheringCopper$WeatherState"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WeatheringCopperBulbBlock extends $CopperBulbBlock implements $WeatheringCopper$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WeatheringCopperBulbBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $WeatheringCopper$WeatherState$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getAge"(): $Enum
public "getChanceModifier"(): float
public "getNext"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getNext"(arg0: $Block$$Type): $Optional<($Block)>
public static "getFirst"(arg0: $BlockState$$Type): $BlockState
public static "getFirst"(arg0: $Block$$Type): $Block
public static "getPrevious"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getPrevious"(arg0: $Block$$Type): $Optional<($Block)>
public "changeOverTime"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getNextState"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($BlockState)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "age"(): $Enum
get "chanceModifier"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatheringCopperBulbBlock$$Type = ($WeatheringCopperBulbBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeatheringCopperBulbBlock$$Original = $WeatheringCopperBulbBlock;}
declare module "net.minecraft.world.level.levelgen.feature.rootplacers.MangroveRootPlacer" {
import {$Optional$$Type} from "java.util.Optional"
import {$AboveRootPlacement$$Type} from "net.minecraft.world.level.levelgen.feature.rootplacers.AboveRootPlacement"
import {$MangroveRootPlacement$$Type} from "net.minecraft.world.level.levelgen.feature.rootplacers.MangroveRootPlacement"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$RootPlacer} from "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacer"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MangroveRootPlacer extends $RootPlacer {
static readonly "CODEC": $MapCodec<($MangroveRootPlacer)>
static readonly "ROOT_WIDTH_LIMIT": integer
static readonly "ROOT_LENGTH_LIMIT": integer

constructor(arg0: $IntProvider$$Type, arg1: $BlockStateProvider$$Type, arg2: ($AboveRootPlacement$$Type)?, arg3: $MangroveRootPlacement$$Type)

public "placeRoots"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MangroveRootPlacer$$Type = ($MangroveRootPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MangroveRootPlacer$$Original = $MangroveRootPlacer;}
declare module "net.minecraft.world.level.levelgen.structure.placement.RandomSpreadStructurePlacement" {
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Optional$$Type} from "java.util.Optional"
import {$StructurePlacement$ExclusionZone$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$ExclusionZone"
import {$RandomSpreadType, $RandomSpreadType$$Type} from "net.minecraft.world.level.levelgen.structure.placement.RandomSpreadType"
import {$StructurePlacementType} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacementType"
import {$ChunkPos} from "net.minecraft.world.level.ChunkPos"
import {$StructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlacement$FrequencyReductionMethod$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$FrequencyReductionMethod"

export class $RandomSpreadStructurePlacement extends $StructurePlacement {
static readonly "CODEC": $MapCodec<($RandomSpreadStructurePlacement)>

constructor(arg0: integer, arg1: integer, arg2: $RandomSpreadType$$Type, arg3: integer)
constructor(arg0: $Vec3i$$Type, arg1: $StructurePlacement$FrequencyReductionMethod$$Type, arg2: float, arg3: integer, arg4: ($StructurePlacement$ExclusionZone$$Type)?, arg5: integer, arg6: integer, arg7: $RandomSpreadType$$Type)

public "getPotentialStructureChunk"(arg0: long, arg1: integer, arg2: integer): $ChunkPos
public "type"(): $StructurePlacementType<(never)>
public "spreadType"(): $RandomSpreadType
public "spacing"(): integer
public "separation"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomSpreadStructurePlacement$$Type = ($RandomSpreadStructurePlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomSpreadStructurePlacement$$Original = $RandomSpreadStructurePlacement;}
declare module "net.minecraft.world.level.block.entity.SmokerBlockEntity" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$Component} from "net.minecraft.network.chat.Component"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AbstractFurnaceBlockEntity} from "net.minecraft.world.level.block.entity.AbstractFurnaceBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SmokerBlockEntity extends $AbstractFurnaceBlockEntity {
static readonly "DATA_LIT_DURATION": integer
static readonly "DATA_COOKING_TOTAL_TIME": integer
static readonly "DATA_COOKING_PROGRESS": integer
static readonly "BURN_TIME_STANDARD": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode
static readonly "NUM_DATA_VALUES": integer
 "litTime": integer
static readonly "DATA_LIT_TIME": integer
static readonly "BURN_COOL_SPEED": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public static "tryClear"(arg0: any): void
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmokerBlockEntity$$Type = ($SmokerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmokerBlockEntity$$Original = $SmokerBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Optional$$Type} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$AboveRootPlacement$$Type} from "net.minecraft.world.level.levelgen.feature.rootplacers.AboveRootPlacement"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $RootPlacer {
static readonly "CODEC": $Codec<($RootPlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $BlockStateProvider$$Type, arg2: ($AboveRootPlacement$$Type)?)

public "placeRoots"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): boolean
public "getTrunkOrigin"(arg0: $BlockPos$$Type, arg1: $RandomSource$$Type): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RootPlacer$$Type = ($RootPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RootPlacer$$Original = $RootPlacer;}
declare module "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record} from "java.lang.Record"

export class $LakeFeature$Configuration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($LakeFeature$Configuration)>

constructor(arg0: $BlockStateProvider$$Type, arg1: $BlockStateProvider$$Type)

public "fluid"(): $BlockStateProvider
public "barrier"(): $BlockStateProvider
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LakeFeature$Configuration$$Type = ({"barrier"?: $BlockStateProvider$$Type, "fluid"?: $BlockStateProvider$$Type}) | ([barrier?: $BlockStateProvider$$Type, fluid?: $BlockStateProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LakeFeature$Configuration$$Original = $LakeFeature$Configuration;}
declare module "net.minecraft.world.level.levelgen.placement.CountPlacement" {
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$RepeatingPlacement} from "net.minecraft.world.level.levelgen.placement.RepeatingPlacement"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $CountPlacement extends $RepeatingPlacement {
static readonly "CODEC": $MapCodec<($CountPlacement)>

public "type"(): $PlacementModifierType<(never)>
public static "of"(arg0: $IntProvider$$Type): $CountPlacement
public static "of"(arg0: integer): $CountPlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CountPlacement$$Type = ($CountPlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CountPlacement$$Original = $CountPlacement;}
declare module "net.minecraft.world.level.block.SporeBlossomBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SporeBlossomBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SporeBlossomBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($SporeBlossomBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SporeBlossomBlock$$Type = ($SporeBlossomBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SporeBlossomBlock$$Original = $SporeBlossomBlock;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $HugeMushroomFeatureConfiguration implements $FeatureConfiguration$$Interface {
readonly "capProvider": $BlockStateProvider
static readonly "CODEC": $Codec<($HugeMushroomFeatureConfiguration)>
readonly "stemProvider": $BlockStateProvider
readonly "foliageRadius": integer

constructor(arg0: $BlockStateProvider$$Type, arg1: $BlockStateProvider$$Type, arg2: integer)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HugeMushroomFeatureConfiguration$$Type = ($HugeMushroomFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HugeMushroomFeatureConfiguration$$Original = $HugeMushroomFeatureConfiguration;}
declare module "net.minecraft.world.level.block.state.pattern.BlockInWorld" {
import {$LevelReader, $LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockInWorld {
constructor(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: boolean)

public static "hasState"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockInWorld)>
public "getLevel"(): $LevelReader
public "getEntity"(): $BlockEntity
public "getState"(): $BlockState
public "getPos"(): $BlockPos
get "level"(): $LevelReader
get "entity"(): $BlockEntity
get "state"(): $BlockState
get "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockInWorld$$Type = ($BlockInWorld);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockInWorld$$Original = $BlockInWorld;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.GravityProcessor" {
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $GravityProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($GravityProcessor)>

constructor(arg0: $Heightmap$Types$$Type, arg1: integer)

public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GravityProcessor$$Type = ($GravityProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GravityProcessor$$Original = $GravityProcessor;}
declare module "net.minecraft.world.level.lighting.LightEngine" {
import {$LayerLightSectionStorage$SectionType} from "net.minecraft.world.level.lighting.LayerLightSectionStorage$SectionType"
import {$LayerLightEventListener$$Interface} from "net.minecraft.world.level.lighting.LayerLightEventListener"
import {$LightEngineAccessor$$Interface} from "dev.engine_room.flywheel.backend.mixin.light.LightEngineAccessor"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$DataLayer, $DataLayer$$Type} from "net.minecraft.world.level.chunk.DataLayer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LayerLightSectionStorage} from "net.minecraft.world.level.lighting.LayerLightSectionStorage"
import {$DataLayerStorageMap} from "net.minecraft.world.level.lighting.DataLayerStorageMap"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LightEngine<M extends $DataLayerStorageMap<(object)>, S extends $LayerLightSectionStorage<(object)>> implements $LayerLightEventListener$$Interface, $LightEngineAccessor$$Interface {
static readonly "MAX_LEVEL": integer

public "hasLightWork"(): boolean
public "getDebugSectionType"(arg0: long): $LayerLightSectionStorage$SectionType
public static "getOcclusionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): $VoxelShape
public static "getLightBlockInto"(arg0: $BlockGetter$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockPos$$Type, arg5: $Direction$$Type, arg6: integer): integer
public "updateSectionStatus"(arg0: $SectionPos$$Type, arg1: boolean): void
public static "hasDifferentLightProperties"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type): boolean
public "checkBlock"(arg0: $BlockPos$$Type): void
public "retainData"(arg0: $ChunkPos$$Type, arg1: boolean): void
public "queueSectionData"(arg0: long, arg1: $DataLayer$$Type): void
public "getDebugData"(arg0: long): StringJS
public "getDataLayerData"(arg0: $SectionPos$$Type): $DataLayer
public "flywheel$storage"(): $LayerLightSectionStorage
public "runLightUpdates"(): integer
public "getLightValue"(arg0: $BlockPos$$Type): integer
public "setLightEnabled"(arg0: $ChunkPos$$Type, arg1: boolean): void
public "updateSectionStatus"(arg0: $BlockPos$$Type, arg1: boolean): void
public "propagateLightSources"(arg0: $ChunkPos$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightEngine$$Type<M, S> = ($LightEngine<(M), (S)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightEngine$$Original<M, S> = $LightEngine<(M), (S)>;}
declare module "net.minecraft.world.level.storage.loot.functions.FunctionUserBuilder" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$Function$$Type} from "java.util.function.Function"
import {$LootItemFunction$Builder$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction$Builder"

export interface $FunctionUserBuilder$$Interface<T extends $FunctionUserBuilder<(object)>> {
}

export class $FunctionUserBuilder<T extends $FunctionUserBuilder<(object)>> implements $FunctionUserBuilder$$Interface {
 "apply"<E>(arg0: (E)[], arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): T
 "apply"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): T
 "apply"(arg0: $LootItemFunction$Builder$$Type): T
 "unwrap"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionUserBuilder$$Type<T> = ($FunctionUserBuilder<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FunctionUserBuilder$$Original<T> = $FunctionUserBuilder<(T)>;}
declare module "net.minecraft.world.level.block.entity.TickingBlockEntity" {
import {$BlockPos} from "net.minecraft.core.BlockPos"

export interface $TickingBlockEntity$$Interface {
get "type"(): StringJS
get "removed"(): boolean
get "pos"(): $BlockPos
}

export class $TickingBlockEntity implements $TickingBlockEntity$$Interface {
 "tick"(): void
 "getType"(): StringJS
 "isRemoved"(): boolean
 "getPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickingBlockEntity$$Type = ($TickingBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TickingBlockEntity$$Original = $TickingBlockEntity;}
declare module "net.minecraft.world.level.chunk.storage.ChunkIOErrorReporter" {
import {$RegionStorageInfo$$Type} from "net.minecraft.world.level.chunk.storage.RegionStorageInfo"
import {$ReportedException} from "net.minecraft.ReportedException"
import {$Throwable$$Type} from "java.lang.Throwable"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export interface $ChunkIOErrorReporter$$Interface {
}

export class $ChunkIOErrorReporter implements $ChunkIOErrorReporter$$Interface {
 "reportChunkLoadFailure"(arg0: $Throwable$$Type, arg1: $RegionStorageInfo$$Type, arg2: $ChunkPos$$Type): void
 "reportChunkSaveFailure"(arg0: $Throwable$$Type, arg1: $RegionStorageInfo$$Type, arg2: $ChunkPos$$Type): void
static "createMisplacedChunkReport"(arg0: $ChunkPos$$Type, arg1: $ChunkPos$$Type): $ReportedException
 "reportMisplacedChunk"(arg0: $ChunkPos$$Type, arg1: $ChunkPos$$Type, arg2: $RegionStorageInfo$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkIOErrorReporter$$Type = ($ChunkIOErrorReporter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkIOErrorReporter$$Original = $ChunkIOErrorReporter;}
declare module "net.minecraft.world.level.block.EndPortalFrameBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BlockPattern} from "net.minecraft.world.level.block.state.pattern.BlockPattern"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $EndPortalFrameBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($EndPortalFrameBlock)>
static readonly "HAS_EYE": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "getOrCreatePortalShape"(): $BlockPattern
public "codec"(): $MapCodec<($EndPortalFrameBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static get "orCreatePortalShape"(): $BlockPattern
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndPortalFrameBlock$$Type = ($EndPortalFrameBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndPortalFrameBlock$$Original = $EndPortalFrameBlock;}
declare module "net.minecraft.world.level.GameRules$Key" {
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"
import {$GameRules$Category, $GameRules$Category$$Type} from "net.minecraft.world.level.GameRules$Category"

export class $GameRules$Key<T extends $GameRules$Value<(object)>> {
constructor(arg0: StringJS, arg1: $GameRules$Category$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getId"(): StringJS
public "getCategory"(): $GameRules$Category
public "getDescriptionId"(): StringJS
get "id"(): StringJS
get "category"(): $GameRules$Category
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$Key$$Type<T> = ($GameRules$Key<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$Key$$Original<T> = $GameRules$Key<(T)>;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$MarkerOrMarked" {
import {$DensityFunctions$Marker$Type} from "net.minecraft.world.level.levelgen.DensityFunctions$Marker$Type"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction, $DensityFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunctions$MarkerOrMarked$$Interface extends $DensityFunction$$Interface {
}

export class $DensityFunctions$MarkerOrMarked implements $DensityFunctions$MarkerOrMarked$$Interface {
 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "wrapped"(): $DensityFunction
 "type"(): $DensityFunctions$Marker$Type
 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
 "cube"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "squeeze"(): $DensityFunction
 "maxValue"(): double
 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "square"(): $DensityFunction
 "minValue"(): double
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$MarkerOrMarked$$Type = ($DensityFunctions$MarkerOrMarked);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$MarkerOrMarked$$Original = $DensityFunctions$MarkerOrMarked;}
declare module "net.minecraft.world.level.block.RedStoneWireBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Map} from "java.util.Map"
import {$Direction} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$RedstoneSide} from "net.minecraft.world.level.block.state.properties.RedstoneSide"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RedStoneWireBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RedStoneWireBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST": $EnumProperty<($RedstoneSide)>
static readonly "POWER": $IntegerProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($EnumProperty<($RedstoneSide)>)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "NORTH": $EnumProperty<($RedstoneSide)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "SOUTH": $EnumProperty<($RedstoneSide)>
static readonly "UPDATE_CLIENTS": integer
static readonly "EAST": $EnumProperty<($RedstoneSide)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "getColorForPower"(arg0: integer): integer
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($RedStoneWireBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedStoneWireBlock$$Type = ($RedStoneWireBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedStoneWireBlock$$Original = $RedStoneWireBlock;}
declare module "net.minecraft.world.level.block.ShulkerBoxBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $ShulkerBoxBlock extends $BaseEntityBlock implements $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ShulkerBoxBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "CONTENTS": $ResourceLocation
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $EnumProperty<($Direction)>

constructor(arg0: $DyeColor$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "getColoredItemStack"(arg0: $DyeColor$$Type): $ItemStack
public static "getColorFromItem"(arg0: $Item$$Type): $DyeColor
public static "getColorFromBlock"(arg0: $Block$$Type): $DyeColor
public static "getBlockByColor"(arg0: $DyeColor$$Type): $Block
public "getColor"(): $DyeColor
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($ShulkerBoxBlock)>
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShulkerBoxBlock$$Type = ($ShulkerBoxBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShulkerBoxBlock$$Original = $ShulkerBoxBlock;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Listener" {
import {$PositionSource} from "net.minecraft.world.level.gameevent.PositionSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$VibrationSystem$$Type} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem"
import {$GameEventListener$$Interface} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$GameEventListener$DeliveryMode} from "net.minecraft.world.level.gameevent.GameEventListener$DeliveryMode"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export class $VibrationSystem$Listener implements $GameEventListener$$Interface {
constructor(arg0: $VibrationSystem$$Type)

public "forceScheduleVibration"(arg0: $ServerLevel$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $GameEvent$Context$$Type, arg3: $Vec3$$Type): void
public "getListenerRadius"(): integer
public "getListenerSource"(): $PositionSource
public "handleGameEvent"(arg0: $ServerLevel$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $GameEvent$Context$$Type, arg3: $Vec3$$Type): boolean
public static "distanceBetweenInBlocks"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): float
public "getDeliveryMode"(): $GameEventListener$DeliveryMode
get "listenerRadius"(): integer
get "listenerSource"(): $PositionSource
get "deliveryMode"(): $GameEventListener$DeliveryMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationSystem$Listener$$Type = ($VibrationSystem$Listener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationSystem$Listener$$Original = $VibrationSystem$Listener;}
declare module "net.minecraft.world.level.block.CryingObsidianBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CryingObsidianBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CryingObsidianBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($CryingObsidianBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CryingObsidianBlock$$Type = ($CryingObsidianBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CryingObsidianBlock$$Original = $CryingObsidianBlock;}
declare module "net.minecraft.world.level.biome.BiomeSource" {
import {$Pair} from "com.mojang.datafixers.util.Pair"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$List$$Type} from "java.util.List"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Climate$Sampler$$Type} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$BiomeResolver$$Interface} from "net.minecraft.world.level.biome.BiomeResolver"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Set} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"

export class $BiomeSource implements $BiomeResolver$$Interface {
static readonly "CODEC": $Codec<($BiomeSource)>

public "findClosestBiome3d"(arg0: $BlockPos$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: $Predicate$$Type<($Holder<($Biome)>)>, arg5: $Climate$Sampler$$Type, arg6: $LevelReader$$Type): $Pair<($BlockPos), ($Holder<($Biome)>)>
public "getBiomesWithin"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Climate$Sampler$$Type): $Set<($Holder<($Biome)>)>
public "findBiomeHorizontal"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: $Predicate$$Type<($Holder<($Biome)>)>, arg6: $RandomSource$$Type, arg7: boolean, arg8: $Climate$Sampler$$Type): $Pair<($BlockPos), ($Holder<($Biome)>)>
public "findBiomeHorizontal"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Predicate$$Type<($Holder<($Biome)>)>, arg5: $RandomSource$$Type, arg6: $Climate$Sampler$$Type): $Pair<($BlockPos), ($Holder<($Biome)>)>
public "possibleBiomes"(): $Set<($Holder<($Biome)>)>
public "addDebugInfo"(arg0: $List$$Type<(StringJS)>, arg1: $BlockPos$$Type, arg2: $Climate$Sampler$$Type): void
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer, arg3: $Climate$Sampler$$Type): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeSource$$Type = ($BiomeSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeSource$$Original = $BiomeSource;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType" {
import {$CherryTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.CherryTrunkPlacer"
import {$MegaJungleTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.MegaJungleTrunkPlacer"
import {$DarkOakTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.DarkOakTrunkPlacer"
import {$StraightTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.StraightTrunkPlacer"
import {$FancyTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.FancyTrunkPlacer"
import {$GiantTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.GiantTrunkPlacer"
import {$UpwardsBranchingTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.UpwardsBranchingTrunkPlacer"
import {$BendingTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.BendingTrunkPlacer"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ForkingTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.ForkingTrunkPlacer"

export class $TrunkPlacerType<P extends $TrunkPlacer> {
static readonly "GIANT_TRUNK_PLACER": $TrunkPlacerType<($GiantTrunkPlacer)>
static readonly "BENDING_TRUNK_PLACER": $TrunkPlacerType<($BendingTrunkPlacer)>
static readonly "UPWARDS_BRANCHING_TRUNK_PLACER": $TrunkPlacerType<($UpwardsBranchingTrunkPlacer)>
static readonly "DARK_OAK_TRUNK_PLACER": $TrunkPlacerType<($DarkOakTrunkPlacer)>
static readonly "FANCY_TRUNK_PLACER": $TrunkPlacerType<($FancyTrunkPlacer)>
static readonly "CHERRY_TRUNK_PLACER": $TrunkPlacerType<($CherryTrunkPlacer)>
static readonly "STRAIGHT_TRUNK_PLACER": $TrunkPlacerType<($StraightTrunkPlacer)>
static readonly "FORKING_TRUNK_PLACER": $TrunkPlacerType<($ForkingTrunkPlacer)>
static readonly "MEGA_JUNGLE_TRUNK_PLACER": $TrunkPlacerType<($MegaJungleTrunkPlacer)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenTrunkPlacerType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenTrunkPlacerTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrunkPlacerType$$Type<P> = (Special.WorldgenTrunkPlacerType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrunkPlacerType$$Original<P> = $TrunkPlacerType<(P)>;}
declare module "net.minecraft.world.level.levelgen.VerticalAnchor" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$WorldGenerationContext, $WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"

export interface $VerticalAnchor$$Interface {

(arg0: $WorldGenerationContext): integer
}

export class $VerticalAnchor implements $VerticalAnchor$$Interface {
static readonly "CODEC": $Codec<($VerticalAnchor)>
static readonly "TOP": $VerticalAnchor
static readonly "BOTTOM": $VerticalAnchor

static "aboveBottom"(arg0: integer): $VerticalAnchor
static "belowTop"(arg0: integer): $VerticalAnchor
 "resolveY"(arg0: $WorldGenerationContext$$Type): integer
static "absolute"(arg0: integer): $VerticalAnchor
static "bottom"(): $VerticalAnchor
static "top"(): $VerticalAnchor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VerticalAnchor$$Type = ((arg0: $WorldGenerationContext) => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VerticalAnchor$$Original = $VerticalAnchor;}
declare module "net.minecraft.world.level.storage.DataVersion" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DataVersion {
static "MAIN_SERIES": StringJS

constructor(arg0: integer)
constructor(arg0: integer, arg1: StringJS)

public "getVersion"(): integer
public "isSideSeries"(): boolean
public "getSeries"(): StringJS
public "isCompatible"(arg0: $DataVersion$$Type): boolean
get "version"(): integer
get "sideSeries"(): boolean
get "series"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataVersion$$Type = ($DataVersion);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataVersion$$Original = $DataVersion;}
declare module "net.minecraft.world.level.Level$ExplosionInteraction" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $Level$ExplosionInteraction extends $Enum<($Level$ExplosionInteraction)> implements $StringRepresentable$$Interface {
static readonly "MOB": $Level$ExplosionInteraction
static readonly "CODEC": $Codec<($Level$ExplosionInteraction)>
static readonly "TRIGGER": $Level$ExplosionInteraction
static readonly "BLOCK": $Level$ExplosionInteraction
static readonly "TNT": $Level$ExplosionInteraction
static readonly "NONE": $Level$ExplosionInteraction

public static "values"(): ($Level$ExplosionInteraction)[]
public static "valueOf"(arg0: StringJS): $Level$ExplosionInteraction
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Level$ExplosionInteraction$$Type = (("none") | ("block") | ("mob") | ("tnt") | ("trigger"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Level$ExplosionInteraction$$Original = $Level$ExplosionInteraction;}
declare module "net.minecraft.world.level.levelgen.structure.placement.StructurePlacementType" {
import {$ConcentricRingsStructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStructurePlacement"
import {$StructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$RandomSpreadStructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.RandomSpreadStructurePlacement"

export interface $StructurePlacementType$$Interface<SP extends $StructurePlacement> {

(): $MapCodec$$Type<(SP)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructurePlacement
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructurePlacementTag
}

export class $StructurePlacementType<SP extends $StructurePlacement> implements $StructurePlacementType$$Interface {
static readonly "RANDOM_SPREAD": $StructurePlacementType<($RandomSpreadStructurePlacement)>
static readonly "CONCENTRIC_RINGS": $StructurePlacementType<($ConcentricRingsStructurePlacement)>

 "codec"(): $MapCodec<(SP)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePlacementType$$Type<SP> = (Special.WorldgenStructurePlacement) | (() => $MapCodec$$Type<(SP)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePlacementType$$Original<SP> = $StructurePlacementType<(SP)>;}
declare module "net.minecraft.world.level.biome.MobSpawnSettings$Builder" {
import {$MobSpawnSettings} from "net.minecraft.world.level.biome.MobSpawnSettings"
import {$Map} from "java.util.Map"
import {$MobCategory, $MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$List} from "java.util.List"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$$Type} from "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData"
import {$MobSpawnSettings$MobSpawnCost} from "net.minecraft.world.level.biome.MobSpawnSettings$MobSpawnCost"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $MobSpawnSettings$Builder {
readonly "mobSpawnCosts": $Map<($EntityType<(never)>), ($MobSpawnSettings$MobSpawnCost)>
readonly "spawners": $Map<($MobCategory), ($List<($MobSpawnSettings$SpawnerData)>)>

constructor()

public "creatureGenerationProbability"(arg0: float): $MobSpawnSettings$Builder
public "addSpawn"(arg0: $MobCategory$$Type, arg1: $MobSpawnSettings$SpawnerData$$Type): $MobSpawnSettings$Builder
public "addMobCharge"(arg0: $EntityType$$Type<(never)>, arg1: double, arg2: double): $MobSpawnSettings$Builder
public "build"(): $MobSpawnSettings
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnSettings$Builder$$Type = ($MobSpawnSettings$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobSpawnSettings$Builder$$Original = $MobSpawnSettings$Builder;}
declare module "net.minecraft.world.level.biome.Climate$ParameterList" {
import {$Climate$TargetPoint$$Type} from "net.minecraft.world.level.biome.Climate$TargetPoint"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Pair, $Pair$$Type} from "com.mojang.datafixers.util.Pair"
import {$List, $List$$Type} from "java.util.List"
import {$Climate$ParameterPoint, $Climate$ParameterPoint$$Type} from "net.minecraft.world.level.biome.Climate$ParameterPoint"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $Climate$ParameterList<T> {
constructor(arg0: $List$$Type<($Pair$$Type<($Climate$ParameterPoint$$Type), (T)>)>)

public "findValueIndex"(arg0: $Climate$TargetPoint$$Type): T
public "findValueBruteForce"(arg0: $Climate$TargetPoint$$Type): T
public "findValue"(arg0: $Climate$TargetPoint$$Type): T
public "values"(): $List<($Pair<($Climate$ParameterPoint), (T)>)>
public static "codec"<T>(arg0: $MapCodec$$Type<(T)>): $Codec<($Climate$ParameterList<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Climate$ParameterList$$Type<T> = ($Climate$ParameterList<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Climate$ParameterList$$Original<T> = $Climate$ParameterList<(T)>;}
declare module "net.minecraft.world.level.gameevent.GameEventListenerRegistry$ListenerVisitor" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"

export interface $GameEventListenerRegistry$ListenerVisitor$$Interface {

(arg0: $GameEventListener, arg1: $Vec3): void
}

export class $GameEventListenerRegistry$ListenerVisitor implements $GameEventListenerRegistry$ListenerVisitor$$Interface {
 "visit"(arg0: $GameEventListener$$Type, arg1: $Vec3$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEventListenerRegistry$ListenerVisitor$$Type = ((arg0: $GameEventListener, arg1: $Vec3) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEventListenerRegistry$ListenerVisitor$$Original = $GameEventListenerRegistry$ListenerVisitor;}
declare module "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $FaceAttachedHorizontalDirectionalBlock extends $HorizontalDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($AttachFace)>

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "canAttach"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FaceAttachedHorizontalDirectionalBlock$$Type = ($FaceAttachedHorizontalDirectionalBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FaceAttachedHorizontalDirectionalBlock$$Original = $FaceAttachedHorizontalDirectionalBlock;}
declare module "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerConfig" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$SpawnData, $SpawnData$$Type} from "net.minecraft.world.level.SpawnData"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$SimpleWeightedRandomList, $SimpleWeightedRandomList$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$Record} from "java.lang.Record"

export class $TrialSpawnerConfig extends $Record {
static readonly "CODEC": $Codec<($TrialSpawnerConfig)>
static readonly "DEFAULT": $TrialSpawnerConfig

constructor(arg0: integer, arg1: float, arg2: float, arg3: float, arg4: float, arg5: integer, arg6: $SimpleWeightedRandomList$$Type<($SpawnData$$Type)>, arg7: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($LootTable$$Type)>)>, arg8: $ResourceKey$$Type<($LootTable)>)

public "lootTablesToEject"(): $SimpleWeightedRandomList<($ResourceKey<($LootTable)>)>
public "ticksBetweenItemSpawners"(): long
public "ticksBetweenSpawn"(): integer
public "spawnPotentialsDefinition"(): $SimpleWeightedRandomList<($SpawnData)>
public "spawnRange"(): integer
public "simultaneousMobsAddedPerPlayer"(): float
public "totalMobs"(): float
public "simultaneousMobs"(): float
public "totalMobsAddedPerPlayer"(): float
public "itemsToDropWhenOminous"(): $ResourceKey<($LootTable)>
public "calculateTargetTotalMobs"(arg0: integer): integer
public "calculateTargetSimultaneousMobs"(arg0: integer): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawnerConfig$$Type = ({"itemsToDropWhenOminous"?: $ResourceKey$$Type<($LootTable)>, "totalMobsAddedPerPlayer"?: float, "simultaneousMobs"?: float, "spawnPotentialsDefinition"?: $SimpleWeightedRandomList$$Type<($SpawnData$$Type)>, "spawnRange"?: integer, "lootTablesToEject"?: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($LootTable$$Type)>)>, "ticksBetweenSpawn"?: integer, "totalMobs"?: float, "simultaneousMobsAddedPerPlayer"?: float}) | ([itemsToDropWhenOminous?: $ResourceKey$$Type<($LootTable)>, totalMobsAddedPerPlayer?: float, simultaneousMobs?: float, spawnPotentialsDefinition?: $SimpleWeightedRandomList$$Type<($SpawnData$$Type)>, spawnRange?: integer, lootTablesToEject?: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($LootTable$$Type)>)>, ticksBetweenSpawn?: integer, totalMobs?: float, simultaneousMobsAddedPerPlayer?: float]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawnerConfig$$Original = $TrialSpawnerConfig;}
declare module "net.minecraft.world.level.levelgen.feature.rootplacers.MangroveRootPlacement" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Record} from "java.lang.Record"

export class $MangroveRootPlacement extends $Record {
static readonly "CODEC": $Codec<($MangroveRootPlacement)>

constructor(arg0: $HolderSet$$Type<($Block)>, arg1: $HolderSet$$Type<($Block)>, arg2: $BlockStateProvider$$Type, arg3: integer, arg4: integer, arg5: float)

public "canGrowThrough"(): $HolderSet<($Block)>
public "maxRootLength"(): integer
public "maxRootWidth"(): integer
public "randomSkewChance"(): float
public "muddyRootsProvider"(): $BlockStateProvider
public "muddyRootsIn"(): $HolderSet<($Block)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MangroveRootPlacement$$Type = ({"canGrowThrough"?: $HolderSet$$Type<($Block)>, "maxRootLength"?: integer, "maxRootWidth"?: integer, "randomSkewChance"?: float, "muddyRootsProvider"?: $BlockStateProvider$$Type, "muddyRootsIn"?: $HolderSet$$Type<($Block)>}) | ([canGrowThrough?: $HolderSet$$Type<($Block)>, maxRootLength?: integer, maxRootWidth?: integer, randomSkewChance?: float, muddyRootsProvider?: $BlockStateProvider$$Type, muddyRootsIn?: $HolderSet$$Type<($Block)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MangroveRootPlacement$$Original = $MangroveRootPlacement;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationSelector" {
import {$VibrationInfo, $VibrationInfo$$Type} from "net.minecraft.world.level.gameevent.vibrations.VibrationInfo"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"

export class $VibrationSelector {
static readonly "CODEC": $Codec<($VibrationSelector)>

constructor(arg0: ($VibrationInfo$$Type)?, arg1: long)
constructor()

public "addCandidate"(arg0: $VibrationInfo$$Type, arg1: long): void
public "chosenCandidate"(arg0: long): $Optional<($VibrationInfo)>
public "startOver"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationSelector$$Type = ($VibrationSelector);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationSelector$$Original = $VibrationSelector;}
declare module "net.minecraft.world.level.material.PushReaction" {
import {$Enum} from "java.lang.Enum"

export class $PushReaction extends $Enum<($PushReaction)> {
static readonly "DESTROY": $PushReaction
static readonly "BLOCK": $PushReaction
static readonly "PUSH_ONLY": $PushReaction
static readonly "IGNORE": $PushReaction
static readonly "NORMAL": $PushReaction

public static "values"(): ($PushReaction)[]
public static "valueOf"(arg0: StringJS): $PushReaction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PushReaction$$Type = (("normal") | ("destroy") | ("block") | ("ignore") | ("push_only"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PushReaction$$Original = $PushReaction;}
declare module "net.minecraft.world.level.block.StonecutterBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $StonecutterBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($StonecutterBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($StonecutterBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StonecutterBlock$$Type = ($StonecutterBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StonecutterBlock$$Original = $StonecutterBlock;}
declare module "net.minecraft.world.level.block.entity.vault.VaultSharedData" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"

export class $VaultSharedData {
public "hasDisplayItem"(): boolean
public "setDisplayItem"(arg0: $ItemStack$$Type): void
public "getDisplayItem"(): $ItemStack
set "displayItem"(value: $ItemStack$$Type)
get "displayItem"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultSharedData$$Type = ($VaultSharedData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultSharedData$$Original = $VaultSharedData;}
declare module "net.minecraft.world.level.block.SoundType" {
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"

export class $SoundType {
static readonly "CANDLE": $SoundType
static readonly "MUD_BRICKS": $SoundType
static readonly "HANGING_ROOTS": $SoundType
static readonly "NYLIUM": $SoundType
static readonly "COPPER_GRATE": $SoundType
static readonly "NETHERITE_BLOCK": $SoundType
static readonly "PACKED_MUD": $SoundType
static readonly "MOSS_CARPET": $SoundType
static readonly "SMALL_AMETHYST_BUD": $SoundType
static readonly "ANVIL": $SoundType
static readonly "CHERRY_SAPLING": $SoundType
static readonly "ROOTS": $SoundType
static readonly "WART_BLOCK": $SoundType
static readonly "SCULK_VEIN": $SoundType
static readonly "WET_SPONGE": $SoundType
readonly "pitch": float
static readonly "LARGE_AMETHYST_BUD": $SoundType
static readonly "FUNGUS": $SoundType
static readonly "TUFF": $SoundType
static readonly "BAMBOO_SAPLING": $SoundType
static readonly "DEEPSLATE": $SoundType
static readonly "NETHER_GOLD_ORE": $SoundType
static readonly "TWISTING_VINES": $SoundType
static readonly "PINK_PETALS": $SoundType
static readonly "SLIME_BLOCK": $SoundType
static readonly "SCULK_SENSOR": $SoundType
static readonly "HONEY_BLOCK": $SoundType
static readonly "TUFF_BRICKS": $SoundType
static readonly "LILY_PAD": $SoundType
static readonly "AZALEA": $SoundType
static readonly "MEDIUM_AMETHYST_BUD": $SoundType
static readonly "SMALL_DRIPLEAF": $SoundType
static readonly "LADDER": $SoundType
static readonly "CHISELED_BOOKSHELF": $SoundType
static readonly "DECORATED_POT": $SoundType
static readonly "BASALT": $SoundType
static readonly "GILDED_BLACKSTONE": $SoundType
static readonly "POINTED_DRIPSTONE": $SoundType
static readonly "GLASS": $SoundType
static readonly "POLISHED_DEEPSLATE": $SoundType
static readonly "CHERRY_WOOD_HANGING_SIGN": $SoundType
static readonly "ROOTED_DIRT": $SoundType
static readonly "DEEPSLATE_BRICKS": $SoundType
static readonly "SOUL_SAND": $SoundType
static readonly "AMETHYST": $SoundType
static readonly "SCULK_CATALYST": $SoundType
static readonly "BAMBOO_WOOD": $SoundType
static readonly "CORAL_BLOCK": $SoundType
static readonly "SCULK_SHRIEKER": $SoundType
static readonly "SCAFFOLDING": $SoundType
static readonly "CHAIN": $SoundType
static readonly "TRIAL_SPAWNER": $SoundType
static readonly "SOUL_SOIL": $SoundType
static readonly "CALCITE": $SoundType
static readonly "VINE": $SoundType
static readonly "DRIPSTONE_BLOCK": $SoundType
static readonly "WOOD": $SoundType
static readonly "CHERRY_WOOD": $SoundType
static readonly "NETHER_SPROUTS": $SoundType
static readonly "SUSPICIOUS_SAND": $SoundType
static readonly "SUSPICIOUS_GRAVEL": $SoundType
static readonly "FROGLIGHT": $SoundType
static readonly "CROP": $SoundType
static readonly "DECORATED_POT_CRACKED": $SoundType
static readonly "NETHER_WOOD": $SoundType
static readonly "GRASS": $SoundType
static readonly "GLOW_LICHEN": $SoundType
static readonly "WOOL": $SoundType
static readonly "MUD": $SoundType
static readonly "SAND": $SoundType
static readonly "BAMBOO": $SoundType
static readonly "SNOW": $SoundType
static readonly "MOSS": $SoundType
static readonly "WEEPING_VINES": $SoundType
static readonly "CHERRY_LEAVES": $SoundType
static readonly "BONE_BLOCK": $SoundType
static readonly "SPORE_BLOSSOM": $SoundType
readonly "volume": float
static readonly "NETHER_WART": $SoundType
static readonly "FLOWERING_AZALEA": $SoundType
static readonly "DEEPSLATE_TILES": $SoundType
static readonly "METAL": $SoundType
static readonly "AZALEA_LEAVES": $SoundType
static readonly "SHROOMLIGHT": $SoundType
static readonly "NETHER_ORE": $SoundType
static readonly "HANGING_SIGN": $SoundType
static readonly "BAMBOO_WOOD_HANGING_SIGN": $SoundType
static readonly "AMETHYST_CLUSTER": $SoundType
static readonly "VAULT": $SoundType
static readonly "COPPER": $SoundType
static readonly "GRAVEL": $SoundType
static readonly "MANGROVE_ROOTS": $SoundType
static readonly "LANTERN": $SoundType
static readonly "COBWEB": $SoundType
static readonly "POWDER_SNOW": $SoundType
static readonly "ANCIENT_DEBRIS": $SoundType
static readonly "EMPTY": $SoundType
static readonly "NETHER_BRICKS": $SoundType
static readonly "MUDDY_MANGROVE_ROOTS": $SoundType
static readonly "BIG_DRIPLEAF": $SoundType
static readonly "HEAVY_CORE": $SoundType
static readonly "POLISHED_TUFF": $SoundType
static readonly "HARD_CROP": $SoundType
static readonly "LODESTONE": $SoundType
static readonly "STEM": $SoundType
static readonly "NETHER_WOOD_HANGING_SIGN": $SoundType
static readonly "CAVE_VINES": $SoundType
static readonly "NETHERRACK": $SoundType
static readonly "WET_GRASS": $SoundType
static readonly "SPONGE": $SoundType
static readonly "COPPER_BULB": $SoundType
static readonly "SCULK": $SoundType
static readonly "FROGSPAWN": $SoundType
static readonly "SWEET_BERRY_BUSH": $SoundType
static readonly "STONE": $SoundType

/**
 * 
 * @deprecated
 */
constructor(arg0: float, arg1: float, arg2: $SoundEvent$$Type, arg3: $SoundEvent$$Type, arg4: $SoundEvent$$Type, arg5: $SoundEvent$$Type, arg6: $SoundEvent$$Type)

public "getPlaceSound"(): $SoundEvent
public "getBreakSound"(): $SoundEvent
public "getHitSound"(): $SoundEvent
public "getFallSound"(): $SoundEvent
public "getVolume"(): float
public "getPitch"(): float
public "getStepSound"(): $SoundEvent
get "placeSound"(): $SoundEvent
get "breakSound"(): $SoundEvent
get "hitSound"(): $SoundEvent
get "fallSound"(): $SoundEvent
get "stepSound"(): $SoundEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundType$$Type = (StringJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundType$$Original = $SoundType;}
declare module "net.minecraft.world.level.levelgen.structure.pools.alias.Direct" {
import {$RandomGroup} from "net.minecraft.world.level.levelgen.structure.pools.alias.RandomGroup"
import {$List$$Type} from "java.util.List"
import {$SimpleWeightedRandomList$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Random} from "net.minecraft.world.level.levelgen.structure.pools.alias.Random"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$StructureTemplatePool, $StructureTemplatePool$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PoolAliasBinding, $PoolAliasBinding$$Type, $PoolAliasBinding$$Interface} from "net.minecraft.world.level.levelgen.structure.pools.alias.PoolAliasBinding"
import {$Record} from "java.lang.Record"

export class $Direct extends $Record implements $PoolAliasBinding$$Interface {
public "forEachResolved"(arg0: $RandomSource$$Type, arg1: $BiConsumer$$Type<($ResourceKey<($StructureTemplatePool)>), ($ResourceKey<($StructureTemplatePool)>)>): void
public static "randomGroup"(arg0: $SimpleWeightedRandomList$$Type<($List$$Type<($PoolAliasBinding$$Type)>)>): $RandomGroup
public static "direct"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>, arg1: $ResourceKey$$Type<($StructureTemplatePool)>): $Direct
public static "direct"(arg0: StringJS, arg1: StringJS): $Direct
public static "random"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>, arg1: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($StructureTemplatePool$$Type)>)>): $Random
public static "random"(arg0: StringJS, arg1: $SimpleWeightedRandomList$$Type<(StringJS)>): $Random
public "allTargets"(): $Stream<($ResourceKey<($StructureTemplatePool)>)>
public "codec"(): $MapCodec<($PoolAliasBinding)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Direct$$Type = ({"alias"?: $ResourceKey$$Type<($StructureTemplatePool)>, "target"?: $ResourceKey$$Type<($StructureTemplatePool)>}) | ([alias?: $ResourceKey$$Type<($StructureTemplatePool)>, target?: $ResourceKey$$Type<($StructureTemplatePool)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Direct$$Original = $Direct;}
declare module "net.minecraft.world.level.block.CrossCollisionBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$Optional} from "java.util.Optional"
import {$Direction} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CrossCollisionBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($BooleanProperty)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "SOUTH": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "EAST": $BooleanProperty

public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrossCollisionBlock$$Type = ($CrossCollisionBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CrossCollisionBlock$$Original = $CrossCollisionBlock;}
declare module "net.minecraft.world.level.block.CampfireBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $CampfireBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CampfireBlock)>
static readonly "SIGNAL_FIRE": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: boolean, arg1: integer, arg2: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "dowse"(arg0: $Entity$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "canLight"(arg0: $BlockState$$Type): boolean
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "handler$bah000$supplementaries$supp$isSmokeSource"(state: $BlockState$$Type, info: $CallbackInfoReturnable$$Type): void
public static "makeParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: boolean, arg3: boolean): void
public static "isSmokeyPos"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public static "isLitCampfire"(arg0: $BlockState$$Type): boolean
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($CampfireBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CampfireBlock$$Type = ($CampfireBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CampfireBlock$$Original = $CampfireBlock;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$PureTransformer" {
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction, $DensityFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunctions$PureTransformer$$Interface extends $DensityFunction$$Interface {
}

export class $DensityFunctions$PureTransformer implements $DensityFunctions$PureTransformer$$Interface {
 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "cube"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "squeeze"(): $DensityFunction
 "maxValue"(): double
 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "square"(): $DensityFunction
 "minValue"(): double
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$PureTransformer$$Type = ($DensityFunctions$PureTransformer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$PureTransformer$$Original = $DensityFunctions$PureTransformer;}
declare module "net.minecraft.world.level.ItemLike" {
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export interface $ItemLike$$Interface {

(): $Item$$Type
}

export class $ItemLike implements $ItemLike$$Interface {
 "asItem"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemLike$$Type = ($Item$$Type) | (() => $Item$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemLike$$Original = $ItemLike;}
declare module "net.minecraft.world.level.levelgen.feature.ReplaceBlobsFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration, $ReplaceSphereConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $ReplaceBlobsFeature extends $Feature<($ReplaceSphereConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($ReplaceSphereConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($ReplaceSphereConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplaceBlobsFeature$$Type = ($ReplaceBlobsFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplaceBlobsFeature$$Original = $ReplaceBlobsFeature;}
declare module "net.minecraft.world.level.GameRules$IntegerValue" {
import {$GameRules$Value, $GameRules$Value$$Type} from "net.minecraft.world.level.GameRules$Value"
import {$GameRules$Type, $GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $GameRules$IntegerValue extends $GameRules$Value<($GameRules$IntegerValue)> {
constructor(arg0: $GameRules$Type$$Type<($GameRules$IntegerValue$$Type)>, arg1: integer)

public "getCommandResult"(): integer
public "tryDeserialize"(arg0: StringJS): boolean
public "get"(): integer
public "set"(arg0: integer, arg1: $MinecraftServer$$Type): void
public static "create"(arg0: integer): $GameRules$Type<($GameRules$IntegerValue)>
public static "create"(arg0: integer, arg1: $BiConsumer$$Type<($MinecraftServer), ($GameRules$IntegerValue)>): $GameRules$Type<($GameRules$IntegerValue)>
public "deserialize"(arg0: StringJS): void
public "serialize"(): StringJS
public "setFrom"(arg0: $GameRules$IntegerValue$$Type, arg1: $MinecraftServer$$Type): void
public "setFrom"(arg0: $GameRules$Value$$Type, arg1: $MinecraftServer$$Type): void
get "commandResult"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$IntegerValue$$Type = ($GameRules$IntegerValue);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$IntegerValue$$Original = $GameRules$IntegerValue;}
declare module "net.minecraft.world.level.chunk.storage.RegionStorageInfo" {
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Record} from "java.lang.Record"

export class $RegionStorageInfo extends $Record {
constructor(arg0: StringJS, arg1: $ResourceKey$$Type<($Level)>, arg2: StringJS)

public "dimension"(): $ResourceKey<($Level)>
public "level"(): StringJS
public "withTypeSuffix"(arg0: StringJS): $RegionStorageInfo
public "type"(): StringJS
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegionStorageInfo$$Type = ({"type"?: StringJS, "level"?: StringJS, "dimension"?: $ResourceKey$$Type<($Level)>}) | ([type?: StringJS, level?: StringJS, dimension?: $ResourceKey$$Type<($Level)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegionStorageInfo$$Original = $RegionStorageInfo;}
declare module "net.minecraft.world.level.block.EndRodBlock" {
import {$RodBlock} from "net.minecraft.world.level.block.RodBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EndRodBlock extends $RodBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($EndRodBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($EndRodBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndRodBlock$$Type = ($EndRodBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndRodBlock$$Original = $EndRodBlock;}
declare module "net.minecraft.world.level.block.Blocks" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $Blocks {
static readonly "GREEN_CONCRETE_POWDER": $Block
static readonly "PIGLIN_HEAD": $Block
static readonly "TUBE_CORAL_WALL_FAN": $Block
static readonly "PURPLE_CARPET": $Block
static readonly "SMALL_AMETHYST_BUD": $Block
static readonly "DEAD_TUBE_CORAL": $Block
static readonly "JUNGLE_PRESSURE_PLATE": $Block
static readonly "GREEN_GLAZED_TERRACOTTA": $Block
static readonly "EXPOSED_CUT_COPPER": $Block
static readonly "WATER_CAULDRON": $Block
static readonly "POTTED_AZALEA": $Block
static readonly "TRAPPED_CHEST": $Block
static readonly "STONE_BRICK_STAIRS": $Block
static readonly "SANDSTONE_WALL": $Block
static readonly "WATER": $Block
static readonly "MELON_STEM": $Block
static readonly "OAK_WOOD": $Block
static readonly "WHITE_TULIP": $Block
static readonly "GRAY_STAINED_GLASS": $Block
static readonly "BLUE_ORCHID": $Block
static readonly "SPRUCE_DOOR": $Block
static readonly "STRIPPED_BIRCH_LOG": $Block
static readonly "LIGHT_BLUE_TERRACOTTA": $Block
static readonly "ZOMBIE_HEAD": $Block
static readonly "BROWN_WOOL": $Block
static readonly "GRANITE_WALL": $Block
static readonly "SHORT_GRASS": $Block
static readonly "ORANGE_SHULKER_BOX": $Block
static readonly "GREEN_CANDLE": $Block
static readonly "CRACKED_STONE_BRICKS": $Block
static readonly "BRICK_SLAB": $Block
static readonly "CYAN_CANDLE_CAKE": $Block
static readonly "BLUE_CANDLE": $Block
static readonly "LAPIS_BLOCK": $Block
static readonly "PURPLE_BED": $Block
static readonly "JUNGLE_SLAB": $Block
static readonly "END_STONE_BRICK_STAIRS": $Block
static readonly "JUNGLE_PLANKS": $Block
static readonly "TURTLE_EGG": $Block
static readonly "WHITE_CANDLE": $Block
static readonly "VERDANT_FROGLIGHT": $Block
static readonly "COBBLESTONE": $Block
static readonly "TUBE_CORAL": $Block
static readonly "GILDED_BLACKSTONE": $Block
static readonly "CYAN_STAINED_GLASS_PANE": $Block
static readonly "WAXED_COPPER_BULB": $Block
static readonly "SMOOTH_RED_SANDSTONE_SLAB": $Block
static readonly "CHISELED_SANDSTONE": $Block
static readonly "LIGHT_BLUE_SHULKER_BOX": $Block
static readonly "NETHER_BRICK_WALL": $Block
static readonly "RED_WOOL": $Block
static readonly "WAXED_WEATHERED_CUT_COPPER_STAIRS": $Block
static readonly "COMMAND_BLOCK": $Block
static readonly "ROOTED_DIRT": $Block
static readonly "PRISMARINE_STAIRS": $Block
static readonly "DEEPSLATE_TILE_STAIRS": $Block
static readonly "POLISHED_ANDESITE": $Block
static readonly "CRAFTING_TABLE": $Block
static readonly "CORNFLOWER": $Block
static readonly "SCULK_SHRIEKER": $Block
static readonly "RED_WALL_BANNER": $Block
static readonly "INFESTED_COBBLESTONE": $Block
static readonly "DIORITE": $Block
static readonly "LIGHT_BLUE_CONCRETE": $Block
static readonly "POLISHED_ANDESITE_SLAB": $Block
static readonly "POLISHED_BLACKSTONE_BUTTON": $Block
static readonly "SPRUCE_WALL_SIGN": $Block
static readonly "MOSSY_STONE_BRICK_WALL": $Block
static readonly "POLISHED_DEEPSLATE_WALL": $Block
static readonly "WARPED_SLAB": $Block
static readonly "STONE_BRICK_WALL": $Block
static readonly "DARK_OAK_WOOD": $Block
static readonly "JUNGLE_WALL_SIGN": $Block
static readonly "CRIMSON_HYPHAE": $Block
static readonly "WAXED_EXPOSED_CUT_COPPER_STAIRS": $Block
static readonly "JUKEBOX": $Block
static readonly "POTTED_RED_MUSHROOM": $Block
static readonly "DARK_OAK_BUTTON": $Block
static readonly "POTTED_ORANGE_TULIP": $Block
static readonly "CRACKED_DEEPSLATE_BRICKS": $Block
static readonly "CHERRY_PRESSURE_PLATE": $Block
static readonly "WARPED_STAIRS": $Block
static readonly "MANGROVE_PLANKS": $Block
static readonly "DEEPSLATE_TILE_WALL": $Block
static readonly "BLACK_CONCRETE_POWDER": $Block
static readonly "DARK_OAK_PRESSURE_PLATE": $Block
static readonly "STRIPPED_SPRUCE_WOOD": $Block
static readonly "MANGROVE_LOG": $Block
static readonly "OAK_BUTTON": $Block
static readonly "GRANITE": $Block
static readonly "SAND": $Block
static readonly "LIGHT": $Block
static readonly "OAK_WALL_SIGN": $Block
static readonly "BROWN_TERRACOTTA": $Block
static readonly "ORANGE_STAINED_GLASS_PANE": $Block
static readonly "REINFORCED_DEEPSLATE": $Block
static readonly "WHITE_WALL_BANNER": $Block
static readonly "NETHER_WART": $Block
static readonly "YELLOW_CARPET": $Block
static readonly "LILY_OF_THE_VALLEY": $Block
static readonly "DEEPSLATE_TILES": $Block
static readonly "HAY_BLOCK": $Block
static readonly "LECTERN": $Block
static readonly "RAW_COPPER_BLOCK": $Block
static readonly "CRIMSON_FENCE_GATE": $Block
static readonly "BLACK_STAINED_GLASS_PANE": $Block
static readonly "ALLIUM": $Block
static readonly "COBBLESTONE_STAIRS": $Block
static readonly "TUFF_BRICK_WALL": $Block
static readonly "CRYING_OBSIDIAN": $Block
static readonly "DETECTOR_RAIL": $Block
static readonly "SOUL_CAMPFIRE": $Block
static readonly "CUT_SANDSTONE_SLAB": $Block
static readonly "CREEPER_WALL_HEAD": $Block
static readonly "AMETHYST_CLUSTER": $Block
static readonly "PURPLE_STAINED_GLASS": $Block
static readonly "BROWN_CONCRETE_POWDER": $Block
static readonly "TUFF_STAIRS": $Block
static readonly "MANGROVE_ROOTS": $Block
static readonly "TERRACOTTA": $Block
static readonly "REDSTONE_WIRE": $Block
static readonly "YELLOW_WALL_BANNER": $Block
static readonly "END_STONE_BRICKS": $Block
static readonly "COARSE_DIRT": $Block
static readonly "LIGHT_GRAY_GLAZED_TERRACOTTA": $Block
static readonly "GLOWSTONE": $Block
static readonly "MANGROVE_HANGING_SIGN": $Block
static readonly "DIORITE_SLAB": $Block
static readonly "ANCIENT_DEBRIS": $Block
static readonly "WAXED_EXPOSED_COPPER_TRAPDOOR": $Block
static readonly "PINK_SHULKER_BOX": $Block
static readonly "CARROTS": $Block
static readonly "CRIMSON_DOOR": $Block
static readonly "GLASS_PANE": $Block
static readonly "POLISHED_TUFF": $Block
static readonly "DIAMOND_ORE": $Block
static readonly "CHIPPED_ANVIL": $Block
static readonly "DEEPSLATE_COPPER_ORE": $Block
static readonly "OAK_LEAVES": $Block
static readonly "CYAN_BANNER": $Block
static readonly "BAMBOO_STAIRS": $Block
static readonly "MAGENTA_BED": $Block
static readonly "WAXED_OXIDIZED_CUT_COPPER_SLAB": $Block
static readonly "SPONGE": $Block
static readonly "RED_BED": $Block
static readonly "SCULK": $Block
static readonly "POTTED_BROWN_MUSHROOM": $Block
static readonly "WARPED_WALL_SIGN": $Block
static readonly "MANGROVE_TRAPDOOR": $Block
static readonly "CANDLE": $Block
static readonly "STRIPPED_SPRUCE_LOG": $Block
static readonly "WAXED_EXPOSED_COPPER_DOOR": $Block
static readonly "COPPER_GRATE": $Block
static readonly "CHORUS_PLANT": $Block
static readonly "ANDESITE_STAIRS": $Block
static readonly "WAXED_WEATHERED_COPPER_BULB": $Block
static readonly "SPRUCE_WALL_HANGING_SIGN": $Block
static readonly "BRICKS": $Block
static readonly "PISTON_HEAD": $Block
static readonly "CRIMSON_WALL_SIGN": $Block
static readonly "RED_NETHER_BRICK_WALL": $Block
static readonly "WET_SPONGE": $Block
static readonly "STRUCTURE_BLOCK": $Block
static readonly "CHERRY_BUTTON": $Block
static readonly "RED_CARPET": $Block
static readonly "ENCHANTING_TABLE": $Block
static readonly "YELLOW_STAINED_GLASS": $Block
static readonly "SOUL_FIRE": $Block
static readonly "DEEPSLATE": $Block
static readonly "RED_BANNER": $Block
static readonly "BLUE_STAINED_GLASS_PANE": $Block
static readonly "SPRUCE_LOG": $Block
static readonly "COPPER_TRAPDOOR": $Block
static readonly "POTTED_RED_TULIP": $Block
static readonly "BIRCH_FENCE": $Block
static readonly "SOUL_LANTERN": $Block
static readonly "POLISHED_BLACKSTONE_BRICKS": $Block
static readonly "POTTED_AZURE_BLUET": $Block
static readonly "WHITE_STAINED_GLASS_PANE": $Block
static readonly "LIME_STAINED_GLASS": $Block
static readonly "DIORITE_WALL": $Block
static readonly "MAGMA_BLOCK": $Block
static readonly "DARK_OAK_SIGN": $Block
static readonly "POLISHED_DEEPSLATE": $Block
static readonly "BLUE_CONCRETE_POWDER": $Block
static readonly "CHORUS_FLOWER": $Block
static readonly "BLACK_GLAZED_TERRACOTTA": $Block
static readonly "RED_STAINED_GLASS": $Block
static readonly "BARRIER": $Block
static readonly "WARPED_FENCE_GATE": $Block
static readonly "DEEPSLATE_REDSTONE_ORE": $Block
static readonly "BAMBOO_MOSAIC_STAIRS": $Block
static readonly "DEEPSLATE_BRICK_STAIRS": $Block
static readonly "GRAY_CANDLE": $Block
static readonly "FARMLAND": $Block
static readonly "TRIAL_SPAWNER": $Block
static readonly "SKELETON_WALL_SKULL": $Block
static readonly "PRISMARINE_BRICKS": $Block
static readonly "SMOOTH_BASALT": $Block
static readonly "DARK_OAK_LOG": $Block
static readonly "BRAIN_CORAL_FAN": $Block
static readonly "WEATHERED_CUT_COPPER_SLAB": $Block
static readonly "ACACIA_HANGING_SIGN": $Block
static readonly "MAGENTA_SHULKER_BOX": $Block
static readonly "QUARTZ_PILLAR": $Block
static readonly "WARPED_TRAPDOOR": $Block
static readonly "BROWN_CANDLE_CAKE": $Block
static readonly "STRIPPED_BAMBOO_BLOCK": $Block
static readonly "PURPLE_WALL_BANNER": $Block
static readonly "REDSTONE_BLOCK": $Block
static readonly "COBBLED_DEEPSLATE_WALL": $Block
static readonly "DEAD_BUBBLE_CORAL_WALL_FAN": $Block
static readonly "CHISELED_POLISHED_BLACKSTONE": $Block
static readonly "BIRCH_SLAB": $Block
static readonly "EXPOSED_CHISELED_COPPER": $Block
static readonly "LIME_SHULKER_BOX": $Block
static readonly "QUARTZ_SLAB": $Block
static readonly "OXIDIZED_COPPER_GRATE": $Block
static readonly "QUARTZ_BLOCK": $Block
static readonly "SNOW": $Block
static readonly "SUGAR_CANE": $Block
static readonly "BRAIN_CORAL_WALL_FAN": $Block
static readonly "ACACIA_FENCE": $Block
static readonly "DARK_OAK_FENCE": $Block
static readonly "HORN_CORAL": $Block
static readonly "TUBE_CORAL_FAN": $Block
static readonly "POTTED_CHERRY_SAPLING": $Block
static readonly "MOSSY_COBBLESTONE": $Block
static readonly "DAYLIGHT_DETECTOR": $Block
static readonly "WARPED_FENCE": $Block
static readonly "POLISHED_TUFF_WALL": $Block
static readonly "BUBBLE_CORAL": $Block
static readonly "JUNGLE_STAIRS": $Block
static readonly "CYAN_CARPET": $Block
static readonly "OXIDIZED_COPPER_DOOR": $Block
static readonly "OBSERVER": $Block
static readonly "DEEPSLATE_DIAMOND_ORE": $Block
static readonly "AMETHYST_BLOCK": $Block
static readonly "SPRUCE_TRAPDOOR": $Block
static readonly "CHERRY_STAIRS": $Block
static readonly "CUT_COPPER": $Block
static readonly "BLAST_FURNACE": $Block
static readonly "OBSIDIAN": $Block
static readonly "RED_SANDSTONE_SLAB": $Block
static readonly "FIRE_CORAL_FAN": $Block
static readonly "AZURE_BLUET": $Block
static readonly "BAMBOO_WALL_SIGN": $Block
static readonly "PURPLE_STAINED_GLASS_PANE": $Block
static readonly "LIME_GLAZED_TERRACOTTA": $Block
static readonly "CARTOGRAPHY_TABLE": $Block
static readonly "ORANGE_CANDLE": $Block
static readonly "WITHER_ROSE": $Block
static readonly "PISTON": $Block
static readonly "DEAD_BRAIN_CORAL_FAN": $Block
static readonly "BLACK_CANDLE": $Block
static readonly "YELLOW_BANNER": $Block
static readonly "CUT_RED_SANDSTONE": $Block
static readonly "BIRCH_SAPLING": $Block
static readonly "LIME_CONCRETE": $Block
static readonly "BEETROOTS": $Block
static readonly "PURPUR_SLAB": $Block
static readonly "PURPLE_BANNER": $Block
static readonly "PURPLE_CONCRETE_POWDER": $Block
static readonly "BIRCH_LOG": $Block
static readonly "DEEPSLATE_BRICK_WALL": $Block
static readonly "DARK_PRISMARINE_SLAB": $Block
static readonly "ACACIA_PLANKS": $Block
static readonly "MYCELIUM": $Block
static readonly "RED_SANDSTONE": $Block
static readonly "BROWN_CONCRETE": $Block
static readonly "PRISMARINE_BRICK_STAIRS": $Block
static readonly "CAVE_VINES": $Block
static readonly "STONE_SLAB": $Block
static readonly "LIME_WALL_BANNER": $Block
static readonly "MANGROVE_WALL_SIGN": $Block
static readonly "BIRCH_LEAVES": $Block
static readonly "CHERRY_WALL_HANGING_SIGN": $Block
static readonly "BLUE_CANDLE_CAKE": $Block
static readonly "BAMBOO_FENCE_GATE": $Block
static readonly "DEEPSLATE_GOLD_ORE": $Block
static readonly "NETHER_BRICK_FENCE": $Block
static readonly "BROWN_MUSHROOM": $Block
static readonly "TUFF_BRICK_SLAB": $Block
static readonly "CYAN_SHULKER_BOX": $Block
static readonly "POLISHED_BLACKSTONE_SLAB": $Block
static readonly "WAXED_EXPOSED_CHISELED_COPPER": $Block
static readonly "JUNGLE_WALL_HANGING_SIGN": $Block
static readonly "NETHERITE_BLOCK": $Block
static readonly "ACACIA_PRESSURE_PLATE": $Block
static readonly "RED_SAND": $Block
static readonly "PACKED_MUD": $Block
static readonly "POLISHED_GRANITE_STAIRS": $Block
static readonly "MAGENTA_BANNER": $Block
static readonly "QUARTZ_STAIRS": $Block
static readonly "DRIED_KELP_BLOCK": $Block
static readonly "SCULK_VEIN": $Block
static readonly "BREWING_STAND": $Block
static readonly "CACTUS": $Block
static readonly "CAKE": $Block
static readonly "SMOOTH_QUARTZ_SLAB": $Block
static readonly "STRIPPED_ACACIA_WOOD": $Block
static readonly "BAMBOO_MOSAIC_SLAB": $Block
static readonly "LIGHT_GRAY_BANNER": $Block
static readonly "GREEN_BANNER": $Block
static readonly "SPRUCE_SIGN": $Block
static readonly "BLUE_STAINED_GLASS": $Block
static readonly "CHISELED_TUFF_BRICKS": $Block
static readonly "STRIPPED_BIRCH_WOOD": $Block
static readonly "SLIME_BLOCK": $Block
static readonly "RED_MUSHROOM": $Block
static readonly "BAMBOO_FENCE": $Block
static readonly "SPRUCE_SAPLING": $Block
static readonly "LIGHT_BLUE_STAINED_GLASS": $Block
static readonly "EXPOSED_COPPER_DOOR": $Block
static readonly "POLISHED_GRANITE_SLAB": $Block
static readonly "SMOOTH_RED_SANDSTONE_STAIRS": $Block
static readonly "WAXED_COPPER_TRAPDOOR": $Block
static readonly "BRAIN_CORAL": $Block
static readonly "COMPARATOR": $Block
static readonly "REDSTONE_ORE": $Block
static readonly "STRIPPED_CRIMSON_HYPHAE": $Block
static readonly "DRAGON_WALL_HEAD": $Block
static readonly "PINK_CANDLE": $Block
static readonly "DEAD_FIRE_CORAL_BLOCK": $Block
static readonly "MAGENTA_CANDLE_CAKE": $Block
static readonly "WITHER_SKELETON_SKULL": $Block
static readonly "RED_SANDSTONE_WALL": $Block
static readonly "LIGHT_GRAY_TERRACOTTA": $Block
static readonly "LIGHT_BLUE_STAINED_GLASS_PANE": $Block
static readonly "GRASS_BLOCK": $Block
static readonly "EXPOSED_COPPER_TRAPDOOR": $Block
static readonly "MAGENTA_STAINED_GLASS": $Block
static readonly "CRIMSON_PRESSURE_PLATE": $Block
static readonly "COAL_ORE": $Block
static readonly "DEEPSLATE_BRICKS": $Block
static readonly "WAXED_EXPOSED_COPPER_BULB": $Block
static readonly "ICE": $Block
static readonly "PURPLE_SHULKER_BOX": $Block
static readonly "GRAY_CANDLE_CAKE": $Block
static readonly "LIGHT_GRAY_CONCRETE_POWDER": $Block
static readonly "STRIPPED_OAK_WOOD": $Block
static readonly "DEEPSLATE_BRICK_SLAB": $Block
static readonly "GOLD_ORE": $Block
static readonly "GREEN_CARPET": $Block
static readonly "OCHRE_FROGLIGHT": $Block
static readonly "POLISHED_BLACKSTONE": $Block
static readonly "CLAY": $Block
static readonly "TUBE_CORAL_BLOCK": $Block
static readonly "LILAC": $Block
static readonly "RED_SANDSTONE_STAIRS": $Block
static readonly "STRIPPED_CHERRY_LOG": $Block
static readonly "DEAD_BRAIN_CORAL_WALL_FAN": $Block
static readonly "WAXED_CUT_COPPER_STAIRS": $Block
static readonly "DARK_PRISMARINE": $Block
static readonly "WAXED_EXPOSED_COPPER_GRATE": $Block
static readonly "NETHER_SPROUTS": $Block
static readonly "BUBBLE_CORAL_BLOCK": $Block
static readonly "BLUE_GLAZED_TERRACOTTA": $Block
static readonly "ACACIA_FENCE_GATE": $Block
static readonly "BRICK_WALL": $Block
static readonly "GLOW_LICHEN": $Block
static readonly "CHERRY_DOOR": $Block
static readonly "WITHER_SKELETON_WALL_SKULL": $Block
static readonly "BIRCH_FENCE_GATE": $Block
static readonly "LIGHT_GRAY_CONCRETE": $Block
static readonly "MOSSY_COBBLESTONE_STAIRS": $Block
static readonly "OXIDIZED_CUT_COPPER_SLAB": $Block
static readonly "DARK_OAK_TRAPDOOR": $Block
static readonly "YELLOW_TERRACOTTA": $Block
static readonly "PITCHER_CROP": $Block
static readonly "WEATHERED_CHISELED_COPPER": $Block
static readonly "CHISELED_RED_SANDSTONE": $Block
static readonly "JUNGLE_WOOD": $Block
static readonly "CRACKED_DEEPSLATE_TILES": $Block
static readonly "WHITE_BANNER": $Block
static readonly "ACACIA_DOOR": $Block
static readonly "FLOWERING_AZALEA": $Block
static readonly "MOSSY_STONE_BRICKS": $Block
static readonly "PRISMARINE": $Block
static readonly "WARPED_BUTTON": $Block
static readonly "DEAD_TUBE_CORAL_BLOCK": $Block
static readonly "TUFF_SLAB": $Block
static readonly "SMOOTH_SANDSTONE": $Block
static readonly "DIAMOND_BLOCK": $Block
static readonly "OAK_SAPLING": $Block
static readonly "POLISHED_DEEPSLATE_SLAB": $Block
static readonly "LAVA": $Block
static readonly "MANGROVE_FENCE_GATE": $Block
static readonly "CHISELED_DEEPSLATE": $Block
static readonly "STONE_BRICK_SLAB": $Block
static readonly "CUT_COPPER_STAIRS": $Block
static readonly "GRAY_CONCRETE": $Block
static readonly "DARK_OAK_LEAVES": $Block
static readonly "EXPOSED_COPPER_GRATE": $Block
static readonly "BAMBOO_PRESSURE_PLATE": $Block
static readonly "MELON": $Block
static readonly "SEA_LANTERN": $Block
static readonly "GREEN_CONCRETE": $Block
static readonly "LANTERN": $Block
static readonly "ORANGE_WALL_BANNER": $Block
static readonly "VOID_AIR": $Block
static readonly "SMOOTH_STONE_SLAB": $Block
static readonly "SMOOTH_STONE": $Block
static readonly "GREEN_STAINED_GLASS_PANE": $Block
static readonly "ORANGE_CONCRETE": $Block
static readonly "RED_NETHER_BRICKS": $Block
static readonly "MANGROVE_DOOR": $Block
static readonly "CYAN_CONCRETE_POWDER": $Block
static readonly "WAXED_COPPER_BLOCK": $Block
static readonly "SMOKER": $Block
static readonly "BIRCH_PLANKS": $Block
static readonly "TRIPWIRE": $Block
static readonly "REPEATING_COMMAND_BLOCK": $Block
static readonly "RED_CONCRETE_POWDER": $Block
static readonly "BIRCH_DOOR": $Block
static readonly "CRIMSON_SIGN": $Block
static readonly "CRIMSON_TRAPDOOR": $Block
static readonly "CHISELED_COPPER": $Block
static readonly "WEATHERED_COPPER_TRAPDOOR": $Block
static readonly "BLUE_CARPET": $Block
static readonly "DEEPSLATE_TILE_SLAB": $Block
static readonly "DRAGON_EGG": $Block
static readonly "SANDSTONE": $Block
static readonly "CRIMSON_STAIRS": $Block
static readonly "EXPOSED_COPPER": $Block
static readonly "WEATHERED_CUT_COPPER_STAIRS": $Block
static readonly "COBBLED_DEEPSLATE_SLAB": $Block
static readonly "MOSS_CARPET": $Block
static readonly "ANVIL": $Block
static readonly "REPEATER": $Block
static readonly "CRIMSON_HANGING_SIGN": $Block
static readonly "OXIDIZED_COPPER_BULB": $Block
static readonly "DEAD_BRAIN_CORAL": $Block
static readonly "BOOKSHELF": $Block
static readonly "SMOOTH_QUARTZ_STAIRS": $Block
static readonly "LIGHT_BLUE_CANDLE": $Block
static readonly "SPRUCE_WOOD": $Block
static readonly "BLACK_TERRACOTTA": $Block
static readonly "STONE_STAIRS": $Block
static readonly "POLISHED_TUFF_SLAB": $Block
static readonly "LIME_WOOL": $Block
static readonly "SPRUCE_FENCE": $Block
static readonly "OAK_PRESSURE_PLATE": $Block
static readonly "HONEY_BLOCK": $Block
static readonly "STRIPPED_DARK_OAK_WOOD": $Block
static readonly "MEDIUM_AMETHYST_BUD": $Block
static readonly "BIRCH_STAIRS": $Block
static readonly "POTTED_BAMBOO": $Block
static readonly "MANGROVE_BUTTON": $Block
static readonly "BIRCH_TRAPDOOR": $Block
static readonly "COMPOSTER": $Block
static readonly "ORANGE_STAINED_GLASS": $Block
static readonly "DECORATED_POT": $Block
static readonly "GLASS": $Block
static readonly "STRIPPED_MANGROVE_LOG": $Block
static readonly "CHERRY_PLANKS": $Block
static readonly "SOUL_SAND": $Block
static readonly "GREEN_STAINED_GLASS": $Block
static readonly "GRAY_STAINED_GLASS_PANE": $Block
static readonly "POTTED_FLOWERING_AZALEA": $Block
static readonly "BLUE_WOOL": $Block
static readonly "MAGENTA_WOOL": $Block
static readonly "BAMBOO_DOOR": $Block
static readonly "PITCHER_PLANT": $Block
static readonly "DEAD_HORN_CORAL": $Block
static readonly "PINK_BED": $Block
static readonly "CYAN_CANDLE": $Block
static readonly "POPPY": $Block
static readonly "CYAN_TERRACOTTA": $Block
static readonly "TRIPWIRE_HOOK": $Block
static readonly "PACKED_ICE": $Block
static readonly "YELLOW_CONCRETE": $Block
static readonly "WEATHERED_COPPER_DOOR": $Block
static readonly "ACACIA_STAIRS": $Block
static readonly "VINE": $Block
static readonly "POTTED_SPRUCE_SAPLING": $Block
static readonly "BUBBLE_COLUMN": $Block
static readonly "INFESTED_STONE_BRICKS": $Block
static readonly "COPPER_ORE": $Block
static readonly "BAMBOO_TRAPDOOR": $Block
static readonly "PODZOL": $Block
static readonly "WARPED_WART_BLOCK": $Block
static readonly "POLISHED_BLACKSTONE_WALL": $Block
static readonly "WARPED_NYLIUM": $Block
static readonly "STRIPPED_CRIMSON_STEM": $Block
static readonly "POTTED_ALLIUM": $Block
static readonly "BLUE_BED": $Block
static readonly "DEAD_FIRE_CORAL": $Block
static readonly "BLACK_WALL_BANNER": $Block
static readonly "BLACK_CARPET": $Block
static readonly "MUD": $Block
static readonly "PINK_TERRACOTTA": $Block
static readonly "POTTED_LILY_OF_THE_VALLEY": $Block
static readonly "FIRE_CORAL_BLOCK": $Block
static readonly "WARPED_WALL_HANGING_SIGN": $Block
static readonly "GRAY_GLAZED_TERRACOTTA": $Block
static readonly "CHERRY_LEAVES": $Block
static readonly "WEATHERED_COPPER_GRATE": $Block
static readonly "JUNGLE_FENCE": $Block
static readonly "SPAWNER": $Block
static readonly "POLISHED_BASALT": $Block
static readonly "WARPED_FUNGUS": $Block
static readonly "GRAY_WALL_BANNER": $Block
static readonly "WHITE_CONCRETE_POWDER": $Block
static readonly "RAIL": $Block
static readonly "GRAY_TERRACOTTA": $Block
static readonly "NETHER_PORTAL": $Block
static readonly "BEDROCK": $Block
static readonly "INFESTED_DEEPSLATE": $Block
static readonly "SHROOMLIGHT": $Block
static readonly "CHAIN_COMMAND_BLOCK": $Block
static readonly "CYAN_GLAZED_TERRACOTTA": $Block
static readonly "WAXED_WEATHERED_CUT_COPPER_SLAB": $Block
static readonly "STRIPPED_DARK_OAK_LOG": $Block
static readonly "GRAY_WOOL": $Block
static readonly "CYAN_WALL_BANNER": $Block
static readonly "DARK_OAK_SLAB": $Block
static readonly "OAK_SIGN": $Block
static readonly "RED_CONCRETE": $Block
static readonly "CRACKED_POLISHED_BLACKSTONE_BRICKS": $Block
static readonly "BEEHIVE": $Block
static readonly "WAXED_OXIDIZED_COPPER_DOOR": $Block
static readonly "GRAY_SHULKER_BOX": $Block
static readonly "WARPED_DOOR": $Block
static readonly "OAK_FENCE": $Block
static readonly "NETHER_BRICKS": $Block
static readonly "RED_CANDLE": $Block
static readonly "PURPLE_CANDLE_CAKE": $Block
static readonly "FLETCHING_TABLE": $Block
static readonly "BIG_DRIPLEAF_STEM": $Block
static readonly "GRAY_BANNER": $Block
static readonly "JUNGLE_FENCE_GATE": $Block
static readonly "MAGENTA_CONCRETE": $Block
static readonly "LIGHT_BLUE_WALL_BANNER": $Block
static readonly "BLACK_SHULKER_BOX": $Block
static readonly "BUBBLE_CORAL_WALL_FAN": $Block
static readonly "FROGSPAWN": $Block
static readonly "JUNGLE_TRAPDOOR": $Block
static readonly "ACTIVATOR_RAIL": $Block
static readonly "OXIDIZED_CUT_COPPER_STAIRS": $Block
static readonly "DIRT_PATH": $Block
static readonly "FROSTED_ICE": $Block
static readonly "ORANGE_CARPET": $Block
static readonly "PINK_CARPET": $Block
static readonly "STRUCTURE_VOID": $Block
static readonly "POWDER_SNOW_CAULDRON": $Block
static readonly "POTTED_ACACIA_SAPLING": $Block
static readonly "STONECUTTER": $Block
static readonly "LIME_CONCRETE_POWDER": $Block
static readonly "PINK_BANNER": $Block
static readonly "POLISHED_BLACKSTONE_PRESSURE_PLATE": $Block
static readonly "GREEN_WOOL": $Block
static readonly "HORN_CORAL_FAN": $Block
static readonly "POTTED_WARPED_ROOTS": $Block
static readonly "DEAD_HORN_CORAL_WALL_FAN": $Block
static readonly "CHERRY_FENCE": $Block
static readonly "OAK_WALL_HANGING_SIGN": $Block
static readonly "MOSSY_COBBLESTONE_SLAB": $Block
static readonly "BAMBOO_SAPLING": $Block
static readonly "DARK_PRISMARINE_STAIRS": $Block
static readonly "TWISTING_VINES": $Block
static readonly "LIME_BANNER": $Block
static readonly "PINK_CONCRETE": $Block
static readonly "RED_CANDLE_CAKE": $Block
static readonly "JUNGLE_BUTTON": $Block
static readonly "WAXED_WEATHERED_COPPER": $Block
static readonly "MUSHROOM_STEM": $Block
static readonly "BLUE_TERRACOTTA": $Block
static readonly "BROWN_MUSHROOM_BLOCK": $Block
static readonly "DEAD_TUBE_CORAL_FAN": $Block
static readonly "MAGENTA_GLAZED_TERRACOTTA": $Block
static readonly "CHISELED_BOOKSHELF": $Block
static readonly "TUFF_WALL": $Block
static readonly "POTTED_CACTUS": $Block
static readonly "DEAD_BUBBLE_CORAL": $Block
static readonly "WHITE_GLAZED_TERRACOTTA": $Block
static readonly "POTTED_BIRCH_SAPLING": $Block
static readonly "DEAD_FIRE_CORAL_WALL_FAN": $Block
static readonly "WAXED_OXIDIZED_COPPER": $Block
static readonly "GREEN_BED": $Block
static readonly "BROWN_WALL_BANNER": $Block
static readonly "CAULDRON": $Block
static readonly "POLISHED_ANDESITE_STAIRS": $Block
static readonly "POTTED_OAK_SAPLING": $Block
static readonly "CHERRY_FENCE_GATE": $Block
static readonly "EMERALD_BLOCK": $Block
static readonly "POTTED_TORCHFLOWER": $Block
static readonly "LIME_STAINED_GLASS_PANE": $Block
static readonly "ORANGE_BANNER": $Block
static readonly "WAXED_WEATHERED_CHISELED_COPPER": $Block
static readonly "CAVE_AIR": $Block
static readonly "LIGHT_BLUE_GLAZED_TERRACOTTA": $Block
static readonly "PINK_STAINED_GLASS": $Block
static readonly "OXIDIZED_COPPER": $Block
static readonly "SPRUCE_STAIRS": $Block
static readonly "BLUE_ICE": $Block
static readonly "SCAFFOLDING": $Block
static readonly "BLUE_SHULKER_BOX": $Block
static readonly "HORN_CORAL_BLOCK": $Block
static readonly "CRIMSON_SLAB": $Block
static readonly "RESPAWN_ANCHOR": $Block
static readonly "POTTED_JUNGLE_SAPLING": $Block
static readonly "KELP": $Block
static readonly "COPPER_BLOCK": $Block
static readonly "STRIPPED_WARPED_HYPHAE": $Block
static readonly "STRIPPED_JUNGLE_LOG": $Block
static readonly "ANDESITE_SLAB": $Block
static readonly "SUSPICIOUS_GRAVEL": $Block
static readonly "ATTACHED_MELON_STEM": $Block
static readonly "POTTED_CRIMSON_ROOTS": $Block
static readonly "GOLD_BLOCK": $Block
static readonly "CRIMSON_PLANKS": $Block
static readonly "DARK_OAK_FENCE_GATE": $Block
static readonly "SPRUCE_PRESSURE_PLATE": $Block
static readonly "ACACIA_LEAVES": $Block
static readonly "COBBLESTONE_SLAB": $Block
static readonly "HEAVY_WEIGHTED_PRESSURE_PLATE": $Block
static readonly "PINK_CONCRETE_POWDER": $Block
static readonly "WAXED_COPPER_GRATE": $Block
static readonly "LIGHT_BLUE_CONCRETE_POWDER": $Block
static readonly "WHITE_BED": $Block
static readonly "CHISELED_TUFF": $Block
static readonly "BUBBLE_CORAL_FAN": $Block
static readonly "YELLOW_CANDLE_CAKE": $Block
static readonly "ACACIA_WALL_HANGING_SIGN": $Block
static readonly "JUNGLE_LOG": $Block
static readonly "NOTE_BLOCK": $Block
static readonly "MANGROVE_SIGN": $Block
static readonly "WARPED_HYPHAE": $Block
static readonly "CHERRY_SIGN": $Block
static readonly "TORCHFLOWER_CROP": $Block
static readonly "SPRUCE_SLAB": $Block
static readonly "PEONY": $Block
static readonly "OXEYE_DAISY": $Block
static readonly "OAK_HANGING_SIGN": $Block
static readonly "ACACIA_SIGN": $Block
static readonly "STRIPPED_WARPED_STEM": $Block
static readonly "BEACON": $Block
static readonly "WAXED_OXIDIZED_CUT_COPPER": $Block
static readonly "MOSS_BLOCK": $Block
static readonly "HONEYCOMB_BLOCK": $Block
static readonly "POTTED_FERN": $Block
static readonly "NETHER_BRICK_STAIRS": $Block
static readonly "COBWEB": $Block
static readonly "POTTED_WITHER_ROSE": $Block
static readonly "DARK_OAK_WALL_SIGN": $Block
static readonly "OAK_LOG": $Block
static readonly "STRIPPED_JUNGLE_WOOD": $Block
static readonly "DEAD_BRAIN_CORAL_BLOCK": $Block
static readonly "MUDDY_MANGROVE_ROOTS": $Block
static readonly "TINTED_GLASS": $Block
static readonly "MAGENTA_CANDLE": $Block
static readonly "YELLOW_BED": $Block
static readonly "LIGHT_GRAY_CANDLE": $Block
static readonly "END_GATEWAY": $Block
static readonly "POTTED_WARPED_FUNGUS": $Block
static readonly "POTTED_DARK_OAK_SAPLING": $Block
static readonly "CHISELED_QUARTZ_BLOCK": $Block
static readonly "LIME_CARPET": $Block
static readonly "DEEPSLATE_EMERALD_ORE": $Block
static readonly "MUD_BRICK_SLAB": $Block
static readonly "PURPLE_GLAZED_TERRACOTTA": $Block
static readonly "IRON_BARS": $Block
static readonly "WHITE_CONCRETE": $Block
static readonly "STONE": $Block
static readonly "YELLOW_WOOL": $Block
static readonly "CAVE_VINES_PLANT": $Block
static readonly "ROSE_BUSH": $Block
static readonly "MUD_BRICKS": $Block
static readonly "BROWN_CARPET": $Block
static readonly "WAXED_CHISELED_COPPER": $Block
static readonly "STRIPPED_CHERRY_WOOD": $Block
static readonly "BLACKSTONE_STAIRS": $Block
static readonly "WHITE_CANDLE_CAKE": $Block
static readonly "REDSTONE_WALL_TORCH": $Block
static readonly "BLACK_CANDLE_CAKE": $Block
static readonly "ACACIA_LOG": $Block
static readonly "INFESTED_MOSSY_STONE_BRICKS": $Block
static readonly "ORANGE_GLAZED_TERRACOTTA": $Block
static readonly "MUD_BRICK_STAIRS": $Block
static readonly "MAGENTA_CONCRETE_POWDER": $Block
static readonly "TNT": $Block
static readonly "BELL": $Block
static readonly "TWISTING_VINES_PLANT": $Block
static readonly "BLACKSTONE_SLAB": $Block
static readonly "TORCHFLOWER": $Block
static readonly "SPRUCE_HANGING_SIGN": $Block
static readonly "STRIPPED_ACACIA_LOG": $Block
static readonly "RAW_IRON_BLOCK": $Block
static readonly "BROWN_BANNER": $Block
static readonly "AIR": $Block
static readonly "GRANITE_STAIRS": $Block
static readonly "BEE_NEST": $Block
static readonly "CHEST": $Block
static readonly "PINK_PETALS": $Block
static readonly "SCULK_SENSOR": $Block
static readonly "OAK_DOOR": $Block
static readonly "MANGROVE_FENCE": $Block
static readonly "LILY_PAD": $Block
static readonly "SMALL_DRIPLEAF": $Block
static readonly "PURPUR_STAIRS": $Block
static readonly "EXPOSED_CUT_COPPER_SLAB": $Block
static readonly "LADDER": $Block
static readonly "RED_MUSHROOM_BLOCK": $Block
static readonly "WALL_TORCH": $Block
static readonly "CRAFTER": $Block
static readonly "BASALT": $Block
static readonly "MAGENTA_WALL_BANNER": $Block
static readonly "BAMBOO_SIGN": $Block
static readonly "TALL_GRASS": $Block
static readonly "DEAD_BUSH": $Block
static readonly "EXPOSED_CUT_COPPER_STAIRS": $Block
static readonly "PETRIFIED_OAK_SLAB": $Block
static readonly "MUD_BRICK_WALL": $Block
static readonly "LIGHT_BLUE_CARPET": $Block
static readonly "MANGROVE_WALL_HANGING_SIGN": $Block
static readonly "CALIBRATED_SCULK_SENSOR": $Block
static readonly "SCULK_CATALYST": $Block
static readonly "WAXED_OXIDIZED_CUT_COPPER_STAIRS": $Block
static readonly "WARPED_ROOTS": $Block
static readonly "CHAIN": $Block
static readonly "FIRE_CORAL": $Block
static readonly "DEEPSLATE_IRON_ORE": $Block
static readonly "WAXED_OXIDIZED_COPPER_BULB": $Block
static readonly "CHISELED_NETHER_BRICKS": $Block
static readonly "LIGHT_GRAY_STAINED_GLASS_PANE": $Block
static readonly "COAL_BLOCK": $Block
static readonly "WHITE_STAINED_GLASS": $Block
static readonly "WEATHERED_CUT_COPPER": $Block
static readonly "PURPUR_PILLAR": $Block
static readonly "CALCITE": $Block
static readonly "ACACIA_TRAPDOOR": $Block
static readonly "CHERRY_WOOD": $Block
static readonly "WHITE_CARPET": $Block
static readonly "CRIMSON_STEM": $Block
static readonly "CHISELED_STONE_BRICKS": $Block
static readonly "RAW_GOLD_BLOCK": $Block
static readonly "JIGSAW": $Block
static readonly "PURPUR_BLOCK": $Block
static readonly "FURNACE": $Block
static readonly "JACK_O_LANTERN": $Block
static readonly "BLACK_BED": $Block
static readonly "BIRCH_PRESSURE_PLATE": $Block
static readonly "DEEPSLATE_LAPIS_ORE": $Block
static readonly "WAXED_OXIDIZED_CHISELED_COPPER": $Block
static readonly "LARGE_FERN": $Block
static readonly "SNIFFER_EGG": $Block
static readonly "BAMBOO_WALL_HANGING_SIGN": $Block
static readonly "PURPLE_TERRACOTTA": $Block
static readonly "CUT_RED_SANDSTONE_SLAB": $Block
static readonly "DIRT": $Block
static readonly "WEEPING_VINES": $Block
static readonly "COBBLED_DEEPSLATE": $Block
static readonly "GRAY_BED": $Block
static readonly "BONE_BLOCK": $Block
static readonly "LIGHT_BLUE_CANDLE_CAKE": $Block
static readonly "POLISHED_DIORITE": $Block
static readonly "CUT_SANDSTONE": $Block
static readonly "WHITE_TERRACOTTA": $Block
static readonly "MOSSY_COBBLESTONE_WALL": $Block
static readonly "GRINDSTONE": $Block
static readonly "POWERED_RAIL": $Block
static readonly "JUNGLE_SIGN": $Block
static readonly "DARK_OAK_PLANKS": $Block
static readonly "ACACIA_WOOD": $Block
static readonly "END_STONE_BRICK_SLAB": $Block
static readonly "MANGROVE_WOOD": $Block
static readonly "LIGHT_GRAY_STAINED_GLASS": $Block
static readonly "PIGLIN_WALL_HEAD": $Block
static readonly "POTTED_OXEYE_DAISY": $Block
static readonly "CHERRY_WALL_SIGN": $Block
static readonly "SEAGRASS": $Block
static readonly "WEATHERED_COPPER": $Block
static readonly "WAXED_WEATHERED_COPPER_GRATE": $Block
static readonly "OAK_PLANKS": $Block
static readonly "DEAD_TUBE_CORAL_WALL_FAN": $Block
static readonly "END_PORTAL_FRAME": $Block
static readonly "WAXED_OXIDIZED_COPPER_TRAPDOOR": $Block
static readonly "DEEPSLATE_COAL_ORE": $Block
static readonly "FLOWER_POT": $Block
static readonly "HEAVY_CORE": $Block
static readonly "RED_TERRACOTTA": $Block
static readonly "WAXED_EXPOSED_CUT_COPPER": $Block
static readonly "WARPED_SIGN": $Block
static readonly "COPPER_BULB": $Block
static readonly "SWEET_BERRY_BUSH": $Block
static readonly "SNOW_BLOCK": $Block
static readonly "CRIMSON_FENCE": $Block
static readonly "POLISHED_DIORITE_SLAB": $Block
static readonly "LAVA_CAULDRON": $Block
static readonly "BRAIN_CORAL_BLOCK": $Block
static readonly "MOSSY_STONE_BRICK_SLAB": $Block
static readonly "STONE_BRICKS": $Block
static readonly "SANDSTONE_STAIRS": $Block
static readonly "BROWN_BED": $Block
static readonly "MANGROVE_LEAVES": $Block
static readonly "POTTED_DANDELION": $Block
static readonly "SMOOTH_SANDSTONE_SLAB": $Block
static readonly "CHERRY_TRAPDOOR": $Block
static readonly "ATTACHED_PUMPKIN_STEM": $Block
static readonly "MAGENTA_TERRACOTTA": $Block
static readonly "SMOOTH_SANDSTONE_STAIRS": $Block
static readonly "SPRUCE_PLANKS": $Block
static readonly "DRAGON_HEAD": $Block
static readonly "CHERRY_SAPLING": $Block
static readonly "FIRE": $Block
static readonly "ANDESITE_WALL": $Block
static readonly "BLACK_WOOL": $Block
static readonly "LIGHT_GRAY_CARPET": $Block
static readonly "PURPLE_CONCRETE": $Block
static readonly "LIGHTNING_ROD": $Block
static readonly "CYAN_BED": $Block
static readonly "CHERRY_HANGING_SIGN": $Block
static readonly "LARGE_AMETHYST_BUD": $Block
static readonly "RED_SHULKER_BOX": $Block
static readonly "PEARLESCENT_FROGLIGHT": $Block
static readonly "REDSTONE_TORCH": $Block
static readonly "MAGENTA_CARPET": $Block
static readonly "STICKY_PISTON": $Block
static readonly "CRIMSON_ROOTS": $Block
static readonly "PUMPKIN": $Block
static readonly "SMOOTH_QUARTZ": $Block
static readonly "FLOWERING_AZALEA_LEAVES": $Block
static readonly "NETHER_WART_BLOCK": $Block
static readonly "COBBLED_DEEPSLATE_STAIRS": $Block
static readonly "COBBLESTONE_WALL": $Block
static readonly "WHEAT": $Block
static readonly "BLUE_WALL_BANNER": $Block
static readonly "DEAD_FIRE_CORAL_FAN": $Block
static readonly "LIME_CANDLE": $Block
static readonly "ACACIA_SLAB": $Block
static readonly "CRIMSON_NYLIUM": $Block
static readonly "ORANGE_CANDLE_CAKE": $Block
static readonly "OXIDIZED_COPPER_TRAPDOOR": $Block
static readonly "ORANGE_TERRACOTTA": $Block
static readonly "BLACK_CONCRETE": $Block
static readonly "DROPPER": $Block
static readonly "AZALEA": $Block
static readonly "POTTED_POPPY": $Block
static readonly "MOSSY_STONE_BRICK_STAIRS": $Block
static readonly "WARPED_HANGING_SIGN": $Block
static readonly "OAK_STAIRS": $Block
static readonly "BLACK_STAINED_GLASS": $Block
static readonly "IRON_TRAPDOOR": $Block
static readonly "KELP_PLANT": $Block
static readonly "PINK_CANDLE_CAKE": $Block
static readonly "INFESTED_CHISELED_STONE_BRICKS": $Block
static readonly "BLUE_BANNER": $Block
static readonly "POLISHED_DIORITE_STAIRS": $Block
static readonly "WARPED_PRESSURE_PLATE": $Block
static readonly "HORN_CORAL_WALL_FAN": $Block
static readonly "BAMBOO_HANGING_SIGN": $Block
static readonly "OAK_SLAB": $Block
static readonly "POINTED_DRIPSTONE": $Block
static readonly "WAXED_EXPOSED_COPPER": $Block
static readonly "PURPLE_CANDLE": $Block
static readonly "CRIMSON_FUNGUS": $Block
static readonly "DARK_OAK_HANGING_SIGN": $Block
static readonly "DARK_OAK_SAPLING": $Block
static readonly "ACACIA_BUTTON": $Block
static readonly "EMERALD_ORE": $Block
static readonly "POLISHED_DEEPSLATE_STAIRS": $Block
static readonly "LIGHT_GRAY_CANDLE_CAKE": $Block
static readonly "OAK_FENCE_GATE": $Block
static readonly "POTTED_WHITE_TULIP": $Block
static readonly "POLISHED_BLACKSTONE_STAIRS": $Block
static readonly "WAXED_CUT_COPPER_SLAB": $Block
static readonly "BAMBOO_BLOCK": $Block
static readonly "SUNFLOWER": $Block
static readonly "CAMPFIRE": $Block
static readonly "SANDSTONE_SLAB": $Block
static readonly "MANGROVE_PRESSURE_PLATE": $Block
static readonly "SPRUCE_BUTTON": $Block
static readonly "POTTED_MANGROVE_PROPAGULE": $Block
static readonly "CYAN_WOOL": $Block
static readonly "JUNGLE_HANGING_SIGN": $Block
static readonly "ZOMBIE_WALL_HEAD": $Block
static readonly "TARGET": $Block
static readonly "PRISMARINE_BRICK_SLAB": $Block
static readonly "LOOM": $Block
static readonly "DRIPSTONE_BLOCK": $Block
static readonly "CREEPER_HEAD": $Block
static readonly "BAMBOO_PLANKS": $Block
static readonly "NETHER_QUARTZ_ORE": $Block
static readonly "DEAD_BUBBLE_CORAL_FAN": $Block
static readonly "SUSPICIOUS_SAND": $Block
static readonly "BLACK_BANNER": $Block
static readonly "COPPER_DOOR": $Block
static readonly "WAXED_COPPER_DOOR": $Block
static readonly "LIGHT_BLUE_BED": $Block
static readonly "BIRCH_WALL_SIGN": $Block
static readonly "PRISMARINE_WALL": $Block
static readonly "PINK_STAINED_GLASS_PANE": $Block
static readonly "WEATHERED_COPPER_BULB": $Block
static readonly "DIORITE_STAIRS": $Block
static readonly "BLACKSTONE_WALL": $Block
static readonly "BRICK_STAIRS": $Block
static readonly "END_PORTAL": $Block
static readonly "PLAYER_WALL_HEAD": $Block
static readonly "BIRCH_HANGING_SIGN": $Block
static readonly "DAMAGED_ANVIL": $Block
static readonly "PINK_WALL_BANNER": $Block
static readonly "BAMBOO": $Block
static readonly "CONDUIT": $Block
static readonly "JUNGLE_LEAVES": $Block
static readonly "RED_TULIP": $Block
static readonly "SPORE_BLOSSOM": $Block
static readonly "WAXED_WEATHERED_COPPER_DOOR": $Block
static readonly "DARK_OAK_STAIRS": $Block
static readonly "YELLOW_SHULKER_BOX": $Block
static readonly "PINK_GLAZED_TERRACOTTA": $Block
static readonly "CANDLE_CAKE": $Block
static readonly "DANDELION": $Block
static readonly "AZALEA_LEAVES": $Block
static readonly "COCOA": $Block
static readonly "RED_GLAZED_TERRACOTTA": $Block
static readonly "BAMBOO_MOSAIC": $Block
static readonly "WARPED_STEM": $Block
static readonly "OAK_TRAPDOOR": $Block
static readonly "YELLOW_CONCRETE_POWDER": $Block
static readonly "BAMBOO_BUTTON": $Block
static readonly "PURPLE_WOOL": $Block
static readonly "VAULT": $Block
static readonly "LIGHT_BLUE_BANNER": $Block
static readonly "END_STONE": $Block
static readonly "SPRUCE_FENCE_GATE": $Block
static readonly "GRAVEL": $Block
static readonly "BUDDING_AMETHYST": $Block
static readonly "CYAN_STAINED_GLASS": $Block
static readonly "LAPIS_ORE": $Block
static readonly "ORANGE_BED": $Block
static readonly "WAXED_WEATHERED_COPPER_TRAPDOOR": $Block
static readonly "BIG_DRIPLEAF": $Block
static readonly "POTTED_CORNFLOWER": $Block
static readonly "DISPENSER": $Block
static readonly "NETHER_BRICK_SLAB": $Block
static readonly "CYAN_CONCRETE": $Block
static readonly "SMITHING_TABLE": $Block
static readonly "IRON_ORE": $Block
static readonly "POLISHED_BLACKSTONE_BRICK_SLAB": $Block
static readonly "NETHERRACK": $Block
static readonly "RED_STAINED_GLASS_PANE": $Block
static readonly "GREEN_CANDLE_CAKE": $Block
static readonly "BROWN_SHULKER_BOX": $Block
static readonly "HANGING_ROOTS": $Block
static readonly "PRISMARINE_SLAB": $Block
static readonly "SMOOTH_RED_SANDSTONE": $Block
static readonly "BROWN_STAINED_GLASS": $Block
static readonly "BIRCH_WALL_HANGING_SIGN": $Block
static readonly "SKELETON_SKULL": $Block
static readonly "GREEN_WALL_BANNER": $Block
static readonly "END_STONE_BRICK_WALL": $Block
static readonly "POLISHED_TUFF_STAIRS": $Block
static readonly "TORCH": $Block
static readonly "ENDER_CHEST": $Block
static readonly "WAXED_OXIDIZED_COPPER_GRATE": $Block
static readonly "FERN": $Block
static readonly "BIRCH_SIGN": $Block
static readonly "POLISHED_GRANITE": $Block
static readonly "PINK_TULIP": $Block
static readonly "INFESTED_CRACKED_STONE_BRICKS": $Block
static readonly "JUNGLE_SAPLING": $Block
static readonly "TALL_SEAGRASS": $Block
static readonly "LEVER": $Block
static readonly "DEAD_BUBBLE_CORAL_BLOCK": $Block
static readonly "STONE_PRESSURE_PLATE": $Block
static readonly "TUFF": $Block
static readonly "POLISHED_BLACKSTONE_BRICK_STAIRS": $Block
static readonly "NETHER_GOLD_ORE": $Block
static readonly "LIME_BED": $Block
static readonly "POTTED_DEAD_BUSH": $Block
static readonly "QUARTZ_BRICKS": $Block
static readonly "POTTED_PINK_TULIP": $Block
static readonly "STRIPPED_OAK_LOG": $Block
static readonly "MANGROVE_SLAB": $Block
static readonly "END_ROD": $Block
static readonly "WARPED_PLANKS": $Block
static readonly "CHERRY_SLAB": $Block
static readonly "ORANGE_CONCRETE_POWDER": $Block
static readonly "ORANGE_WOOL": $Block
static readonly "PLAYER_HEAD": $Block
static readonly "LIME_TERRACOTTA": $Block
static readonly "MANGROVE_STAIRS": $Block
static readonly "TUFF_BRICKS": $Block
static readonly "WHITE_WOOL": $Block
static readonly "GRAY_CARPET": $Block
static readonly "GREEN_TERRACOTTA": $Block
static readonly "BROWN_CANDLE": $Block
static readonly "DARK_OAK_DOOR": $Block
static readonly "GREEN_SHULKER_BOX": $Block
static readonly "GRAY_CONCRETE_POWDER": $Block
static readonly "OXIDIZED_CUT_COPPER": $Block
static readonly "LIGHT_GRAY_WALL_BANNER": $Block
static readonly "WHITE_SHULKER_BOX": $Block
static readonly "CRIMSON_BUTTON": $Block
static readonly "IRON_BLOCK": $Block
static readonly "BLUE_CONCRETE": $Block
static readonly "REDSTONE_LAMP": $Block
static readonly "POLISHED_BLACKSTONE_BRICK_WALL": $Block
static readonly "PUMPKIN_STEM": $Block
static readonly "POTTED_BLUE_ORCHID": $Block
static readonly "POTATOES": $Block
static readonly "BIRCH_BUTTON": $Block
static readonly "HOPPER": $Block
static readonly "DARK_OAK_WALL_HANGING_SIGN": $Block
static readonly "LIGHT_WEIGHTED_PRESSURE_PLATE": $Block
static readonly "SOUL_SOIL": $Block
static readonly "YELLOW_CANDLE": $Block
static readonly "SOUL_TORCH": $Block
static readonly "LIGHT_BLUE_WOOL": $Block
static readonly "TUFF_BRICK_STAIRS": $Block
static readonly "ACACIA_WALL_SIGN": $Block
static readonly "POTTED_CRIMSON_FUNGUS": $Block
static readonly "LIGHT_GRAY_SHULKER_BOX": $Block
static readonly "WAXED_CUT_COPPER": $Block
static readonly "STRIPPED_MANGROVE_WOOD": $Block
static readonly "FIRE_CORAL_WALL_FAN": $Block
static readonly "CHERRY_LOG": $Block
static readonly "WAXED_WEATHERED_CUT_COPPER": $Block
static readonly "YELLOW_STAINED_GLASS_PANE": $Block
static readonly "CUT_COPPER_SLAB": $Block
static readonly "BLACKSTONE": $Block
static readonly "RED_NETHER_BRICK_SLAB": $Block
static readonly "LIME_CANDLE_CAKE": $Block
static readonly "MAGENTA_STAINED_GLASS_PANE": $Block
static readonly "DEAD_HORN_CORAL_FAN": $Block
static readonly "SHULKER_BOX": $Block
static readonly "DEAD_HORN_CORAL_BLOCK": $Block
static readonly "CARVED_PUMPKIN": $Block
static readonly "PINK_WOOL": $Block
static readonly "WEEPING_VINES_PLANT": $Block
static readonly "LIGHT_GRAY_WOOL": $Block
static readonly "JUNGLE_DOOR": $Block
static readonly "STONE_BUTTON": $Block
static readonly "GRANITE_SLAB": $Block
static readonly "CRACKED_NETHER_BRICKS": $Block
static readonly "LIGHT_GRAY_BED": $Block
static readonly "ACACIA_SAPLING": $Block
static readonly "POWDER_SNOW": $Block
static readonly "EXPOSED_COPPER_BULB": $Block
static readonly "BAMBOO_SLAB": $Block
static readonly "CRIMSON_WALL_HANGING_SIGN": $Block
static readonly "IRON_DOOR": $Block
static readonly "BROWN_STAINED_GLASS_PANE": $Block
static readonly "MOVING_PISTON": $Block
static readonly "WAXED_EXPOSED_CUT_COPPER_SLAB": $Block
static readonly "SOUL_WALL_TORCH": $Block
static readonly "BIRCH_WOOD": $Block
static readonly "LODESTONE": $Block
static readonly "SEA_PICKLE": $Block
static readonly "SPRUCE_LEAVES": $Block
static readonly "ORANGE_TULIP": $Block
static readonly "ANDESITE": $Block
static readonly "RED_NETHER_BRICK_STAIRS": $Block
static readonly "MANGROVE_PROPAGULE": $Block
static readonly "BROWN_GLAZED_TERRACOTTA": $Block
static readonly "BARREL": $Block
static readonly "OXIDIZED_CHISELED_COPPER": $Block
static readonly "INFESTED_STONE": $Block
static readonly "YELLOW_GLAZED_TERRACOTTA": $Block

constructor()

public static "never"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public static "never"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $EntityType$$Type<(never)>): boolean
public static "ocelotOrParrot"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $EntityType$$Type<(never)>): boolean
public static "rebuildCache"(): void
public static "register"(arg0: StringJS, arg1: $Block$$Type): $Block
public static "register"(arg0: $ResourceKey$$Type<($Block)>, arg1: $Block$$Type): $Block
public static "always"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $EntityType$$Type<(never)>): boolean
public static "always"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Blocks$$Type = ($Blocks);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Blocks$$Original = $Blocks;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.StraightTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $StraightTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($StraightTrunkPlacer)>
static readonly "MAX_HEIGHT": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StraightTrunkPlacer$$Type = ($StraightTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StraightTrunkPlacer$$Original = $StraightTrunkPlacer;}
declare module "net.minecraft.world.level.material.FlowingFluid" {
import {$FlowingFluidAccessor$$Interface} from "com.simibubi.create.foundation.mixin.accessor.FlowingFluidAccessor"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$Holder} from "net.minecraft.core.Holder"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$FlowingFluidAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.FlowingFluidAccess"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FlowingFluid extends $Fluid implements $FlowingFluidAccess$$Interface, $FlowingFluidAccessor$$Interface {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty

constructor()

public "canConvertToSource"(arg0: $FluidState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): boolean
public "getOwnHeight"(arg0: $FluidState$$Type): float
public "callCanPassThroughWall"(arg0: $Direction$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockPos$$Type, arg5: $BlockState$$Type): boolean
public "create$getNewLiquid"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $FluidState
public "getFlowing"(): $Fluid
public "getFlowing"(arg0: integer, arg1: boolean): $FluidState
public "handler$ddp000$lithium$getSpread"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CallbackInfoReturnable$$Type): void
public "getHeight"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): float
public "getSource"(arg0: boolean): $FluidState
public "getSource"(): $Fluid
public "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type): void
public "getShape"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getAmount"(arg0: $FluidState$$Type): integer
public "getFlow"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type): $Vec3
public "asHolder"(): $Holder
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
get "flowing"(): $Fluid
get "source"(): $Fluid
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlowingFluid$$Type = ($FlowingFluid);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlowingFluid$$Original = $FlowingFluid;}
declare module "net.minecraft.world.level.block.entity.HopperBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Hopper$$Type, $Hopper$$Interface} from "net.minecraft.world.level.block.entity.Hopper"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$SectionedEntityMovementListener$$Interface} from "net.caffeinemc.mods.lithium.common.tracking.entity.SectionedEntityMovementListener"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$Class$$Type} from "java.lang.Class"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$UpdateReceiver$$Interface} from "net.caffeinemc.mods.lithium.common.hopper.UpdateReceiver"
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$InventoryChangeListener$$Type, $InventoryChangeListener$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type, $InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $HopperBlockEntity extends $RandomizableContainerBlockEntity implements $Hopper$$Interface, $LithiumInventory$$Interface, $InventoryChangeListener$$Interface, $UpdateReceiver$$Interface, $SectionedEntityMovementListener$$Interface, $InventoryChangeTracker$$Interface, $SleepingBlockEntity$$Interface {
static readonly "MOVE_ITEM_SPEED": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
static readonly "HOPPER_CONTAINER_SIZE": integer
 "lockKey": $LockCode

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public static "pushItemsTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $HopperBlockEntity$$Type): void
public "lithium$invalidateCacheOnUndirectedNeighborUpdate"(): void
public "lithium$invalidateCacheOnNeighborUpdate"(arg0: boolean): void
public "lithium$invalidateCacheOnNeighborUpdate"(arg0: $Direction$$Type): void
public static "getContainerAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $Container
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "lithium$handleInventoryContentModified"(arg0: $Container$$Type): void
public "lithium$handleInventoryRemoved"(arg0: $Container$$Type): void
public "lithium$handleComparatorAdded"(arg0: $Container$$Type): boolean
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "lithium$startSleeping"(): boolean
public static "isFullContainer"(arg0: $Container$$Type, arg1: $Direction$$Type): boolean
public static "suckInItems"(arg0: $Level$$Type, arg1: $Hopper$$Type): boolean
public "getLevelX"(): double
public "getLevelY"(): double
public "getLevelZ"(): double
public "isGridAligned"(): boolean
public "setCooldown"(arg0: integer): void
public "isOnCustomCooldown"(): boolean
public static "getItemsAtAndAbove"(arg0: $Level$$Type, arg1: $Hopper$$Type): $List<($ItemEntity)>
public "handler$dim003$lithium$setInventoryStackListReplacement"(arg0: $NonNullList$$Type, arg1: $CallbackInfo$$Type): void
public "getLastUpdateTime"(): long
public "getExtractBlockInventory"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $Container
public "getInsertInventory"(arg0: $Level$$Type): $Container
public "getInsertBlockInventory"(arg0: $Level$$Type): $Container
public "lithium$handleEntityMovement"(arg0: $Class$$Type): void
public static "addItem"(arg0: $Container$$Type, arg1: $Container$$Type, arg2: $ItemStack$$Type, arg3: $Direction$$Type): $ItemStack
public static "addItem"(arg0: $Container$$Type, arg1: $ItemEntity$$Type): boolean
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "getContainerSize"(): integer
public static "entityInside"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type, arg4: $HopperBlockEntity$$Type): void
public "setBlockState"(arg0: $BlockState$$Type): void
public "getSuckAabb"(): $AABB
public "generateLootLithium"(): void
public "handleStackListReplaced"(arg0: $Container$$Type): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "wakeUpNow"(): void
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "sleepOnlyCurrentTick"(): void
public "isSleeping"(): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public "lithium$emitRemoved"(): void
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitContentModified"(): void
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "tryClear"(arg0: any): void
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "levelX"(): double
get "levelY"(): double
get "levelZ"(): double
get "gridAligned"(): boolean
set "cooldown"(value: integer)
get "onCustomCooldown"(): boolean
get "lastUpdateTime"(): long
get "containerSize"(): integer
set "blockState"(value: $BlockState$$Type)
get "suckAabb"(): $AABB
set "ticker"(value: $TickingBlockEntity$$Type)
get "sleeping"(): boolean
get "changed"(): void
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HopperBlockEntity$$Type = ($HopperBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HopperBlockEntity$$Original = $HopperBlockEntity;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.AppendLoot" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RuleBlockEntityModifier$$Interface} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RuleBlockEntityModifierType} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifierType"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AppendLoot implements $RuleBlockEntityModifier$$Interface {
static readonly "CODEC": $MapCodec<($AppendLoot)>

constructor(arg0: $ResourceKey$$Type<($LootTable)>)

public "apply"(arg0: $RandomSource$$Type, arg1: $CompoundTag$$Type): $CompoundTag
public "getType"(): $RuleBlockEntityModifierType<(never)>
get "type"(): $RuleBlockEntityModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AppendLoot$$Type = ($AppendLoot);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AppendLoot$$Original = $AppendLoot;}
declare module "net.minecraft.world.level.storage.ServerLevelData" {
import {$GameRules} from "net.minecraft.world.level.GameRules"
import {$WorldBorder$Settings, $WorldBorder$Settings$$Type} from "net.minecraft.world.level.border.WorldBorder$Settings"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$TimerQueue} from "net.minecraft.world.level.timers.TimerQueue"
import {$WritableLevelData$$Interface} from "net.minecraft.world.level.storage.WritableLevelData"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$GameType, $GameType$$Type} from "net.minecraft.world.level.GameType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CrashReportCategory$$Type} from "net.minecraft.CrashReportCategory"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

export interface $ServerLevelData$$Interface extends $WritableLevelData$$Interface {
get "wanderingTraderSpawnDelay"(): integer
set "wanderingTraderSpawnDelay"(value: integer)
get "wanderingTraderSpawnChance"(): integer
set "wanderingTraderSpawnChance"(value: integer)
get "wanderingTraderId"(): $UUID
set "wanderingTraderId"(value: $UUID$$Type)
get "gameType"(): $GameType
set "gameType"(value: $GameType$$Type)
set "clearWeatherTime"(value: integer)
set "rainTime"(value: integer)
set "thunderTime"(value: integer)
set "thundering"(value: boolean)
get "scheduledEvents"(): $TimerQueue<($MinecraftServer)>
get "clearWeatherTime"(): integer
get "thunderTime"(): integer
get "rainTime"(): integer
set "worldBorder"(value: $WorldBorder$Settings$$Type)
get "levelName"(): StringJS
set "initialized"(value: boolean)
get "initialized"(): boolean
get "worldBorder"(): $WorldBorder$Settings
get "allowCommands"(): boolean
get "dayTimeFraction"(): float
set "dayTimeFraction"(value: float)
get "dayTimePerTick"(): float
set "dayTimePerTick"(value: float)
set "gameTime"(value: long)
set "dayTime"(value: long)
get "difficultyLocked"(): boolean
set "raining"(value: boolean)
get "hardcore"(): boolean
get "gameTime"(): long
get "difficulty"(): $Difficulty
get "gameRules"(): $GameRules
get "dayTime"(): long
get "spawnPos"(): $BlockPos
get "spawnAngle"(): float
get "thundering"(): boolean
get "raining"(): boolean
}

export class $ServerLevelData implements $ServerLevelData$$Interface {
 "getWanderingTraderSpawnDelay"(): integer
 "setWanderingTraderSpawnDelay"(arg0: integer): void
 "getWanderingTraderSpawnChance"(): integer
 "setWanderingTraderSpawnChance"(arg0: integer): void
 "getWanderingTraderId"(): $UUID
 "setWanderingTraderId"(arg0: $UUID$$Type): void
 "getGameType"(): $GameType
 "setGameType"(arg0: $GameType$$Type): void
 "setClearWeatherTime"(arg0: integer): void
 "setRainTime"(arg0: integer): void
 "setThunderTime"(arg0: integer): void
 "setThundering"(arg0: boolean): void
 "getScheduledEvents"(): $TimerQueue<($MinecraftServer)>
 "getClearWeatherTime"(): integer
 "getThunderTime"(): integer
 "getRainTime"(): integer
 "setWorldBorder"(arg0: $WorldBorder$Settings$$Type): void
 "getLevelName"(): StringJS
 "setInitialized"(arg0: boolean): void
 "isInitialized"(): boolean
 "getWorldBorder"(): $WorldBorder$Settings
 "isAllowCommands"(): boolean
 "getDayTimeFraction"(): float
 "fillCrashReportCategory"(arg0: $CrashReportCategory$$Type, arg1: $LevelHeightAccessor$$Type): void
 "setDayTimeFraction"(arg0: float): void
 "getDayTimePerTick"(): float
 "setDayTimePerTick"(arg0: float): void
 "setGameTime"(arg0: long): void
 "setDayTime"(arg0: long): void
 "setSpawn"(arg0: $BlockPos$$Type, arg1: float): void
 "isDifficultyLocked"(): boolean
 "setRaining"(arg0: boolean): void
 "isHardcore"(): boolean
 "getGameTime"(): long
 "getDifficulty"(): $Difficulty
 "getGameRules"(): $GameRules
 "getDayTime"(): long
 "getSpawnPos"(): $BlockPos
 "getSpawnAngle"(): float
 "isThundering"(): boolean
 "isRaining"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLevelData$$Type = ($ServerLevelData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerLevelData$$Original = $ServerLevelData;}
declare module "net.minecraft.world.level.border.BorderChangeListener" {
import {$WorldBorder$$Type} from "net.minecraft.world.level.border.WorldBorder"

export interface $BorderChangeListener$$Interface {
}

export class $BorderChangeListener implements $BorderChangeListener$$Interface {
 "onBorderCenterSet"(arg0: $WorldBorder$$Type, arg1: double, arg2: double): void
 "onBorderSizeSet"(arg0: $WorldBorder$$Type, arg1: double): void
 "onBorderSizeLerping"(arg0: $WorldBorder$$Type, arg1: double, arg2: double, arg3: long): void
 "onBorderSetDamageSafeZOne"(arg0: $WorldBorder$$Type, arg1: double): void
 "onBorderSetDamagePerBlock"(arg0: $WorldBorder$$Type, arg1: double): void
 "onBorderSetWarningTime"(arg0: $WorldBorder$$Type, arg1: integer): void
 "onBorderSetWarningBlocks"(arg0: $WorldBorder$$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BorderChangeListener$$Type = ($BorderChangeListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BorderChangeListener$$Original = $BorderChangeListener;}
declare module "net.minecraft.world.level.border.WorldBorder$BorderExtent" {
import {$BorderStatus} from "net.minecraft.world.level.border.BorderStatus"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"

export interface $WorldBorder$BorderExtent$$Interface {
get "maxX"(): double
get "minZ"(): double
get "maxZ"(): double
get "lerpRemainingTime"(): long
get "lerpTarget"(): double
get "lerpSpeed"(): double
get "minX"(): double
get "size"(): double
get "status"(): $BorderStatus
get "collisionShape"(): $VoxelShape
}

export class $WorldBorder$BorderExtent implements $WorldBorder$BorderExtent$$Interface {
 "getMaxX"(): double
 "getMinZ"(): double
 "getMaxZ"(): double
 "onCenterChange"(): void
 "getLerpRemainingTime"(): long
 "getLerpTarget"(): double
 "onAbsoluteMaxSizeChange"(): void
 "getLerpSpeed"(): double
 "getMinX"(): double
 "update"(): $WorldBorder$BorderExtent
 "getSize"(): double
 "getStatus"(): $BorderStatus
 "getCollisionShape"(): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldBorder$BorderExtent$$Type = ($WorldBorder$BorderExtent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldBorder$BorderExtent$$Original = $WorldBorder$BorderExtent;}
declare module "net.minecraft.world.level.block.MultifaceSpreader$SpreadPos" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"

export class $MultifaceSpreader$SpreadPos extends $Record {
constructor(arg0: $BlockPos$$Type, arg1: $Direction$$Type)

public "face"(): $Direction
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceSpreader$SpreadPos$$Type = ({"pos"?: $BlockPos$$Type, "face"?: $Direction$$Type}) | ([pos?: $BlockPos$$Type, face?: $Direction$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceSpreader$SpreadPos$$Original = $MultifaceSpreader$SpreadPos;}
declare module "net.minecraft.world.level.block.WeepingVinesBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$GrowingPlantHeadBlock} from "net.minecraft.world.level.block.GrowingPlantHeadBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $WeepingVinesBlock extends $GrowingPlantHeadBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WeepingVinesBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($WeepingVinesBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeepingVinesBlock$$Type = ($WeepingVinesBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeepingVinesBlock$$Original = $WeepingVinesBlock;}
declare module "net.minecraft.world.level.block.SkullBlock$Type" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Map} from "java.util.Map"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export interface $SkullBlock$Type$$Interface extends $StringRepresentable$$Interface {

(): StringJS
get "remappedEnumConstantName"(): StringJS
get "serializedName"(): StringJS
}

export class $SkullBlock$Type implements $SkullBlock$Type$$Interface {
static readonly "TYPES": $Map<(StringJS), ($SkullBlock$Type)>
static readonly "CODEC": $Codec<($SkullBlock$Type)>

static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
 "getRemappedEnumConstantName"(): StringJS
static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
 "getSerializedName"(): StringJS
static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SkullBlock$Type$$Type = (() => StringJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SkullBlock$Type$$Original = $SkullBlock$Type;}
declare module "net.minecraft.world.level.PathNavigationRegion" {
import {$Iterable} from "java.lang.Iterable"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$CollisionGetter$$Interface} from "net.minecraft.world.level.CollisionGetter"
import {$ProfilerFiller} from "net.minecraft.util.profiling.ProfilerFiller"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$ChunkView$$Interface} from "net.caffeinemc.mods.lithium.common.world.ChunkView"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$BlockGetter, $BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export class $PathNavigationRegion implements $BlockGetter$$Interface, $CollisionGetter$$Interface, $ChunkView$$Interface {
constructor(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type)

public "getHeight"(): integer
public "getProfiler"(): $ProfilerFiller
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getWorldBorder"(): $WorldBorder
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "getMinBuildHeight"(): integer
public "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
public "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
public "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
public "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
public "clip"(arg0: $ClipContext$$Type): $BlockHitResult
public "getLightEmission"(arg0: $BlockPos$$Type): integer
public "getMaxLightLevel"(): integer
public "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
public "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
public "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
public "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
public "noCollision"(arg0: $Entity$$Type): boolean
public "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "noCollision"(arg0: $AABB$$Type): boolean
public "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
public "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
public "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
public "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
public "isUnobstructed"(arg0: $Entity$$Type): boolean
public "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
public "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
public "getMaxBuildHeight"(): integer
public "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
public "isOutsideBuildHeight"(arg0: integer): boolean
public "getSectionIndex"(arg0: integer): integer
public "getSectionsCount"(): integer
public "getMaxSection"(): integer
public "getMinSection"(): integer
public "getSectionIndexFromSectionY"(arg0: integer): integer
public "getSectionYFromSectionIndex"(arg0: integer): integer
public "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
public "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
public "getModelData"(arg0: $BlockPos$$Type): $ModelData
get "height"(): integer
get "profiler"(): $ProfilerFiller
get "worldBorder"(): $WorldBorder
get "minBuildHeight"(): integer
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathNavigationRegion$$Type = ($PathNavigationRegion);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathNavigationRegion$$Original = $PathNavigationRegion;}
declare module "net.minecraft.world.level.block.RotatedPillarBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RotatedPillarBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RotatedPillarBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "rotatePillar"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "codec"(): $MapCodec<($RotatedPillarBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotatedPillarBlock$$Type = ($RotatedPillarBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RotatedPillarBlock$$Original = $RotatedPillarBlock;}
declare module "net.minecraft.world.level.levelgen.feature.UnderwaterMagmaFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$UnderwaterMagmaConfiguration, $UnderwaterMagmaConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $UnderwaterMagmaFeature extends $Feature<($UnderwaterMagmaConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($UnderwaterMagmaConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($UnderwaterMagmaConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnderwaterMagmaFeature$$Type = ($UnderwaterMagmaFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UnderwaterMagmaFeature$$Original = $UnderwaterMagmaFeature;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.ReplaceablePredicate" {
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$StateTestingPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.StateTestingPredicate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ReplaceablePredicate extends $StateTestingPredicate {
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplaceablePredicate$$Type = ($ReplaceablePredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplaceablePredicate$$Original = $ReplaceablePredicate;}
declare module "net.minecraft.world.level.block.entity.CommandBlockEntity$Mode" {
import {$Enum} from "java.lang.Enum"

export class $CommandBlockEntity$Mode extends $Enum<($CommandBlockEntity$Mode)> {
static readonly "AUTO": $CommandBlockEntity$Mode
static readonly "REDSTONE": $CommandBlockEntity$Mode
static readonly "SEQUENCE": $CommandBlockEntity$Mode

public static "values"(): ($CommandBlockEntity$Mode)[]
public static "valueOf"(arg0: StringJS): $CommandBlockEntity$Mode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandBlockEntity$Mode$$Type = (("sequence") | ("auto") | ("redstone"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandBlockEntity$Mode$$Original = $CommandBlockEntity$Mode;}
declare module "net.minecraft.world.level.block.entity.SignText" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$FormattedCharSequence, $FormattedCharSequence$$Type} from "net.minecraft.util.FormattedCharSequence"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export class $SignText {
static readonly "DIRECT_CODEC": $Codec<($SignText)>
static readonly "LINES": integer

constructor(arg0: ($Component$$Type)[], arg1: ($Component$$Type)[], arg2: $DyeColor$$Type, arg3: boolean)
constructor()

public "hasAnyClickCommands"(arg0: $Player$$Type): boolean
public "setHasGlowingText"(arg0: boolean): $SignText
public "hasMessage"(arg0: $Player$$Type): boolean
public "hasGlowingText"(): boolean
public "setColor"(arg0: $DyeColor$$Type): $SignText
public "getMessage"(arg0: integer, arg1: boolean): $Component
public "setMessage"(arg0: integer, arg1: $Component$$Type, arg2: $Component$$Type): $SignText
public "setMessage"(arg0: integer, arg1: $Component$$Type): $SignText
public "getMessages"(arg0: boolean): ($Component)[]
public "getColor"(): $DyeColor
public "getRenderMessages"(arg0: boolean, arg1: $Function$$Type<($Component), ($FormattedCharSequence$$Type)>): ($FormattedCharSequence)[]
set "color"(value: $DyeColor$$Type)
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignText$$Type = ($SignText);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignText$$Original = $SignText;}
declare module "net.minecraft.world.level.levelgen.structure.pools.ListPoolElement" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$List, $List$$Type} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructurePoolElement, $StructurePoolElement$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$StructureTemplatePool$Projection$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplate$StructureBlockInfo} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $ListPoolElement extends $StructurePoolElement {
static readonly "CODEC": $MapCodec<($ListPoolElement)>
readonly "elements": $List<($StructurePoolElement)>

constructor(arg0: $List$$Type<($StructurePoolElement$$Type)>, arg1: $StructureTemplatePool$Projection$$Type)

public "getShuffledJigsawBlocks"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: $RandomSource$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "setProjection"(arg0: $StructureTemplatePool$Projection$$Type): $StructurePoolElement
public "place"(arg0: $StructureTemplateManager$$Type, arg1: $WorldGenLevel$$Type, arg2: $StructureManager$$Type, arg3: $ChunkGenerator$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type, arg6: $Rotation$$Type, arg7: $BoundingBox$$Type, arg8: $RandomSource$$Type, arg9: $LiquidSettings$$Type, arg10: boolean): boolean
public "toString"(): StringJS
public "getType"(): $StructurePoolElementType<(never)>
public "getSize"(arg0: $StructureTemplateManager$$Type, arg1: $Rotation$$Type): $Vec3i
public "getBoundingBox"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BoundingBox
set "projection"(value: $StructureTemplatePool$Projection$$Type)
get "type"(): $StructurePoolElementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListPoolElement$$Type = ($ListPoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ListPoolElement$$Original = $ListPoolElement;}
declare module "net.minecraft.world.level.block.FenceGateBlock" {
import {$WoodType$$Type} from "net.minecraft.world.level.block.state.properties.WoodType"
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional$$Type} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$FenceGateBlockAccessor$$Interface} from "com.hlysine.create_connected.mixin.copycat.fencegate.FenceGateBlockAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $FenceGateBlock extends $HorizontalDirectionalBlock implements $FenceGateBlockAccessor$$Interface {
static readonly "IN_WALL": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FenceGateBlock)>
readonly "closeSound": $SoundEvent
readonly "openSound": $SoundEvent
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $WoodType$$Type, arg1: $BlockBehaviour$Properties$$Type)
constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $SoundEvent$$Type, arg2: $SoundEvent$$Type)
constructor(arg0: ($WoodType$$Type)?, arg1: $BlockBehaviour$Properties$$Type, arg2: ($SoundEvent$$Type)?, arg3: ($SoundEvent$$Type)?)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public static "connectsToDirection"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "callUseWithoutItem"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type, arg4: $BlockHitResult$$Type): $InteractionResult
public "codec"(): $MapCodec<($FenceGateBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceGateBlock$$Type = ($FenceGateBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FenceGateBlock$$Original = $FenceGateBlock;}
declare module "net.minecraft.world.level.block.entity.PotDecorations" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Record} from "java.lang.Record"

export class $PotDecorations extends $Record {
static readonly "CODEC": $Codec<($PotDecorations)>
static readonly "EMPTY": $PotDecorations
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($PotDecorations)>

constructor(arg0: $Item$$Type, arg1: $Item$$Type, arg2: $Item$$Type, arg3: $Item$$Type)
constructor(arg0: ($Item$$Type)?, arg1: ($Item$$Type)?, arg2: ($Item$$Type)?, arg3: ($Item$$Type)?)

public "front"(): $Optional<($Item)>
public "back"(): $Optional<($Item)>
public "ordered"(): $List<($Item)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "load"(arg0: $CompoundTag$$Type): $PotDecorations
public "save"(arg0: $CompoundTag$$Type): $CompoundTag
public "left"(): $Optional<($Item)>
public "right"(): $Optional<($Item)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotDecorations$$Type = ({"left"?: ($Item$$Type)?, "back"?: ($Item$$Type)?, "front"?: ($Item$$Type)?, "right"?: ($Item$$Type)?}) | ([left?: ($Item$$Type)?, back?: ($Item$$Type)?, front?: ($Item$$Type)?, right?: ($Item$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotDecorations$$Original = $PotDecorations;}
declare module "net.minecraft.world.level.levelgen.structure.pools.alias.RandomGroup" {
import {$Direct} from "net.minecraft.world.level.levelgen.structure.pools.alias.Direct"
import {$List$$Type} from "java.util.List"
import {$SimpleWeightedRandomList$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Random} from "net.minecraft.world.level.levelgen.structure.pools.alias.Random"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$StructureTemplatePool, $StructureTemplatePool$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PoolAliasBinding, $PoolAliasBinding$$Type, $PoolAliasBinding$$Interface} from "net.minecraft.world.level.levelgen.structure.pools.alias.PoolAliasBinding"
import {$Record} from "java.lang.Record"

export class $RandomGroup extends $Record implements $PoolAliasBinding$$Interface {
public "forEachResolved"(arg0: $RandomSource$$Type, arg1: $BiConsumer$$Type<($ResourceKey<($StructureTemplatePool)>), ($ResourceKey<($StructureTemplatePool)>)>): void
public static "randomGroup"(arg0: $SimpleWeightedRandomList$$Type<($List$$Type<($PoolAliasBinding$$Type)>)>): $RandomGroup
public static "direct"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>, arg1: $ResourceKey$$Type<($StructureTemplatePool)>): $Direct
public static "direct"(arg0: StringJS, arg1: StringJS): $Direct
public static "random"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>, arg1: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($StructureTemplatePool$$Type)>)>): $Random
public static "random"(arg0: StringJS, arg1: $SimpleWeightedRandomList$$Type<(StringJS)>): $Random
public "allTargets"(): $Stream<($ResourceKey<($StructureTemplatePool)>)>
public "codec"(): $MapCodec<($PoolAliasBinding)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomGroup$$Type = ({"groups"?: $SimpleWeightedRandomList$$Type<($List$$Type<($PoolAliasBinding$$Type)>)>}) | ([groups?: $SimpleWeightedRandomList$$Type<($List$$Type<($PoolAliasBinding$$Type)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomGroup$$Original = $RandomGroup;}
declare module "net.minecraft.world.level.block.AbstractBannerBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$DyeColor} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractBannerBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "isPossibleToRespawnInThis"(arg0: $BlockState$$Type): boolean
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getColor"(): $DyeColor
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractBannerBlock$$Type = ($AbstractBannerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractBannerBlock$$Original = $AbstractBannerBlock;}
declare module "net.minecraft.world.level.block.entity.FurnaceBlockEntity" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$Component} from "net.minecraft.network.chat.Component"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AbstractFurnaceBlockEntity} from "net.minecraft.world.level.block.entity.AbstractFurnaceBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FurnaceBlockEntity extends $AbstractFurnaceBlockEntity {
static readonly "DATA_LIT_DURATION": integer
static readonly "DATA_COOKING_TOTAL_TIME": integer
static readonly "DATA_COOKING_PROGRESS": integer
static readonly "BURN_TIME_STANDARD": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode
static readonly "NUM_DATA_VALUES": integer
 "litTime": integer
static readonly "DATA_LIT_TIME": integer
static readonly "BURN_COOL_SPEED": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public static "tryClear"(arg0: any): void
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FurnaceBlockEntity$$Type = ($FurnaceBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FurnaceBlockEntity$$Original = $FurnaceBlockEntity;}
declare module "net.minecraft.world.level.storage.loot.LootContext$VisitedEntry" {
import {$LootDataType, $LootDataType$$Type} from "net.minecraft.world.level.storage.loot.LootDataType"
import {$Record} from "java.lang.Record"

export class $LootContext$VisitedEntry<T> extends $Record {
constructor(type: $LootDataType$$Type<(T)>, value: T)

public "type"(): $LootDataType<(T)>
public "value"(): T
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContext$VisitedEntry$$Type<T> = ({"value"?: T, "type"?: $LootDataType$$Type<(T)>}) | ([value?: T, type?: $LootDataType$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContext$VisitedEntry$$Original<T> = $LootContext$VisitedEntry<(T)>;}
declare module "net.minecraft.world.level.block.state.properties.SculkSensorPhase" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $SculkSensorPhase extends $Enum<($SculkSensorPhase)> implements $StringRepresentable$$Interface {
static readonly "COOLDOWN": $SculkSensorPhase
static readonly "ACTIVE": $SculkSensorPhase
static readonly "INACTIVE": $SculkSensorPhase

public "toString"(): StringJS
public static "values"(): ($SculkSensorPhase)[]
public static "valueOf"(arg0: StringJS): $SculkSensorPhase
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkSensorPhase$$Type = (("inactive") | ("active") | ("cooldown"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkSensorPhase$$Original = $SculkSensorPhase;}
declare module "net.minecraft.world.level.LevelSettings" {
import {$GameRules, $GameRules$$Type} from "net.minecraft.world.level.GameRules"
import {$Difficulty, $Difficulty$$Type} from "net.minecraft.world.Difficulty"
import {$Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$Lifecycle, $Lifecycle$$Type} from "com.mojang.serialization.Lifecycle"
import {$GameType, $GameType$$Type} from "net.minecraft.world.level.GameType"
import {$WorldDataConfiguration, $WorldDataConfiguration$$Type} from "net.minecraft.world.level.WorldDataConfiguration"

export class $LevelSettings {
constructor(arg0: StringJS, arg1: $GameType$$Type, arg2: boolean, arg3: $Difficulty$$Type, arg4: boolean, arg5: $GameRules$$Type, arg6: $WorldDataConfiguration$$Type)
constructor(arg0: StringJS, arg1: $GameType$$Type, arg2: boolean, arg3: $Difficulty$$Type, arg4: boolean, arg5: $GameRules$$Type, arg6: $WorldDataConfiguration$$Type, arg7: $Lifecycle$$Type)

public "getLifecycle"(): $Lifecycle
public "difficulty"(): $Difficulty
public "gameType"(): $GameType
public "withGameType"(arg0: $GameType$$Type): $LevelSettings
public "withDifficulty"(arg0: $Difficulty$$Type): $LevelSettings
public static "parse"(arg0: $Dynamic$$Type<(never)>, arg1: $WorldDataConfiguration$$Type): $LevelSettings
public "copy"(): $LevelSettings
public "levelName"(): StringJS
public "withLifecycle"(arg0: $Lifecycle$$Type): $LevelSettings
public "hardcore"(): boolean
public "allowCommands"(): boolean
public "getDataConfiguration"(): $WorldDataConfiguration
public "gameRules"(): $GameRules
public "withDataConfiguration"(arg0: $WorldDataConfiguration$$Type): $LevelSettings
get "lifecycle"(): $Lifecycle
get "dataConfiguration"(): $WorldDataConfiguration
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelSettings$$Type = ($LevelSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelSettings$$Original = $LevelSettings;}
declare module "net.minecraft.world.level.levelgen.WorldOptions" {
import {$OptionalLong, $OptionalLong$$Type} from "java.util.OptionalLong"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $WorldOptions {
static readonly "CODEC": $MapCodec<($WorldOptions)>
static readonly "DEMO_OPTIONS": $WorldOptions

constructor(arg0: long, arg1: boolean, arg2: boolean)

public "withBonusChest"(arg0: boolean): $WorldOptions
public "withStructures"(arg0: boolean): $WorldOptions
public "withSeed"(arg0: $OptionalLong$$Type): $WorldOptions
public "isOldCustomizedWorld"(): boolean
public "generateStructures"(): boolean
public "generateBonusChest"(): boolean
public "seed"(): long
public static "randomSeed"(): long
public static "defaultWithRandomSeed"(): $WorldOptions
public static "parseSeed"(arg0: StringJS): $OptionalLong
get "oldCustomizedWorld"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldOptions$$Type = ($WorldOptions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldOptions$$Original = $WorldOptions;}
declare module "net.minecraft.world.level.levelgen.XoroshiroRandomSource" {
import {$RandomSource, $RandomSource$$Interface} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RandomSupport$Seed128bit$$Type} from "net.minecraft.world.level.levelgen.RandomSupport$Seed128bit"
import {$PositionalRandomFactory} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"

export class $XoroshiroRandomSource implements $RandomSource$$Interface {
static readonly "CODEC": $Codec<($XoroshiroRandomSource)>

constructor(arg0: long)
constructor(arg0: $RandomSupport$Seed128bit$$Type)
constructor(arg0: long, arg1: long)

public "fork"(): $RandomSource
public "setSeed"(arg0: long): void
public "nextFloat"(): float
public "nextGaussian"(): double
public "nextDouble"(): double
public "nextInt"(arg0: integer): integer
public "nextInt"(): integer
public "nextLong"(): long
public "nextBoolean"(): boolean
public "forkPositional"(): $PositionalRandomFactory
public "consumeCount"(arg0: integer): void
public static "create"(): $RandomSource
public static "create"(arg0: long): $RandomSource
public "nextInt"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public static "createThreadSafe"(): $RandomSource
public "triangle"(arg0: double, arg1: double): double
public "nextIntBetweenInclusive"(arg0: integer, arg1: integer): integer
public static "createNewThreadLocalInstance"(): $RandomSource
set "seed"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $XoroshiroRandomSource$$Type = ($XoroshiroRandomSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $XoroshiroRandomSource$$Original = $XoroshiroRandomSource;}
declare module "net.minecraft.world.level.block.HeavyCoreBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HeavyCoreBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($HeavyCoreBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($HeavyCoreBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeavyCoreBlock$$Type = ($HeavyCoreBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HeavyCoreBlock$$Original = $HeavyCoreBlock;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.HasSturdyFacePredicate" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type, $BlockPredicate$$Interface} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HasSturdyFacePredicate implements $BlockPredicate$$Interface {
static readonly "CODEC": $MapCodec<($HasSturdyFacePredicate)>

constructor(arg0: $Vec3i$$Type, arg1: $Direction$$Type)

public "type"(): $BlockPredicateType<(never)>
public "test"(arg0: any, arg1: any): boolean
public "test"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): boolean
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
public "or"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "negate"(): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "and"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HasSturdyFacePredicate$$Type = ($HasSturdyFacePredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HasSturdyFacePredicate$$Original = $HasSturdyFacePredicate;}
declare module "net.minecraft.world.level.material.FluidState" {
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Holder} from "net.minecraft.core.Holder"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function} from "java.util.function.Function"
import {$PathType, $PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidType} from "net.neoforged.neoforge.fluids.FluidType"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Reference2ObjectArrayMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap"
import {$IFluidStateExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IFluidStateExtension"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$StateHolder} from "net.minecraft.world.level.block.state.StateHolder"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ParticleOptions} from "net.minecraft.core.particles.ParticleOptions"
import {$Boat$$Type} from "net.minecraft.world.entity.vehicle.Boat"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $FluidState extends $StateHolder<($Fluid), ($FluidState)> implements $IFluidStateExtension$$Interface {
static readonly "PROPERTIES_TAG": StringJS
static readonly "AMOUNT_MAX": integer
static readonly "CODEC": $Codec<($FluidState)>
static readonly "PROPERTY_ENTRY_TO_STRING_FUNCTION": $Function<($Map$Entry<($Property<(never)>), ($Comparable<(never)>)>), (StringJS)>
static readonly "AMOUNT_FULL": integer
static readonly "NAME_TAG": StringJS

constructor(arg0: $Fluid$$Type, arg1: $Reference2ObjectArrayMap$$Type<($Property$$Type<(never)>), ($Comparable$$Type<(never)>)>, arg2: $MapCodec$$Type<($FluidState$$Type)>)

public "isSource"(): boolean
/**
 * 
 * @deprecated
 */
public "getExplosionResistance"(): float
public "canBeReplacedWith"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Fluid$$Type, arg3: $Direction$$Type): boolean
public "getOwnHeight"(): float
public "isRandomlyTicking"(): boolean
public "randomTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public "isSourceOfType"(arg0: $Fluid$$Type): boolean
public "shouldRenderBackwardUpFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getHeight"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): float
public "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "isEmpty"(): boolean
public "holder"(): $Holder<($Fluid)>
public "getType"(): $Fluid
public "is"(arg0: $HolderSet$$Type<($Fluid)>): boolean
public "is"(arg0: $TagKey$$Type<($Fluid)>): boolean
public "is"(arg0: $Fluid$$Type): boolean
public "animateTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public "getTags"(): $Stream<($TagKey<($Fluid)>)>
public "getAmount"(): integer
public "getFlow"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Vec3
public "createLegacyBlock"(): $BlockState
public "getDripParticle"(): $ParticleOptions
public "canConvertToSource"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public "supportsBoating"(arg0: $Boat$$Type): boolean
public "getBlockPathType"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Mob$$Type, arg3: boolean): $PathType
public "getAdjacentBlockPathType"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Mob$$Type, arg3: $PathType$$Type): $PathType
public "getExplosionResistance"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): float
public "move"(arg0: $LivingEntity$$Type, arg1: $Vec3$$Type, arg2: double): boolean
public "getFluidType"(): $FluidType
public "canExtinguish"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "canHydrate"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type): boolean
get "source"(): boolean
get "explosionResistance"(): float
get "ownHeight"(): float
get "randomlyTicking"(): boolean
get "empty"(): boolean
get "type"(): $Fluid
get "tags"(): $Stream<($TagKey<($Fluid)>)>
get "amount"(): integer
get "dripParticle"(): $ParticleOptions
get "fluidType"(): $FluidType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidState$$Type = ($FluidState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidState$$Original = $FluidState;}
declare module "net.minecraft.world.level.levelgen.feature.FillLayerFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration, $LayerConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $FillLayerFeature extends $Feature<($LayerConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($LayerConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($LayerConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FillLayerFeature$$Type = ($FillLayerFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FillLayerFeature$$Original = $FillLayerFeature;}
declare module "net.minecraft.world.level.block.MultifaceBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Collection$$Type} from "java.util.Collection"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$Set} from "java.util.Set"
import {$MultifaceSpreader} from "net.minecraft.world.level.block.MultifaceSpreader"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MultifaceBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): $BlockState
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "canAttachTo"(arg0: $BlockGetter$$Type, arg1: $Direction$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "getSpreader"(): $MultifaceSpreader
public static "availableFaces"(arg0: $BlockState$$Type): $Set<($Direction)>
public static "hasFace"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public static "getFaceProperty"(arg0: $Direction$$Type): $BooleanProperty
public "isValidStateForPlacement"(arg0: $BlockGetter$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public static "pack"(arg0: $Collection$$Type<($Direction$$Type)>): byte
public static "unpack"(arg0: byte): $Set<($Direction)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "spreader"(): $MultifaceSpreader
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceBlock$$Type = ($MultifaceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceBlock$$Original = $MultifaceBlock;}
declare module "net.minecraft.world.level.lighting.LightEventListener" {
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export interface $LightEventListener$$Interface {
}

export class $LightEventListener implements $LightEventListener$$Interface {
 "hasLightWork"(): boolean
 "updateSectionStatus"(arg0: $SectionPos$$Type, arg1: boolean): void
 "updateSectionStatus"(arg0: $BlockPos$$Type, arg1: boolean): void
 "checkBlock"(arg0: $BlockPos$$Type): void
 "propagateLightSources"(arg0: $ChunkPos$$Type): void
 "runLightUpdates"(): integer
 "setLightEnabled"(arg0: $ChunkPos$$Type, arg1: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightEventListener$$Type = ($LightEventListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightEventListener$$Original = $LightEventListener;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecoratorType" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$AlterGroundDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.AlterGroundDecorator"
import {$LeaveVineDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.LeaveVineDecorator"
import {$AttachedToLeavesDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.AttachedToLeavesDecorator"
import {$CocoaDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.CocoaDecorator"
import {$TrunkVineDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TrunkVineDecorator"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BeehiveDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.BeehiveDecorator"

export class $TreeDecoratorType<P extends $TreeDecorator> {
static readonly "BEEHIVE": $TreeDecoratorType<($BeehiveDecorator)>
static readonly "LEAVE_VINE": $TreeDecoratorType<($LeaveVineDecorator)>
static readonly "TRUNK_VINE": $TreeDecoratorType<($TrunkVineDecorator)>
static readonly "ATTACHED_TO_LEAVES": $TreeDecoratorType<($AttachedToLeavesDecorator)>
static readonly "COCOA": $TreeDecoratorType<($CocoaDecorator)>
static readonly "ALTER_GROUND": $TreeDecoratorType<($AlterGroundDecorator)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenTreeDecoratorType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenTreeDecoratorTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeDecoratorType$$Type<P> = (Special.WorldgenTreeDecoratorType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeDecoratorType$$Original<P> = $TreeDecoratorType<(P)>;}
declare module "net.minecraft.world.level.block.BeaconBeamBlock" {
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"

export interface $BeaconBeamBlock$$Interface {

(): $DyeColor$$Type
get "color"(): $DyeColor
}

export class $BeaconBeamBlock implements $BeaconBeamBlock$$Interface {
 "getColor"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeaconBeamBlock$$Type = (() => $DyeColor$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeaconBeamBlock$$Original = $BeaconBeamBlock;}
declare module "net.minecraft.world.level.block.Block$BlockStatePairKey" {
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $Block$BlockStatePairKey {
constructor(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Block$BlockStatePairKey$$Type = ($Block$BlockStatePairKey);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Block$BlockStatePairKey$$Original = $Block$BlockStatePairKey;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.BlockMatchTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockMatchTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($BlockMatchTest)>

constructor(arg0: $Block$$Type)

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockMatchTest$$Type = ($BlockMatchTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockMatchTest$$Original = $BlockMatchTest;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.WeightedStateProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BlockStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$SimpleWeightedRandomList$Builder$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList$Builder"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$SimpleWeightedRandomList$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WeightedStateProvider extends $BlockStateProvider {
static readonly "CODEC": $MapCodec<($WeightedStateProvider)>

constructor(arg0: $SimpleWeightedRandomList$Builder$$Type<($BlockState$$Type)>)
constructor(arg0: $SimpleWeightedRandomList$$Type<($BlockState$$Type)>)

public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeightedStateProvider$$Type = ($WeightedStateProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeightedStateProvider$$Original = $WeightedStateProvider;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$Marker" {
import {$DensityFunctions$Marker$Type, $DensityFunctions$Marker$Type$$Type} from "net.minecraft.world.level.levelgen.DensityFunctions$Marker$Type"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$Record} from "java.lang.Record"
import {$DensityFunctions$MarkerOrMarked$$Interface} from "net.minecraft.world.level.levelgen.DensityFunctions$MarkerOrMarked"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"

export class $DensityFunctions$Marker extends $Record implements $DensityFunctions$MarkerOrMarked$$Interface {
constructor(arg0: $DensityFunctions$Marker$Type$$Type, arg1: $DensityFunction$$Type)

public "maxValue"(): double
public "wrapped"(): $DensityFunction
public "type"(): $DensityFunctions$Marker$Type
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
public "minValue"(): double
public "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
public "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
public "cube"(): $DensityFunction
public "halfNegative"(): $DensityFunction
public "quarterNegative"(): $DensityFunction
public "squeeze"(): $DensityFunction
public "abs"(): $DensityFunction
public "clamp"(arg0: double, arg1: double): $DensityFunction
public "square"(): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$Marker$$Type = ({"wrapped"?: $DensityFunction$$Type, "type"?: $DensityFunctions$Marker$Type$$Type}) | ([wrapped?: $DensityFunction$$Type, type?: $DensityFunctions$Marker$Type$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$Marker$$Original = $DensityFunctions$Marker;}
declare module "net.minecraft.world.level.levelgen.feature.BonusChestFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $BonusChestFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BonusChestFeature$$Type = ($BonusChestFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BonusChestFeature$$Original = $BonusChestFeature;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings" {
import {$StructureTemplate$Palette, $StructureTemplate$Palette$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$Palette"
import {$StructureProcessor, $StructureProcessor$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$List, $List$$Type} from "java.util.List"
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $StructurePlaceSettings {
constructor()

public "setMirror"(arg0: $Mirror$$Type): $StructurePlaceSettings
public "setRotation"(arg0: $Rotation$$Type): $StructurePlaceSettings
public "isIgnoreEntities"(): boolean
public "setIgnoreEntities"(arg0: boolean): $StructurePlaceSettings
public "clearProcessors"(): $StructurePlaceSettings
public "addProcessor"(arg0: $StructureProcessor$$Type): $StructurePlaceSettings
public "setRandom"(arg0: $RandomSource$$Type): $StructurePlaceSettings
public "setRotationPivot"(arg0: $BlockPos$$Type): $StructurePlaceSettings
public "setLiquidSettings"(arg0: $LiquidSettings$$Type): $StructurePlaceSettings
public "setKnownShape"(arg0: boolean): $StructurePlaceSettings
public "setFinalizeEntities"(arg0: boolean): $StructurePlaceSettings
public "popProcessor"(arg0: $StructureProcessor$$Type): $StructurePlaceSettings
public "getRotationPivot"(): $BlockPos
public "getRandomPalette"(arg0: $List$$Type<($StructureTemplate$Palette$$Type)>, arg1: $BlockPos$$Type): $StructureTemplate$Palette
public "shouldApplyWaterlogging"(): boolean
public "getKnownShape"(): boolean
public "shouldFinalizeEntities"(): boolean
public "copy"(): $StructurePlaceSettings
public "getMirror"(): $Mirror
public "getProcessors"(): $List<($StructureProcessor)>
public "getRotation"(): $Rotation
public "getBoundingBox"(): $BoundingBox
public "getRandom"(arg0: $BlockPos$$Type): $RandomSource
public "setBoundingBox"(arg0: $BoundingBox$$Type): $StructurePlaceSettings
set "mirror"(value: $Mirror$$Type)
set "rotation"(value: $Rotation$$Type)
get "ignoreEntities"(): boolean
set "ignoreEntities"(value: boolean)
set "random"(value: $RandomSource$$Type)
set "rotationPivot"(value: $BlockPos$$Type)
set "liquidSettings"(value: $LiquidSettings$$Type)
set "knownShape"(value: boolean)
set "finalizeEntities"(value: boolean)
get "rotationPivot"(): $BlockPos
get "knownShape"(): boolean
get "mirror"(): $Mirror
get "processors"(): $List<($StructureProcessor)>
get "rotation"(): $Rotation
get "boundingBox"(): $BoundingBox
set "boundingBox"(value: $BoundingBox$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePlaceSettings$$Type = ($StructurePlaceSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePlaceSettings$$Original = $StructurePlaceSettings;}
declare module "net.minecraft.world.level.block.SnowLayerBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $SnowLayerBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SnowLayerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "LAYERS": $IntegerProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "MAX_HEIGHT": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "HEIGHT_IMPASSABLE": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($SnowLayerBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SnowLayerBlock$$Type = ($SnowLayerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SnowLayerBlock$$Original = $SnowLayerBlock;}
declare module "net.minecraft.world.level.storage.loot.functions.LootItemFunction$Builder" {
import {$LootItemFunction, $LootItemFunction$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"

export interface $LootItemFunction$Builder$$Interface {

(): $LootItemFunction$$Type
}

export class $LootItemFunction$Builder implements $LootItemFunction$Builder$$Interface {
 "build"(): $LootItemFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemFunction$Builder$$Type = (() => $LootItemFunction$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemFunction$Builder$$Original = $LootItemFunction$Builder;}
declare module "net.minecraft.world.level.SpawnData" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$EquipmentTable, $EquipmentTable$$Type} from "net.minecraft.world.entity.EquipmentTable"
import {$SpawnData$CustomSpawnRules, $SpawnData$CustomSpawnRules$$Type} from "net.minecraft.world.level.SpawnData$CustomSpawnRules"
import {$SimpleWeightedRandomList} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$Record} from "java.lang.Record"

export class $SpawnData extends $Record {
static readonly "CODEC": $Codec<($SpawnData)>
static readonly "ENTITY_TAG": StringJS
static readonly "LIST_CODEC": $Codec<($SimpleWeightedRandomList<($SpawnData)>)>

constructor()
constructor(arg0: $CompoundTag$$Type, arg1: ($SpawnData$CustomSpawnRules$$Type)?, arg2: ($EquipmentTable$$Type)?)

public "getEntityToSpawn"(): $CompoundTag
public "getCustomSpawnRules"(): $Optional<($SpawnData$CustomSpawnRules)>
public "getEquipment"(): $Optional<($EquipmentTable)>
public "entityToSpawn"(): $CompoundTag
public "customSpawnRules"(): $Optional<($SpawnData$CustomSpawnRules)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "equipment"(): $Optional<($EquipmentTable)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnData$$Type = ({"entityToSpawn"?: $CompoundTag$$Type, "equipment"?: ($EquipmentTable$$Type)?, "customSpawnRules"?: ($SpawnData$CustomSpawnRules$$Type)?}) | ([entityToSpawn?: $CompoundTag$$Type, equipment?: ($EquipmentTable$$Type)?, customSpawnRules?: ($SpawnData$CustomSpawnRules$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpawnData$$Original = $SpawnData;}
declare module "net.minecraft.world.level.block.PointedDripstoneBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Fallable$$Interface} from "net.minecraft.world.level.block.Fallable"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$DripstoneThickness} from "net.minecraft.world.level.block.state.properties.DripstoneThickness"
import {$Item} from "net.minecraft.world.item.Item"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $PointedDripstoneBlock extends $Block implements $Fallable$$Interface, $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PointedDripstoneBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "LAVA_TRANSFER_PROBABILITY_PER_RANDOM_TICK": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "TIP_DIRECTION": $DirectionProperty
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "WATER_TRANSFER_PROBABILITY_PER_RANDOM_TICK": float
static readonly "UPDATE_CLIENTS": integer
static readonly "THICKNESS": $EnumProperty<($DripstoneThickness)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "onBrokenAfterFall"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FallingBlockEntity$$Type): void
public "getFallDamageSource"(arg0: $Entity$$Type): $DamageSource
public static "findStalactiteTipAboveCauldron"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $BlockPos
public static "getCauldronFillFluidType"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): $Fluid
public static "canDrip"(arg0: $BlockState$$Type): boolean
public static "maybeTransferFluid"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: float): void
public static "growStalactiteOrStalagmiteIfPossible"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "spawnDripParticle"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($PointedDripstoneBlock)>
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public "onLand"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $FallingBlockEntity$$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PointedDripstoneBlock$$Type = ($PointedDripstoneBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PointedDripstoneBlock$$Original = $PointedDripstoneBlock;}
declare module "net.minecraft.world.level.block.entity.ChestBlockEntity" {
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type, $InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$Component} from "net.minecraft.network.chat.Component"
import {$InventoryChangeEmitter$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeEmitter"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$LidBlockEntity$$Interface} from "net.minecraft.world.level.block.entity.LidBlockEntity"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ChestBlockEntity extends $RandomizableContainerBlockEntity implements $LidBlockEntity$$Interface, $InventoryChangeEmitter$$Interface, $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface {
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "lidAnimateTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $ChestBlockEntity$$Type): void
public "recheckOpen"(): void
public static "getOpenCount"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): integer
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "startOpen"(arg0: $Player$$Type): void
public "stopOpen"(arg0: $Player$$Type): void
public "handler$dik001$lithium$setInventoryStackListReplacement"(arg0: $NonNullList$$Type, arg1: $CallbackInfo$$Type): void
public "getOpenNess"(arg0: float): float
public static "swapContents"(arg0: $ChestBlockEntity$$Type, arg1: $ChestBlockEntity$$Type): void
public "getContainerSize"(): integer
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "setBlockState"(arg0: $BlockState$$Type): void
public "lithium$emitRemoved"(): void
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitContentModified"(): void
public "generateLootLithium"(): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "tryClear"(arg0: any): void
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "containerSize"(): integer
set "blockState"(value: $BlockState$$Type)
get "changed"(): void
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestBlockEntity$$Type = ($ChestBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestBlockEntity$$Original = $ChestBlockEntity;}
declare module "net.minecraft.world.level.block.entity.Hopper" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container, $Container$$Type, $Container$$Interface} from "net.minecraft.world.Container"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB} from "net.minecraft.world.phys.AABB"

export interface $Hopper$$Interface extends $Container$$Interface {
get "levelX"(): double
get "levelY"(): double
get "levelZ"(): double
get "gridAligned"(): boolean
get "suckAabb"(): $AABB
get "empty"(): boolean
get "maxStackSize"(): integer
get "changed"(): void
get "containerSize"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "width"(): integer
get "height"(): integer
get "changed"(): void
set "transferCooldown"(value: long)
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}

export class $Hopper implements $Hopper$$Interface {
static readonly "SUCK_AABB": $AABB

 "getLevelX"(): double
 "getLevelY"(): double
 "getLevelZ"(): double
 "isGridAligned"(): boolean
 "getSuckAabb"(): $AABB
 "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
 "startOpen"(arg0: $Player$$Type): void
 "stopOpen"(arg0: $Player$$Type): void
 "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
 "countItem"(arg0: $Item$$Type): integer
 "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
 "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
 "getItem"(arg0: integer): $ItemStack
 "removeItem"(arg0: integer, arg1: integer): $ItemStack
 "isEmpty"(): boolean
 "getMaxStackSize"(): integer
 "getMaxStackSize"(arg0: $ItemStack$$Type): integer
 "setChanged"(): void
 "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
 "stillValid"(arg0: $Player$$Type): boolean
 "getContainerSize"(): integer
 "removeItemNoUpdate"(arg0: integer): $ItemStack
 "clearContent"(): void
static "tryClear"(arg0: any): void
 "self"(): $Container
 "isMutable"(): boolean
 "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
 "getSlots"(): integer
 "getStackInSlot"(slot: integer): $ItemStack
 "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
 "getSlotLimit"(slot: integer): integer
 "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
 "clear"(): void
 "getWidth"(): integer
 "getHeight"(): integer
 "getBlock"(level: $Level$$Type): $LevelBlock
 "setChanged"(): void
 "asContainer"(): $Container
 "setTransferCooldown"(arg0: long): void
 "canReceiveTransferCooldown"(): boolean
 "lithium$itemInsertionTestRequiresStackSize1"(): boolean
 "isEmpty"(): boolean
 "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "clear"(match: $ItemPredicate$$Type): void
 "find"(match: $ItemPredicate$$Type): integer
 "find"(): integer
 "count"(match: $ItemPredicate$$Type): integer
 "count"(): integer
 "countNonEmpty"(): integer
 "countNonEmpty"(match: $ItemPredicate$$Type): integer
 "getAllItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Hopper$$Type = ($Hopper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Hopper$$Original = $Hopper;}
declare module "net.minecraft.world.level.levelgen.feature.RootSystemFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration, $RootSystemConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $RootSystemFeature extends $Feature<($RootSystemConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($RootSystemConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($RootSystemConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RootSystemFeature$$Type = ($RootSystemFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RootSystemFeature$$Original = $RootSystemFeature;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState"
import {$OreConfigurationAccessor$$Interface} from "com.almostreliable.unified.mixin.neoforge.worldgen.OreConfigurationAccessor"
import {$RuleTest$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $OreConfiguration implements $FeatureConfiguration$$Interface, $OreConfigurationAccessor$$Interface {
readonly "discardChanceOnAirExposure": float
static readonly "CODEC": $Codec<($OreConfiguration)>
readonly "size": integer
 "targetStates": $List<($OreConfiguration$TargetBlockState)>

constructor(arg0: $RuleTest$$Type, arg1: $BlockState$$Type, arg2: integer)
constructor(arg0: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>, arg1: integer, arg2: float)
constructor(arg0: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>, arg1: integer)
constructor(arg0: $RuleTest$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: float)

public "almostunified$setTargets"(arg0: $List$$Type): void
public static "target"(arg0: $RuleTest$$Type, arg1: $BlockState$$Type): $OreConfiguration$TargetBlockState
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreConfiguration$$Type = ($OreConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OreConfiguration$$Original = $OreConfiguration;}
declare module "net.minecraft.world.level.block.entity.vault.VaultServerData" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"

export class $VaultServerData {
public "ejectionProgress"(): float
public "addToRewardedPlayers"(arg0: $Player$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultServerData$$Type = ($VaultServerData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultServerData$$Original = $VaultServerData;}
declare module "net.minecraft.world.level.biome.AmbientMoodSettings" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $AmbientMoodSettings {
static readonly "CODEC": $Codec<($AmbientMoodSettings)>
static readonly "LEGACY_CAVE_SETTINGS": $AmbientMoodSettings

constructor(arg0: $Holder$$Type<($SoundEvent)>, arg1: integer, arg2: integer, arg3: double)

public "getTickDelay"(): integer
public "getSoundEvent"(): $Holder<($SoundEvent)>
public "getBlockSearchExtent"(): integer
public "getSoundPositionOffset"(): double
get "tickDelay"(): integer
get "soundEvent"(): $Holder<($SoundEvent)>
get "blockSearchExtent"(): integer
get "soundPositionOffset"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AmbientMoodSettings$$Type = ($AmbientMoodSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AmbientMoodSettings$$Original = $AmbientMoodSettings;}
declare module "net.minecraft.world.level.storage.loot.predicates.LootItemConditionType" {
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"
import {$Record} from "java.lang.Record"

export class $LootItemConditionType extends $Record {
constructor(arg0: $MapCodec$$Type<($LootItemCondition$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "codec"(): $MapCodec<($LootItemCondition)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.LootConditionType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.LootConditionTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemConditionType$$Type = (Special.LootConditionType) | ({"codec"?: $MapCodec$$Type<($LootItemCondition$$Type)>}) | ([codec?: $MapCodec$$Type<($LootItemCondition$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemConditionType$$Original = $LootItemConditionType;}
declare module "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext" {
import {$LevelHeightAccessor, $LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$WorldgenRandom, $WorldgenRandom$$Type} from "net.minecraft.world.level.levelgen.WorldgenRandom"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$RandomState, $RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$StructureTemplateManager, $StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BiomeSource, $BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$Record} from "java.lang.Record"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $Structure$GenerationContext extends $Record {
constructor(arg0: $RegistryAccess$$Type, arg1: $ChunkGenerator$$Type, arg2: $BiomeSource$$Type, arg3: $RandomState$$Type, arg4: $StructureTemplateManager$$Type, arg5: long, arg6: $ChunkPos$$Type, arg7: $LevelHeightAccessor$$Type, arg8: $Predicate$$Type<($Holder<($Biome)>)>)
constructor(registryAccess: $RegistryAccess$$Type, chunkGenerator: $ChunkGenerator$$Type, biomeSource: $BiomeSource$$Type, randomState: $RandomState$$Type, structureTemplateManager: $StructureTemplateManager$$Type, random: $WorldgenRandom$$Type, seed: long, chunkPos: $ChunkPos$$Type, heightAccessor: $LevelHeightAccessor$$Type, validBiome: $Predicate$$Type<($Holder<($Biome)>)>)

public "randomState"(): $RandomState
public "chunkGenerator"(): $ChunkGenerator
public "heightAccessor"(): $LevelHeightAccessor
public "validBiome"(): $Predicate<($Holder<($Biome)>)>
public "structureTemplateManager"(): $StructureTemplateManager
public "biomeSource"(): $BiomeSource
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "seed"(): long
public "random"(): $WorldgenRandom
public "registryAccess"(): $RegistryAccess
public "chunkPos"(): $ChunkPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$GenerationContext$$Type = ({"random"?: $WorldgenRandom$$Type, "validBiome"?: $Predicate$$Type<($Holder$$Type<($Biome$$Type)>)>, "seed"?: long, "registryAccess"?: $RegistryAccess$$Type, "heightAccessor"?: $LevelHeightAccessor$$Type, "chunkGenerator"?: $ChunkGenerator$$Type, "structureTemplateManager"?: $StructureTemplateManager$$Type, "biomeSource"?: $BiomeSource$$Type, "randomState"?: $RandomState$$Type, "chunkPos"?: $ChunkPos$$Type}) | ([random?: $WorldgenRandom$$Type, validBiome?: $Predicate$$Type<($Holder$$Type<($Biome$$Type)>)>, seed?: long, registryAccess?: $RegistryAccess$$Type, heightAccessor?: $LevelHeightAccessor$$Type, chunkGenerator?: $ChunkGenerator$$Type, structureTemplateManager?: $StructureTemplateManager$$Type, biomeSource?: $BiomeSource$$Type, randomState?: $RandomState$$Type, chunkPos?: $ChunkPos$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Structure$GenerationContext$$Original = $Structure$GenerationContext;}
declare module "net.minecraft.world.level.block.MagmaBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MagmaBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($MagmaBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($MagmaBlock)>
public "stepOn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MagmaBlock$$Type = ($MagmaBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MagmaBlock$$Original = $MagmaBlock;}
declare module "net.minecraft.world.level.pathfinder.Node" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $Node {
 "cameFrom": $Node
 "f": float
 "g": float
readonly "x": integer
 "h": float
readonly "y": integer
 "closed": boolean
readonly "z": integer
 "walkedDistance": float
 "costMalus": float
 "type": $PathType
 "heapIdx": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "asBlockPos"(): $BlockPos
public "cloneAndMove"(arg0: integer, arg1: integer, arg2: integer): $Node
public "inOpenSet"(): boolean
public "writeToStream"(arg0: $FriendlyByteBuf$$Type): void
public static "createFromStream"(arg0: $FriendlyByteBuf$$Type): $Node
public "asVec3"(): $Vec3
public static "createHash"(arg0: integer, arg1: integer, arg2: integer): integer
public "distanceToXZ"(arg0: $Node$$Type): float
public "distanceManhattan"(arg0: $Node$$Type): float
public "distanceManhattan"(arg0: $BlockPos$$Type): float
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "distanceTo"(arg0: $Node$$Type): float
public "distanceTo"(arg0: $BlockPos$$Type): float
public "distanceToSqr"(arg0: $Node$$Type): float
public "distanceToSqr"(arg0: $BlockPos$$Type): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Node$$Type = ($Node);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Node$$Original = $Node;}
declare module "net.minecraft.world.level.levelgen.feature.LargeDripstoneFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration, $LargeDripstoneConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $LargeDripstoneFeature extends $Feature<($LargeDripstoneConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($LargeDripstoneConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($LargeDripstoneConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LargeDripstoneFeature$$Type = ($LargeDripstoneFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LargeDripstoneFeature$$Original = $LargeDripstoneFeature;}
declare module "net.minecraft.world.level.levelgen.NoiseGeneratorSettings" {
import {$WorldgenRandom$Algorithm} from "net.minecraft.world.level.levelgen.WorldgenRandom$Algorithm"
import {$List, $List$$Type} from "java.util.List"
import {$NoiseSettings, $NoiseSettings$$Type} from "net.minecraft.world.level.levelgen.NoiseSettings"
import {$Holder} from "net.minecraft.core.Holder"
import {$NoiseRouter, $NoiseRouter$$Type} from "net.minecraft.world.level.levelgen.NoiseRouter"
import {$SurfaceRules$RuleSource, $SurfaceRules$RuleSource$$Type} from "net.minecraft.world.level.levelgen.SurfaceRules$RuleSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Climate$ParameterPoint, $Climate$ParameterPoint$$Type} from "net.minecraft.world.level.biome.Climate$ParameterPoint"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BootstrapContext$$Type} from "net.minecraft.data.worldgen.BootstrapContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Record} from "java.lang.Record"

export class $NoiseGeneratorSettings extends $Record {
static readonly "AMPLIFIED": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "CODEC": $Codec<($Holder<($NoiseGeneratorSettings)>)>
static readonly "OVERWORLD": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "NETHER": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "CAVES": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "DIRECT_CODEC": $Codec<($NoiseGeneratorSettings)>
static readonly "END": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "FLOATING_ISLANDS": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "LARGE_BIOMES": $ResourceKey<($NoiseGeneratorSettings)>

constructor(arg0: $NoiseSettings$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $NoiseRouter$$Type, arg4: $SurfaceRules$RuleSource$$Type, arg5: $List$$Type<($Climate$ParameterPoint$$Type)>, arg6: integer, arg7: boolean, arg8: boolean, arg9: boolean, arg10: boolean)

public "defaultBlock"(): $BlockState
public "seaLevel"(): integer
public "surfaceRule"(): $SurfaceRules$RuleSource
public "defaultFluid"(): $BlockState
public static "nether"(arg0: $BootstrapContext$$Type<(never)>): $NoiseGeneratorSettings
public "spawnTarget"(): $List<($Climate$ParameterPoint)>
public "noiseSettings"(): $NoiseSettings
public "useLegacyRandomSource"(): boolean
public "noiseRouter"(): $NoiseRouter
public "aquifersEnabled"(): boolean
public "oreVeinsEnabled"(): boolean
public "isAquifersEnabled"(): boolean
public "getRandomSource"(): $WorldgenRandom$Algorithm
public static "caves"(arg0: $BootstrapContext$$Type<(never)>): $NoiseGeneratorSettings
public static "floatingIslands"(arg0: $BootstrapContext$$Type<(never)>): $NoiseGeneratorSettings
/**
 * 
 * @deprecated
 */
public "disableMobGeneration"(): boolean
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "end"(arg0: $BootstrapContext$$Type<(never)>): $NoiseGeneratorSettings
public static "dummy"(): $NoiseGeneratorSettings
public static "bootstrap"(arg0: $BootstrapContext$$Type<($NoiseGeneratorSettings$$Type)>): void
public static "overworld"(arg0: $BootstrapContext$$Type<(never)>, arg1: boolean, arg2: boolean): $NoiseGeneratorSettings
get "randomSource"(): $WorldgenRandom$Algorithm
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenNoiseSettings
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenNoiseSettingsTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseGeneratorSettings$$Type = (Special.WorldgenNoiseSettings) | ({"defaultBlock"?: $BlockState$$Type, "noiseSettings"?: $NoiseSettings$$Type, "defaultFluid"?: $BlockState$$Type, "spawnTarget"?: $List$$Type<($Climate$ParameterPoint$$Type)>, "noiseRouter"?: $NoiseRouter$$Type, "seaLevel"?: integer, "aquifersEnabled"?: boolean, "useLegacyRandomSource"?: boolean, "disableMobGeneration"?: boolean, "surfaceRule"?: $SurfaceRules$RuleSource$$Type, "oreVeinsEnabled"?: boolean}) | ([defaultBlock?: $BlockState$$Type, noiseSettings?: $NoiseSettings$$Type, defaultFluid?: $BlockState$$Type, spawnTarget?: $List$$Type<($Climate$ParameterPoint$$Type)>, noiseRouter?: $NoiseRouter$$Type, seaLevel?: integer, aquifersEnabled?: boolean, useLegacyRandomSource?: boolean, disableMobGeneration?: boolean, surfaceRule?: $SurfaceRules$RuleSource$$Type, oreVeinsEnabled?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseGeneratorSettings$$Original = $NoiseGeneratorSettings;}
declare module "net.minecraft.world.level.border.BorderStatus" {
import {$Enum} from "java.lang.Enum"

export class $BorderStatus extends $Enum<($BorderStatus)> {
static readonly "GROWING": $BorderStatus
static readonly "SHRINKING": $BorderStatus
static readonly "STATIONARY": $BorderStatus

public static "values"(): ($BorderStatus)[]
public static "valueOf"(arg0: StringJS): $BorderStatus
public "getColor"(): integer
get "color"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BorderStatus$$Type = (("growing") | ("shrinking") | ("stationary"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BorderStatus$$Original = $BorderStatus;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.Clear" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RuleBlockEntityModifier$$Interface} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RuleBlockEntityModifierType} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifierType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $Clear implements $RuleBlockEntityModifier$$Interface {
static readonly "CODEC": $MapCodec<($Clear)>

constructor()

public "apply"(arg0: $RandomSource$$Type, arg1: $CompoundTag$$Type): $CompoundTag
public "getType"(): $RuleBlockEntityModifierType<(never)>
get "type"(): $RuleBlockEntityModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Clear$$Type = ($Clear);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Clear$$Original = $Clear;}
declare module "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings" {
import {$GenerationStep$Decoration, $GenerationStep$Decoration$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Decoration"
import {$Map, $Map$$Type} from "java.util.Map"
import {$MobCategory, $MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$TerrainAdjustment, $TerrainAdjustment$$Type} from "net.minecraft.world.level.levelgen.structure.TerrainAdjustment"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructureSpawnOverride, $StructureSpawnOverride$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSpawnOverride"
import {$Record} from "java.lang.Record"

export class $Structure$StructureSettings extends $Record {
static readonly "CODEC": $MapCodec<($Structure$StructureSettings)>

constructor(arg0: $HolderSet$$Type<($Biome)>)
constructor(biomes: $HolderSet$$Type<($Biome)>, spawnOverrides: $Map$$Type<($MobCategory$$Type), ($StructureSpawnOverride$$Type)>, step: $GenerationStep$Decoration$$Type, terrainAdaptation: $TerrainAdjustment$$Type)

public "spawnOverrides"(): $Map<($MobCategory), ($StructureSpawnOverride)>
public "terrainAdaptation"(): $TerrainAdjustment
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "step"(): $GenerationStep$Decoration
public "biomes"(): $HolderSet<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$StructureSettings$$Type = ({"terrainAdaptation"?: $TerrainAdjustment$$Type, "biomes"?: $HolderSet$$Type<($Biome)>, "step"?: $GenerationStep$Decoration$$Type, "spawnOverrides"?: $Map$$Type<($MobCategory$$Type), ($StructureSpawnOverride$$Type)>}) | ([terrainAdaptation?: $TerrainAdjustment$$Type, biomes?: $HolderSet$$Type<($Biome)>, step?: $GenerationStep$Decoration$$Type, spawnOverrides?: $Map$$Type<($MobCategory$$Type), ($StructureSpawnOverride$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Structure$StructureSettings$$Original = $Structure$StructureSettings;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.BendingTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $BendingTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($BendingTrunkPlacer)>
static readonly "MAX_HEIGHT": integer

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $IntProvider$$Type)

public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BendingTrunkPlacer$$Type = ($BendingTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BendingTrunkPlacer$$Original = $BendingTrunkPlacer;}
declare module "net.minecraft.world.level.block.state.properties.EnumProperty" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Optional} from "java.util.Optional"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Comparable$$Type} from "java.lang.Comparable"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Class$$Type} from "java.lang.Class"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $EnumProperty<T extends $Enum<(object)>> extends $Property<(T)> {
public "getPossibleValues"(): $Collection<(T)>
public "generateHashCode"(): integer
public "getName"(arg0: $Comparable$$Type): StringJS
public "getName"(arg0: T): StringJS
public "equals"(arg0: any): boolean
public "getValue"(arg0: StringJS): $Optional<(T)>
public static "create"<T extends $Enum<(object)>>(arg0: StringJS, arg1: $Class$$Type<(T)>): $EnumProperty<(T)>
public static "create"<T extends $Enum<(object)>>(arg0: StringJS, arg1: $Class$$Type<(T)>, arg2: $Collection$$Type<(T)>): $EnumProperty<(T)>
public static "create"<T extends $Enum<(object)>>(arg0: StringJS, arg1: $Class$$Type<(T)>, ...arg2: (T)[]): $EnumProperty<(T)>
public static "create"<T extends $Enum<(object)>>(arg0: StringJS, arg1: $Class$$Type<(T)>, arg2: $Predicate$$Type<(T)>): $EnumProperty<(T)>
get "possibleValues"(): $Collection<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumProperty$$Type<T> = ($EnumProperty<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnumProperty$$Original<T> = $EnumProperty<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.WeepingVinesFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$BlockPos$MutableBlockPos$$Type} from "net.minecraft.core.BlockPos$MutableBlockPos"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $WeepingVinesFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public static "placeWeepingVinesColumn"(arg0: $LevelAccessor$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$MutableBlockPos$$Type, arg3: integer, arg4: integer, arg5: integer): void
public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeepingVinesFeature$$Type = ($WeepingVinesFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeepingVinesFeature$$Original = $WeepingVinesFeature;}
declare module "net.minecraft.world.level.block.ComparatorBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$DiodeBlock} from "net.minecraft.world.level.block.DiodeBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$EntityBlock$$Interface} from "net.minecraft.world.level.block.EntityBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ComparatorMode} from "net.minecraft.world.level.block.state.properties.ComparatorMode"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $ComparatorBlock extends $DiodeBlock implements $EntityBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ComparatorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "MODE": $EnumProperty<($ComparatorMode)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "handler$bam000$supplementaries$supp$updateSideRelayers"(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, ci: $CallbackInfo$$Type): void
public "codec"(): $MapCodec<($ComparatorBlock)>
public "onNeighborChange"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type): void
public "getWeakChanges"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparatorBlock$$Type = ($ComparatorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComparatorBlock$$Original = $ComparatorBlock;}
declare module "net.minecraft.world.level.biome.BiomeGenerationSettings$PlainBuilder" {
import {$GenerationStep$Decoration$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Decoration"
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$List} from "java.util.List"
import {$BiomeGenerationSettings} from "net.minecraft.world.level.biome.BiomeGenerationSettings"
import {$ConfiguredWorldCarver$$Type} from "net.minecraft.world.level.levelgen.carver.ConfiguredWorldCarver"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $BiomeGenerationSettings$PlainBuilder {
readonly "features": $List<($List<($Holder<($PlacedFeature)>)>)>

constructor()

public "addFeature"(arg0: integer, arg1: $Holder$$Type<($PlacedFeature)>): $BiomeGenerationSettings$PlainBuilder
public "addFeature"(arg0: $GenerationStep$Decoration$$Type, arg1: $Holder$$Type<($PlacedFeature)>): $BiomeGenerationSettings$PlainBuilder
public "addCarver"(arg0: $GenerationStep$Carving$$Type, arg1: $Holder$$Type<($ConfiguredWorldCarver<(never)>)>): $BiomeGenerationSettings$PlainBuilder
public "build"(): $BiomeGenerationSettings
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeGenerationSettings$PlainBuilder$$Type = ($BiomeGenerationSettings$PlainBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeGenerationSettings$PlainBuilder$$Original = $BiomeGenerationSettings$PlainBuilder;}
declare module "net.minecraft.world.level.entity.EntitySection" {
import {$EntitySectionStorage$$Type} from "net.minecraft.world.level.entity.EntitySectionStorage"
import {$ArrayList$$Type} from "java.util.ArrayList"
import {$EntitySectionAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.util.accessors.EntitySectionAccessor"
import {$Visibility, $Visibility$$Type} from "net.minecraft.world.level.entity.Visibility"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockCachingEntity$$Type} from "net.caffeinemc.mods.lithium.common.entity.pushable.BlockCachingEntity"
import {$AbortableIterationConsumer$$Type} from "net.minecraft.util.AbortableIterationConsumer"
import {$ClimbingMobCachingSection$$Interface} from "net.caffeinemc.mods.lithium.common.world.ClimbingMobCachingSection"
import {$EntityPushablePredicate$$Type} from "net.caffeinemc.mods.lithium.common.entity.pushable.EntityPushablePredicate"
import {$SectionedEntityMovementTracker$$Type} from "net.caffeinemc.mods.lithium.common.tracking.entity.SectionedEntityMovementTracker"
import {$EntitySectionAccessor$$Interface as $EntitySectionAccessor$1$$Interface} from "net.caffeinemc.mods.lithium.mixin.minimal_nonvanilla.spawning.EntitySectionAccessor"
import {$EntityAccess, $EntityAccess$$Type} from "net.minecraft.world.level.entity.EntityAccess"
import {$AbortableIterationConsumer$Continuation} from "net.minecraft.util.AbortableIterationConsumer$Continuation"
import {$PositionedEntityTrackingSection$$Interface} from "net.caffeinemc.mods.lithium.common.entity.PositionedEntityTrackingSection"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$EntityMovementTrackerSection$$Interface} from "net.caffeinemc.mods.lithium.common.tracking.entity.EntityMovementTrackerSection"
import {$ClassInstanceMultiMap} from "net.minecraft.util.ClassInstanceMultiMap"
import {$Class$$Type} from "java.lang.Class"
import {$EntitySectionAccessor$$Interface as $EntitySectionAccessor$0$$Interface} from "net.caffeinemc.mods.lithium.mixin.block.hopper.EntitySectionAccessor"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Stream} from "java.util.stream.Stream"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EntitySection<T extends $EntityAccess> implements $EntitySectionAccessor$0$$Interface, $ClimbingMobCachingSection$$Interface, $EntitySectionAccessor$1$$Interface, $EntitySectionAccessor$$Interface, $PositionedEntityTrackingSection$$Interface, $EntityMovementTrackerSection$$Interface {
constructor(arg0: $Class$$Type<(T)>, arg1: $Visibility$$Type)

public "updateChunkStatus"(arg0: $Visibility$$Type): $Visibility
public "getCollection"(): $ClassInstanceMultiMap
public "getEntities"<U extends $EntityAccess>(arg0: $EntityTypeTest$$Type<(T), (U)>, arg1: $AABB$$Type, arg2: $AbortableIterationConsumer$$Type<(U)>): $AbortableIterationConsumer$Continuation
public "getEntities"(): $Stream<(T)>
public "getEntities"(arg0: $AABB$$Type, arg1: $AbortableIterationConsumer$$Type<(T)>): $AbortableIterationConsumer$Continuation
public "lithium$setPos"(arg0: long): void
public "modifyReturnValue$die000$lithium$modifyIsEmpty"(arg0: boolean): boolean
public "localvar$die000$lithium$swapStatus"(arg0: $Visibility$$Type): $Visibility
public "lithium$collectPushableEntities"(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: $AABB$$Type, arg3: $EntityPushablePredicate$$Type, arg4: $ArrayList$$Type): $AbortableIterationConsumer$Continuation
public "lithium$addListener"(arg0: $SectionedEntityMovementTracker$$Type): void
public "lithium$removeListener"(arg0: $EntitySectionStorage$$Type, arg1: $SectionedEntityMovementTracker$$Type): void
public "lithium$getPos"(): long
public "lithium$trackEntityMovement"(arg0: integer, arg1: long): void
public "lithium$getChangeTime"(arg0: integer): long
public "lithium$listenToMovementOnce"(arg0: $SectionedEntityMovementTracker$$Type, arg1: integer): void
public "lithium$removeListenToMovementOnce"(arg0: $SectionedEntityMovementTracker$$Type, arg1: integer): void
public "remove"(arg0: T): boolean
public "size"(): integer
public "isEmpty"(): boolean
public "add"(arg0: T): void
public "getStatus"(): $Visibility
public "lithium$onEntityModifiedCachedBlock"(arg0: $BlockCachingEntity$$Type, arg1: $BlockState$$Type): void
get "collection"(): $ClassInstanceMultiMap
get "entities"(): $Stream<(T)>
get "empty"(): boolean
get "status"(): $Visibility
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySection$$Type<T> = ($EntitySection<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySection$$Original<T> = $EntitySection<(T)>;}
declare module "net.minecraft.world.level.block.entity.EnchantingTableBlockEntity" {
import {$Nameable$$Interface} from "net.minecraft.world.Nameable"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EnchantingTableBlockEntity extends $BlockEntity implements $Nameable$$Interface {
 "oFlip": float
 "flipA": float
 "rot": float
 "tRot": float
 "flipT": float
 "oOpen": float
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "time": integer
 "oRot": float
 "flip": float
 "open": float

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "bookAnimationTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $EnchantingTableBlockEntity$$Type): void
public "getName"(): $Component
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "getCustomName"(): $Component
public "setCustomName"(arg0: $Component$$Type): void
public "getDisplayName"(): $Component
public "hasCustomName"(): boolean
get "name"(): $Component
get "customName"(): $Component
set "customName"(value: $Component$$Type)
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantingTableBlockEntity$$Type = ($EnchantingTableBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnchantingTableBlockEntity$$Original = $EnchantingTableBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $TrunkPlacer {
static readonly "CODEC": $Codec<($TrunkPlacer)>
static readonly "MAX_HEIGHT": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "getTreeHeight"(arg0: $RandomSource$$Type): integer
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
public "isFree"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrunkPlacer$$Type = ($TrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrunkPlacer$$Original = $TrunkPlacer;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BoundingBox} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List, $List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"
import {$ObjectArrayList} from "it.unimi.dsi.fastutil.objects.ObjectArrayList"
import {$HolderGetter$$Type} from "net.minecraft.core.HolderGetter"
import {$ServerLevelAccessor$$Type} from "net.minecraft.world.level.ServerLevelAccessor"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$StructureTemplate$StructureEntityInfo, $StructureTemplate$StructureEntityInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureEntityInfo"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$IConnectionTemplate$$Interface} from "blusunrize.immersiveengineering.api.wires.IConnectionTemplate"
import {$DiscreteVoxelShape$$Type} from "net.minecraft.world.phys.shapes.DiscreteVoxelShape"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$TemplateAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.TemplateAccess"

export class $StructureTemplate implements $TemplateAccess$$Interface, $IConnectionTemplate$$Interface {
static readonly "ENTITY_TAG_POS": StringJS
static readonly "BLOCK_TAG_NBT": StringJS
static readonly "BLOCK_TAG_STATE": StringJS
static readonly "PALETTE_LIST_TAG": StringJS
static readonly "BLOCK_TAG_POS": StringJS
static readonly "BLOCKS_TAG": StringJS
static readonly "SIZE_TAG": StringJS
static readonly "PALETTE_TAG": StringJS
static readonly "ENTITY_TAG_NBT": StringJS
static readonly "ENTITIES_TAG": StringJS
static readonly "ENTITY_TAG_BLOCKPOS": StringJS

constructor()

public "fillFromWorld"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Vec3i$$Type, arg3: boolean, arg4: $Block$$Type): void
public "setAuthor"(arg0: StringJS): void
public "getAuthor"(): StringJS
public "placeInWorld"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructurePlaceSettings$$Type, arg4: $RandomSource$$Type, arg5: integer): boolean
public static "updateShapeAtEdge"(arg0: $LevelAccessor$$Type, arg1: integer, arg2: $DiscreteVoxelShape$$Type, arg3: integer, arg4: integer, arg5: integer): void
public static "updateShapeAtEdge"(arg0: $LevelAccessor$$Type, arg1: integer, arg2: $DiscreteVoxelShape$$Type, arg3: $BlockPos$$Type): void
public static "calculateRelativePosition"(arg0: $StructurePlaceSettings$$Type, arg1: $BlockPos$$Type): $BlockPos
public "filterBlocks"(arg0: $BlockPos$$Type, arg1: $StructurePlaceSettings$$Type, arg2: $Block$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "filterBlocks"(arg0: $BlockPos$$Type, arg1: $StructurePlaceSettings$$Type, arg2: $Block$$Type, arg3: boolean): $ObjectArrayList<($StructureTemplate$StructureBlockInfo)>
public static "processBlockInfos"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructurePlaceSettings$$Type, arg4: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>): $List<($StructureTemplate$StructureBlockInfo)>
public static "processBlockInfos"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructurePlaceSettings$$Type, arg4: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>, arg5: $StructureTemplate$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "getPalettes"(): $List
public static "transformedVec3d"(arg0: $StructurePlaceSettings$$Type, arg1: $Vec3$$Type): $Vec3
public "handler$edn000$immersiveengineering$takeConnectionsFromWorld"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Vec3i$$Type, arg3: boolean, arg4: $Block$$Type, arg5: $CallbackInfo$$Type): void
public "handler$een000$ae2$enableClientSideStateSaving"(arg0: $CallbackInfo$$Type): void
public "handler$een000$ae2$disableClientSideStateSaving"(arg0: $CallbackInfo$$Type): void
public "calculateConnectedPosition"(arg0: $StructurePlaceSettings$$Type, arg1: $BlockPos$$Type, arg2: $StructurePlaceSettings$$Type, arg3: $BlockPos$$Type): $BlockPos
public "handler$edn000$immersiveengineering$addConnectionsToWorld"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructurePlaceSettings$$Type, arg4: $RandomSource$$Type, arg5: integer, arg6: $CallbackInfoReturnable$$Type): void
public static "processEntityInfos"(arg0: $StructureTemplate$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $StructurePlaceSettings$$Type, arg4: $List$$Type<($StructureTemplate$StructureEntityInfo$$Type)>): $List<($StructureTemplate$StructureEntityInfo)>
public "handler$edn000$immersiveengineering$writeConnectionsToNBT"(arg0: $CompoundTag$$Type, arg1: $CallbackInfoReturnable$$Type): void
public "handler$edn000$immersiveengineering$readConnectionsFromNBT"(arg0: $HolderGetter$$Type, arg1: $CompoundTag$$Type, arg2: $CallbackInfo$$Type): void
public "getStoredConnections"(): $List
public "setSize"(arg0: $Vec3i$$Type): void
public "load"(arg0: $HolderGetter$$Type<($Block$$Type)>, arg1: $CompoundTag$$Type): void
public static "transform"(arg0: $Vec3$$Type, arg1: $Mirror$$Type, arg2: $Rotation$$Type, arg3: $BlockPos$$Type): $Vec3
public static "transform"(arg0: $BlockPos$$Type, arg1: $Mirror$$Type, arg2: $Rotation$$Type, arg3: $BlockPos$$Type): $BlockPos
public "save"(arg0: $CompoundTag$$Type): $CompoundTag
public "getSize"(arg0: $Rotation$$Type): $Vec3i
public "getSize"(): $Vec3i
public "getZeroPositionWithTransform"(arg0: $BlockPos$$Type, arg1: $Mirror$$Type, arg2: $Rotation$$Type): $BlockPos
public static "getZeroPositionWithTransform"(arg0: $BlockPos$$Type, arg1: $Mirror$$Type, arg2: $Rotation$$Type, arg3: integer, arg4: integer): $BlockPos
public "getBoundingBox"(arg0: $BlockPos$$Type, arg1: $Rotation$$Type, arg2: $BlockPos$$Type, arg3: $Mirror$$Type): $BoundingBox
public "getBoundingBox"(arg0: $StructurePlaceSettings$$Type, arg1: $BlockPos$$Type): $BoundingBox
set "author"(value: StringJS)
get "author"(): StringJS
get "palettes"(): $List
get "storedConnections"(): $List
set "size"(value: $Vec3i$$Type)
get "size"(): $Vec3i
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplate$$Type = ($StructureTemplate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplate$$Original = $StructureTemplate;}
declare module "net.minecraft.world.level.block.piston.PistonMovingBlockEntity" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$IExtendedPistonTile$$Interface} from "net.mehvahdjukaar.moonlight.core.misc.IExtendedPistonTile"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$IBlockHolder$$Interface} from "net.mehvahdjukaar.moonlight.api.block.IBlockHolder"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PistonMovingBlockEntity extends $BlockEntity implements $IExtendedPistonTile$$Interface, $IBlockHolder$$Interface {
 "progressO": float
static readonly "TICK_MOVEMENT": double
 "lastTicked": long
 "progress": float
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "deathTicks": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type, arg4: boolean, arg5: boolean)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "isExtending"(): boolean
public "getLastTicked"(): long
public "finalTick"(): void
public "getMovedState"(): $BlockState
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "isSourcePiston"(): boolean
public "getXOff"(arg0: float): float
public "getYOff"(arg0: float): float
public "getZOff"(arg0: float): float
public static "moveCollidedEntities"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: float, arg3: $PistonMovingBlockEntity$$Type): void
public "getMovementDirection"(): $Direction
public static "moveStuckEntities"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: float, arg3: $PistonMovingBlockEntity$$Type): void
public "handler$eap000$moonlight$onFinishedShortPulse"(ci: $CallbackInfo$$Type): void
public "getHeldBlock"(): $BlockState
public "setHeldBlock"(state: $BlockState$$Type): boolean
public "tickMovedBlock"(level: $Level$$Type, pos: $BlockPos$$Type): void
public static "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $PistonMovingBlockEntity$$Type): void
public "setLevel"(arg0: $Level$$Type): void
public "getDirection"(): $Direction
public "getCollisionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "getProgress"(arg0: float): float
public "getHeldBlock"(arg0: integer): $BlockState
public "setHeldBlock"(arg0: $BlockState$$Type, arg1: integer): boolean
get "extending"(): boolean
get "movedState"(): $BlockState
get "sourcePiston"(): boolean
get "movementDirection"(): $Direction
get "heldBlock"(): $BlockState
set "heldBlock"(value: $BlockState$$Type)
set "level"(value: $Level$$Type)
get "direction"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonMovingBlockEntity$$Type = ($PistonMovingBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PistonMovingBlockEntity$$Original = $PistonMovingBlockEntity;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifier" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RuleBlockEntityModifierType} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifierType"

export interface $RuleBlockEntityModifier$$Interface {
get "type"(): $RuleBlockEntityModifierType<(never)>
}

export class $RuleBlockEntityModifier implements $RuleBlockEntityModifier$$Interface {
static readonly "CODEC": $Codec<($RuleBlockEntityModifier)>

 "apply"(arg0: $RandomSource$$Type, arg1: $CompoundTag$$Type): $CompoundTag
 "getType"(): $RuleBlockEntityModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleBlockEntityModifier$$Type = ($RuleBlockEntityModifier);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleBlockEntityModifier$$Original = $RuleBlockEntityModifier;}
declare module "net.minecraft.world.level.levelgen.GeodeBlockSettings" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $GeodeBlockSettings {
static readonly "CODEC": $Codec<($GeodeBlockSettings)>
readonly "outerLayerProvider": $BlockStateProvider
readonly "innerLayerProvider": $BlockStateProvider
readonly "alternateInnerLayerProvider": $BlockStateProvider
readonly "innerPlacements": $List<($BlockState)>
readonly "cannotReplace": $TagKey<($Block)>
readonly "middleLayerProvider": $BlockStateProvider
readonly "invalidBlocks": $TagKey<($Block)>
readonly "fillingProvider": $BlockStateProvider

constructor(arg0: $BlockStateProvider$$Type, arg1: $BlockStateProvider$$Type, arg2: $BlockStateProvider$$Type, arg3: $BlockStateProvider$$Type, arg4: $BlockStateProvider$$Type, arg5: $List$$Type<($BlockState$$Type)>, arg6: $TagKey$$Type<($Block)>, arg7: $TagKey$$Type<($Block)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeBlockSettings$$Type = ($GeodeBlockSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeodeBlockSettings$$Original = $GeodeBlockSettings;}
declare module "net.minecraft.world.level.levelgen.heightproviders.TrapezoidHeight" {
import {$HeightProviderType} from "net.minecraft.world.level.levelgen.heightproviders.HeightProviderType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $TrapezoidHeight extends $HeightProvider {
static readonly "CODEC": $MapCodec<($TrapezoidHeight)>

public "toString"(): StringJS
public static "of"(arg0: $VerticalAnchor$$Type, arg1: $VerticalAnchor$$Type, arg2: integer): $TrapezoidHeight
public static "of"(arg0: $VerticalAnchor$$Type, arg1: $VerticalAnchor$$Type): $TrapezoidHeight
public "getType"(): $HeightProviderType<(never)>
public "sample"(arg0: $RandomSource$$Type, arg1: $WorldGenerationContext$$Type): integer
get "type"(): $HeightProviderType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrapezoidHeight$$Type = ($TrapezoidHeight);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrapezoidHeight$$Original = $TrapezoidHeight;}
declare module "net.minecraft.world.level.levelgen.structure.SinglePieceStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Holder} from "net.minecraft.core.Holder"

export class $SinglePieceStructure extends $Structure {
static readonly "CODEC": $Codec<($Holder<($Structure)>)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SinglePieceStructure$$Type = ($SinglePieceStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SinglePieceStructure$$Original = $SinglePieceStructure;}
declare module "net.minecraft.world.level.levelgen.WorldDimensions$Complete" {
import {$LevelStem, $LevelStem$$Type} from "net.minecraft.world.level.dimension.LevelStem"
import {$RegistryAccess$Frozen} from "net.minecraft.core.RegistryAccess$Frozen"
import {$PrimaryLevelData$SpecialWorldProperty, $PrimaryLevelData$SpecialWorldProperty$$Type} from "net.minecraft.world.level.storage.PrimaryLevelData$SpecialWorldProperty"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Lifecycle} from "com.mojang.serialization.Lifecycle"
import {$Record} from "java.lang.Record"

export class $WorldDimensions$Complete extends $Record {
constructor(dimensions: $Registry$$Type<($LevelStem$$Type)>, specialWorldProperty: $PrimaryLevelData$SpecialWorldProperty$$Type)

public "dimensionsRegistryAccess"(): $RegistryAccess$Frozen
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "dimensions"(): $Registry<($LevelStem)>
public "lifecycle"(): $Lifecycle
public "specialWorldProperty"(): $PrimaryLevelData$SpecialWorldProperty
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldDimensions$Complete$$Type = ({"dimensions"?: $Registry$$Type<($LevelStem$$Type)>, "specialWorldProperty"?: $PrimaryLevelData$SpecialWorldProperty$$Type}) | ([dimensions?: $Registry$$Type<($LevelStem$$Type)>, specialWorldProperty?: $PrimaryLevelData$SpecialWorldProperty$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldDimensions$Complete$$Original = $WorldDimensions$Complete;}
declare module "net.minecraft.world.level.block.TwistingVinesPlantBlock" {
import {$GrowingPlantBodyBlock} from "net.minecraft.world.level.block.GrowingPlantBodyBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $TwistingVinesPlantBlock extends $GrowingPlantBodyBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TwistingVinesPlantBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $VoxelShape
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($TwistingVinesPlantBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TwistingVinesPlantBlock$$Type = ($TwistingVinesPlantBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TwistingVinesPlantBlock$$Original = $TwistingVinesPlantBlock;}
declare module "net.minecraft.world.level.block.entity.SculkCatalystBlockEntity" {
import {$GameEventListener$Provider$$Interface} from "net.minecraft.world.level.gameevent.GameEventListener$Provider"
import {$SculkCatalystBlockEntity$CatalystListener} from "net.minecraft.world.level.block.entity.SculkCatalystBlockEntity$CatalystListener"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SculkCatalystBlockEntity extends $BlockEntity implements $GameEventListener$Provider$$Interface<($SculkCatalystBlockEntity$CatalystListener)> {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SculkCatalystBlockEntity$$Type): void
public "getListener"(): $SculkCatalystBlockEntity$CatalystListener
get "listener"(): $SculkCatalystBlockEntity$CatalystListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkCatalystBlockEntity$$Type = ($SculkCatalystBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkCatalystBlockEntity$$Original = $SculkCatalystBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.DiskFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$DiskConfiguration, $DiskConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $DiskFeature extends $Feature<($DiskConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($DiskConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($DiskConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiskFeature$$Type = ($DiskFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiskFeature$$Original = $DiskFeature;}
declare module "net.minecraft.world.level.block.ConcretePowderBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ConcretePowderBlockAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.ConcretePowderBlockAccess"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$ConcretePowderBlockAccessor$$Interface} from "com.simibubi.create.foundation.mixin.accessor.ConcretePowderBlockAccessor"
import {$Item} from "net.minecraft.world.item.Item"
import {$FallingBlock} from "net.minecraft.world.level.block.FallingBlock"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ConcretePowderBlock extends $FallingBlock implements $ConcretePowderBlockAccess$$Interface, $ConcretePowderBlockAccessor$$Interface {
readonly "concrete": $Block
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ConcretePowderBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getDustColor"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): integer
public "onLand"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $FallingBlockEntity$$Type): void
public "getConcrete"(): $Block
public "create$getConcrete"(): $Block
public "codec"(): $MapCodec<($ConcretePowderBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConcretePowderBlock$$Type = ($ConcretePowderBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConcretePowderBlock$$Original = $ConcretePowderBlock;}
declare module "net.minecraft.world.level.block.SculkCatalystBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SculkCatalystBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SculkCatalystBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "PULSE": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getExpDrop"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): integer
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($SculkCatalystBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkCatalystBlock$$Type = ($SculkCatalystBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkCatalystBlock$$Original = $SculkCatalystBlock;}
declare module "net.minecraft.world.level.block.entity.SculkCatalystBlockEntity$CatalystListener" {
import {$SculkSpreader} from "net.minecraft.world.level.block.SculkSpreader"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$PositionSource, $PositionSource$$Type} from "net.minecraft.world.level.gameevent.PositionSource"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$GameEventListener$$Interface} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$GameEventListener$DeliveryMode} from "net.minecraft.world.level.gameevent.GameEventListener$DeliveryMode"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SculkCatalystBlockEntity$CatalystListener implements $GameEventListener$$Interface {
static readonly "PULSE_TICKS": integer

constructor(arg0: $BlockState$$Type, arg1: $PositionSource$$Type)

public "getSculkSpreader"(): $SculkSpreader
public "getListenerRadius"(): integer
public "getListenerSource"(): $PositionSource
public "handleGameEvent"(arg0: $ServerLevel$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $GameEvent$Context$$Type, arg3: $Vec3$$Type): boolean
public "getDeliveryMode"(): $GameEventListener$DeliveryMode
get "sculkSpreader"(): $SculkSpreader
get "listenerRadius"(): integer
get "listenerSource"(): $PositionSource
get "deliveryMode"(): $GameEventListener$DeliveryMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkCatalystBlockEntity$CatalystListener$$Type = ($SculkCatalystBlockEntity$CatalystListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkCatalystBlockEntity$CatalystListener$$Original = $SculkCatalystBlockEntity$CatalystListener;}
declare module "net.minecraft.world.level.levelgen.carver.CanyonCarverConfiguration" {
import {$VerticalAnchor, $VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$CarverConfiguration, $CarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CarverConfiguration"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"
import {$CarverDebugSettings, $CarverDebugSettings$$Type} from "net.minecraft.world.level.levelgen.carver.CarverDebugSettings"
import {$HeightProvider, $HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"
import {$CanyonCarverConfiguration$CanyonShapeConfiguration, $CanyonCarverConfiguration$CanyonShapeConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CanyonCarverConfiguration$CanyonShapeConfiguration"

export class $CanyonCarverConfiguration extends $CarverConfiguration {
readonly "verticalRotation": $FloatProvider
readonly "lavaLevel": $VerticalAnchor
readonly "debugSettings": $CarverDebugSettings
static readonly "CODEC": $Codec<($CanyonCarverConfiguration)>
readonly "shape": $CanyonCarverConfiguration$CanyonShapeConfiguration
readonly "probability": float
readonly "replaceable": $HolderSet<($Block)>
readonly "y": $HeightProvider
readonly "yScale": $FloatProvider

constructor(arg0: float, arg1: $HeightProvider$$Type, arg2: $FloatProvider$$Type, arg3: $VerticalAnchor$$Type, arg4: $CarverDebugSettings$$Type, arg5: $HolderSet$$Type<($Block)>, arg6: $FloatProvider$$Type, arg7: $CanyonCarverConfiguration$CanyonShapeConfiguration$$Type)
constructor(arg0: $CarverConfiguration$$Type, arg1: $FloatProvider$$Type, arg2: $CanyonCarverConfiguration$CanyonShapeConfiguration$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanyonCarverConfiguration$$Type = ($CanyonCarverConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CanyonCarverConfiguration$$Original = $CanyonCarverConfiguration;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $RandomBooleanFeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($RandomBooleanFeatureConfiguration)>
readonly "featureTrue": $Holder<($PlacedFeature)>
readonly "featureFalse": $Holder<($PlacedFeature)>

constructor(arg0: $Holder$$Type<($PlacedFeature)>, arg1: $Holder$$Type<($PlacedFeature)>)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomBooleanFeatureConfiguration$$Type = ($RandomBooleanFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomBooleanFeatureConfiguration$$Original = $RandomBooleanFeatureConfiguration;}
declare module "net.minecraft.world.level.pathfinder.PathfindingContext" {
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CollisionGetter, $CollisionGetter$$Type} from "net.minecraft.world.level.CollisionGetter"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PathfindingContext {
constructor(arg0: $CollisionGetter$$Type, arg1: $Mob$$Type)

public "level"(): $CollisionGetter
public "getPathTypeFromState"(arg0: integer, arg1: integer, arg2: integer): $PathType
public "mobPosition"(): $BlockPos
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathfindingContext$$Type = ($PathfindingContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathfindingContext$$Original = $PathfindingContext;}
declare module "net.minecraft.world.level.block.RailBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$RailShape} from "net.minecraft.world.level.block.state.properties.RailShape"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BaseRailBlock} from "net.minecraft.world.level.block.BaseRailBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $RailBlock extends $BaseRailBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RailBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $EnumProperty<($RailShape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getShapeProperty"(): $Property<($RailShape)>
public "codec"(): $MapCodec<($RailBlock)>
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "shapeProperty"(): $Property<($RailShape)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RailBlock$$Type = ($RailBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RailBlock$$Original = $RailBlock;}
declare module "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub" {
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$StructurePiecesBuilder, $StructurePiecesBuilder$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder"
import {$Record} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $Structure$GenerationStub extends $Record {
constructor(arg0: $BlockPos$$Type, arg1: $Consumer$$Type<($StructurePiecesBuilder)>)
constructor(position: $BlockPos$$Type, generator: $Either$$Type<($Consumer$$Type<($StructurePiecesBuilder$$Type)>), ($StructurePiecesBuilder$$Type)>)

public "getPiecesBuilder"(): $StructurePiecesBuilder
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "position"(): $BlockPos
public "generator"(): $Either<($Consumer<($StructurePiecesBuilder)>), ($StructurePiecesBuilder)>
get "piecesBuilder"(): $StructurePiecesBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$GenerationStub$$Type = ({"generator"?: $Either$$Type<($Consumer$$Type<($StructurePiecesBuilder$$Type)>), ($StructurePiecesBuilder$$Type)>, "position"?: $BlockPos$$Type}) | ([generator?: $Either$$Type<($Consumer$$Type<($StructurePiecesBuilder$$Type)>), ($StructurePiecesBuilder$$Type)>, position?: $BlockPos$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Structure$GenerationStub$$Original = $Structure$GenerationStub;}
declare module "net.minecraft.world.level.block.PlayerHeadBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$SkullBlock} from "net.minecraft.world.level.block.SkullBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PlayerHeadBlock extends $SkullBlock {
static readonly "ROTATION": $IntegerProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PlayerHeadBlock)>
static readonly "MAX": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($PlayerHeadBlock)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerHeadBlock$$Type = ($PlayerHeadBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerHeadBlock$$Original = $PlayerHeadBlock;}
declare module "net.minecraft.world.level.levelgen.feature.CoralClawFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$CoralFeature} from "net.minecraft.world.level.levelgen.feature.CoralFeature"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $CoralClawFeature extends $CoralFeature {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoralClawFeature$$Type = ($CoralClawFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CoralClawFeature$$Original = $CoralClawFeature;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.RandomSpreadFoliagePlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $RandomSpreadFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($RandomSpreadFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type, arg3: integer)

public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomSpreadFoliagePlacer$$Type = ($RandomSpreadFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomSpreadFoliagePlacer$$Original = $RandomSpreadFoliagePlacer;}
declare module "net.minecraft.world.level.block.CommandBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$GameMasterBlock$$Interface} from "net.minecraft.world.level.block.GameMasterBlock"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CommandBlock extends $BaseEntityBlock implements $GameMasterBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CommandBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "CONDITIONAL": $BooleanProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: boolean, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($CommandBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandBlock$$Type = ($CommandBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandBlock$$Original = $CommandBlock;}
declare module "net.minecraft.world.level.block.RedstoneLampBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $RedstoneLampBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RedstoneLampBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($RedstoneLampBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneLampBlock$$Type = ($RedstoneLampBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneLampBlock$$Original = $RedstoneLampBlock;}
declare module "net.minecraft.world.level.levelgen.heightproviders.ConstantHeight" {
import {$HeightProviderType} from "net.minecraft.world.level.levelgen.heightproviders.HeightProviderType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$VerticalAnchor, $VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $ConstantHeight extends $HeightProvider {
static readonly "ZERO": $ConstantHeight
static readonly "CODEC": $MapCodec<($ConstantHeight)>

public "toString"(): StringJS
public "getValue"(): $VerticalAnchor
public static "of"(arg0: $VerticalAnchor$$Type): $ConstantHeight
public "getType"(): $HeightProviderType<(never)>
public "sample"(arg0: $RandomSource$$Type, arg1: $WorldGenerationContext$$Type): integer
get "value"(): $VerticalAnchor
get "type"(): $HeightProviderType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstantHeight$$Type = ($ConstantHeight);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConstantHeight$$Original = $ConstantHeight;}
declare module "net.minecraft.world.level.levelgen.carver.CarverDebugSettings" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CarverDebugSettings {
static readonly "CODEC": $Codec<($CarverDebugSettings)>
static readonly "DEFAULT": $CarverDebugSettings

public "getBarrierState"(): $BlockState
public "getAirState"(): $BlockState
public "getWaterState"(): $BlockState
public "getLavaState"(): $BlockState
public "isDebugMode"(): boolean
public static "of"(arg0: boolean, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $BlockState$$Type): $CarverDebugSettings
public static "of"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type): $CarverDebugSettings
public static "of"(arg0: boolean, arg1: $BlockState$$Type): $CarverDebugSettings
get "barrierState"(): $BlockState
get "airState"(): $BlockState
get "waterState"(): $BlockState
get "lavaState"(): $BlockState
get "debugMode"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarverDebugSettings$$Type = ($CarverDebugSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarverDebugSettings$$Original = $CarverDebugSettings;}
declare module "net.minecraft.world.level.levelgen.structure.StructureSpawnOverride$BoundingBoxType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $StructureSpawnOverride$BoundingBoxType extends $Enum<($StructureSpawnOverride$BoundingBoxType)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($StructureSpawnOverride$BoundingBoxType)>
static readonly "STRUCTURE": $StructureSpawnOverride$BoundingBoxType
static readonly "PIECE": $StructureSpawnOverride$BoundingBoxType

public static "values"(): ($StructureSpawnOverride$BoundingBoxType)[]
public static "valueOf"(arg0: StringJS): $StructureSpawnOverride$BoundingBoxType
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureSpawnOverride$BoundingBoxType$$Type = (("piece") | ("full"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureSpawnOverride$BoundingBoxType$$Original = $StructureSpawnOverride$BoundingBoxType;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record} from "java.lang.Record"

export class $SimpleBlockConfiguration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($SimpleBlockConfiguration)>

constructor(arg0: $BlockStateProvider$$Type)

public "toPlace"(): $BlockStateProvider
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleBlockConfiguration$$Type = ({"toPlace"?: $BlockStateProvider$$Type}) | ([toPlace?: $BlockStateProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleBlockConfiguration$$Original = $SimpleBlockConfiguration;}
declare module "net.minecraft.world.level.LevelAccessor" {
import {$Iterable} from "java.lang.Iterable"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$LevelData} from "net.minecraft.world.level.storage.LevelData"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$CommonLevelAccessor$$Interface} from "net.minecraft.world.level.CommonLevelAccessor"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$LevelTimeAccess$$Interface} from "net.minecraft.world.level.LevelTimeAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ChunkSource} from "net.minecraft.world.level.chunk.ChunkSource"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$TickPriority$$Type} from "net.minecraft.world.ticks.TickPriority"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$Class$$Type} from "java.lang.Class"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$LevelTickAccess} from "net.minecraft.world.ticks.LevelTickAccess"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$DifficultyInstance} from "net.minecraft.world.DifficultyInstance"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $LevelAccessor$$Interface extends $CommonLevelAccessor$$Interface, $LevelTimeAccess$$Interface {
get "levelData"(): $LevelData
get "chunkSource"(): $ChunkSource
get "random"(): $RandomSource
get "difficulty"(): $Difficulty
get "server"(): $MinecraftServer
get "blockTicks"(): $LevelTickAccess<($Block)>
get "fluidTicks"(): $LevelTickAccess<($Fluid)>
get "moonBrightness"(): float
get "moonPhase"(): integer
get "height"(): integer
get "clientSide"(): boolean
get "minBuildHeight"(): integer
get "biomeManager"(): $BiomeManager
get "seaLevel"(): integer
get "skyDarken"(): integer
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "entities"(): $EntityArrayList
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $LevelAccessor implements $LevelAccessor$$Interface {
 "getLevelData"(): $LevelData
 "getChunkSource"(): $ChunkSource
 "gameEvent"(arg0: $ResourceKey$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $Vec3$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $BlockPos$$Type): void
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $Vec3$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "getRandom"(): $RandomSource
 "addParticle"(arg0: $ParticleOptions$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): void
 "getDifficulty"(): $Difficulty
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type): void
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
 "getServer"(): $MinecraftServer
 "levelEvent"(arg0: $Player$$Type, arg1: integer, arg2: $BlockPos$$Type, arg3: integer): void
 "levelEvent"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
 "neighborShapeChanged"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
 "hasChunk"(arg0: integer, arg1: integer): boolean
 "getCurrentDifficultyAt"(arg0: $BlockPos$$Type): $DifficultyInstance
 "blockUpdated"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
 "nextSubTickCount"(): long
 "dayTime"(): long
 "getBlockTicks"(): $LevelTickAccess<($Block)>
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer): void
 "getFluidTicks"(): $LevelTickAccess<($Fluid)>
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getTimeOfDay"(arg0: float): float
 "getMoonBrightness"(): float
 "getMoonPhase"(): integer
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
 "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
 "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
 "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
 "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
 "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
 "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
 "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
 "getPlayerByUUID"(arg0: $UUID$$Type): $Player
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
 "enabledFeatures"(): $FeatureFlagSet
 "registryAccess"(): $RegistryAccess
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "isClientSide"(): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getBiomeManager"(): $BiomeManager
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "dimensionType"(): $DimensionType
 "getSkyDarken"(): integer
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "self"(): $EntityGetter
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getWorldBorder"(): $WorldBorder
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntities"(): $EntityArrayList
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelAccessor$$Type = ($LevelAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelAccessor$$Original = $LevelAccessor;}
declare module "net.minecraft.world.level.levelgen.placement.RepeatingPlacement" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"

export class $RepeatingPlacement extends $PlacementModifier {
static readonly "CODEC": $Codec<($PlacementModifier)>

constructor()

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RepeatingPlacement$$Type = ($RepeatingPlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RepeatingPlacement$$Original = $RepeatingPlacement;}
declare module "net.minecraft.world.level.block.LightBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ToIntFunction} from "java.util.function.ToIntFunction"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LightBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LightBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "LEVEL": $IntegerProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "LIGHT_EMISSION": $ToIntFunction<($BlockState)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "MAX_LEVEL": integer
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "setLightOnStack"(arg0: $ItemStack$$Type, arg1: integer): $ItemStack
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($LightBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightBlock$$Type = ($LightBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightBlock$$Original = $LightBlock;}
declare module "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer$Builder" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$LootPoolEntryContainer} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$Function$$Type} from "java.util.function.Function"
import {$EntryGroup$Builder} from "net.minecraft.world.level.storage.loot.entries.EntryGroup$Builder"
import {$SequentialEntry$Builder} from "net.minecraft.world.level.storage.loot.entries.SequentialEntry$Builder"
import {$ConditionUserBuilder, $ConditionUserBuilder$$Interface} from "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder"
import {$AlternativesEntry$Builder} from "net.minecraft.world.level.storage.loot.entries.AlternativesEntry$Builder"

export class $LootPoolEntryContainer$Builder<T extends $LootPoolEntryContainer$Builder<(object)>> implements $ConditionUserBuilder$$Interface<(T)> {
constructor()

public "otherwise"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $AlternativesEntry$Builder
public "then"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $SequentialEntry$Builder
public "when"(arg0: $LootItemCondition$Builder$$Type): $ConditionUserBuilder
public "append"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $EntryGroup$Builder
public "unwrap"(): T
public "build"(): $LootPoolEntryContainer
public "when"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemCondition$Builder$$Type)>): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPoolEntryContainer$Builder$$Type<T> = ($LootPoolEntryContainer$Builder<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootPoolEntryContainer$Builder$$Original<T> = $LootPoolEntryContainer$Builder<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DeltaFeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($DeltaFeatureConfiguration)>

constructor(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $IntProvider$$Type, arg3: $IntProvider$$Type)

public "rimSize"(): $IntProvider
public "rim"(): $BlockState
public "contents"(): $BlockState
public "size"(): $IntProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeltaFeatureConfiguration$$Type = ($DeltaFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeltaFeatureConfiguration$$Original = $DeltaFeatureConfiguration;}
declare module "net.minecraft.world.level.block.RodBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$DirectionalBlock} from "net.minecraft.world.level.block.DirectionalBlock"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $RodBlock extends $DirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RodBlock$$Type = ($RodBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RodBlock$$Original = $RodBlock;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.RandomizedIntStateProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IntegerProperty$$Type} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $RandomizedIntStateProvider extends $BlockStateProvider {
static readonly "CODEC": $MapCodec<($RandomizedIntStateProvider)>

constructor(arg0: $BlockStateProvider$$Type, arg1: $IntegerProperty$$Type, arg2: $IntProvider$$Type)
constructor(arg0: $BlockStateProvider$$Type, arg1: StringJS, arg2: $IntProvider$$Type)

public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomizedIntStateProvider$$Type = ($RandomizedIntStateProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomizedIntStateProvider$$Original = $RandomizedIntStateProvider;}
declare module "net.minecraft.world.level.levelgen.feature.CoralFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $CoralFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoralFeature$$Type = ($CoralFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CoralFeature$$Original = $CoralFeature;}
declare module "net.minecraft.world.level.block.WeatheringCopperGrateBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Enum} from "java.lang.Enum"
import {$Optional} from "java.util.Optional"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$WeatheringCopper$$Interface} from "net.minecraft.world.level.block.WeatheringCopper"
import {$WaterloggedTransparentBlock} from "net.minecraft.world.level.block.WaterloggedTransparentBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$WeatheringCopper$WeatherState$$Type} from "net.minecraft.world.level.block.WeatheringCopper$WeatherState"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WeatheringCopperGrateBlock extends $WaterloggedTransparentBlock implements $WeatheringCopper$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WeatheringCopperGrateBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $WeatheringCopper$WeatherState$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getAge"(): $Enum
public "getChanceModifier"(): float
public "getNext"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getNext"(arg0: $Block$$Type): $Optional<($Block)>
public static "getFirst"(arg0: $BlockState$$Type): $BlockState
public static "getFirst"(arg0: $Block$$Type): $Block
public static "getPrevious"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getPrevious"(arg0: $Block$$Type): $Optional<($Block)>
public "changeOverTime"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getNextState"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($BlockState)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "age"(): $Enum
get "chanceModifier"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatheringCopperGrateBlock$$Type = ($WeatheringCopperGrateBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeatheringCopperGrateBlock$$Original = $WeatheringCopperGrateBlock;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.Passthrough" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RuleBlockEntityModifier$$Interface} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RuleBlockEntityModifierType} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifierType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $Passthrough implements $RuleBlockEntityModifier$$Interface {
static readonly "CODEC": $MapCodec<($Passthrough)>
static readonly "INSTANCE": $Passthrough

constructor()

public "apply"(arg0: $RandomSource$$Type, arg1: $CompoundTag$$Type): $CompoundTag
public "getType"(): $RuleBlockEntityModifierType<(never)>
get "type"(): $RuleBlockEntityModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Passthrough$$Type = ($Passthrough);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Passthrough$$Original = $Passthrough;}
declare module "net.minecraft.world.level.block.EnderChestBlock" {
import {$ChestBlockEntity} from "net.minecraft.world.level.block.entity.ChestBlockEntity"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$EnderChestBlockEntity} from "net.minecraft.world.level.block.entity.EnderChestBlockEntity"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$AbstractChestBlock} from "net.minecraft.world.level.block.AbstractChestBlock"
import {$DoubleBlockCombiner$NeighborCombineResult} from "net.minecraft.world.level.block.DoubleBlockCombiner$NeighborCombineResult"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $EnderChestBlock extends $AbstractChestBlock<($EnderChestBlockEntity)> implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($EnderChestBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "combine"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: boolean): $DoubleBlockCombiner$NeighborCombineResult<($ChestBlockEntity)>
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($EnderChestBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnderChestBlock$$Type = ($EnderChestBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnderChestBlock$$Original = $EnderChestBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.EndCityStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $EndCityStructure extends $Structure {
static readonly "CODEC": $MapCodec<($EndCityStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndCityStructure$$Type = ($EndCityStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndCityStructure$$Original = $EndCityStructure;}
declare module "net.minecraft.world.level.WorldDataConfiguration" {
import {$FeatureFlagSet, $FeatureFlagSet$$Type} from "net.minecraft.world.flag.FeatureFlagSet"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DataPackConfig, $DataPackConfig$$Type} from "net.minecraft.world.level.DataPackConfig"
import {$Record} from "java.lang.Record"

export class $WorldDataConfiguration extends $Record {
static readonly "CODEC": $Codec<($WorldDataConfiguration)>
static readonly "ENABLED_FEATURES_ID": StringJS
static readonly "DEFAULT": $WorldDataConfiguration

constructor(arg0: $DataPackConfig$$Type, arg1: $FeatureFlagSet$$Type)

public "expandFeatures"(arg0: $FeatureFlagSet$$Type): $WorldDataConfiguration
public "dataPacks"(): $DataPackConfig
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "enabledFeatures"(): $FeatureFlagSet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldDataConfiguration$$Type = ({"dataPacks"?: $DataPackConfig$$Type, "enabledFeatures"?: $FeatureFlagSet$$Type}) | ([dataPacks?: $DataPackConfig$$Type, enabledFeatures?: $FeatureFlagSet$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldDataConfiguration$$Original = $WorldDataConfiguration;}
declare module "net.minecraft.world.level.block.WetSpongeBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WetSpongeBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WetSpongeBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($WetSpongeBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WetSpongeBlock$$Type = ($WetSpongeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WetSpongeBlock$$Original = $WetSpongeBlock;}
declare module "net.minecraft.world.level.biome.Biome$Precipitation" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $Biome$Precipitation extends $Enum<($Biome$Precipitation)> implements $StringRepresentable$$Interface {
static readonly "RAIN": $Biome$Precipitation
static readonly "CODEC": $Codec<($Biome$Precipitation)>
static readonly "SNOW": $Biome$Precipitation
static readonly "NONE": $Biome$Precipitation

public static "values"(): ($Biome$Precipitation)[]
public static "valueOf"(arg0: StringJS): $Biome$Precipitation
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Biome$Precipitation$$Type = (("none") | ("rain") | ("snow"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Biome$Precipitation$$Original = $Biome$Precipitation;}
declare module "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$FrequencyReductionMethod" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $StructurePlacement$FrequencyReductionMethod extends $Enum<($StructurePlacement$FrequencyReductionMethod)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($StructurePlacement$FrequencyReductionMethod)>
static readonly "LEGACY_TYPE_3": $StructurePlacement$FrequencyReductionMethod
static readonly "LEGACY_TYPE_2": $StructurePlacement$FrequencyReductionMethod
static readonly "LEGACY_TYPE_1": $StructurePlacement$FrequencyReductionMethod
static readonly "DEFAULT": $StructurePlacement$FrequencyReductionMethod

public "shouldGenerate"(arg0: long, arg1: integer, arg2: integer, arg3: integer, arg4: float): boolean
public static "values"(): ($StructurePlacement$FrequencyReductionMethod)[]
public static "valueOf"(arg0: StringJS): $StructurePlacement$FrequencyReductionMethod
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePlacement$FrequencyReductionMethod$$Type = (("default") | ("legacy_type_1") | ("legacy_type_2") | ("legacy_type_3"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePlacement$FrequencyReductionMethod$$Original = $StructurePlacement$FrequencyReductionMethod;}
declare module "net.minecraft.world.level.block.GameMasterBlock" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $GameMasterBlock$$Interface {
}

export class $GameMasterBlock implements $GameMasterBlock$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameMasterBlock$$Type = ($GameMasterBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameMasterBlock$$Original = $GameMasterBlock;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.SolidPredicate" {
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StateTestingPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.StateTestingPredicate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

/**
 * 
 * @deprecated
 */
export class $SolidPredicate extends $StateTestingPredicate {
static readonly "CODEC": $MapCodec<($SolidPredicate)>

constructor(arg0: $Vec3i$$Type)

public "type"(): $BlockPredicateType<(never)>
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SolidPredicate$$Type = ($SolidPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SolidPredicate$$Original = $SolidPredicate;}
declare module "net.minecraft.world.level.chunk.BlockColumn" {
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockColumn$$Interface {
}

export class $BlockColumn implements $BlockColumn$$Interface {
 "getBlock"(arg0: integer): $BlockState
 "setBlock"(arg0: integer, arg1: $BlockState$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockColumn$$Type = ($BlockColumn);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockColumn$$Original = $BlockColumn;}
declare module "net.minecraft.world.level.block.LecternBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LecternBlock extends $BaseEntityBlock {
static readonly "SHAPE_NORTH": $VoxelShape
static readonly "SHAPE_SOUTH": $VoxelShape
static readonly "SHAPE_BASE": $VoxelShape
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "HAS_BOOK": $BooleanProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "SHAPE_COMMON": $VoxelShape
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE_POST": $VoxelShape
static readonly "SHAPE_TOP_PLATE": $VoxelShape
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "SHAPE_COLLISION": $VoxelShape
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "SHAPE_WEST": $VoxelShape
 "item": $Item
static readonly "CODEC": $MapCodec<($LecternBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "POWERED": $BooleanProperty
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "SHAPE_EAST": $VoxelShape

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "tryPlaceBook"(arg0: $LivingEntity$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $ItemStack$$Type): boolean
public static "resetBookState"(arg0: $Entity$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "signalPageChange"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "codec"(): $MapCodec<($LecternBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LecternBlock$$Type = ($LecternBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LecternBlock$$Original = $LecternBlock;}
declare module "net.minecraft.world.level.levelgen.feature.IceSpikeFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $IceSpikeFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IceSpikeFeature$$Type = ($IceSpikeFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IceSpikeFeature$$Original = $IceSpikeFeature;}
declare module "net.minecraft.world.level.block.state.properties.IntegerProperty" {
import {$Collection} from "java.util.Collection"
import {$Optional} from "java.util.Optional"
import {$Comparable$$Type} from "java.lang.Comparable"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $IntegerProperty extends $Property<(integer)> {
public "getPossibleValues"(): $Collection<(integer)>
public "generateHashCode"(): integer
public "getName"(arg0: integer): StringJS
public "getName"(arg0: $Comparable$$Type): StringJS
public "equals"(arg0: any): boolean
public "getValue"(arg0: StringJS): $Optional<(integer)>
public static "create"(arg0: StringJS, arg1: integer, arg2: integer): $IntegerProperty
get "possibleValues"(): $Collection<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntegerProperty$$Type = ($IntegerProperty);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IntegerProperty$$Original = $IntegerProperty;}
declare module "net.minecraft.world.level.CommonLevelAccessor" {
import {$Iterable} from "java.lang.Iterable"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder} from "net.minecraft.core.Holder"
import {$LevelReader$$Interface} from "net.minecraft.world.level.LevelReader"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$Class$$Type} from "java.lang.Class"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$LevelSimulatedRW$$Interface} from "net.minecraft.world.level.LevelSimulatedRW"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$EntityGetter, $EntityGetter$$Interface} from "net.minecraft.world.level.EntityGetter"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $CommonLevelAccessor$$Interface extends $EntityGetter$$Interface, $LevelReader$$Interface, $LevelSimulatedRW$$Interface {
get "height"(): integer
get "clientSide"(): boolean
get "minBuildHeight"(): integer
get "biomeManager"(): $BiomeManager
get "seaLevel"(): integer
get "skyDarken"(): integer
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "entities"(): $EntityArrayList
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $CommonLevelAccessor implements $CommonLevelAccessor$$Interface {
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
 "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
 "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
 "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
 "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
 "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
 "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
 "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
 "getPlayerByUUID"(arg0: $UUID$$Type): $Player
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
 "enabledFeatures"(): $FeatureFlagSet
 "registryAccess"(): $RegistryAccess
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "isClientSide"(): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getBiomeManager"(): $BiomeManager
/**
 * 
 * @deprecated
 */
 "hasChunk"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "dimensionType"(): $DimensionType
 "getSkyDarken"(): integer
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "self"(): $EntityGetter
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getWorldBorder"(): $WorldBorder
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntities"(): $EntityArrayList
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommonLevelAccessor$$Type = ($CommonLevelAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommonLevelAccessor$$Original = $CommonLevelAccessor;}
declare module "net.minecraft.world.level.storage.LevelStorageSource" {
import {$LevelStorageSource$LevelStorageAccess} from "net.minecraft.world.level.storage.LevelStorageSource$LevelStorageAccess"
import {$LevelDataAndDimensions} from "net.minecraft.world.level.storage.LevelDataAndDimensions"
import {$LevelStorageSource$LevelCandidates, $LevelStorageSource$LevelCandidates$$Type} from "net.minecraft.world.level.storage.LevelStorageSource$LevelCandidates"
import {$List} from "java.util.List"
import {$Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$PackRepository$$Type} from "net.minecraft.server.packs.repository.PackRepository"
import {$DirectoryValidator, $DirectoryValidator$$Type} from "net.minecraft.world.level.validation.DirectoryValidator"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"
import {$LevelStem$$Type} from "net.minecraft.world.level.dimension.LevelStem"
import {$RegistryAccess$Frozen$$Type} from "net.minecraft.core.RegistryAccess$Frozen"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$WorldLoader$PackConfig} from "net.minecraft.server.WorldLoader$PackConfig"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$LevelSummary} from "net.minecraft.world.level.storage.LevelSummary"
import {$WorldDataConfiguration, $WorldDataConfiguration$$Type} from "net.minecraft.world.level.WorldDataConfiguration"

export class $LevelStorageSource {
static readonly "ALLOWED_SYMLINKS_CONFIG_NAME": StringJS

constructor(arg0: $Path$$Type, arg1: $Path$$Type, arg2: $DirectoryValidator$$Type, arg3: $DataFixer$$Type)

public "getName"(): StringJS
public static "parseValidator"(arg0: $Path$$Type): $DirectoryValidator
public static "createDefault"(arg0: $Path$$Type): $LevelStorageSource
public "getLevelPath"(arg0: StringJS): $Path
public static "readDataConfig"(arg0: $Dynamic$$Type<(never)>): $WorldDataConfiguration
public static "getPackConfig"(arg0: $Dynamic$$Type<(never)>, arg1: $PackRepository$$Type, arg2: boolean): $WorldLoader$PackConfig
public static "getLevelDataAndDimensions"(arg0: $Dynamic$$Type<(never)>, arg1: $WorldDataConfiguration$$Type, arg2: $Registry$$Type<($LevelStem$$Type)>, arg3: $RegistryAccess$Frozen$$Type): $LevelDataAndDimensions
public "findLevelCandidates"(): $LevelStorageSource$LevelCandidates
public "loadLevelSummaries"(arg0: $LevelStorageSource$LevelCandidates$$Type): $CompletableFuture<($List<($LevelSummary)>)>
public "isNewLevelIdAcceptable"(arg0: StringJS): boolean
public "levelExists"(arg0: StringJS): boolean
public "getBaseDir"(): $Path
public "getBackupPath"(): $Path
public "validateAndCreateAccess"(arg0: StringJS): $LevelStorageSource$LevelStorageAccess
public "getWorldDirValidator"(): $DirectoryValidator
public "createAccess"(arg0: StringJS): $LevelStorageSource$LevelStorageAccess
get "name"(): StringJS
get "baseDir"(): $Path
get "backupPath"(): $Path
get "worldDirValidator"(): $DirectoryValidator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelStorageSource$$Type = ($LevelStorageSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelStorageSource$$Original = $LevelStorageSource;}
declare module "net.minecraft.world.level.Explosion$BlockInteraction" {
import {$Enum} from "java.lang.Enum"

export class $Explosion$BlockInteraction extends $Enum<($Explosion$BlockInteraction)> {
static readonly "TRIGGER_BLOCK": $Explosion$BlockInteraction
static readonly "DESTROY_WITH_DECAY": $Explosion$BlockInteraction
static readonly "DESTROY": $Explosion$BlockInteraction
static readonly "KEEP": $Explosion$BlockInteraction

public static "values"(): ($Explosion$BlockInteraction)[]
public static "valueOf"(arg0: StringJS): $Explosion$BlockInteraction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Explosion$BlockInteraction$$Type = (("keep") | ("destroy") | ("destroy_with_decay") | ("trigger_block"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Explosion$BlockInteraction$$Original = $Explosion$BlockInteraction;}
declare module "net.minecraft.world.level.block.CalibratedSculkSensorBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SculkSensorBlock} from "net.minecraft.world.level.block.SculkSensorBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$SculkSensorPhase} from "net.minecraft.world.level.block.state.properties.SculkSensorPhase"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $CalibratedSculkSensorBlock extends $SculkSensorBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CalibratedSculkSensorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "POWER": $IntegerProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "PHASE": $EnumProperty<($SculkSensorPhase)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "ACTIVE_TICKS": integer
static readonly "COOLDOWN_TICKS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getActiveTicks"(): integer
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "codec"(): $MapCodec<($CalibratedSculkSensorBlock)>
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "activeTicks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CalibratedSculkSensorBlock$$Type = ($CalibratedSculkSensorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CalibratedSculkSensorBlock$$Original = $CalibratedSculkSensorBlock;}
declare module "net.minecraft.world.level.levelgen.feature.SpikeFeature$EndSpike" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $SpikeFeature$EndSpike {
static readonly "CODEC": $Codec<($SpikeFeature$EndSpike)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: boolean)

public "getRadius"(): integer
public "isCenterWithinChunk"(arg0: $BlockPos$$Type): boolean
public "isGuarded"(): boolean
public "getTopBoundingBox"(): $AABB
public "getHeight"(): integer
public "getCenterX"(): integer
public "getCenterZ"(): integer
get "radius"(): integer
get "guarded"(): boolean
get "topBoundingBox"(): $AABB
get "height"(): integer
get "centerX"(): integer
get "centerZ"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpikeFeature$EndSpike$$Type = ($SpikeFeature$EndSpike);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpikeFeature$EndSpike$$Original = $SpikeFeature$EndSpike;}
declare module "net.minecraft.world.level.LevelTimeAccess" {
import {$Iterable} from "java.lang.Iterable"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder} from "net.minecraft.core.Holder"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$LevelReader$$Interface} from "net.minecraft.world.level.LevelReader"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $LevelTimeAccess$$Interface extends $LevelReader$$Interface {
get "moonBrightness"(): float
get "moonPhase"(): integer
get "height"(): integer
get "clientSide"(): boolean
get "minBuildHeight"(): integer
get "biomeManager"(): $BiomeManager
get "seaLevel"(): integer
get "skyDarken"(): integer
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $LevelTimeAccess implements $LevelTimeAccess$$Interface {
 "getTimeOfDay"(arg0: float): float
 "getMoonBrightness"(): float
 "dayTime"(): long
 "getMoonPhase"(): integer
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
 "enabledFeatures"(): $FeatureFlagSet
 "registryAccess"(): $RegistryAccess
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "isClientSide"(): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getBiomeManager"(): $BiomeManager
/**
 * 
 * @deprecated
 */
 "hasChunk"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "dimensionType"(): $DimensionType
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "getSkyDarken"(): integer
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getWorldBorder"(): $WorldBorder
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelTimeAccess$$Type = ($LevelTimeAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelTimeAccess$$Original = $LevelTimeAccess;}
declare module "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType" {
import {$SinglePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.SinglePoolElement"
import {$FeaturePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.FeaturePoolElement"
import {$EmptyPoolElement} from "net.minecraft.world.level.levelgen.structure.pools.EmptyPoolElement"
import {$StructurePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$LegacySinglePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.LegacySinglePoolElement"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ListPoolElement} from "net.minecraft.world.level.levelgen.structure.pools.ListPoolElement"

export interface $StructurePoolElementType$$Interface<P extends $StructurePoolElement> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructurePoolElement
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructurePoolElementTag
}

export class $StructurePoolElementType<P extends $StructurePoolElement> implements $StructurePoolElementType$$Interface {
static readonly "SINGLE": $StructurePoolElementType<($SinglePoolElement)>
static readonly "LEGACY": $StructurePoolElementType<($LegacySinglePoolElement)>
static readonly "FEATURE": $StructurePoolElementType<($FeaturePoolElement)>
static readonly "LIST": $StructurePoolElementType<($ListPoolElement)>
static readonly "EMPTY": $StructurePoolElementType<($EmptyPoolElement)>

static "register"<P extends $StructurePoolElement>(arg0: StringJS, arg1: $MapCodec$$Type<(P)>): $StructurePoolElementType<(P)>
 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePoolElementType$$Type<P> = (Special.WorldgenStructurePoolElement) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePoolElementType$$Original<P> = $StructurePoolElementType<(P)>;}
declare module "net.minecraft.world.level.block.Mirror" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Rotation} from "net.minecraft.world.level.block.Rotation"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Component} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$OctahedralGroup} from "com.mojang.math.OctahedralGroup"

export class $Mirror extends $Enum<($Mirror)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($Mirror)>
static readonly "FRONT_BACK": $Mirror
static readonly "LEFT_RIGHT": $Mirror
static readonly "NONE": $Mirror

public "symbol"(): $Component
public static "values"(): ($Mirror)[]
public static "valueOf"(arg0: StringJS): $Mirror
public "mirror"(arg0: $Direction$$Type): $Direction
public "mirror"(arg0: integer, arg1: integer): integer
public "getSerializedName"(): StringJS
public "rotation"(): $OctahedralGroup
public "getRotation"(arg0: $Direction$$Type): $Rotation
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Mirror$$Type = (("none") | ("left_right") | ("front_back"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Mirror$$Original = $Mirror;}
declare module "net.minecraft.world.level.block.KelpPlantBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$LiquidBlockContainer$$Interface} from "net.minecraft.world.level.block.LiquidBlockContainer"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$GrowingPlantBodyBlock} from "net.minecraft.world.level.block.GrowingPlantBodyBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $KelpPlantBlock extends $GrowingPlantBodyBlock implements $LiquidBlockContainer$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($KelpPlantBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "codec"(): $MapCodec<($KelpPlantBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KelpPlantBlock$$Type = ($KelpPlantBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KelpPlantBlock$$Original = $KelpPlantBlock;}
declare module "net.minecraft.world.level.levelgen.SurfaceRules$RuleSource" {
import {$SurfaceRules$SurfaceRule, $SurfaceRules$SurfaceRule$$Type} from "net.minecraft.world.level.levelgen.SurfaceRules$SurfaceRule"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type, $Function$$Interface} from "java.util.function.Function"
import {$SurfaceRules$Context, $SurfaceRules$Context$$Type} from "net.minecraft.world.level.levelgen.SurfaceRules$Context"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export interface $SurfaceRules$RuleSource$$Interface extends $Function$$Interface<($SurfaceRules$Context), ($SurfaceRules$SurfaceRule)> {
}

export class $SurfaceRules$RuleSource implements $SurfaceRules$RuleSource$$Interface {
static readonly "CODEC": $Codec<($SurfaceRules$RuleSource)>

static "bootstrap"(arg0: $Registry$$Type<($MapCodec$$Type<($SurfaceRules$RuleSource$$Type)>)>): $MapCodec<($SurfaceRules$RuleSource)>
 "codec"(): $KeyDispatchDataCodec<($SurfaceRules$RuleSource)>
 "apply"(arg0: $SurfaceRules$Context$$Type): $SurfaceRules$SurfaceRule
static "identity"<T>(): $Function<($SurfaceRules$Context), ($SurfaceRules$Context)>
 "compose"<V>(arg0: $Function$$Type<(V), ($SurfaceRules$Context$$Type)>): $Function<(V), ($SurfaceRules$SurfaceRule)>
 "andThen"<V>(arg0: $Function$$Type<($SurfaceRules$SurfaceRule), (V)>): $Function<($SurfaceRules$Context), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceRules$RuleSource$$Type = ($SurfaceRules$RuleSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SurfaceRules$RuleSource$$Original = $SurfaceRules$RuleSource;}
declare module "net.minecraft.world.level.block.SugarCaneBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $SugarCaneBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SugarCaneBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($SugarCaneBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SugarCaneBlock$$Type = ($SugarCaneBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SugarCaneBlock$$Original = $SugarCaneBlock;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$YClampedGradient" {
import {$DensityFunction$SimpleFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction$SimpleFunction"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$Record} from "java.lang.Record"
import {$DensityFunction} from "net.minecraft.world.level.levelgen.DensityFunction"

export class $DensityFunctions$YClampedGradient extends $Record implements $DensityFunction$SimpleFunction$$Interface {
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
public "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
public "cube"(): $DensityFunction
public "halfNegative"(): $DensityFunction
public "quarterNegative"(): $DensityFunction
public "squeeze"(): $DensityFunction
public "maxValue"(): double
public "abs"(): $DensityFunction
public "clamp"(arg0: double, arg1: double): $DensityFunction
public "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
public "square"(): $DensityFunction
public "minValue"(): double
public "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$YClampedGradient$$Type = ({"toValue"?: double, "fromValue"?: double, "fromY"?: integer, "toY"?: integer}) | ([toValue?: double, fromValue?: double, fromY?: integer, toY?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$YClampedGradient$$Original = $DensityFunctions$YClampedGradient;}
declare module "net.minecraft.world.level.pathfinder.NodeEvaluator" {
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$PathNavigationRegion$$Type} from "net.minecraft.world.level.PathNavigationRegion"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$PathfindingContext$$Type} from "net.minecraft.world.level.pathfinder.PathfindingContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Node, $Node$$Type} from "net.minecraft.world.level.pathfinder.Node"
import {$Target} from "net.minecraft.world.level.pathfinder.Target"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NodeEvaluator {
constructor()

public static "isBurningBlock"(arg0: $BlockState$$Type): boolean
public "canFloat"(): boolean
public "setCanOpenDoors"(arg0: boolean): void
public "setCanFloat"(arg0: boolean): void
public "setCanPassDoors"(arg0: boolean): void
public "getPathType"(arg0: $PathfindingContext$$Type, arg1: integer, arg2: integer, arg3: integer): $PathType
public "getPathType"(arg0: $Mob$$Type, arg1: $BlockPos$$Type): $PathType
public "canPassDoors"(): boolean
public "canOpenDoors"(): boolean
public "setCanWalkOverFences"(arg0: boolean): void
public "getNeighbors"(arg0: ($Node$$Type)[], arg1: $Node$$Type): integer
public "canWalkOverFences"(): boolean
public "getPathTypeOfMob"(arg0: $PathfindingContext$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: $Mob$$Type): $PathType
public "done"(): void
public "prepare"(arg0: $PathNavigationRegion$$Type, arg1: $Mob$$Type): void
public "getTarget"(arg0: double, arg1: double, arg2: double): $Target
public "getStart"(): $Node
get "start"(): $Node
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NodeEvaluator$$Type = ($NodeEvaluator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NodeEvaluator$$Original = $NodeEvaluator;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.DarkOakTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $DarkOakTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($DarkOakTrunkPlacer)>
static readonly "MAX_HEIGHT": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DarkOakTrunkPlacer$$Type = ($DarkOakTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DarkOakTrunkPlacer$$Original = $DarkOakTrunkPlacer;}
declare module "net.minecraft.world.level.biome.BiomeManager" {
import {$BiomeManager$NoiseBiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeManager$NoiseBiomeSource"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$BiomeManagerAccessor$$Interface} from "net.createmod.ponder.mixin.accessor.BiomeManagerAccessor"
import {$Holder} from "net.minecraft.core.Holder"

export class $BiomeManager implements $BiomeManagerAccessor$$Interface {
readonly "biomeZoomSeed": long
static readonly "CHUNK_CENTER_QUART": integer

constructor(arg0: $BiomeManager$NoiseBiomeSource$$Type, arg1: long)

public static "obfuscateSeed"(arg0: long): long
public "withDifferentSource"(arg0: $BiomeManager$NoiseBiomeSource$$Type): $BiomeManager
public "getNoiseBiomeAtPosition"(arg0: double, arg1: double, arg2: double): $Holder<($Biome)>
public "getNoiseBiomeAtPosition"(arg0: $BlockPos$$Type): $Holder<($Biome)>
public "catnip$getBiomeZoomSeed"(): long
public "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
public "getNoiseBiomeAtQuart"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeManager$$Type = ($BiomeManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeManager$$Original = $BiomeManager;}
declare module "net.minecraft.world.level.block.entity.TheEndPortalBlockEntity" {
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TheEndPortalBlockEntity extends $BlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "shouldRenderFace"(arg0: $Direction$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TheEndPortalBlockEntity$$Type = ($TheEndPortalBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TheEndPortalBlockEntity$$Original = $TheEndPortalBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"

export class $TreeDecorator {
static readonly "CODEC": $Codec<($TreeDecorator)>

constructor()

public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeDecorator$$Type = ($TreeDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeDecorator$$Original = $TreeDecorator;}
declare module "net.minecraft.world.level.entity.Visibility" {
import {$Enum} from "java.lang.Enum"
import {$FullChunkStatus$$Type} from "net.minecraft.server.level.FullChunkStatus"

export class $Visibility extends $Enum<($Visibility)> {
static readonly "TICKING": $Visibility
static readonly "TRACKED": $Visibility
static readonly "HIDDEN": $Visibility

public "isTicking"(): boolean
public static "fromFullChunkStatus"(arg0: $FullChunkStatus$$Type): $Visibility
public static "values"(): ($Visibility)[]
public static "valueOf"(arg0: StringJS): $Visibility
public "isAccessible"(): boolean
get "ticking"(): boolean
get "accessible"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Visibility$$Type = (("hidden") | ("tracked") | ("ticking"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Visibility$$Original = $Visibility;}
declare module "net.minecraft.world.level.block.PlayerWallHeadBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$WallSkullBlock} from "net.minecraft.world.level.block.WallSkullBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PlayerWallHeadBlock extends $WallSkullBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PlayerWallHeadBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($PlayerWallHeadBlock)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerWallHeadBlock$$Type = ($PlayerWallHeadBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerWallHeadBlock$$Original = $PlayerWallHeadBlock;}
declare module "net.minecraft.world.level.storage.loot.predicates.AllOfCondition$Builder" {
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$CompositeLootItemCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.CompositeLootItemCondition$Builder"

export class $AllOfCondition$Builder extends $CompositeLootItemCondition$Builder {
constructor(...arg0: ($LootItemCondition$Builder$$Type)[])

public "and"(arg0: $LootItemCondition$Builder$$Type): $AllOfCondition$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllOfCondition$Builder$$Type = ($AllOfCondition$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllOfCondition$Builder$$Original = $AllOfCondition$Builder;}
declare module "net.minecraft.world.level.levelgen.feature.BlockColumnFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration, $BlockColumnConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $BlockColumnFeature extends $Feature<($BlockColumnConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($BlockColumnConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($BlockColumnConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockColumnFeature$$Type = ($BlockColumnFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockColumnFeature$$Original = $BlockColumnFeature;}
declare module "net.minecraft.world.level.block.MangroveLeavesBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$LeavesBlock} from "net.minecraft.world.level.block.LeavesBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MangroveLeavesBlock extends $LeavesBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "DISTANCE": $IntegerProperty
static readonly "PERSISTENT": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($MangroveLeavesBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "DECAY_DISTANCE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "codec"(): $MapCodec<($MangroveLeavesBlock)>
public "getType"(): $BonemealableBlock$Type
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MangroveLeavesBlock$$Type = ($MangroveLeavesBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MangroveLeavesBlock$$Original = $MangroveLeavesBlock;}
declare module "net.minecraft.world.level.levelgen.placement.NoiseBasedCountPlacement" {
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$RepeatingPlacement} from "net.minecraft.world.level.levelgen.placement.RepeatingPlacement"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $NoiseBasedCountPlacement extends $RepeatingPlacement {
static readonly "CODEC": $MapCodec<($NoiseBasedCountPlacement)>

public "type"(): $PlacementModifierType<(never)>
public static "of"(arg0: integer, arg1: double, arg2: double): $NoiseBasedCountPlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseBasedCountPlacement$$Type = ($NoiseBasedCountPlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseBasedCountPlacement$$Original = $NoiseBasedCountPlacement;}
declare module "net.minecraft.world.level.levelgen.structure.structures.StrongholdStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $StrongholdStructure extends $Structure {
static readonly "CODEC": $MapCodec<($StrongholdStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StrongholdStructure$$Type = ($StrongholdStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StrongholdStructure$$Original = $StrongholdStructure;}
declare module "net.minecraft.world.level.block.SculkBehaviour" {
import {$SculkSpreader, $SculkSpreader$$Type} from "net.minecraft.world.level.block.SculkSpreader"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Collection$$Type} from "java.util.Collection"
import {$SculkSpreader$ChargeCursor, $SculkSpreader$ChargeCursor$$Type} from "net.minecraft.world.level.block.SculkSpreader$ChargeCursor"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $SculkBehaviour$$Interface {

(arg0: $SculkSpreader$ChargeCursor, arg1: $LevelAccessor, arg2: $BlockPos, arg3: $RandomSource, arg4: $SculkSpreader, arg5: boolean): integer
get "sculkSpreadDelay"(): byte
}

export class $SculkBehaviour implements $SculkBehaviour$$Interface {
static readonly "DEFAULT": $SculkBehaviour

 "canChangeBlockStateOnSpread"(): boolean
 "attemptUseCharge"(arg0: $SculkSpreader$ChargeCursor$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type, arg4: $SculkSpreader$$Type, arg5: boolean): integer
 "getSculkSpreadDelay"(): byte
 "onDischarged"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
 "depositCharge"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): boolean
 "attemptSpreadVein"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Collection$$Type<($Direction$$Type)>, arg4: boolean): boolean
 "updateDecayDelay"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkBehaviour$$Type = ((arg0: $SculkSpreader$ChargeCursor, arg1: $LevelAccessor, arg2: $BlockPos, arg3: $RandomSource, arg4: $SculkSpreader, arg5: boolean) => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkBehaviour$$Original = $SculkBehaviour;}
declare module "net.minecraft.world.level.levelgen.feature.CoralTreeFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$CoralFeature} from "net.minecraft.world.level.levelgen.feature.CoralFeature"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $CoralTreeFeature extends $CoralFeature {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoralTreeFeature$$Type = ($CoralTreeFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CoralTreeFeature$$Original = $CoralTreeFeature;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$Codec} from "com.mojang.serialization.Codec"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $FoliagePlacer {
static readonly "CODEC": $Codec<($FoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type)

public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer): void
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
public "foliageRadius"(arg0: $RandomSource$$Type, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoliagePlacer$$Type = ($FoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoliagePlacer$$Original = $FoliagePlacer;}
declare module "net.minecraft.world.level.levelgen.placement.PlacementFilter" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"

export class $PlacementFilter extends $PlacementModifier {
static readonly "CODEC": $Codec<($PlacementModifier)>

constructor()

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacementFilter$$Type = ($PlacementFilter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacementFilter$$Original = $PlacementFilter;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record} from "java.lang.Record"

export class $TwistingVinesConfig extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($TwistingVinesConfig)>

constructor(arg0: integer, arg1: integer, arg2: integer)

public "maxHeight"(): integer
public "spreadWidth"(): integer
public "spreadHeight"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TwistingVinesConfig$$Type = ({"spreadHeight"?: integer, "maxHeight"?: integer, "spreadWidth"?: integer}) | ([spreadHeight?: integer, maxHeight?: integer, spreadWidth?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TwistingVinesConfig$$Original = $TwistingVinesConfig;}
declare module "net.minecraft.world.level.saveddata.maps.MapItemSavedData" {
import {$Iterable} from "java.lang.Iterable"
import {$CustomMapData$Type$$Type} from "net.mehvahdjukaar.moonlight.api.map.CustomMapData$Type"
import {$FramedMap$MarkerRemover$$Interface} from "xfacthd.framedblocks.common.data.component.FramedMap$MarkerRemover"
import {$MapId$$Type} from "net.minecraft.world.level.saveddata.maps.MapId"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List$$Type} from "java.util.List"
import {$ExpandedMapData$$Interface} from "net.mehvahdjukaar.moonlight.api.map.ExpandedMapData"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MapDecoration, $MapDecoration$$Type} from "net.minecraft.world.level.saveddata.maps.MapDecoration"
import {$SavedData} from "net.minecraft.world.level.saveddata.SavedData"
import {$MapItemSavedData$HoldingPlayer} from "net.minecraft.world.level.saveddata.maps.MapItemSavedData$HoldingPlayer"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$MapDecorationType$$Type} from "net.minecraft.world.level.saveddata.maps.MapDecorationType"
import {$StationBlockEntity$$Type} from "com.simibubi.create.content.trains.station.StationBlockEntity"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$MapOpacity$$Interface} from "ca.fxco.moreculling.api.map.MapOpacity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$StationMarker$$Type} from "com.simibubi.create.content.trains.station.StationMarker"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection} from "java.util.Collection"
import {$Map} from "java.util.Map"
import {$MLMapMarker$$Type} from "net.mehvahdjukaar.moonlight.api.map.decoration.MLMapMarker"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$MapBanner} from "net.minecraft.world.level.saveddata.maps.MapBanner"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$StationMapData$$Interface} from "com.simibubi.create.content.trains.station.StationMapData"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$SavedData$Factory} from "net.minecraft.world.level.saveddata.SavedData$Factory"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $MapItemSavedData extends $SavedData implements $MapOpacity$$Interface, $ExpandedMapData$$Interface, $FramedMap$MarkerRemover$$Interface, $StationMapData$$Interface {
 "centerZ": integer
static readonly "TRACKED_DECORATION_LIMIT": integer
 "centerX": integer
readonly "moonlight$customData": $Map
 "moonlight$customDecorations": $Map
readonly "scale": byte
static readonly "MAX_SCALE": integer
 "dimension": $ResourceKey<($Level)>
 "colors": (byte)[]

public "moreculling$hasTransparency"(): boolean
public "getUpdatePacket"(arg0: $MapId$$Type, arg1: $Player$$Type): $Packet<(never)>
public static "createFresh"(arg0: double, arg1: double, arg2: byte, arg3: boolean, arg4: boolean, arg5: $ResourceKey$$Type<($Level)>): $MapItemSavedData
public "getHoldingPlayer"(arg0: $Player$$Type): $MapItemSavedData$HoldingPlayer
public "checkBanners"(arg0: $BlockGetter$$Type, arg1: integer, arg2: integer): void
public "updateColor"(arg0: integer, arg1: integer, arg2: byte): boolean
public "tickCarriedBy"(arg0: $Player$$Type, arg1: $ItemStack$$Type): void
public "scaled"(): $MapItemSavedData
public "toggleBanner"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): boolean
public "ml$getCustomData"(): $Map
public "removedFromFrame"(arg0: $BlockPos$$Type, arg1: integer): void
public "isTrackedCountOverLimit"(arg0: integer): boolean
public "isExplorationMap"(): boolean
public static "addTargetDecoration"(arg0: $ItemStack$$Type, arg1: $BlockPos$$Type, arg2: StringJS, arg3: $Holder$$Type<($MapDecorationType)>): void
public "toggleStation"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $StationBlockEntity$$Type): boolean
public "ml$toggleCustomDecoration"(world: $LevelAccessor$$Type, pos: $BlockPos$$Type): boolean
public "handler$eam000$moonlight$initCustomData"(i: integer, j: integer, b: byte, bl: boolean, bl2: boolean, bl3: boolean, resourceKey: $ResourceKey$$Type, ci: $CallbackInfo$$Type): void
public static "createForClient"(arg0: byte, arg1: boolean, arg2: $ResourceKey$$Type<($Level)>): $MapItemSavedData
public "addDecoration"(arg0: $Holder$$Type<($MapDecorationType)>, arg1: $LevelAccessor$$Type, arg2: StringJS, arg3: double, arg4: double, arg5: double, arg6: $Component$$Type): void
public "handler$eam000$moonlight$save"(tag: $CompoundTag$$Type, registries: $HolderLookup$Provider$$Type, cir: $CallbackInfoReturnable$$Type): void
public "handler$eam000$moonlight$locked"(cir: $CallbackInfoReturnable$$Type): void
public "handler$eam000$moonlight$scaled"(cir: $CallbackInfoReturnable$$Type): void
public "removeDecoration"(arg0: StringJS): void
public "handler$eam000$moonlight$tickCarriedBy"(player: $Player$$Type, stack: $ItemStack$$Type, ci: $CallbackInfo$$Type): void
public "handler$eam000$moonlight$checkCustomDeco"(world: $BlockGetter$$Type, x: integer, z: integer, ci: $CallbackInfo$$Type): void
public "handler$fei000$create$onCheckBanners"(arg0: $BlockGetter$$Type, arg1: integer, arg2: integer, arg3: $CallbackInfo$$Type): void
public "getBanners"(): $Collection<($MapBanner)>
public "modifyReturnValue$eam000$moonlight$ml$isExplorationMap"(original: boolean): boolean
public "addClientSideDecorations"(arg0: $List$$Type<($MapDecoration$$Type)>): void
public "ml$setCustomDecorationsDirty"(): void
public "ml$setCustomDataDirty"(type: $CustomMapData$Type$$Type, dirtySetter: $Consumer$$Type): void
public "ml$getCustomDecorations"(): $Map
public "ml$getCustomMarkers"(): $Map
public "ml$getVanillaDecorationSize"(): integer
public "ml$addCustomMarker"(marker: $MLMapMarker$$Type): void
public "ml$removeCustomMarker"(key: StringJS): boolean
public "ml$copy"(): $MapItemSavedData
public "ml$resetCustomDecoration"(): void
public "framedblocks$removeMapMarker"(arg0: $BlockPos$$Type): void
public "addStationMarker"(arg0: $StationMarker$$Type): void
public "setColor"(arg0: integer, arg1: integer, arg2: byte): void
public static "load"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $MapItemSavedData
public static "factory"(): $SavedData$Factory<($MapItemSavedData)>
public "save"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "locked"(): $MapItemSavedData
public "getDecorations"(): $Iterable<($MapDecoration)>
get "explorationMap"(): boolean
get "banners"(): $Collection<($MapBanner)>
get "decorations"(): $Iterable<($MapDecoration)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapItemSavedData$$Type = ($MapItemSavedData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapItemSavedData$$Original = $MapItemSavedData;}
declare module "net.minecraft.world.level.levelgen.placement.PlacedFeature" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$ConfiguredFeature, $ConfiguredFeature$$Type} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$HolderSet} from "net.minecraft.core.HolderSet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier, $PlacementModifier$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"
import {$Record} from "java.lang.Record"

export class $PlacedFeature extends $Record {
static readonly "CODEC": $Codec<($Holder<($PlacedFeature)>)>
static readonly "DIRECT_CODEC": $Codec<($PlacedFeature)>
static readonly "LIST_CODEC": $Codec<($HolderSet<($PlacedFeature)>)>
static readonly "LIST_OF_LISTS_CODEC": $Codec<($List<($HolderSet<($PlacedFeature)>)>)>

constructor(arg0: $Holder$$Type<($ConfiguredFeature<(never), (never)>)>, arg1: $List$$Type<($PlacementModifier$$Type)>)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
public "placement"(): $List<($PlacementModifier)>
public "placeWithBiomeCheck"(arg0: $WorldGenLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): boolean
public "place"(arg0: $WorldGenLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): boolean
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "feature"(): $Holder<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenPlacedFeature
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenPlacedFeatureTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacedFeature$$Type = (Special.WorldgenPlacedFeature) | ({"placement"?: $List$$Type<($PlacementModifier$$Type)>, "feature"?: $Holder$$Type<($ConfiguredFeature<(never), (never)>)>}) | ([placement?: $List$$Type<($PlacementModifier$$Type)>, feature?: $Holder$$Type<($ConfiguredFeature<(never), (never)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacedFeature$$Original = $PlacedFeature;}
declare module "net.minecraft.world.level.chunk.PalettedContainer$Strategy" {
import {$PalettedContainer$Configuration} from "net.minecraft.world.level.chunk.PalettedContainer$Configuration"
import {$Palette$Factory} from "net.minecraft.world.level.chunk.Palette$Factory"
import {$IdMap$$Type} from "net.minecraft.core.IdMap"

export class $PalettedContainer$Strategy {
static "SECTION_STATES": $PalettedContainer$Strategy
static readonly "SINGLE_VALUE_PALETTE_FACTORY": $Palette$Factory
static readonly "LINEAR_PALETTE_FACTORY": $Palette$Factory
static "SECTION_BIOMES": $PalettedContainer$Strategy
static readonly "HASHMAP_PALETTE_FACTORY": $Palette$Factory

constructor(arg0: integer)

public "calculateBitsForSerialization"<A>(arg0: $IdMap$$Type<(A)>, arg1: integer): integer
public "size"(): integer
public "getIndex"(arg0: integer, arg1: integer, arg2: integer): integer
public "getConfiguration"<A>(arg0: $IdMap$$Type<(A)>, arg1: integer): $PalettedContainer$Configuration<(A)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainer$Strategy$$Type = ($PalettedContainer$Strategy);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainer$Strategy$$Original = $PalettedContainer$Strategy;}
declare module "net.minecraft.world.level.block.entity.DropperBlockEntity" {
import {$DispenserBlockEntity} from "net.minecraft.world.level.block.entity.DispenserBlockEntity"
import {$Level} from "net.minecraft.world.level.Level"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$Component} from "net.minecraft.network.chat.Component"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DropperBlockEntity extends $DispenserBlockEntity {
static readonly "CONTAINER_SIZE": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public "lithium$emitRemoved"(): void
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitContentModified"(): void
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "tryClear"(arg0: any): void
get "changed"(): void
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropperBlockEntity$$Type = ($DropperBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DropperBlockEntity$$Original = $DropperBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.RandomPatchFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration, $RandomPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $RandomPatchFeature extends $Feature<($RandomPatchConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($RandomPatchConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($RandomPatchConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomPatchFeature$$Type = ($RandomPatchFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomPatchFeature$$Original = $RandomPatchFeature;}
declare module "net.minecraft.world.level.block.AbstractSkullBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Holder} from "net.minecraft.core.Holder"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$EquipmentSlot} from "net.minecraft.world.entity.EquipmentSlot"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SkullBlock$Type, $SkullBlock$Type$$Type} from "net.minecraft.world.level.block.SkullBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Equipable, $Equipable$$Interface} from "net.minecraft.world.item.Equipable"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AbstractSkullBlock extends $BaseEntityBlock implements $Equipable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $SkullBlock$Type$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getType"(): $SkullBlock$Type
public "getEquipmentSlot"(): $EquipmentSlot
public "swapWithEquipmentSlot"(arg0: $Item$$Type, arg1: $Level$$Type, arg2: $Player$$Type, arg3: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public "getEquipSound"(): $Holder<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $SkullBlock$Type
get "equipmentSlot"(): $EquipmentSlot
get "equipSound"(): $Holder<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractSkullBlock$$Type = ($AbstractSkullBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractSkullBlock$$Original = $AbstractSkullBlock;}
declare module "net.minecraft.world.level.block.state.properties.StructureMode" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Component} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $StructureMode extends $Enum<($StructureMode)> implements $StringRepresentable$$Interface {
static readonly "CORNER": $StructureMode
static readonly "LOAD": $StructureMode
static readonly "DATA": $StructureMode
static readonly "SAVE": $StructureMode

public static "values"(): ($StructureMode)[]
public static "valueOf"(arg0: StringJS): $StructureMode
public "getDisplayName"(): $Component
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "displayName"(): $Component
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureMode$$Type = (("save") | ("load") | ("corner") | ("data"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureMode$$Original = $StructureMode;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.DualNoiseProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InclusiveRange$$Type} from "net.minecraft.util.InclusiveRange"
import {$List$$Type} from "java.util.List"
import {$NoiseProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DualNoiseProvider extends $NoiseProvider {
static readonly "CODEC": $MapCodec<($DualNoiseProvider)>

constructor(arg0: $InclusiveRange$$Type<(integer)>, arg1: $NormalNoise$NoiseParameters$$Type, arg2: float, arg3: long, arg4: $NormalNoise$NoiseParameters$$Type, arg5: float, arg6: $List$$Type<($BlockState$$Type)>)

public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DualNoiseProvider$$Type = ($DualNoiseProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DualNoiseProvider$$Original = $DualNoiseProvider;}
declare module "net.minecraft.world.level.levelgen.structure.structures.JungleTempleStructure" {
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$SinglePieceStructure} from "net.minecraft.world.level.levelgen.structure.SinglePieceStructure"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $JungleTempleStructure extends $SinglePieceStructure {
static readonly "CODEC": $MapCodec<($JungleTempleStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JungleTempleStructure$$Type = ($JungleTempleStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JungleTempleStructure$$Original = $JungleTempleStructure;}
declare module "net.minecraft.world.level.block.BubbleColumnBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BucketPickup$$Interface} from "net.minecraft.world.level.block.BucketPickup"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BubbleColumnBlock extends $Block implements $BucketPickup$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BubbleColumnBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "DRAG_DOWN": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getPickupSound"(): $Optional<($SoundEvent)>
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public static "updateColumn"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type): void
public static "updateColumn"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($BubbleColumnBlock)>
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BubbleColumnBlock$$Type = ($BubbleColumnBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BubbleColumnBlock$$Original = $BubbleColumnBlock;}
declare module "net.minecraft.world.level.block.TorchflowerCropBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$CropBlock} from "net.minecraft.world.level.block.CropBlock"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TorchflowerCropBlock extends $CropBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TorchflowerCropBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "randomTick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getStateForAge"(arg0: integer): $BlockState
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getMaxAge"(): integer
public "codec"(): $MapCodec<($TorchflowerCropBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "maxAge"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TorchflowerCropBlock$$Type = ($TorchflowerCropBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TorchflowerCropBlock$$Original = $TorchflowerCropBlock;}
declare module "net.minecraft.world.level.block.CrafterBlock" {
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$RecipeHolder} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$CraftingRecipe} from "net.minecraft.world.item.crafting.CraftingRecipe"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CrafterBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CrafterBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "CRAFTING": $BooleanProperty
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "TRIGGERED": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "getPotentialResults"(arg0: $Level$$Type, arg1: $CraftingInput$$Type): $Optional<($RecipeHolder<($CraftingRecipe)>)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrafterBlock$$Type = ($CrafterBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CrafterBlock$$Original = $CrafterBlock;}
declare module "net.minecraft.world.level.block.SculkSensorBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$SculkSensorPhase} from "net.minecraft.world.level.block.state.properties.SculkSensorPhase"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SculkSensorBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SculkSensorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "POWER": $IntegerProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "PHASE": $EnumProperty<($SculkSensorPhase)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "ACTIVE_TICKS": integer
static readonly "COOLDOWN_TICKS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getExpDrop"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): integer
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "canActivate"(arg0: $BlockState$$Type): boolean
public "getActiveTicks"(): integer
public static "tryResonateVibration"(arg0: $Entity$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: integer): void
public "activate"(arg0: $Entity$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: integer, arg5: integer): void
public static "deactivate"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public static "getPhase"(arg0: $BlockState$$Type): $SculkSensorPhase
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($SculkSensorBlock)>
public "stepOn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type): void
public "getDirectSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "activeTicks"(): integer
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkSensorBlock$$Type = ($SculkSensorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkSensorBlock$$Original = $SculkSensorBlock;}
declare module "net.minecraft.world.level.block.entity.DecoratedPotPattern" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Record} from "java.lang.Record"

export class $DecoratedPotPattern extends $Record {
constructor(arg0: $ResourceLocation$$Type)

public "assetId"(): $ResourceLocation
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.DecoratedPotPattern
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.DecoratedPotPatternTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DecoratedPotPattern$$Type = (Special.DecoratedPotPattern) | ({"assetId"?: $ResourceLocation$$Type}) | ([assetId?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DecoratedPotPattern$$Original = $DecoratedPotPattern;}
declare module "net.minecraft.world.level.block.NetherSproutsBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $NetherSproutsBlock extends $BushBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($NetherSproutsBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($NetherSproutsBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherSproutsBlock$$Type = ($NetherSproutsBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherSproutsBlock$$Original = $NetherSproutsBlock;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.ProtectedBlockProcessor" {
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $ProtectedBlockProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($ProtectedBlockProcessor)>
readonly "cannotReplace": $TagKey<($Block)>

constructor(arg0: $TagKey$$Type<($Block)>)

public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProtectedBlockProcessor$$Type = ($ProtectedBlockProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProtectedBlockProcessor$$Original = $ProtectedBlockProcessor;}
declare module "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $TrialSpawnerState extends $Enum<($TrialSpawnerState)> implements $StringRepresentable$$Interface {
static readonly "COOLDOWN": $TrialSpawnerState
static readonly "ACTIVE": $TrialSpawnerState
static readonly "INACTIVE": $TrialSpawnerState
static readonly "EJECTING_REWARD": $TrialSpawnerState
static readonly "WAITING_FOR_REWARD_EJECTION": $TrialSpawnerState
static readonly "WAITING_FOR_PLAYERS": $TrialSpawnerState

public "lightLevel"(): integer
public "spinningMobSpeed"(): double
public "isCapableOfSpawning"(): boolean
public "hasSpinningMob"(): boolean
public "emitParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: boolean): void
public static "values"(): ($TrialSpawnerState)[]
public static "valueOf"(arg0: StringJS): $TrialSpawnerState
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "capableOfSpawning"(): boolean
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawnerState$$Type = (("inactive") | ("waiting_for_players") | ("active") | ("waiting_for_reward_ejection") | ("ejecting_reward") | ("cooldown"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawnerState$$Original = $TrialSpawnerState;}
declare module "net.minecraft.world.level.block.MultifaceSpreader$SpreadType" {
import {$Enum} from "java.lang.Enum"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$MultifaceSpreader$SpreadPos} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadPos"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $MultifaceSpreader$SpreadType extends $Enum<($MultifaceSpreader$SpreadType)> {
static readonly "WRAP_AROUND": $MultifaceSpreader$SpreadType
static readonly "SAME_POSITION": $MultifaceSpreader$SpreadType
static readonly "SAME_PLANE": $MultifaceSpreader$SpreadType

public "getSpreadPos"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: $Direction$$Type): $MultifaceSpreader$SpreadPos
public static "values"(): ($MultifaceSpreader$SpreadType)[]
public static "valueOf"(arg0: StringJS): $MultifaceSpreader$SpreadType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceSpreader$SpreadType$$Type = (("same_position") | ("same_plane") | ("wrap_around"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceSpreader$SpreadType$$Original = $MultifaceSpreader$SpreadType;}
declare module "net.minecraft.world.level.block.LiquidBlockContainer" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $LiquidBlockContainer$$Interface {
}

export class $LiquidBlockContainer implements $LiquidBlockContainer$$Interface {
 "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
 "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LiquidBlockContainer$$Type = ($LiquidBlockContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LiquidBlockContainer$$Original = $LiquidBlockContainer;}
declare module "net.minecraft.world.level.block.CoralBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CoralBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CoralBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "DEAD_CORAL_FIELD": $MapCodec<($Block)>
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($CoralBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoralBlock$$Type = ($CoralBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CoralBlock$$Original = $CoralBlock;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.TrunkVineDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $TrunkVineDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($TrunkVineDecorator)>
static readonly "INSTANCE": $TrunkVineDecorator

constructor()

public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrunkVineDecorator$$Type = ($TrunkVineDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrunkVineDecorator$$Original = $TrunkVineDecorator;}
declare module "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration" {
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HugeFungusConfiguration implements $FeatureConfiguration$$Interface {
readonly "validBaseState": $BlockState
readonly "replaceableBlocks": $BlockPredicate
static readonly "CODEC": $Codec<($HugeFungusConfiguration)>
readonly "decorState": $BlockState
readonly "planted": boolean
readonly "hatState": $BlockState
readonly "stemState": $BlockState

constructor(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $BlockPredicate$$Type, arg5: boolean)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HugeFungusConfiguration$$Type = ($HugeFungusConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HugeFungusConfiguration$$Original = $HugeFungusConfiguration;}
declare module "net.minecraft.world.level.block.entity.BlockEntityType" {
import {$ChestBlockEntity} from "net.minecraft.world.level.block.entity.ChestBlockEntity"
import {$BlockEntityType$BlockEntitySupplier$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType$BlockEntitySupplier"
import {$ChiseledBookShelfBlockEntity} from "net.minecraft.world.level.block.entity.ChiseledBookShelfBlockEntity"
import {$DispenserBlockEntity} from "net.minecraft.world.level.block.entity.DispenserBlockEntity"
import {$HopperBlockEntity} from "net.minecraft.world.level.block.entity.HopperBlockEntity"
import {$SignBlockEntity} from "net.minecraft.world.level.block.entity.SignBlockEntity"
import {$SmokerBlockEntity} from "net.minecraft.world.level.block.entity.SmokerBlockEntity"
import {$BarrelBlockEntity} from "net.minecraft.world.level.block.entity.BarrelBlockEntity"
import {$SculkSensorBlockEntity} from "net.minecraft.world.level.block.entity.SculkSensorBlockEntity"
import {$JigsawBlockEntity} from "net.minecraft.world.level.block.entity.JigsawBlockEntity"
import {$BrushableBlockEntity} from "net.minecraft.world.level.block.entity.BrushableBlockEntity"
import {$BlockEntityTypeMethods$$Interface} from "forge.me.thosea.badoptimizations.interfaces.BlockEntityTypeMethods"
import {$JukeboxBlockEntity} from "net.minecraft.world.level.block.entity.JukeboxBlockEntity"
import {$CommandBlockEntity} from "net.minecraft.world.level.block.entity.CommandBlockEntity"
import {$BrewingStandBlockEntity} from "net.minecraft.world.level.block.entity.BrewingStandBlockEntity"
import {$BannerBlockEntity} from "net.minecraft.world.level.block.entity.BannerBlockEntity"
import {$DaylightDetectorBlockEntity} from "net.minecraft.world.level.block.entity.DaylightDetectorBlockEntity"
import {$TrappedChestBlockEntity} from "net.minecraft.world.level.block.entity.TrappedChestBlockEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BeaconBlockEntity} from "net.minecraft.world.level.block.entity.BeaconBlockEntity"
import {$TheEndGatewayBlockEntity} from "net.minecraft.world.level.block.entity.TheEndGatewayBlockEntity"
import {$CalibratedSculkSensorBlockEntity} from "net.minecraft.world.level.block.entity.CalibratedSculkSensorBlockEntity"
import {$TrialSpawnerBlockEntity} from "net.minecraft.world.level.block.entity.TrialSpawnerBlockEntity"
import {$PistonMovingBlockEntity} from "net.minecraft.world.level.block.piston.PistonMovingBlockEntity"
import {$BlockEntityVisualizer, $BlockEntityVisualizer$$Type} from "dev.engine_room.flywheel.api.visualization.BlockEntityVisualizer"
import {$DecoratedPotBlockEntity} from "net.minecraft.world.level.block.entity.DecoratedPotBlockEntity"
import {$CrafterBlockEntity} from "net.minecraft.world.level.block.entity.CrafterBlockEntity"
import {$VaultBlockEntity} from "net.minecraft.world.level.block.entity.vault.VaultBlockEntity"
import {$BlockEntityRenderer, $BlockEntityRenderer$$Type} from "net.minecraft.client.renderer.blockentity.BlockEntityRenderer"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$AccessorBlockEntityType$$Interface} from "com.railwayteam.railways.mixin.AccessorBlockEntityType"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockEntityTypeAccessor$$Interface} from "net.neoforged.neoforge.mixins.BlockEntityTypeAccessor"
import {$ConduitBlockEntity} from "net.minecraft.world.level.block.entity.ConduitBlockEntity"
import {$Type$$Type} from "com.mojang.datafixers.types.Type"
import {$SculkShriekerBlockEntity} from "net.minecraft.world.level.block.entity.SculkShriekerBlockEntity"
import {$DropperBlockEntity} from "net.minecraft.world.level.block.entity.DropperBlockEntity"
import {$BlockEntityTypeExtension$$Interface} from "dev.engine_room.flywheel.impl.extension.BlockEntityTypeExtension"
import {$TheEndPortalBlockEntity} from "net.minecraft.world.level.block.entity.TheEndPortalBlockEntity"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$EnchantingTableBlockEntity} from "net.minecraft.world.level.block.entity.EnchantingTableBlockEntity"
import {$SculkCatalystBlockEntity} from "net.minecraft.world.level.block.entity.SculkCatalystBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CampfireBlockEntity} from "net.minecraft.world.level.block.entity.CampfireBlockEntity"
import {$BellBlockEntity} from "net.minecraft.world.level.block.entity.BellBlockEntity"
import {$LecternBlockEntity} from "net.minecraft.world.level.block.entity.LecternBlockEntity"
import {$EnderChestBlockEntity} from "net.minecraft.world.level.block.entity.EnderChestBlockEntity"
import {$FurnaceBlockEntity} from "net.minecraft.world.level.block.entity.FurnaceBlockEntity"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$SpawnerBlockEntity} from "net.minecraft.world.level.block.entity.SpawnerBlockEntity"
import {$ShulkerBoxBlockEntity} from "net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity"
import {$BETypeAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.BETypeAccess"
import {$BeehiveBlockEntity} from "net.minecraft.world.level.block.entity.BeehiveBlockEntity"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$HangingSignBlockEntity} from "net.minecraft.world.level.block.entity.HangingSignBlockEntity"
import {$StructureBlockEntity} from "net.minecraft.world.level.block.entity.StructureBlockEntity"
import {$BlockEntityTypeAccess$$Interface} from "me.desht.pneumaticcraft.mixin.accessors.BlockEntityTypeAccess"
import {$BedBlockEntity} from "net.minecraft.world.level.block.entity.BedBlockEntity"
import {$SkullBlockEntity} from "net.minecraft.world.level.block.entity.SkullBlockEntity"
import {$BlastFurnaceBlockEntity} from "net.minecraft.world.level.block.entity.BlastFurnaceBlockEntity"
import {$ComparatorBlockEntity} from "net.minecraft.world.level.block.entity.ComparatorBlockEntity"

export class $BlockEntityType<T extends $BlockEntity> implements $BlockEntityTypeAccessor$$Interface, $AccessorBlockEntityType$$Interface, $BlockEntityTypeAccess$$Interface, $BETypeAccess$$Interface, $BlockEntityTypeExtension$$Interface, $BlockEntityTypeMethods$$Interface {
static readonly "BLAST_FURNACE": $BlockEntityType<($BlastFurnaceBlockEntity)>
static readonly "HANGING_SIGN": $BlockEntityType<($HangingSignBlockEntity)>
static readonly "COMPARATOR": $BlockEntityType<($ComparatorBlockEntity)>
static readonly "VAULT": $BlockEntityType<($VaultBlockEntity)>
static readonly "SKULL": $BlockEntityType<($SkullBlockEntity)>
static readonly "CHISELED_BOOKSHELF": $BlockEntityType<($ChiseledBookShelfBlockEntity)>
static readonly "JIGSAW": $BlockEntityType<($JigsawBlockEntity)>
static readonly "DECORATED_POT": $BlockEntityType<($DecoratedPotBlockEntity)>
static readonly "BEACON": $BlockEntityType<($BeaconBlockEntity)>
static readonly "CRAFTER": $BlockEntityType<($CrafterBlockEntity)>
static readonly "FURNACE": $BlockEntityType<($FurnaceBlockEntity)>
static readonly "BEEHIVE": $BlockEntityType<($BeehiveBlockEntity)>
static readonly "PISTON": $BlockEntityType<($PistonMovingBlockEntity)>
static readonly "TRAPPED_CHEST": $BlockEntityType<($TrappedChestBlockEntity)>
static readonly "END_PORTAL": $BlockEntityType<($TheEndPortalBlockEntity)>
static readonly "ENDER_CHEST": $BlockEntityType<($EnderChestBlockEntity)>
static readonly "COMMAND_BLOCK": $BlockEntityType<($CommandBlockEntity)>
static readonly "SIGN": $BlockEntityType<($SignBlockEntity)>
static readonly "STRUCTURE_BLOCK": $BlockEntityType<($StructureBlockEntity)>
static readonly "BELL": $BlockEntityType<($BellBlockEntity)>
static readonly "ENCHANTING_TABLE": $BlockEntityType<($EnchantingTableBlockEntity)>
static readonly "BREWING_STAND": $BlockEntityType<($BrewingStandBlockEntity)>
static readonly "BED": $BlockEntityType<($BedBlockEntity)>
static readonly "MOB_SPAWNER": $BlockEntityType<($SpawnerBlockEntity)>
static readonly "CALIBRATED_SCULK_SENSOR": $BlockEntityType<($CalibratedSculkSensorBlockEntity)>
static readonly "SCULK_CATALYST": $BlockEntityType<($SculkCatalystBlockEntity)>
static readonly "CONDUIT": $BlockEntityType<($ConduitBlockEntity)>
static readonly "CAMPFIRE": $BlockEntityType<($CampfireBlockEntity)>
static readonly "END_GATEWAY": $BlockEntityType<($TheEndGatewayBlockEntity)>
static readonly "SMOKER": $BlockEntityType<($SmokerBlockEntity)>
static readonly "DISPENSER": $BlockEntityType<($DispenserBlockEntity)>
static readonly "SCULK_SHRIEKER": $BlockEntityType<($SculkShriekerBlockEntity)>
static readonly "HOPPER": $BlockEntityType<($HopperBlockEntity)>
static readonly "CHEST": $BlockEntityType<($ChestBlockEntity)>
static readonly "DAYLIGHT_DETECTOR": $BlockEntityType<($DaylightDetectorBlockEntity)>
static readonly "BANNER": $BlockEntityType<($BannerBlockEntity)>
static readonly "SCULK_SENSOR": $BlockEntityType<($SculkSensorBlockEntity)>
static readonly "TRIAL_SPAWNER": $BlockEntityType<($TrialSpawnerBlockEntity)>
static readonly "LECTERN": $BlockEntityType<($LecternBlockEntity)>
static readonly "SHULKER_BOX": $BlockEntityType<($ShulkerBoxBlockEntity)>
static readonly "BRUSHABLE_BLOCK": $BlockEntityType<($BrushableBlockEntity)>
static readonly "JUKEBOX": $BlockEntityType<($JukeboxBlockEntity)>
static readonly "BARREL": $BlockEntityType<($BarrelBlockEntity)>
static readonly "DROPPER": $BlockEntityType<($DropperBlockEntity)>

constructor(arg0: $BlockEntityType$BlockEntitySupplier$$Type<(T)>, arg1: $Set$$Type<($Block$$Type)>, arg2: $Type$$Type<(never)>)

public "builtInRegistryHolder"(): $Holder$Reference<($BlockEntityType<(never)>)>
public "flywheel$getVisualizer"(): $BlockEntityVisualizer
public "flywheel$setVisualizer"(visualizer: $BlockEntityVisualizer$$Type): void
public "bo$setRenderer"(renderer: $BlockEntityRenderer$$Type): void
public "getValidBlocks"(): $Set
public "neoforge$setValidBlocks"(arg0: $Set$$Type): void
public "setValidBlocks"(arg0: $Set$$Type): void
public "isValid"(arg0: $BlockState$$Type): boolean
public static "getKey"(arg0: $BlockEntityType$$Type<(never)>): $ResourceLocation
public "create"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): T
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): T
public "bo$getRenderer"(): $BlockEntityRenderer
get "validBlocks"(): $Set
set "validBlocks"(value: $Set$$Type)
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.BlockEntityType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.BlockEntityTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityType$$Type<T> = (Special.BlockEntityType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityType$$Original<T> = $BlockEntityType<(T)>;}
declare module "net.minecraft.world.level.dimension.DimensionType$MonsterSettings" {
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $DimensionType$MonsterSettings extends $Record {
static readonly "CODEC": $MapCodec<($DimensionType$MonsterSettings)>

constructor(arg0: boolean, arg1: boolean, arg2: $IntProvider$$Type, arg3: integer)

public "monsterSpawnBlockLightLimit"(): integer
public "monsterSpawnLightTest"(): $IntProvider
public "piglinSafe"(): boolean
public "hasRaids"(): boolean
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionType$MonsterSettings$$Type = ({"monsterSpawnLightTest"?: $IntProvider$$Type, "hasRaids"?: boolean, "monsterSpawnBlockLightLimit"?: integer, "piglinSafe"?: boolean}) | ([monsterSpawnLightTest?: $IntProvider$$Type, hasRaids?: boolean, monsterSpawnBlockLightLimit?: integer, piglinSafe?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionType$MonsterSettings$$Original = $DimensionType$MonsterSettings;}
declare module "net.minecraft.world.level.block.FletchingTableBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$CraftingTableBlock} from "net.minecraft.world.level.block.CraftingTableBlock"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FletchingTableBlock extends $CraftingTableBlock implements $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FletchingTableBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "moreculling$customShouldDrawFace"(arg0: $BlockGetter$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: $Direction$$Type): $Optional
public "moreculling$usesCustomShouldDrawFace"(arg0: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($FletchingTableBlock)>
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FletchingTableBlock$$Type = ($FletchingTableBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FletchingTableBlock$$Original = $FletchingTableBlock;}
declare module "net.minecraft.world.level.block.ObserverBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$DirectionalBlock} from "net.minecraft.world.level.block.DirectionalBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ObserverBlock extends $DirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ObserverBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "wrapWithCondition$bcb000$supplementaries$supp$preventSlidyBlockUpdates"(instance: $ObserverBlock$$Type, level: $LevelAccessor$$Type, pos: $BlockPos$$Type, neighbor: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($ObserverBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObserverBlock$$Type = ($ObserverBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ObserverBlock$$Original = $ObserverBlock;}
declare module "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$ExclusionZone" {
import {$StructureSet, $StructureSet$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSet"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

/**
 * 
 * @deprecated
 */
export class $StructurePlacement$ExclusionZone extends $Record {
static readonly "CODEC": $Codec<($StructurePlacement$ExclusionZone)>

constructor(arg0: $Holder$$Type<($StructureSet)>, arg1: integer)

public "otherSet"(): $Holder<($StructureSet)>
public "chunkCount"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePlacement$ExclusionZone$$Type = ({"chunkCount"?: integer, "otherSet"?: $Holder$$Type<($StructureSet)>}) | ([chunkCount?: integer, otherSet?: $Holder$$Type<($StructureSet)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePlacement$ExclusionZone$$Original = $StructurePlacement$ExclusionZone;}
declare module "net.minecraft.world.level.block.SaplingBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$TreeGrower$$Type} from "net.minecraft.world.level.block.grower.TreeGrower"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SaplingBlock extends $BushBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SaplingBlock)>
static readonly "STAGE": $IntegerProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $TreeGrower$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "advanceTree"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($SaplingBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SaplingBlock$$Type = ($SaplingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SaplingBlock$$Original = $SaplingBlock;}
declare module "net.minecraft.world.level.levelgen.NoiseChunk" {
import {$NoiseGeneratorSettings$$Type} from "net.minecraft.world.level.levelgen.NoiseGeneratorSettings"
import {$IExtendedNoiseChunk$AquifierNuke, $IExtendedNoiseChunk$AquifierNuke$$Type} from "io.redspace.ironsspellbooks.worldgen.IExtendedNoiseChunk$AquifierNuke"
import {$DensityFunction$ContextProvider$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Blender, $Blender$$Type} from "net.minecraft.world.level.levelgen.blending.Blender"
import {$NoiseSettings$$Type} from "net.minecraft.world.level.levelgen.NoiseSettings"
import {$DensityFunction$FunctionContext, $DensityFunction$FunctionContext$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"
import {$Aquifer} from "net.minecraft.world.level.levelgen.Aquifer"
import {$DensityFunctions$BeardifierOrMarker$$Type} from "net.minecraft.world.level.levelgen.DensityFunctions$BeardifierOrMarker"
import {$Aquifer$FluidPicker$$Type} from "net.minecraft.world.level.levelgen.Aquifer$FluidPicker"
import {$IExtendedNoiseChunk$$Interface} from "io.redspace.ironsspellbooks.worldgen.IExtendedNoiseChunk"

export class $NoiseChunk implements $DensityFunction$ContextProvider$$Interface, $DensityFunction$FunctionContext$$Interface, $IExtendedNoiseChunk$$Interface {
constructor(arg0: integer, arg1: $RandomState$$Type, arg2: integer, arg3: integer, arg4: $NoiseSettings$$Type, arg5: $DensityFunctions$BeardifierOrMarker$$Type, arg6: $NoiseGeneratorSettings$$Type, arg7: $Aquifer$FluidPicker$$Type, arg8: $Blender$$Type)

public "blockY"(): integer
public "blockZ"(): integer
public "blockX"(): integer
public "getBlender"(): $Blender
public static "forChunk"(arg0: $ChunkAccess$$Type, arg1: $RandomState$$Type, arg2: $DensityFunctions$BeardifierOrMarker$$Type, arg3: $NoiseGeneratorSettings$$Type, arg4: $Aquifer$FluidPicker$$Type, arg5: $Blender$$Type): $NoiseChunk
public "initializeForFirstCellX"(): void
public "advanceCellX"(arg0: integer): void
public "selectCellYZ"(arg0: integer, arg1: integer): void
public "updateForY"(arg0: integer, arg1: double): void
public "updateForX"(arg0: integer, arg1: double): void
public "updateForZ"(arg0: integer, arg1: double): void
public "stopInterpolation"(): void
public "aquifer"(): $Aquifer
public "fillAllDirectly"(arg0: (double)[], arg1: $DensityFunction$$Type): void
public "swapSlices"(): void
public "irons_spellbooks$setAquifierStatus"(arg0: $IExtendedNoiseChunk$AquifierNuke$$Type): void
public "forIndex"(arg0: integer): $DensityFunction$FunctionContext
public "irons_spellbooks$getAquifierStatus"(): $IExtendedNoiseChunk$AquifierNuke
public "preliminarySurfaceLevel"(arg0: integer, arg1: integer): integer
get "blender"(): $Blender
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseChunk$$Type = ($NoiseChunk);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseChunk$$Original = $NoiseChunk;}
declare module "net.minecraft.world.level.block.entity.SculkSensorBlockEntity" {
import {$VibrationSystem$Data} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Data"
import {$GameEventListener$Provider$$Interface} from "net.minecraft.world.level.gameevent.GameEventListener$Provider"
import {$VibrationSystem$Listener} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Listener"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$VibrationSystem$User} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$User"
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$VibrationSystem$$Interface} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SculkSensorBlockEntity extends $BlockEntity implements $GameEventListener$Provider$$Interface<($VibrationSystem$Listener)>, $VibrationSystem$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getVibrationUser"(): $VibrationSystem$User
public "getLastVibrationFrequency"(): integer
public "getVibrationData"(): $VibrationSystem$Data
public "createVibrationUser"(): $VibrationSystem$User
public "setLastVibrationFrequency"(arg0: integer): void
public "getListener"(): $GameEventListener
public static "getResonanceEventByFrequency"(arg0: integer): $ResourceKey<($GameEvent)>
public static "getGameEventFrequency"(arg0: $ResourceKey$$Type<($GameEvent)>): integer
public static "getGameEventFrequency"(arg0: $Holder$$Type<($GameEvent)>): integer
public static "getRedstoneStrengthForDistance"(arg0: float, arg1: integer): integer
get "vibrationUser"(): $VibrationSystem$User
get "lastVibrationFrequency"(): integer
get "vibrationData"(): $VibrationSystem$Data
set "lastVibrationFrequency"(value: integer)
get "listener"(): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkSensorBlockEntity$$Type = ($SculkSensorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkSensorBlockEntity$$Original = $SculkSensorBlockEntity;}
declare module "net.minecraft.world.level.storage.loot.providers.nbt.LootNbtProviderType" {
import {$NbtProvider, $NbtProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.nbt.NbtProvider"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $LootNbtProviderType extends $Record {
constructor(arg0: $MapCodec$$Type<($NbtProvider$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "codec"(): $MapCodec<($NbtProvider)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.LootNbtProviderType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.LootNbtProviderTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootNbtProviderType$$Type = (Special.LootNbtProviderType) | ({"codec"?: $MapCodec$$Type<($NbtProvider$$Type)>}) | ([codec?: $MapCodec$$Type<($NbtProvider$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootNbtProviderType$$Original = $LootNbtProviderType;}
declare module "net.minecraft.world.level.block.AttachedStemBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AttachedStemBlock extends $BushBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($AttachedStemBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $ResourceKey$$Type<($Block)>, arg1: $ResourceKey$$Type<($Block)>, arg2: $ResourceKey$$Type<($Item)>, arg3: $BlockBehaviour$Properties$$Type)

public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($AttachedStemBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedStemBlock$$Type = ($AttachedStemBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttachedStemBlock$$Original = $AttachedStemBlock;}
declare module "net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity$AnimationStatus" {
import {$Enum} from "java.lang.Enum"

export class $ShulkerBoxBlockEntity$AnimationStatus extends $Enum<($ShulkerBoxBlockEntity$AnimationStatus)> {
static readonly "CLOSED": $ShulkerBoxBlockEntity$AnimationStatus
static readonly "CLOSING": $ShulkerBoxBlockEntity$AnimationStatus
static readonly "OPENING": $ShulkerBoxBlockEntity$AnimationStatus
static readonly "OPENED": $ShulkerBoxBlockEntity$AnimationStatus

public static "values"(): ($ShulkerBoxBlockEntity$AnimationStatus)[]
public static "valueOf"(arg0: StringJS): $ShulkerBoxBlockEntity$AnimationStatus
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShulkerBoxBlockEntity$AnimationStatus$$Type = (("closed") | ("opening") | ("opened") | ("closing"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShulkerBoxBlockEntity$AnimationStatus$$Original = $ShulkerBoxBlockEntity$AnimationStatus;}
declare module "net.minecraft.world.level.biome.BiomeSpecialEffects$Builder" {
import {$AmbientMoodSettings, $AmbientMoodSettings$$Type} from "net.minecraft.world.level.biome.AmbientMoodSettings"
import {$BiomeSpecialEffects$GrassColorModifier$$Type} from "net.minecraft.world.level.biome.BiomeSpecialEffects$GrassColorModifier"
import {$Optional} from "java.util.Optional"
import {$AmbientParticleSettings$$Type} from "net.minecraft.world.level.biome.AmbientParticleSettings"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$AmbientAdditionsSettings, $AmbientAdditionsSettings$$Type} from "net.minecraft.world.level.biome.AmbientAdditionsSettings"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Music$$Type} from "net.minecraft.sounds.Music"
import {$BiomeSpecialEffects} from "net.minecraft.world.level.biome.BiomeSpecialEffects"

export class $BiomeSpecialEffects$Builder {
 "ambientLoopSoundEvent": $Optional<($Holder<($SoundEvent)>)>
 "ambientAdditionsSettings": $Optional<($AmbientAdditionsSettings)>
 "ambientMoodSettings": $Optional<($AmbientMoodSettings)>

constructor()

public "fogColor"(arg0: integer): $BiomeSpecialEffects$Builder
public "waterColor"(arg0: integer): $BiomeSpecialEffects$Builder
public "waterFogColor"(arg0: integer): $BiomeSpecialEffects$Builder
public "foliageColorOverride"(arg0: integer): $BiomeSpecialEffects$Builder
public "grassColorOverride"(arg0: integer): $BiomeSpecialEffects$Builder
public "grassColorModifier"(arg0: $BiomeSpecialEffects$GrassColorModifier$$Type): $BiomeSpecialEffects$Builder
public "backgroundMusic"(arg0: $Music$$Type): $BiomeSpecialEffects$Builder
public "ambientMoodSound"(arg0: $AmbientMoodSettings$$Type): $BiomeSpecialEffects$Builder
public "ambientParticle"(arg0: $AmbientParticleSettings$$Type): $BiomeSpecialEffects$Builder
public "ambientLoopSound"(arg0: $Holder$$Type<($SoundEvent)>): $BiomeSpecialEffects$Builder
public "ambientAdditionsSound"(arg0: $AmbientAdditionsSettings$$Type): $BiomeSpecialEffects$Builder
public "build"(): $BiomeSpecialEffects
public "skyColor"(arg0: integer): $BiomeSpecialEffects$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeSpecialEffects$Builder$$Type = ($BiomeSpecialEffects$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeSpecialEffects$Builder$$Original = $BiomeSpecialEffects$Builder;}
declare module "net.minecraft.world.level.levelgen.LegacyRandomSource" {
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$PositionalRandomFactory} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"
import {$BitRandomSource$$Interface} from "net.minecraft.world.level.levelgen.BitRandomSource"

export class $LegacyRandomSource implements $BitRandomSource$$Interface {
constructor(arg0: long)

public "fork"(): $RandomSource
public "setSeed"(arg0: long): void
public "nextGaussian"(): double
public "next"(arg0: integer): integer
public "forkPositional"(): $PositionalRandomFactory
public "nextFloat"(): float
public "nextDouble"(): double
public "nextInt"(): integer
public "nextInt"(arg0: integer): integer
public "nextLong"(): long
public "nextBoolean"(): boolean
public static "create"(): $RandomSource
public static "create"(arg0: long): $RandomSource
public "nextInt"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public static "createThreadSafe"(): $RandomSource
public "triangle"(arg0: double, arg1: double): double
public "nextIntBetweenInclusive"(arg0: integer, arg1: integer): integer
public static "createNewThreadLocalInstance"(): $RandomSource
public "consumeCount"(arg0: integer): void
set "seed"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyRandomSource$$Type = ($LegacyRandomSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LegacyRandomSource$$Original = $LegacyRandomSource;}
declare module "net.minecraft.world.level.block.WallSignBlock" {
import {$SignBlock} from "net.minecraft.world.level.block.SignBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$WoodType$$Type} from "net.minecraft.world.level.block.state.properties.WoodType"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WallSignBlock extends $SignBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WallSignBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $WoodType$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getYRotationDegrees"(arg0: $BlockState$$Type): float
public "getSignHitboxCenterPosition"(arg0: $BlockState$$Type): $Vec3
public "getDescriptionId"(): StringJS
public "codec"(): $MapCodec<($WallSignBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallSignBlock$$Type = ($WallSignBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallSignBlock$$Original = $WallSignBlock;}
declare module "net.minecraft.world.level.block.SpreadingSnowyDirtBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$SnowyDirtBlock} from "net.minecraft.world.level.block.SnowyDirtBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $SpreadingSnowyDirtBlock extends $SnowyDirtBlock {
static readonly "SNOWY": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SnowyDirtBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpreadingSnowyDirtBlock$$Type = ($SpreadingSnowyDirtBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpreadingSnowyDirtBlock$$Original = $SpreadingSnowyDirtBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.OceanMonumentStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$PiecesContainer, $PiecesContainer$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $OceanMonumentStructure extends $Structure {
static readonly "CODEC": $MapCodec<($OceanMonumentStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public static "regeneratePiecesAfterLoad"(arg0: $ChunkPos$$Type, arg1: long, arg2: $PiecesContainer$$Type): $PiecesContainer
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OceanMonumentStructure$$Type = ($OceanMonumentStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OceanMonumentStructure$$Original = $OceanMonumentStructure;}
declare module "net.minecraft.world.level.block.LanternBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LanternBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LanternBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "HANGING": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($LanternBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LanternBlock$$Type = ($LanternBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LanternBlock$$Original = $LanternBlock;}
declare module "net.minecraft.world.level.block.entity.vault.VaultBlockEntity" {
import {$VaultServerData} from "net.minecraft.world.level.block.entity.vault.VaultServerData"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$VaultSharedData} from "net.minecraft.world.level.block.entity.vault.VaultSharedData"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$VaultConfig, $VaultConfig$$Type} from "net.minecraft.world.level.block.entity.vault.VaultConfig"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$VaultClientData} from "net.minecraft.world.level.block.entity.vault.VaultClientData"
import {$ClientGamePacketListener} from "net.minecraft.network.protocol.game.ClientGamePacketListener"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $VaultBlockEntity extends $BlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getSharedData"(): $VaultSharedData
public "getClientData"(): $VaultClientData
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "setConfig"(arg0: $VaultConfig$$Type): void
public "getConfig"(): $VaultConfig
public "getServerData"(): $VaultServerData
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "sharedData"(): $VaultSharedData
get "clientData"(): $VaultClientData
set "config"(value: $VaultConfig$$Type)
get "config"(): $VaultConfig
get "serverData"(): $VaultServerData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultBlockEntity$$Type = ($VaultBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultBlockEntity$$Original = $VaultBlockEntity;}
declare module "net.minecraft.world.level.block.entity.BannerPatternLayers$Layer" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BannerPattern, $BannerPattern$$Type} from "net.minecraft.world.level.block.entity.BannerPattern"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $BannerPatternLayers$Layer extends $Record {
static readonly "CODEC": $Codec<($BannerPatternLayers$Layer)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($BannerPatternLayers$Layer)>

constructor(arg0: $Holder$$Type<($BannerPattern)>, arg1: $DyeColor$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "pattern"(): $Holder<($BannerPattern)>
public "color"(): $DyeColor
public "description"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BannerPatternLayers$Layer$$Type = ({"color"?: $DyeColor$$Type, "pattern"?: $Holder$$Type<($BannerPattern)>}) | ([color?: $DyeColor$$Type, pattern?: $Holder$$Type<($BannerPattern)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BannerPatternLayers$Layer$$Original = $BannerPatternLayers$Layer;}
declare module "net.minecraft.world.level.WorldGenLevel" {
import {$Iterable} from "java.lang.Iterable"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$LevelData} from "net.minecraft.world.level.storage.LevelData"
import {$ServerLevelAccessor$$Interface} from "net.minecraft.world.level.ServerLevelAccessor"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ChunkSource} from "net.minecraft.world.level.chunk.ChunkSource"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$TickPriority$$Type} from "net.minecraft.world.ticks.TickPriority"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$Class$$Type} from "java.lang.Class"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$LevelTickAccess} from "net.minecraft.world.ticks.LevelTickAccess"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$DifficultyInstance} from "net.minecraft.world.DifficultyInstance"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $WorldGenLevel$$Interface extends $ServerLevelAccessor$$Interface {
set "currentlyGenerating"(value: $Supplier$$Type<(StringJS)>)
get "seed"(): long
get "level"(): $ServerLevel
get "levelData"(): $LevelData
get "chunkSource"(): $ChunkSource
get "random"(): $RandomSource
get "difficulty"(): $Difficulty
get "server"(): $MinecraftServer
get "blockTicks"(): $LevelTickAccess<($Block)>
get "fluidTicks"(): $LevelTickAccess<($Fluid)>
get "moonBrightness"(): float
get "moonPhase"(): integer
get "height"(): integer
get "clientSide"(): boolean
get "minBuildHeight"(): integer
get "biomeManager"(): $BiomeManager
get "seaLevel"(): integer
get "skyDarken"(): integer
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "entities"(): $EntityArrayList
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $WorldGenLevel implements $WorldGenLevel$$Interface {
 "ensureCanWrite"(arg0: $BlockPos$$Type): boolean
 "setCurrentlyGenerating"(arg0: $Supplier$$Type<(StringJS)>): void
 "getSeed"(): long
 "addFreshEntityWithPassengers"(arg0: $Entity$$Type): void
 "getLevel"(): $ServerLevel
 "getLevelData"(): $LevelData
 "getChunkSource"(): $ChunkSource
 "gameEvent"(arg0: $ResourceKey$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $Vec3$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $BlockPos$$Type): void
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $Vec3$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "getRandom"(): $RandomSource
 "addParticle"(arg0: $ParticleOptions$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): void
 "getDifficulty"(): $Difficulty
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type): void
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
 "getServer"(): $MinecraftServer
 "levelEvent"(arg0: $Player$$Type, arg1: integer, arg2: $BlockPos$$Type, arg3: integer): void
 "levelEvent"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
 "neighborShapeChanged"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
 "hasChunk"(arg0: integer, arg1: integer): boolean
 "getCurrentDifficultyAt"(arg0: $BlockPos$$Type): $DifficultyInstance
 "blockUpdated"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
 "nextSubTickCount"(): long
 "dayTime"(): long
 "getBlockTicks"(): $LevelTickAccess<($Block)>
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer): void
 "getFluidTicks"(): $LevelTickAccess<($Fluid)>
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getTimeOfDay"(arg0: float): float
 "getMoonBrightness"(): float
 "getMoonPhase"(): integer
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
 "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
 "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
 "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
 "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
 "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
 "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
 "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
 "getPlayerByUUID"(arg0: $UUID$$Type): $Player
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
 "enabledFeatures"(): $FeatureFlagSet
 "registryAccess"(): $RegistryAccess
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "isClientSide"(): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getBiomeManager"(): $BiomeManager
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "dimensionType"(): $DimensionType
 "getSkyDarken"(): integer
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "self"(): $EntityGetter
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getWorldBorder"(): $WorldBorder
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntities"(): $EntityArrayList
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldGenLevel$$Type = ($WorldGenLevel);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldGenLevel$$Original = $WorldGenLevel;}
declare module "net.minecraft.world.level.levelgen.structure.structures.IglooStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $IglooStructure extends $Structure {
static readonly "CODEC": $MapCodec<($IglooStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IglooStructure$$Type = ($IglooStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IglooStructure$$Original = $IglooStructure;}
declare module "net.minecraft.world.level.block.ChangeOverTimeBlock" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Optional} from "java.util.Optional"
import {$Enum} from "java.lang.Enum"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $ChangeOverTimeBlock$$Interface<T extends $Enum<(object)>> {
get "chanceModifier"(): float
get "age"(): T
}

export class $ChangeOverTimeBlock<T extends $Enum<(object)>> implements $ChangeOverTimeBlock$$Interface {
static readonly "SCAN_DISTANCE": integer

 "changeOverTime"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
 "getChanceModifier"(): float
 "getNextState"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($BlockState)>
 "getNext"(arg0: $BlockState$$Type): $Optional<($BlockState)>
 "getAge"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChangeOverTimeBlock$$Type<T> = ($ChangeOverTimeBlock<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChangeOverTimeBlock$$Original<T> = $ChangeOverTimeBlock<(T)>;}
declare module "net.minecraft.world.level.block.MyceliumBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$SpreadingSnowyDirtBlock} from "net.minecraft.world.level.block.SpreadingSnowyDirtBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MyceliumBlock extends $SpreadingSnowyDirtBlock {
static readonly "SNOWY": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($MyceliumBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($MyceliumBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MyceliumBlock$$Type = ($MyceliumBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MyceliumBlock$$Original = $MyceliumBlock;}
declare module "net.minecraft.world.level.GameRules$GameRuleTypeVisitor" {
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"
import {$GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$GameRules$BooleanValue$$Type} from "net.minecraft.world.level.GameRules$BooleanValue"
import {$GameRules$Key$$Type} from "net.minecraft.world.level.GameRules$Key"
import {$GameRules$IntegerValue$$Type} from "net.minecraft.world.level.GameRules$IntegerValue"

export interface $GameRules$GameRuleTypeVisitor$$Interface {
}

export class $GameRules$GameRuleTypeVisitor implements $GameRules$GameRuleTypeVisitor$$Interface {
 "visitInteger"(arg0: $GameRules$Key$$Type<($GameRules$IntegerValue$$Type)>, arg1: $GameRules$Type$$Type<($GameRules$IntegerValue$$Type)>): void
 "visit"<T extends $GameRules$Value<(object)>>(arg0: $GameRules$Key$$Type<(T)>, arg1: $GameRules$Type$$Type<(T)>): void
 "visitBoolean"(arg0: $GameRules$Key$$Type<($GameRules$BooleanValue$$Type)>, arg1: $GameRules$Type$$Type<($GameRules$BooleanValue$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$GameRuleTypeVisitor$$Type = ($GameRules$GameRuleTypeVisitor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$GameRuleTypeVisitor$$Original = $GameRules$GameRuleTypeVisitor;}
declare module "net.minecraft.world.level.levelgen.placement.SurfaceRelativeThresholdFilter" {
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$PlacementFilter} from "net.minecraft.world.level.levelgen.placement.PlacementFilter"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SurfaceRelativeThresholdFilter extends $PlacementFilter {
static readonly "CODEC": $MapCodec<($SurfaceRelativeThresholdFilter)>

public "type"(): $PlacementModifierType<(never)>
public static "of"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): $SurfaceRelativeThresholdFilter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceRelativeThresholdFilter$$Type = ($SurfaceRelativeThresholdFilter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SurfaceRelativeThresholdFilter$$Original = $SurfaceRelativeThresholdFilter;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureEntityInfo" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $StructureTemplate$StructureEntityInfo {
readonly "nbt": $CompoundTag
readonly "blockPos": $BlockPos
readonly "pos": $Vec3

constructor(arg0: $Vec3$$Type, arg1: $BlockPos$$Type, arg2: $CompoundTag$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplate$StructureEntityInfo$$Type = ($StructureTemplate$StructureEntityInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplate$StructureEntityInfo$$Original = $StructureTemplate$StructureEntityInfo;}
declare module "net.minecraft.world.level.chunk.PalettedContainer$CountConsumer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $PalettedContainer$CountConsumer$$Interface<T> {

(arg0: T, arg1: integer): void
}

export class $PalettedContainer$CountConsumer<T> implements $PalettedContainer$CountConsumer$$Interface {
 "accept"(arg0: T, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainer$CountConsumer$$Type<T> = ((arg0: T, arg1: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainer$CountConsumer$$Original<T> = $PalettedContainer$CountConsumer<(T)>;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.BlackstoneReplaceProcessor" {
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $BlackstoneReplaceProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($BlackstoneReplaceProcessor)>
static readonly "INSTANCE": $BlackstoneReplaceProcessor

public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlackstoneReplaceProcessor$$Type = ($BlackstoneReplaceProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlackstoneReplaceProcessor$$Original = $BlackstoneReplaceProcessor;}
declare module "net.minecraft.world.level.chunk.ChunkAccess" {
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor, $LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$NoiseChunk, $NoiseChunk$$Type} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$BelowZeroRetrogen} from "net.minecraft.world.level.levelgen.BelowZeroRetrogen"
import {$ChunkAccess$TicksToSave} from "net.minecraft.world.level.chunk.ChunkAccess$TicksToSave"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$Holder} from "net.minecraft.core.Holder"
import {$Map$Entry} from "java.util.Map$Entry"
import {$TickContainerAccess} from "net.minecraft.world.ticks.TickContainerAccess"
import {$BlendingData, $BlendingData$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData"
import {$IAttachmentHolder$$Interface} from "net.neoforged.neoforge.attachment.IAttachmentHolder"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$BiomeGenerationSettings, $BiomeGenerationSettings$$Type} from "net.minecraft.world.level.biome.BiomeGenerationSettings"
import {$Set} from "java.util.Set"
import {$Heightmap} from "net.minecraft.world.level.levelgen.Heightmap"
import {$BiomeManager$NoiseBiomeSource$$Interface} from "net.minecraft.world.level.biome.BiomeManager$NoiseBiomeSource"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$ChunkSkyLightSources} from "net.minecraft.world.level.lighting.ChunkSkyLightSources"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ExtendedChunk$$Interface} from "ca.spottedleaf.starlight.common.chunk.ExtendedChunk"
import {$ChunkStatus} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$LightChunk$$Interface} from "net.minecraft.world.level.chunk.LightChunk"
import {$StructureAccess$$Interface} from "net.minecraft.world.level.chunk.StructureAccess"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$SWMRNibbleArray, $SWMRNibbleArray$$Type} from "ca.spottedleaf.starlight.common.light.SWMRNibbleArray"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$StructureStart, $StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$ChunkAccessAccessor$$Interface} from "com.copycatsplus.copycats.mixin.foundation.copycat.ChunkAccessAccessor"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$GameEventListenerRegistry} from "net.minecraft.world.level.gameevent.GameEventListenerRegistry"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$ShortList, $ShortList$$Type} from "it.unimi.dsi.fastutil.shorts.ShortList"
import {$UpgradeData, $UpgradeData$$Type} from "net.minecraft.world.level.chunk.UpgradeData"
import {$BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$Level} from "net.minecraft.world.level.Level"
import {$Trackable, $Trackable$$Interface} from "dev.uncandango.alltheleaks.mixin.Trackable"
import {$Climate$Sampler$$Type} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Class} from "java.lang.Class"
import {$AttachmentHolder$AsField} from "net.neoforged.neoforge.attachment.AttachmentHolder$AsField"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$ObjectOpenCustomHashSet} from "it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$AttachmentType$$Type} from "net.neoforged.neoforge.attachment.AttachmentType"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$LevelChunkSection, $LevelChunkSection$$Type} from "net.minecraft.world.level.chunk.LevelChunkSection"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$BiomeResolver$$Type} from "net.minecraft.world.level.biome.BiomeResolver"
import {$Heightmap$Types, $Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"

export class $ChunkAccess implements $BlockGetter$$Interface, $BiomeManager$NoiseBiomeSource$$Interface, $LightChunk$$Interface, $StructureAccess$$Interface, $IAttachmentHolder$$Interface, $ExtendedChunk$$Interface, $ChunkAccessAccessor$$Interface, $Trackable$$Interface {
readonly "blockEntities": $Map<($BlockPos), ($BlockEntity)>
static readonly "NO_FILLED_SECTION": integer

constructor(arg0: $ChunkPos$$Type, arg1: $UpgradeData$$Type, arg2: $LevelHeightAccessor$$Type, arg3: $Registry$$Type<($Biome$$Type)>, arg4: long, arg5: ($LevelChunkSection$$Type)[], arg6: $BlendingData$$Type)

public "getAllStarts"(): $Map<($Structure), ($StructureStart)>
public "markPosForPostprocessing"(arg0: $BlockPos$$Type): void
public "getHighestFilledSectionIndex"(): integer
/**
 * 
 * @deprecated
 */
public "getHighestSectionPosition"(): integer
public "getListenerRegistry"(arg0: integer): $GameEventListenerRegistry
public "getBlockEntitiesPos"(): $Set<($BlockPos)>
public "getHeightmaps"(): $Collection<($Map$Entry<($Heightmap$Types), ($Heightmap)>)>
public "setHeightmap"(arg0: $Heightmap$Types$$Type, arg1: (long)[]): void
public "hasPrimedHeightmap"(arg0: $Heightmap$Types$$Type): boolean
public "getStartForStructure"(arg0: $Structure$$Type): $StructureStart
public "setStartForStructure"(arg0: $Structure$$Type, arg1: $StructureStart$$Type): void
public "setAllStarts"(arg0: $Map$$Type<($Structure$$Type), ($StructureStart$$Type)>): void
public "getReferencesForStructure"(arg0: $Structure$$Type): $LongSet
public "addReferenceForStructure"(arg0: $Structure$$Type, arg1: long): void
public "setAllReferences"(arg0: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>): void
public "isYSpaceEmpty"(arg0: integer, arg1: integer): boolean
public "isSectionEmpty"(arg0: integer): boolean
public "isUnsaved"(): boolean
public "getPersistedStatus"(): $ChunkStatus
public "getHighestGeneratedStatus"(): $ChunkStatus
public "getBelowZeroRetrogen"(): $BelowZeroRetrogen
public "getPostProcessing"(): ($ShortList)[]
public "addPackedPostProcess"(arg0: short, arg1: integer): void
public static "getOrCreateOffsetList"(arg0: ($ShortList$$Type)[], arg1: integer): $ShortList
public "setBlockEntityNbt"(arg0: $CompoundTag$$Type): void
public "getBlockEntityNbt"(arg0: $BlockPos$$Type): $CompoundTag
public "getBlockEntityNbtForSaving"(arg0: $BlockPos$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "findBlockLightSources"(arg0: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "findBlocks"(arg0: $Predicate$$Type<($BlockState)>, arg1: $BiPredicate$$Type<($BlockState), ($BlockPos)>, arg2: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
/**
 * 
 * @deprecated
 */
public "findBlocks"(arg0: $BiPredicate$$Type<($BlockState), ($BlockPos)>, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "findBlocks"(arg0: $Predicate$$Type<($BlockState)>, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "getOrCreateHeightmapUnprimed"(arg0: $Heightmap$Types$$Type): $Heightmap
public "isLightCorrect"(): boolean
public "getTicksForSerialization"(): $ChunkAccess$TicksToSave
public "getUpgradeData"(): $UpgradeData
public "isOldNoiseGeneration"(): boolean
public "getBlendingData"(): $BlendingData
public "setBlendingData"(arg0: $BlendingData$$Type): void
public "incrementInhabitedTime"(arg0: long): void
public "setInhabitedTime"(arg0: long): void
public "setLightCorrect"(arg0: boolean): void
public "getOrCreateNoiseChunk"(arg0: $Function$$Type<($ChunkAccess), ($NoiseChunk$$Type)>): $NoiseChunk
/**
 * 
 * @deprecated
 */
public "carverBiome"(arg0: $Supplier$$Type<($BiomeGenerationSettings$$Type)>): $BiomeGenerationSettings
public "fillBiomesFromNoise"(arg0: $BiomeResolver$$Type, arg1: $Climate$Sampler$$Type): void
public "getHeightAccessorForGeneration"(): $LevelHeightAccessor
public "hasAnyStructureReferences"(): boolean
public "getAllReferences"(): $Map
public "isUpgrading"(): boolean
public "initializeLightSources"(): void
public "getSkyLightSources"(): $ChunkSkyLightSources
public "getAttachmentHolder"(): $AttachmentHolder$AsField
public "writeAttachmentsToNBT"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "readAttachmentsFromNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
public "getBlockNibbles"(): ($SWMRNibbleArray)[]
public "setBlockNibbles"(nibbles: ($SWMRNibbleArray$$Type)[]): void
public "getSkyNibbles"(): ($SWMRNibbleArray)[]
public "setSkyNibbles"(nibbles: ($SWMRNibbleArray$$Type)[]): void
public "getSkyEmptinessMap"(): (boolean)[]
public "setSkyEmptinessMap"(emptinessMap: (boolean)[]): void
public "getBlockEmptinessMap"(): (boolean)[]
public "setBlockEmptinessMap"(emptinessMap: (boolean)[]): void
public "getBlockEntities"(): $Map
public "removeData"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "getHeight"(): integer
public "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
public "getData"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "setData"<T>(arg0: $AttachmentType$$Type<(T)>, arg1: T): T
public "getLevel"(): $Level
public "getSections"(): ($LevelChunkSection)[]
public "atl$getBaseClass"(): $Class
public "getMinBuildHeight"(): integer
public "getSection"(arg0: integer): $LevelChunkSection
public "hasAttachments"(): boolean
public "hasData"(arg0: $AttachmentType$$Type<(never)>): boolean
public "getExistingDataOrNull"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "getPos"(): $ChunkPos
public "setBlockEntity"(arg0: $BlockEntity$$Type): void
public "removeBlockEntity"(arg0: $BlockPos$$Type): void
public "setUnsaved"(arg0: boolean): void
public "getInhabitedTime"(): long
public "setBlockState"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: boolean): $BlockState
public "getBlockTicks"(): $TickContainerAccess<($Block)>
public "getFluidTicks"(): $TickContainerAccess<($Fluid)>
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "addEntity"(arg0: $Entity$$Type): void
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
public "clip"(arg0: $ClipContext$$Type): $BlockHitResult
public "getLightEmission"(arg0: $BlockPos$$Type): integer
public "getMaxLightLevel"(): integer
public "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
public "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
public "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
public "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
public "removeData"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>): T
public "getData"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>): T
public "setData"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>, arg1: T): T
public "syncData"(arg0: $AttachmentType$$Type<(never)>): void
public "syncData"(arg0: $Supplier$$Type<($AttachmentType$$Type<(never)>)>): void
public "hasData"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>): boolean
public "getExistingDataOrNull"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>): T
public "getExistingData"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>): $Optional<(T)>
public "getExistingData"<T>(arg0: $AttachmentType$$Type<(T)>): $Optional<(T)>
public "wrap"(): $WeakReference<($Trackable)>
public "startTracking"(): void
public static "startTracking"(arg0: any): void
public static "createWeakRefBasedSet"(): $ObjectOpenCustomHashSet<($WeakReference<($Trackable)>)>
public static "clearNullReferences"(): void
public static "getSummary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
public "getMaxBuildHeight"(): integer
public "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
public "isOutsideBuildHeight"(arg0: integer): boolean
public "getSectionIndex"(arg0: integer): integer
public "getSectionsCount"(): integer
public "getMaxSection"(): integer
public "getMinSection"(): integer
public "getSectionIndexFromSectionY"(arg0: integer): integer
public "getSectionYFromSectionIndex"(arg0: integer): integer
public "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
public "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
public "getModelData"(arg0: $BlockPos$$Type): $ModelData
get "allStarts"(): $Map<($Structure), ($StructureStart)>
get "highestFilledSectionIndex"(): integer
get "highestSectionPosition"(): integer
get "blockEntitiesPos"(): $Set<($BlockPos)>
get "heightmaps"(): $Collection<($Map$Entry<($Heightmap$Types), ($Heightmap)>)>
set "allStarts"(value: $Map$$Type<($Structure$$Type), ($StructureStart$$Type)>)
set "allReferences"(value: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>)
get "unsaved"(): boolean
get "persistedStatus"(): $ChunkStatus
get "highestGeneratedStatus"(): $ChunkStatus
get "belowZeroRetrogen"(): $BelowZeroRetrogen
get "postProcessing"(): ($ShortList)[]
set "blockEntityNbt"(value: $CompoundTag$$Type)
get "lightCorrect"(): boolean
get "ticksForSerialization"(): $ChunkAccess$TicksToSave
get "upgradeData"(): $UpgradeData
get "oldNoiseGeneration"(): boolean
get "blendingData"(): $BlendingData
set "blendingData"(value: $BlendingData$$Type)
set "inhabitedTime"(value: long)
set "lightCorrect"(value: boolean)
get "heightAccessorForGeneration"(): $LevelHeightAccessor
get "allReferences"(): $Map
get "upgrading"(): boolean
get "skyLightSources"(): $ChunkSkyLightSources
get "attachmentHolder"(): $AttachmentHolder$AsField
get "blockNibbles"(): ($SWMRNibbleArray)[]
set "blockNibbles"(value: ($SWMRNibbleArray$$Type)[])
get "skyNibbles"(): ($SWMRNibbleArray)[]
set "skyNibbles"(value: ($SWMRNibbleArray$$Type)[])
get "skyEmptinessMap"(): (boolean)[]
set "skyEmptinessMap"(value: (boolean)[])
get "blockEmptinessMap"(): (boolean)[]
set "blockEmptinessMap"(value: (boolean)[])
get "height"(): integer
get "level"(): $Level
get "sections"(): ($LevelChunkSection)[]
get "minBuildHeight"(): integer
get "pos"(): $ChunkPos
set "blockEntity"(value: $BlockEntity$$Type)
set "unsaved"(value: boolean)
get "inhabitedTime"(): long
get "blockTicks"(): $TickContainerAccess<($Block)>
get "fluidTicks"(): $TickContainerAccess<($Fluid)>
get "maxLightLevel"(): integer
public static get "summary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkAccess$$Type = ($ChunkAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkAccess$$Original = $ChunkAccess;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.TagMatchTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TagMatchTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($TagMatchTest)>

constructor(arg0: $TagKey$$Type<($Block)>)

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagMatchTest$$Type = ($TagMatchTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagMatchTest$$Original = $TagMatchTest;}
declare module "net.minecraft.world.level.block.InfestedRotatedPillarBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Map} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$InfestedBlock} from "net.minecraft.world.level.block.InfestedBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $InfestedRotatedPillarBlock extends $InfestedBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($InfestedRotatedPillarBlock)>
static readonly "BLOCK_BY_HOST_BLOCK": $Map<($Block), ($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($InfestedRotatedPillarBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InfestedRotatedPillarBlock$$Type = ($InfestedRotatedPillarBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InfestedRotatedPillarBlock$$Original = $InfestedRotatedPillarBlock;}
declare module "net.minecraft.world.level.portal.DimensionTransition" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$DimensionTransition$PostDimensionTransition, $DimensionTransition$PostDimensionTransition$$Type} from "net.minecraft.world.level.portal.DimensionTransition$PostDimensionTransition"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Record} from "java.lang.Record"

export class $DimensionTransition extends $Record {
static readonly "PLACE_PORTAL_TICKET": $DimensionTransition$PostDimensionTransition
static readonly "PLAY_PORTAL_SOUND": $DimensionTransition$PostDimensionTransition
static readonly "DO_NOTHING": $DimensionTransition$PostDimensionTransition

constructor(arg0: $ServerLevel$$Type, arg1: $Entity$$Type, arg2: $DimensionTransition$PostDimensionTransition$$Type)
constructor(arg0: $ServerLevel$$Type, arg1: $Vec3$$Type, arg2: $Vec3$$Type, arg3: float, arg4: float, arg5: boolean, arg6: $DimensionTransition$PostDimensionTransition$$Type)
constructor(arg0: $ServerLevel$$Type, arg1: $Vec3$$Type, arg2: $Vec3$$Type, arg3: float, arg4: float, arg5: $DimensionTransition$PostDimensionTransition$$Type)

public static "missingRespawnBlock"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type, arg2: $DimensionTransition$PostDimensionTransition$$Type): $DimensionTransition
public "missingRespawnBlock"(): boolean
public "newLevel"(): $ServerLevel
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "pos"(): $Vec3
public "speed"(): $Vec3
public "xRot"(): float
public "yRot"(): float
public "postDimensionTransition"(): $DimensionTransition$PostDimensionTransition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionTransition$$Type = ({"pos"?: $Vec3$$Type, "speed"?: $Vec3$$Type, "yRot"?: float, "xRot"?: float, "missingRespawnBlock"?: boolean, "newLevel"?: $ServerLevel$$Type, "postDimensionTransition"?: $DimensionTransition$PostDimensionTransition$$Type}) | ([pos?: $Vec3$$Type, speed?: $Vec3$$Type, yRot?: float, xRot?: float, missingRespawnBlock?: boolean, newLevel?: $ServerLevel$$Type, postDimensionTransition?: $DimensionTransition$PostDimensionTransition$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionTransition$$Original = $DimensionTransition;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$MultifaceBlock, $MultifaceBlock$$Type} from "net.minecraft.world.level.block.MultifaceBlock"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $MultifaceGrowthConfiguration implements $FeatureConfiguration$$Interface {
readonly "canPlaceOnWall": boolean
readonly "chanceOfSpreading": float
static readonly "CODEC": $Codec<($MultifaceGrowthConfiguration)>
readonly "canPlaceOnCeiling": boolean
readonly "searchRange": integer
readonly "canPlaceOnFloor": boolean
readonly "canBePlacedOn": $HolderSet<($Block)>
readonly "placeBlock": $MultifaceBlock

constructor(arg0: $MultifaceBlock$$Type, arg1: integer, arg2: boolean, arg3: boolean, arg4: boolean, arg5: float, arg6: $HolderSet$$Type<($Block)>)

public "getShuffledDirectionsExcept"(arg0: $RandomSource$$Type, arg1: $Direction$$Type): $List<($Direction)>
public "getShuffledDirections"(arg0: $RandomSource$$Type): $List<($Direction)>
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceGrowthConfiguration$$Type = ($MultifaceGrowthConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceGrowthConfiguration$$Original = $MultifaceGrowthConfiguration;}
declare module "net.minecraft.world.level.block.HorizontalDirectionalBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $HorizontalDirectionalBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HorizontalDirectionalBlock$$Type = ($HorizontalDirectionalBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HorizontalDirectionalBlock$$Original = $HorizontalDirectionalBlock;}
declare module "net.minecraft.world.level.material.FogType" {
import {$Enum} from "java.lang.Enum"

export class $FogType extends $Enum<($FogType)> {
static readonly "LAVA": $FogType
static readonly "POWDER_SNOW": $FogType
static readonly "NONE": $FogType
static readonly "WATER": $FogType

public static "values"(): ($FogType)[]
public static "valueOf"(arg0: StringJS): $FogType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FogType$$Type = (("lava") | ("water") | ("powder_snow") | ("none"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FogType$$Original = $FogType;}
declare module "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector$EntitySelector" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export interface $PlayerDetector$EntitySelector$$Interface {
}

export class $PlayerDetector$EntitySelector implements $PlayerDetector$EntitySelector$$Interface {
static readonly "SELECT_FROM_LEVEL": $PlayerDetector$EntitySelector

 "getPlayers"(arg0: $ServerLevel$$Type, arg1: $Predicate$$Type<($Player)>): $List<($Player)>
static "onlySelectPlayers"(arg0: $List$$Type<($Player$$Type)>): $PlayerDetector$EntitySelector
static "onlySelectPlayer"(arg0: $Player$$Type): $PlayerDetector$EntitySelector
 "getEntities"<T extends $Entity>(arg0: $ServerLevel$$Type, arg1: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg2: $AABB$$Type, arg3: $Predicate$$Type<(T)>): $List<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerDetector$EntitySelector$$Type = ($PlayerDetector$EntitySelector);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerDetector$EntitySelector$$Original = $PlayerDetector$EntitySelector;}
declare module "net.minecraft.world.level.levelgen.structure.StructureCheck" {
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Map$$Type} from "java.util.Map"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$StructurePlacement$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$StructureCheckResult} from "net.minecraft.world.level.levelgen.structure.StructureCheckResult"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"
import {$BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$ChunkScanAccess$$Type} from "net.minecraft.world.level.chunk.storage.ChunkScanAccess"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $StructureCheck {
constructor(arg0: $ChunkScanAccess$$Type, arg1: $RegistryAccess$$Type, arg2: $StructureTemplateManager$$Type, arg3: $ResourceKey$$Type<($Level)>, arg4: $ChunkGenerator$$Type, arg5: $RandomState$$Type, arg6: $LevelHeightAccessor$$Type, arg7: $BiomeSource$$Type, arg8: long, arg9: $DataFixer$$Type)

public "onStructureLoad"(arg0: $ChunkPos$$Type, arg1: $Map$$Type<($Structure$$Type), ($StructureStart$$Type)>): void
public "incrementReference"(arg0: $ChunkPos$$Type, arg1: $Structure$$Type): void
public "checkStart"(arg0: $ChunkPos$$Type, arg1: $Structure$$Type, arg2: $StructurePlacement$$Type, arg3: boolean): $StructureCheckResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureCheck$$Type = ($StructureCheck);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureCheck$$Original = $StructureCheck;}
declare module "net.minecraft.world.level.block.WitherWallSkullBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$WallSkullBlock} from "net.minecraft.world.level.block.WallSkullBlock"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WitherWallSkullBlock extends $WallSkullBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WitherWallSkullBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "codec"(): $MapCodec<($WitherWallSkullBlock)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WitherWallSkullBlock$$Type = ($WitherWallSkullBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WitherWallSkullBlock$$Original = $WitherWallSkullBlock;}
declare module "net.minecraft.world.level.biome.AmbientAdditionsSettings" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $AmbientAdditionsSettings {
static readonly "CODEC": $Codec<($AmbientAdditionsSettings)>

constructor(arg0: $Holder$$Type<($SoundEvent)>, arg1: double)

public "getSoundEvent"(): $Holder<($SoundEvent)>
public "getTickChance"(): double
get "soundEvent"(): $Holder<($SoundEvent)>
get "tickChance"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AmbientAdditionsSettings$$Type = ($AmbientAdditionsSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AmbientAdditionsSettings$$Original = $AmbientAdditionsSettings;}
declare module "net.minecraft.world.level.block.piston.PistonBaseBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DirectionalBlock} from "net.minecraft.world.level.block.DirectionalBlock"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$PistonStructureResolver$$Type} from "net.minecraft.world.level.block.piston.PistonStructureResolver"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PistonBaseBlock extends $DirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PistonBaseBlock)>
static readonly "EXTENDED": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "TRIGGER_CONTRACT": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "TRIGGER_EXTEND": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "PLATFORM_THICKNESS": float
static readonly "TRIGGER_DROP": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: boolean, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "handler$doj000$ftbchunks$onMoveBlocks"(level: $Level$$Type, blockPos: $BlockPos$$Type, direction: $Direction$$Type, extending: boolean, cir: $CallbackInfoReturnable$$Type, pistonStructureResolver: $PistonStructureResolver$$Type): void
public "rotate"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $Rotation$$Type): $BlockState
public "codec"(): $MapCodec<($PistonBaseBlock)>
public static "isPushable"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: boolean, arg5: $Direction$$Type): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonBaseBlock$$Type = ($PistonBaseBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PistonBaseBlock$$Original = $PistonBaseBlock;}
declare module "net.minecraft.world.level.storage.WritableLevelData" {
import {$GameRules} from "net.minecraft.world.level.GameRules"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CrashReportCategory$$Type} from "net.minecraft.CrashReportCategory"
import {$LevelData$$Interface} from "net.minecraft.world.level.storage.LevelData"

export interface $WritableLevelData$$Interface extends $LevelData$$Interface {
get "difficultyLocked"(): boolean
set "raining"(value: boolean)
get "hardcore"(): boolean
get "gameTime"(): long
get "difficulty"(): $Difficulty
get "gameRules"(): $GameRules
get "dayTime"(): long
get "spawnPos"(): $BlockPos
get "spawnAngle"(): float
get "thundering"(): boolean
get "raining"(): boolean
}

export class $WritableLevelData implements $WritableLevelData$$Interface {
 "setSpawn"(arg0: $BlockPos$$Type, arg1: float): void
 "isDifficultyLocked"(): boolean
 "setRaining"(arg0: boolean): void
 "isHardcore"(): boolean
 "getGameTime"(): long
 "getDifficulty"(): $Difficulty
 "getGameRules"(): $GameRules
 "getDayTime"(): long
 "fillCrashReportCategory"(arg0: $CrashReportCategory$$Type, arg1: $LevelHeightAccessor$$Type): void
 "getSpawnPos"(): $BlockPos
 "getSpawnAngle"(): float
 "isThundering"(): boolean
 "isRaining"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WritableLevelData$$Type = ($WritableLevelData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WritableLevelData$$Original = $WritableLevelData;}
declare module "net.minecraft.world.level.levelgen.structure.StructureCheckResult" {
import {$Enum} from "java.lang.Enum"

export class $StructureCheckResult extends $Enum<($StructureCheckResult)> {
static readonly "CHUNK_LOAD_NEEDED": $StructureCheckResult
static readonly "START_NOT_PRESENT": $StructureCheckResult
static readonly "START_PRESENT": $StructureCheckResult

public static "values"(): ($StructureCheckResult)[]
public static "valueOf"(arg0: StringJS): $StructureCheckResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureCheckResult$$Type = (("start_present") | ("start_not_present") | ("chunk_load_needed"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureCheckResult$$Original = $StructureCheckResult;}
declare module "net.minecraft.world.level.block.state.properties.Half" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $Half extends $Enum<($Half)> implements $StringRepresentable$$Interface {
static readonly "TOP": $Half
static readonly "BOTTOM": $Half

public "toString"(): StringJS
public static "values"(): ($Half)[]
public static "valueOf"(arg0: StringJS): $Half
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Half$$Type = (("top") | ("bottom"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Half$$Original = $Half;}
declare module "net.minecraft.world.level.block.AnvilBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$FallingBlock} from "net.minecraft.world.level.block.FallingBlock"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AnvilBlock extends $FallingBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($AnvilBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getDustColor"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): integer
public "onLand"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $FallingBlockEntity$$Type): void
public "onBrokenAfterFall"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FallingBlockEntity$$Type): void
public "getFallDamageSource"(arg0: $Entity$$Type): $DamageSource
public "handler$zcg000$placebo$onLand"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $FallingBlockEntity$$Type, arg5: $CallbackInfo$$Type): void
public "codec"(): $MapCodec<($AnvilBlock)>
public static "damage"(arg0: $BlockState$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnvilBlock$$Type = ($AnvilBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AnvilBlock$$Original = $AnvilBlock;}
declare module "net.minecraft.world.level.biome.MultiNoiseBiomeSourceParameterList$Preset" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$MultiNoiseBiomeSourceParameterList$Preset$SourceProvider, $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider$$Type} from "net.minecraft.world.level.biome.MultiNoiseBiomeSourceParameterList$Preset$SourceProvider"
import {$Stream} from "java.util.stream.Stream"
import {$Record} from "java.lang.Record"

export class $MultiNoiseBiomeSourceParameterList$Preset extends $Record {
static readonly "OVERWORLD": $MultiNoiseBiomeSourceParameterList$Preset
static readonly "CODEC": $Codec<($MultiNoiseBiomeSourceParameterList$Preset)>
static readonly "NETHER": $MultiNoiseBiomeSourceParameterList$Preset

constructor(arg0: $ResourceLocation$$Type, arg1: $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider$$Type)

public "usedBiomes"(): $Stream<($ResourceKey<($Biome)>)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "provider"(): $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiNoiseBiomeSourceParameterList$Preset$$Type = ({"id"?: $ResourceLocation$$Type, "provider"?: $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider$$Type}) | ([id?: $ResourceLocation$$Type, provider?: $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultiNoiseBiomeSourceParameterList$Preset$$Original = $MultiNoiseBiomeSourceParameterList$Preset;}
declare module "net.minecraft.world.level.block.BaseCoralPlantBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BaseCoralPlantTypeBlock} from "net.minecraft.world.level.block.BaseCoralPlantTypeBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $BaseCoralPlantBlock extends $BaseCoralPlantTypeBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BaseCoralPlantBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($BaseCoralPlantBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseCoralPlantBlock$$Type = ($BaseCoralPlantBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseCoralPlantBlock$$Original = $BaseCoralPlantBlock;}
declare module "net.minecraft.world.level.biome.Biome" {
import {$Biome$ClimateSettings} from "net.minecraft.world.level.biome.Biome$ClimateSettings"
import {$Optional} from "java.util.Optional"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BiomeInvoker$$Interface} from "journeymap.common.mixin.client.BiomeInvoker"
import {$Holder} from "net.minecraft.core.Holder"
import {$PerlinSimplexNoise} from "net.minecraft.world.level.levelgen.synth.PerlinSimplexNoise"
import {$AmbientMoodSettings} from "net.minecraft.world.level.biome.AmbientMoodSettings"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$MobSpawnSettings} from "net.minecraft.world.level.biome.MobSpawnSettings"
import {$ModifiableBiomeInfo} from "net.neoforged.neoforge.common.world.ModifiableBiomeInfo"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BiomeFTBC$$Interface} from "dev.ftb.mods.ftbchunks.core.BiomeFTBC"
import {$BiomeGenerationSettings} from "net.minecraft.world.level.biome.BiomeGenerationSettings"
import {$HolderSet} from "net.minecraft.core.HolderSet"
import {$AmbientParticleSettings} from "net.minecraft.world.level.biome.AmbientParticleSettings"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ExtendedBiome$$Interface} from "net.irisshaders.iris.parsing.ExtendedBiome"
import {$AmbientAdditionsSettings} from "net.minecraft.world.level.biome.AmbientAdditionsSettings"
import {$Music} from "net.minecraft.sounds.Music"
import {$Biome$Precipitation} from "net.minecraft.world.level.biome.Biome$Precipitation"
import {$BiomeSpecialEffects} from "net.minecraft.world.level.biome.BiomeSpecialEffects"

export class $Biome implements $ExtendedBiome$$Interface, $BiomeInvoker$$Interface, $BiomeFTBC$$Interface {
static readonly "CODEC": $Codec<($Holder<($Biome)>)>
static readonly "NETWORK_CODEC": $Codec<($Biome)>
/**
 * 
 * @deprecated
 */
static readonly "BIOME_INFO_NOISE": $PerlinSimplexNoise
static readonly "DIRECT_CODEC": $Codec<($Biome)>
static readonly "LIST_CODEC": $Codec<($HolderSet<($Biome)>)>

public "getTemperature"(arg0: $BlockPos$$Type): float
public "shouldFreeze"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: boolean): boolean
public "shouldFreeze"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
public "shouldSnow"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
public "getGenerationSettings"(): $BiomeGenerationSettings
public "getGrassColor"(arg0: double, arg1: double): integer
public "getFoliageColor"(): integer
public "getBiomeCategory"(): integer
public "setBiomeCategory"(arg0: integer): void
public "getDownfall"(): float
public "setFTBCBiomeColorIndex"(c: integer): void
public "getFTBCBiomeColorIndex"(): integer
public "invokeGetGrassColorFromTexture"(): integer
public "modifiableBiomeInfo"(): $ModifiableBiomeInfo
public "getMobSettings"(): $MobSpawnSettings
public "hasPrecipitation"(): boolean
public "coldEnoughToSnow"(arg0: $BlockPos$$Type): boolean
public "getBaseTemperature"(): float
public "warmEnoughToRain"(arg0: $BlockPos$$Type): boolean
public "shouldMeltFrozenOceanIcebergSlightly"(arg0: $BlockPos$$Type): boolean
public "getFogColor"(): integer
public "getSpecialEffects"(): $BiomeSpecialEffects
public "getWaterColor"(): integer
public "getWaterFogColor"(): integer
public "getAmbientLoop"(): $Optional<($Holder<($SoundEvent)>)>
public "getAmbientMood"(): $Optional<($AmbientMoodSettings)>
public "getAmbientAdditions"(): $Optional<($AmbientAdditionsSettings)>
public "getModifiedClimateSettings"(): $Biome$ClimateSettings
public "getModifiedSpecialEffects"(): $BiomeSpecialEffects
public "getBackgroundMusic"(): $Optional<($Music)>
public "getPrecipitationAt"(arg0: $BlockPos$$Type): $Biome$Precipitation
public "getSkyColor"(): integer
public "getAmbientParticle"(): $Optional<($AmbientParticleSettings)>
get "generationSettings"(): $BiomeGenerationSettings
get "foliageColor"(): integer
get "biomeCategory"(): integer
set "biomeCategory"(value: integer)
get "downfall"(): float
set "FTBCBiomeColorIndex"(value: integer)
get "FTBCBiomeColorIndex"(): integer
get "mobSettings"(): $MobSpawnSettings
get "baseTemperature"(): float
get "fogColor"(): integer
get "specialEffects"(): $BiomeSpecialEffects
get "waterColor"(): integer
get "waterFogColor"(): integer
get "ambientLoop"(): $Optional<($Holder<($SoundEvent)>)>
get "ambientMood"(): $Optional<($AmbientMoodSettings)>
get "ambientAdditions"(): $Optional<($AmbientAdditionsSettings)>
get "modifiedClimateSettings"(): $Biome$ClimateSettings
get "modifiedSpecialEffects"(): $BiomeSpecialEffects
get "backgroundMusic"(): $Optional<($Music)>
get "skyColor"(): integer
get "ambientParticle"(): $Optional<($AmbientParticleSettings)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenBiome
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenBiomeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Biome$$Type = (Special.WorldgenBiome);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Biome$$Original = $Biome;}
declare module "net.minecraft.world.level.block.StairBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Half} from "net.minecraft.world.level.block.state.properties.Half"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$StairsShape} from "net.minecraft.world.level.block.state.properties.StairsShape"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $StairBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($StairBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($Half)>
static readonly "SHAPE": $EnumProperty<($StairsShape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockState$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getExplosionResistance"(): float
public static "isStairs"(arg0: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($StairBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "explosionResistance"(): float
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StairBlock$$Type = ($StairBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StairBlock$$Original = $StairBlock;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.InsideWorldBoundsPredicate" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type, $BlockPredicate$$Interface} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $InsideWorldBoundsPredicate implements $BlockPredicate$$Interface {
static readonly "CODEC": $MapCodec<($InsideWorldBoundsPredicate)>

constructor(arg0: $Vec3i$$Type)

public "type"(): $BlockPredicateType<(never)>
public "test"(arg0: any, arg1: any): boolean
public "test"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): boolean
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
public "or"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "negate"(): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "and"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InsideWorldBoundsPredicate$$Type = ($InsideWorldBoundsPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InsideWorldBoundsPredicate$$Original = $InsideWorldBoundsPredicate;}
declare module "net.minecraft.world.level.block.piston.MovingPistonBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$PistonType} from "net.minecraft.world.level.block.state.properties.PistonType"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MovingPistonBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($MovingPistonBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "TYPE": $EnumProperty<($PistonType)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "newMovingBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type, arg4: boolean, arg5: boolean): $BlockEntity
public "destroy"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($MovingPistonBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MovingPistonBlock$$Type = ($MovingPistonBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MovingPistonBlock$$Original = $MovingPistonBlock;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $LargeDripstoneConfiguration implements $FeatureConfiguration$$Interface {
readonly "minRadiusForWind": integer
static readonly "CODEC": $Codec<($LargeDripstoneConfiguration)>
readonly "maxColumnRadiusToCaveHeightRatio": float
readonly "heightScale": $FloatProvider
readonly "stalactiteBluntness": $FloatProvider
readonly "columnRadius": $IntProvider
readonly "floorToCeilingSearchRange": integer
readonly "stalagmiteBluntness": $FloatProvider
readonly "windSpeed": $FloatProvider
readonly "minBluntnessForWind": float

constructor(arg0: integer, arg1: $IntProvider$$Type, arg2: $FloatProvider$$Type, arg3: float, arg4: $FloatProvider$$Type, arg5: $FloatProvider$$Type, arg6: $FloatProvider$$Type, arg7: integer, arg8: float)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LargeDripstoneConfiguration$$Type = ($LargeDripstoneConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LargeDripstoneConfiguration$$Original = $LargeDripstoneConfiguration;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BiPredicate, $BiPredicate$$Type, $BiPredicate$$Interface} from "java.util.function.BiPredicate"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Codec} from "com.mojang.serialization.Codec"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockPredicate$$Interface extends $BiPredicate$$Interface<($WorldGenLevel), ($BlockPos)> {
}

export class $BlockPredicate implements $BlockPredicate$$Interface {
static readonly "ONLY_IN_AIR_OR_WATER_PREDICATE": $BlockPredicate
static readonly "CODEC": $Codec<($BlockPredicate)>
static readonly "ONLY_IN_AIR_PREDICATE": $BlockPredicate

static "solid"(): $BlockPredicate
static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
static "replaceable"(): $BlockPredicate
static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
static "unobstructed"(): $BlockPredicate
static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
static "noFluid"(): $BlockPredicate
static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
static "alwaysTrue"(): $BlockPredicate
static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
 "type"(): $BlockPredicateType<(never)>
 "or"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
 "negate"(): $BiPredicate<($WorldGenLevel), ($BlockPos)>
 "and"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
 "test"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPredicate$$Type = ($BlockPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPredicate$$Original = $BlockPredicate;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $CountConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($CountConfiguration)>

constructor(arg0: integer)
constructor(arg0: $IntProvider$$Type)

public "count"(): $IntProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CountConfiguration$$Type = ($CountConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CountConfiguration$$Original = $CountConfiguration;}
declare module "net.minecraft.world.level.storage.loot.predicates.CompositeLootItemCondition$Builder" {
import {$AnyOfCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.AnyOfCondition$Builder"
import {$LootItemCondition$Builder, $LootItemCondition$Builder$$Type, $LootItemCondition$Builder$$Interface} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$AllOfCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.AllOfCondition$Builder"
import {$LootItemCondition} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export class $CompositeLootItemCondition$Builder implements $LootItemCondition$Builder$$Interface {
public "addTerm"(arg0: $LootItemCondition$Builder$$Type): void
public "build"(): $LootItemCondition
public "invert"(): $LootItemCondition$Builder
public "or"(arg0: $LootItemCondition$Builder$$Type): $AnyOfCondition$Builder
public "and"(arg0: $LootItemCondition$Builder$$Type): $AllOfCondition$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompositeLootItemCondition$Builder$$Type = ($CompositeLootItemCondition$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CompositeLootItemCondition$Builder$$Original = $CompositeLootItemCondition$Builder;}
declare module "net.minecraft.world.level.block.LavaCauldronBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$AbstractCauldronBlock} from "net.minecraft.world.level.block.AbstractCauldronBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LavaCauldronBlock extends $AbstractCauldronBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LavaCauldronBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isFull"(arg0: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($LavaCauldronBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LavaCauldronBlock$$Type = ($LavaCauldronBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LavaCauldronBlock$$Original = $LavaCauldronBlock;}
declare module "net.minecraft.world.level.storage.loot.providers.score.LootScoreProviderType" {
import {$ScoreboardNameProvider, $ScoreboardNameProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.score.ScoreboardNameProvider"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $LootScoreProviderType extends $Record {
constructor(arg0: $MapCodec$$Type<($ScoreboardNameProvider$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "codec"(): $MapCodec<($ScoreboardNameProvider)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.LootScoreProviderType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.LootScoreProviderTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootScoreProviderType$$Type = (Special.LootScoreProviderType) | ({"codec"?: $MapCodec$$Type<($ScoreboardNameProvider$$Type)>}) | ([codec?: $MapCodec$$Type<($ScoreboardNameProvider$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootScoreProviderType$$Original = $LootScoreProviderType;}
declare module "net.minecraft.world.level.levelgen.feature.BlockPileFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration, $BlockPileConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $BlockPileFeature extends $Feature<($BlockPileConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($BlockPileConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($BlockPileConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPileFeature$$Type = ($BlockPileFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPileFeature$$Original = $BlockPileFeature;}
declare module "net.minecraft.world.level.levelgen.placement.CaveSurface" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Direction} from "net.minecraft.core.Direction"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $CaveSurface extends $Enum<($CaveSurface)> implements $StringRepresentable$$Interface {
static readonly "FLOOR": $CaveSurface
static readonly "CODEC": $Codec<($CaveSurface)>
static readonly "CEILING": $CaveSurface

public "getY"(): integer
public static "values"(): ($CaveSurface)[]
public static "valueOf"(arg0: StringJS): $CaveSurface
public "getDirection"(): $Direction
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "y"(): integer
get "direction"(): $Direction
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaveSurface$$Type = (("ceiling") | ("floor"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CaveSurface$$Original = $CaveSurface;}
declare module "net.minecraft.world.level.levelgen.heightproviders.HeightProviderType" {
import {$TrapezoidHeight} from "net.minecraft.world.level.levelgen.heightproviders.TrapezoidHeight"
import {$WeightedListHeight} from "net.minecraft.world.level.levelgen.heightproviders.WeightedListHeight"
import {$UniformHeight} from "net.minecraft.world.level.levelgen.heightproviders.UniformHeight"
import {$VeryBiasedToBottomHeight} from "net.minecraft.world.level.levelgen.heightproviders.VeryBiasedToBottomHeight"
import {$ConstantHeight} from "net.minecraft.world.level.levelgen.heightproviders.ConstantHeight"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BiasedToBottomHeight} from "net.minecraft.world.level.levelgen.heightproviders.BiasedToBottomHeight"
import {$HeightProvider} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export interface $HeightProviderType$$Interface<P extends $HeightProvider> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.HeightProviderType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.HeightProviderTypeTag
}

export class $HeightProviderType<P extends $HeightProvider> implements $HeightProviderType$$Interface {
static readonly "VERY_BIASED_TO_BOTTOM": $HeightProviderType<($VeryBiasedToBottomHeight)>
static readonly "BIASED_TO_BOTTOM": $HeightProviderType<($BiasedToBottomHeight)>
static readonly "WEIGHTED_LIST": $HeightProviderType<($WeightedListHeight)>
static readonly "UNIFORM": $HeightProviderType<($UniformHeight)>
static readonly "CONSTANT": $HeightProviderType<($ConstantHeight)>
static readonly "TRAPEZOID": $HeightProviderType<($TrapezoidHeight)>

 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeightProviderType$$Type<P> = (Special.HeightProviderType) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HeightProviderType$$Original<P> = $HeightProviderType<(P)>;}
declare module "net.minecraft.world.level.levelgen.structure.StructureSet" {
import {$StructureSet$StructureSelectionEntry, $StructureSet$StructureSelectionEntry$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSet$StructureSelectionEntry"
import {$Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List, $List$$Type} from "java.util.List"
import {$StructurePlacement, $StructurePlacement$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $StructureSet extends $Record {
static readonly "CODEC": $Codec<($Holder<($StructureSet)>)>
static readonly "DIRECT_CODEC": $Codec<($StructureSet)>

constructor(arg0: $Holder$$Type<($Structure)>, arg1: $StructurePlacement$$Type)
constructor(arg0: $List$$Type<($StructureSet$StructureSelectionEntry$$Type)>, arg1: $StructurePlacement$$Type)

public "placement"(): $StructurePlacement
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "entry"(arg0: $Holder$$Type<($Structure)>, arg1: integer): $StructureSet$StructureSelectionEntry
public static "entry"(arg0: $Holder$$Type<($Structure)>): $StructureSet$StructureSelectionEntry
public "structures"(): $List<($StructureSet$StructureSelectionEntry)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructureSet
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructureSetTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureSet$$Type = (Special.WorldgenStructureSet) | ({"structures"?: $List$$Type<($StructureSet$StructureSelectionEntry$$Type)>, "placement"?: $StructurePlacement$$Type}) | ([structures?: $List$$Type<($StructureSet$StructureSelectionEntry$$Type)>, placement?: $StructurePlacement$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureSet$$Original = $StructureSet;}
declare module "net.minecraft.world.level.block.WaterloggedTransparentBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$TransparentBlock} from "net.minecraft.world.level.block.TransparentBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WaterloggedTransparentBlock extends $TransparentBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WaterloggedTransparentBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterloggedTransparentBlock$$Type = ($WaterloggedTransparentBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WaterloggedTransparentBlock$$Original = $WaterloggedTransparentBlock;}
declare module "net.minecraft.world.level.block.StainedGlassBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$TransparentBlock} from "net.minecraft.world.level.block.TransparentBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BeaconBeamBlock$$Interface} from "net.minecraft.world.level.block.BeaconBeamBlock"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $StainedGlassBlock extends $TransparentBlock implements $BeaconBeamBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($StainedGlassBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $DyeColor$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getColor"(): $DyeColor
public "codec"(): $MapCodec<($StainedGlassBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StainedGlassBlock$$Type = ($StainedGlassBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StainedGlassBlock$$Original = $StainedGlassBlock;}
declare module "net.minecraft.world.level.block.ChorusFlowerBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ChorusFlowerBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ChorusFlowerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "DEAD_AGE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getBlockSupportShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public static "generatePlant"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type, arg3: integer): void
public "codec"(): $MapCodec<($ChorusFlowerBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChorusFlowerBlock$$Type = ($ChorusFlowerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChorusFlowerBlock$$Original = $ChorusFlowerBlock;}
declare module "net.minecraft.world.level.levelgen.placement.FixedPlacement" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $FixedPlacement extends $PlacementModifier {
static readonly "CODEC": $MapCodec<($FixedPlacement)>

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
public "type"(): $PlacementModifierType<(never)>
public static "of"(...arg0: ($BlockPos$$Type)[]): $FixedPlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FixedPlacement$$Type = ($FixedPlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FixedPlacement$$Original = $FixedPlacement;}
declare module "net.minecraft.world.level.levelgen.structure.structures.NetherFossilStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider, $HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $NetherFossilStructure extends $Structure {
static readonly "CODEC": $MapCodec<($NetherFossilStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>
readonly "height": $HeightProvider

constructor(arg0: $Structure$StructureSettings$$Type, arg1: $HeightProvider$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherFossilStructure$$Type = ($NetherFossilStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherFossilStructure$$Original = $NetherFossilStructure;}
declare module "net.minecraft.world.level.block.WallSkullBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SkullBlock$Type$$Type} from "net.minecraft.world.level.block.SkullBlock$Type"
import {$AbstractSkullBlock} from "net.minecraft.world.level.block.AbstractSkullBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $WallSkullBlock extends $AbstractSkullBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WallSkullBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $SkullBlock$Type$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getDescriptionId"(): StringJS
public "codec"(): $MapCodec<($WallSkullBlock)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallSkullBlock$$Type = ($WallSkullBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallSkullBlock$$Original = $WallSkullBlock;}
declare module "net.minecraft.world.level.LevelReader" {
import {$Iterable} from "java.lang.Iterable"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ILevelReaderExtension$$Interface} from "net.neoforged.neoforge.common.extensions.ILevelReaderExtension"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder} from "net.minecraft.core.Holder"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$BiomeManager$NoiseBiomeSource$$Interface} from "net.minecraft.world.level.biome.BiomeManager$NoiseBiomeSource"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$ChunkView$$Interface} from "net.caffeinemc.mods.lithium.common.world.ChunkView"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$CollisionGetter$$Interface} from "net.minecraft.world.level.CollisionGetter"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockAndTintGetter$$Interface} from "net.minecraft.world.level.BlockAndTintGetter"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$SignalGetter$$Interface} from "net.minecraft.world.level.SignalGetter"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $LevelReader$$Interface extends $BlockAndTintGetter$$Interface, $CollisionGetter$$Interface, $SignalGetter$$Interface, $BiomeManager$NoiseBiomeSource$$Interface, $ILevelReaderExtension$$Interface, $ChunkView$$Interface {
get "height"(): integer
get "clientSide"(): boolean
get "minBuildHeight"(): integer
get "biomeManager"(): $BiomeManager
get "seaLevel"(): integer
get "skyDarken"(): integer
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $LevelReader implements $LevelReader$$Interface {
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
 "enabledFeatures"(): $FeatureFlagSet
 "registryAccess"(): $RegistryAccess
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "isClientSide"(): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getBiomeManager"(): $BiomeManager
/**
 * 
 * @deprecated
 */
 "hasChunk"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "dimensionType"(): $DimensionType
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "getSkyDarken"(): integer
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getWorldBorder"(): $WorldBorder
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelReader$$Type = ($LevelReader);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelReader$$Original = $LevelReader;}
declare module "net.minecraft.world.level.block.RootedDirtBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RootedDirtBlock extends $Block implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RootedDirtBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "codec"(): $MapCodec<($RootedDirtBlock)>
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RootedDirtBlock$$Type = ($RootedDirtBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RootedDirtBlock$$Original = $RootedDirtBlock;}
declare module "net.minecraft.world.level.levelgen.synth.PerlinSimplexNoise" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List$$Type} from "java.util.List"

export class $PerlinSimplexNoise {
constructor(arg0: $RandomSource$$Type, arg1: $List$$Type<(integer)>)

public "getValue"(arg0: double, arg1: double, arg2: boolean): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PerlinSimplexNoise$$Type = ($PerlinSimplexNoise);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PerlinSimplexNoise$$Original = $PerlinSimplexNoise;}
declare module "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer" {
import {$BoundingBox} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$StructurePiece, $StructurePiece$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePiece"
import {$List, $List$$Type} from "java.util.List"
import {$StructurePieceSerializationContext$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ListTag$$Type} from "net.minecraft.nbt.ListTag"
import {$Record} from "java.lang.Record"

export class $PiecesContainer extends $Record {
constructor(arg0: $List$$Type<($StructurePiece$$Type)>)

public "calculateBoundingBox"(): $BoundingBox
public "isInsidePiece"(arg0: $BlockPos$$Type): boolean
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "load"(arg0: $ListTag$$Type, arg1: $StructurePieceSerializationContext$$Type): $PiecesContainer
public "isEmpty"(): boolean
public "save"(arg0: $StructurePieceSerializationContext$$Type): $Tag
public "pieces"(): $List<($StructurePiece)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PiecesContainer$$Type = ({"pieces"?: $List$$Type<($StructurePiece$$Type)>}) | ([pieces?: $List$$Type<($StructurePiece$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PiecesContainer$$Original = $PiecesContainer;}
declare module "net.minecraft.world.level.block.state.properties.Property" {
import {$Collection} from "java.util.Collection"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Property$Value} from "net.minecraft.world.level.block.state.properties.Property$Value"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$Class} from "java.lang.Class"
import {$StateHolder, $StateHolder$$Type} from "net.minecraft.world.level.block.state.StateHolder"
import {$Stream} from "java.util.stream.Stream"

export class $Property<T extends $Comparable<(object)>> {
public "getAllValues"(): $Stream<($Property$Value<(T)>)>
public "getPossibleValues"(): $Collection<(T)>
public "generateHashCode"(): integer
public "parseValue"<U, S extends $StateHolder<(object), (object)>>(arg0: $DynamicOps$$Type<(U)>, arg1: S, arg2: U): $DataResult<(S)>
public "getName"(arg0: T): StringJS
public "getName"(): StringJS
public "value"(arg0: $StateHolder$$Type<(never), (never)>): $Property$Value<(T)>
public "value"(arg0: T): $Property$Value<(T)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getValue"(arg0: StringJS): $Optional<(T)>
public "getValueClass"(): $Class<(T)>
public "codec"(): $Codec<(T)>
public "valueCodec"(): $Codec<($Property$Value<(T)>)>
get "allValues"(): $Stream<($Property$Value<(T)>)>
get "possibleValues"(): $Collection<(T)>
get "name"(): StringJS
get "valueClass"(): $Class<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Property$$Type<T> = ($Property<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Property$$Original<T> = $Property<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.ReplaceBlockFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration, $ReplaceBlockConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $ReplaceBlockFeature extends $Feature<($ReplaceBlockConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($ReplaceBlockConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($ReplaceBlockConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplaceBlockFeature$$Type = ($ReplaceBlockFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplaceBlockFeature$$Original = $ReplaceBlockFeature;}
declare module "net.minecraft.world.level.ClipContext$Fluid" {
import {$Enum} from "java.lang.Enum"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"

export class $ClipContext$Fluid extends $Enum<($ClipContext$Fluid)> {
static readonly "SOURCE_ONLY": $ClipContext$Fluid
static readonly "NONE": $ClipContext$Fluid
static readonly "ANY": $ClipContext$Fluid
static readonly "WATER": $ClipContext$Fluid

public "canPick"(arg0: $FluidState$$Type): boolean
public static "values"(): ($ClipContext$Fluid)[]
public static "valueOf"(arg0: StringJS): $ClipContext$Fluid
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipContext$Fluid$$Type = (("none") | ("source_only") | ("any") | ("water"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipContext$Fluid$$Original = $ClipContext$Fluid;}
declare module "net.minecraft.world.level.block.BedBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$CollisionGetter$$Type} from "net.minecraft.world.level.CollisionGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BedPart} from "net.minecraft.world.level.block.state.properties.BedPart"
import {$EntityBlock$$Interface} from "net.minecraft.world.level.block.EntityBlock"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$DoubleBlockCombiner$BlockType} from "net.minecraft.world.level.block.DoubleBlockCombiner$BlockType"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $BedBlock extends $HorizontalDirectionalBlock implements $EntityBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BedBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "PART": $EnumProperty<($BedPart)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "OCCUPIED": $BooleanProperty
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $DyeColor$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public static "canSetSpawn"(arg0: $Level$$Type): boolean
public static "getConnectedDirection"(arg0: $BlockState$$Type): $Direction
public static "getBlockType"(arg0: $BlockState$$Type): $DoubleBlockCombiner$BlockType
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getColor"(): $DyeColor
public "codec"(): $MapCodec<($BedBlock)>
public static "getBedOrientation"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Direction
public static "findStandUpPosition"(arg0: $EntityType$$Type<(never)>, arg1: $CollisionGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: float): $Optional<($Vec3)>
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BedBlock$$Type = ($BedBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BedBlock$$Original = $BedBlock;}
declare module "net.minecraft.world.level.biome.Climate$Sampler" {
import {$Climate$TargetPoint} from "net.minecraft.world.level.biome.Climate$TargetPoint"
import {$List, $List$$Type} from "java.util.List"
import {$Climate$ParameterPoint, $Climate$ParameterPoint$$Type} from "net.minecraft.world.level.biome.Climate$ParameterPoint"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"

export class $Climate$Sampler extends $Record {
constructor(arg0: $DensityFunction$$Type, arg1: $DensityFunction$$Type, arg2: $DensityFunction$$Type, arg3: $DensityFunction$$Type, arg4: $DensityFunction$$Type, arg5: $DensityFunction$$Type, arg6: $List$$Type<($Climate$ParameterPoint$$Type)>)

public "temperature"(): $DensityFunction
public "humidity"(): $DensityFunction
public "continentalness"(): $DensityFunction
public "erosion"(): $DensityFunction
public "weirdness"(): $DensityFunction
public "findSpawnPosition"(): $BlockPos
public "spawnTarget"(): $List<($Climate$ParameterPoint)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "depth"(): $DensityFunction
public "sample"(arg0: integer, arg1: integer, arg2: integer): $Climate$TargetPoint
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Climate$Sampler$$Type = ({"erosion"?: $DensityFunction$$Type, "weirdness"?: $DensityFunction$$Type, "continentalness"?: $DensityFunction$$Type, "humidity"?: $DensityFunction$$Type, "spawnTarget"?: $List$$Type<($Climate$ParameterPoint$$Type)>, "depth"?: $DensityFunction$$Type, "temperature"?: $DensityFunction$$Type}) | ([erosion?: $DensityFunction$$Type, weirdness?: $DensityFunction$$Type, continentalness?: $DensityFunction$$Type, humidity?: $DensityFunction$$Type, spawnTarget?: $List$$Type<($Climate$ParameterPoint$$Type)>, depth?: $DensityFunction$$Type, temperature?: $DensityFunction$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Climate$Sampler$$Original = $Climate$Sampler;}
declare module "net.minecraft.world.level.gameevent.GameEventListenerRegistry" {
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$GameEventListenerRegistry$ListenerVisitor$$Type} from "net.minecraft.world.level.gameevent.GameEventListenerRegistry$ListenerVisitor"
import {$GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export interface $GameEventListenerRegistry$$Interface {
get "empty"(): boolean
}

export class $GameEventListenerRegistry implements $GameEventListenerRegistry$$Interface {
static readonly "NOOP": $GameEventListenerRegistry

 "unregister"(arg0: $GameEventListener$$Type): void
 "visitInRangeListeners"(arg0: $Holder$$Type<($GameEvent)>, arg1: $Vec3$$Type, arg2: $GameEvent$Context$$Type, arg3: $GameEventListenerRegistry$ListenerVisitor$$Type): boolean
 "isEmpty"(): boolean
 "register"(arg0: $GameEventListener$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEventListenerRegistry$$Type = ($GameEventListenerRegistry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEventListenerRegistry$$Original = $GameEventListenerRegistry;}
declare module "net.minecraft.world.level.chunk.Palette$Factory" {
import {$List, $List$$Type} from "java.util.List"
import {$Palette, $Palette$$Type} from "net.minecraft.world.level.chunk.Palette"
import {$IdMap, $IdMap$$Type} from "net.minecraft.core.IdMap"
import {$PaletteResize, $PaletteResize$$Type} from "net.minecraft.world.level.chunk.PaletteResize"

export interface $Palette$Factory$$Interface {

(arg0: integer, arg1: $IdMap<(A)>, arg2: $PaletteResize<(A)>, arg3: $List<(A)>): $Palette$$Type<(A)>
}

export class $Palette$Factory implements $Palette$Factory$$Interface {
 "create"<A>(arg0: integer, arg1: $IdMap$$Type<(A)>, arg2: $PaletteResize$$Type<(A)>, arg3: $List$$Type<(A)>): $Palette<(A)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Palette$Factory$$Type = ((arg0: integer, arg1: $IdMap<(A)>, arg2: $PaletteResize<(A)>, arg3: $List<(A)>) => $Palette$$Type<(A)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Palette$Factory$$Original = $Palette$Factory;}
declare module "net.minecraft.world.level.block.DispenserBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Position} from "net.minecraft.core.Position"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockSource$$Type} from "net.minecraft.core.dispenser.BlockSource"
import {$Item} from "net.minecraft.world.item.Item"
import {$DispenseItemBehavior, $DispenseItemBehavior$$Type} from "net.minecraft.core.dispenser.DispenseItemBehavior"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$DispenserBlockAccessor$$Interface} from "com.simibubi.create.foundation.mixin.accessor.DispenserBlockAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$DispenserBlockAccessor$$Interface as $DispenserBlockAccessor$0$$Interface} from "net.mehvahdjukaar.moonlight.core.mixins.accessor.DispenserBlockAccessor"
import {$Map} from "java.util.Map"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $DispenserBlock extends $BaseEntityBlock implements $DispenserBlockAccessor$0$$Interface, $DispenserBlockAccessor$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DispenserBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "DISPENSER_REGISTRY": $Map<($Item), ($DispenseItemBehavior)>
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "TRIGGERED": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "registerBehavior"(arg0: $ItemLike$$Type, arg1: $DispenseItemBehavior$$Type): void
public static "registerProjectileBehavior"(arg0: $ItemLike$$Type): void
public "getDispenseMethod"(arg0: $Level$$Type, arg1: $ItemStack$$Type): $DispenseItemBehavior
public static "getDispensePosition"(arg0: $BlockSource$$Type, arg1: double, arg2: $Vec3$$Type): $Position
public static "getDispensePosition"(arg0: $BlockSource$$Type): $Position
public static "getDispenserRegistry$moonlight_$md$a93e73$0"(): $Map
public "create$callGetDispenseMethod"(arg0: $Level$$Type, arg1: $ItemStack$$Type): $DispenseItemBehavior
public "codec"(): $MapCodec<($DispenserBlock)>
public static "getDispenserRegistry"(): $Map<($Item), ($DispenseItemBehavior)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static get "dispenserRegistry$moonlight_$md$a93e73$0"(): $Map
public static get "dispenserRegistry"(): $Map<($Item), ($DispenseItemBehavior)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DispenserBlock$$Type = ($DispenserBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DispenserBlock$$Original = $DispenserBlock;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.FancyFoliagePlacer" {
import {$BlobFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.BlobFoliagePlacer"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $FancyFoliagePlacer extends $BlobFoliagePlacer {
static readonly "CODEC": $MapCodec<($FancyFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FancyFoliagePlacer$$Type = ($FancyFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FancyFoliagePlacer$$Original = $FancyFoliagePlacer;}
declare module "net.minecraft.world.level.lighting.LayerLightSectionStorage" {
import {$LayerLightSectionStorage$SectionType} from "net.minecraft.world.level.lighting.LayerLightSectionStorage$SectionType"
import {$LayerLightSectionStorageAccessor$$Interface} from "dev.engine_room.flywheel.backend.mixin.light.LayerLightSectionStorageAccessor"
import {$DataLayer} from "net.minecraft.world.level.chunk.DataLayer"
import {$DataLayerStorageMap} from "net.minecraft.world.level.lighting.DataLayerStorageMap"

export class $LayerLightSectionStorage<M extends $DataLayerStorageMap<(object)>> implements $LayerLightSectionStorageAccessor$$Interface {
public "getDebugSectionType"(arg0: long): $LayerLightSectionStorage$SectionType
public "retainData"(arg0: long, arg1: boolean): void
public "getDataLayerData"(arg0: long): $DataLayer
public "flywheel$callGetDataLayer"(arg0: long, arg1: boolean): $DataLayer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LayerLightSectionStorage$$Type<M> = ($LayerLightSectionStorage<(M)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LayerLightSectionStorage$$Original<M> = $LayerLightSectionStorage<(M)>;}
declare module "net.minecraft.world.level.saveddata.maps.MapBanner" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List} from "java.util.List"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapDecorationType} from "net.minecraft.world.level.saveddata.maps.MapDecorationType"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $MapBanner extends $Record {
static readonly "CODEC": $Codec<($MapBanner)>
static readonly "LIST_CODEC": $Codec<($List<($MapBanner)>)>

constructor(arg0: $BlockPos$$Type, arg1: $DyeColor$$Type, arg2: ($Component$$Type)?)

public static "fromWorld"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $MapBanner
public "name"(): $Optional<($Component)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getId"(): StringJS
public "color"(): $DyeColor
public "pos"(): $BlockPos
public "getDecoration"(): $Holder<($MapDecorationType)>
get "id"(): StringJS
get "decoration"(): $Holder<($MapDecorationType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBanner$$Type = ({"pos"?: $BlockPos$$Type, "color"?: $DyeColor$$Type, "name"?: ($Component$$Type)?}) | ([pos?: $BlockPos$$Type, color?: $DyeColor$$Type, name?: ($Component$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapBanner$$Original = $MapBanner;}
declare module "net.minecraft.world.level.levelgen.structure.pools.alias.PoolAliasBinding" {
import {$RandomGroup} from "net.minecraft.world.level.levelgen.structure.pools.alias.RandomGroup"
import {$Direct} from "net.minecraft.world.level.levelgen.structure.pools.alias.Direct"
import {$List$$Type} from "java.util.List"
import {$SimpleWeightedRandomList$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Random} from "net.minecraft.world.level.levelgen.structure.pools.alias.Random"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$StructureTemplatePool, $StructureTemplatePool$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export interface $PoolAliasBinding$$Interface {
}

export class $PoolAliasBinding implements $PoolAliasBinding$$Interface {
static readonly "CODEC": $Codec<($PoolAliasBinding)>

 "forEachResolved"(arg0: $RandomSource$$Type, arg1: $BiConsumer$$Type<($ResourceKey<($StructureTemplatePool)>), ($ResourceKey<($StructureTemplatePool)>)>): void
static "randomGroup"(arg0: $SimpleWeightedRandomList$$Type<($List$$Type<($PoolAliasBinding$$Type)>)>): $RandomGroup
static "direct"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>, arg1: $ResourceKey$$Type<($StructureTemplatePool)>): $Direct
static "direct"(arg0: StringJS, arg1: StringJS): $Direct
static "random"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>, arg1: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($StructureTemplatePool$$Type)>)>): $Random
static "random"(arg0: StringJS, arg1: $SimpleWeightedRandomList$$Type<(StringJS)>): $Random
 "allTargets"(): $Stream<($ResourceKey<($StructureTemplatePool)>)>
 "codec"(): $MapCodec<($PoolAliasBinding)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoolAliasBinding$$Type = ($PoolAliasBinding);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PoolAliasBinding$$Original = $PoolAliasBinding;}
declare module "net.minecraft.world.level.levelgen.presets.WorldPreset" {
import {$LevelStem, $LevelStem$$Type} from "net.minecraft.world.level.dimension.LevelStem"
import {$Map$$Type} from "java.util.Map"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$WorldDimensions} from "net.minecraft.world.level.levelgen.WorldDimensions"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Holder} from "net.minecraft.core.Holder"

export class $WorldPreset {
static readonly "CODEC": $Codec<($Holder<($WorldPreset)>)>
static readonly "DIRECT_CODEC": $Codec<($WorldPreset)>

constructor(arg0: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>)

public "createWorldDimensions"(): $WorldDimensions
public "overworld"(): $Optional<($LevelStem)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenWorldPreset
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenWorldPresetTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldPreset$$Type = (Special.WorldgenWorldPreset);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldPreset$$Original = $WorldPreset;}
declare module "net.minecraft.world.level.levelgen.placement.CountOnEveryLayerPlacement" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

/**
 * 
 * @deprecated
 */
export class $CountOnEveryLayerPlacement extends $PlacementModifier {
static readonly "CODEC": $MapCodec<($CountOnEveryLayerPlacement)>

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
public "type"(): $PlacementModifierType<(never)>
public static "of"(arg0: integer): $CountOnEveryLayerPlacement
public static "of"(arg0: $IntProvider$$Type): $CountOnEveryLayerPlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CountOnEveryLayerPlacement$$Type = ($CountOnEveryLayerPlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CountOnEveryLayerPlacement$$Original = $CountOnEveryLayerPlacement;}
declare module "net.minecraft.world.level.chunk.CarvingMask" {
import {$CarvingMask$Mask$$Type} from "net.minecraft.world.level.chunk.CarvingMask$Mask"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Stream} from "java.util.stream.Stream"

export class $CarvingMask {
constructor(arg0: integer, arg1: integer)
constructor(arg0: (long)[], arg1: integer)

public "setAdditionalMask"(arg0: $CarvingMask$Mask$$Type): void
public "get"(arg0: integer, arg1: integer, arg2: integer): boolean
public "toArray"(): (long)[]
public "stream"(arg0: $ChunkPos$$Type): $Stream<($BlockPos)>
public "set"(arg0: integer, arg1: integer, arg2: integer): void
set "additionalMask"(value: $CarvingMask$Mask$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarvingMask$$Type = ($CarvingMask);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarvingMask$$Original = $CarvingMask;}
declare module "net.minecraft.world.level.block.DragonEggBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$FallingBlock} from "net.minecraft.world.level.block.FallingBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $DragonEggBlock extends $FallingBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DragonEggBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($DragonEggBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DragonEggBlock$$Type = ($DragonEggBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DragonEggBlock$$Original = $DragonEggBlock;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.BlockAgeProcessor" {
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $BlockAgeProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($BlockAgeProcessor)>

constructor(arg0: float)

public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockAgeProcessor$$Type = ($BlockAgeProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockAgeProcessor$$Original = $BlockAgeProcessor;}
declare module "net.minecraft.world.level.biome.MobSpawnSettings$MobSpawnCost" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $MobSpawnSettings$MobSpawnCost extends $Record {
static readonly "CODEC": $Codec<($MobSpawnSettings$MobSpawnCost)>

constructor(energyBudget: double, charge: double)

public "charge"(): double
public "energyBudget"(): double
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnSettings$MobSpawnCost$$Type = ({"charge"?: double, "energyBudget"?: double}) | ([charge?: double, energyBudget?: double]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobSpawnSettings$MobSpawnCost$$Original = $MobSpawnSettings$MobSpawnCost;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $SimpleRandomFeatureConfiguration implements $FeatureConfiguration$$Interface {
readonly "features": $HolderSet<($PlacedFeature)>
static readonly "CODEC": $Codec<($SimpleRandomFeatureConfiguration)>

constructor(arg0: $HolderSet$$Type<($PlacedFeature)>)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleRandomFeatureConfiguration$$Type = ($SimpleRandomFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleRandomFeatureConfiguration$$Original = $SimpleRandomFeatureConfiguration;}
declare module "net.minecraft.world.level.block.SweetBerryBushBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SweetBerryBushBlock extends $BushBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SweetBerryBushBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($SweetBerryBushBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SweetBerryBushBlock$$Type = ($SweetBerryBushBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SweetBerryBushBlock$$Original = $SweetBerryBushBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.MineshaftStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"
import {$MineshaftStructure$Type$$Type} from "net.minecraft.world.level.levelgen.structure.structures.MineshaftStructure$Type"

export class $MineshaftStructure extends $Structure {
static readonly "CODEC": $MapCodec<($MineshaftStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type, arg1: $MineshaftStructure$Type$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MineshaftStructure$$Type = ($MineshaftStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MineshaftStructure$$Original = $MineshaftStructure;}
declare module "net.minecraft.world.level.pathfinder.PathComputationType" {
import {$Enum} from "java.lang.Enum"

export class $PathComputationType extends $Enum<($PathComputationType)> {
static readonly "LAND": $PathComputationType
static readonly "AIR": $PathComputationType
static readonly "WATER": $PathComputationType

public static "values"(): ($PathComputationType)[]
public static "valueOf"(arg0: StringJS): $PathComputationType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathComputationType$$Type = (("land") | ("water") | ("air"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathComputationType$$Original = $PathComputationType;}
declare module "net.minecraft.world.level.levelgen.blending.Blender$BlendingOutput" {
import {$Record} from "java.lang.Record"

export class $Blender$BlendingOutput extends $Record {
constructor(arg0: double, arg1: double)

public "blendingOffset"(): double
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "alpha"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Blender$BlendingOutput$$Type = ({"blendingOffset"?: double, "alpha"?: double}) | ([blendingOffset?: double, alpha?: double]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Blender$BlendingOutput$$Original = $Blender$BlendingOutput;}
declare module "net.minecraft.world.level.levelgen.feature.rootplacers.AboveRootPlacement" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Record} from "java.lang.Record"

export class $AboveRootPlacement extends $Record {
static readonly "CODEC": $Codec<($AboveRootPlacement)>

constructor(arg0: $BlockStateProvider$$Type, arg1: float)

public "aboveRootProvider"(): $BlockStateProvider
public "aboveRootPlacementChance"(): float
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AboveRootPlacement$$Type = ({"aboveRootProvider"?: $BlockStateProvider$$Type, "aboveRootPlacementChance"?: float}) | ([aboveRootProvider?: $BlockStateProvider$$Type, aboveRootPlacementChance?: float]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AboveRootPlacement$$Original = $AboveRootPlacement;}
declare module "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement" {
import {$ChunkGeneratorStructureState$$Type} from "net.minecraft.world.level.chunk.ChunkGeneratorStructureState"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructurePlacementType} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacementType"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export class $StructurePlacement {
static readonly "CODEC": $Codec<($StructurePlacement)>

public "isStructureChunk"(arg0: $ChunkGeneratorStructureState$$Type, arg1: integer, arg2: integer): boolean
public "applyAdditionalChunkRestrictions"(arg0: integer, arg1: integer, arg2: long): boolean
public "applyInteractionsWithOtherStructures"(arg0: $ChunkGeneratorStructureState$$Type, arg1: integer, arg2: integer): boolean
public "getLocatePos"(arg0: $ChunkPos$$Type): $BlockPos
public "type"(): $StructurePlacementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePlacement$$Type = ($StructurePlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePlacement$$Original = $StructurePlacement;}
declare module "net.minecraft.world.level.block.Block" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ItemAbility$$Type} from "net.neoforged.neoforge.common.ItemAbility"
import {$Holder} from "net.minecraft.core.Holder"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$AccessorMixinBlock$$Interface} from "noobanidus.mods.lootr.common.mixin.accessor.AccessorMixinBlock"
import {$IBlockExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBlockExtension"
import {$PathType, $PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$Set} from "java.util.Set"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$StateDefinition} from "net.minecraft.world.level.block.state.StateDefinition"
import {$EnchantmentStatBlock$$Interface} from "dev.shadowsoffire.apothic_enchanting.api.EnchantmentStatBlock"
import {$BubbleColumnDirection} from "net.neoforged.neoforge.common.enums.BubbleColumnDirection"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$TriState} from "net.neoforged.neoforge.common.util.TriState"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$IClientBlockExtensions$$Type} from "net.neoforged.neoforge.client.extensions.common.IClientBlockExtensions"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ItemLike$$Interface} from "net.minecraft.world.level.ItemLike"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"
import {$MapColor, $MapColor$$Type} from "net.minecraft.world.level.material.MapColor"
import {$Comparable} from "java.lang.Comparable"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerPlayer$RespawnPosAngle} from "net.minecraft.server.level.ServerPlayer$RespawnPosAngle"
import {$BlockBehaviour} from "net.minecraft.world.level.block.state.BlockBehaviour"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Map} from "java.util.Map"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$BlockKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockKJS"
import {$Enchantment} from "net.minecraft.world.item.enchantment.Enchantment"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$InjectedBlockExtension$$Interface} from "dev.architectury.extensions.injected.InjectedBlockExtension"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$ParticleOptions} from "net.minecraft.core.particles.ParticleOptions"
import {$Biome$Precipitation$$Type} from "net.minecraft.world.level.biome.Biome$Precipitation"

export class $Block extends $BlockBehaviour implements $ItemLike$$Interface, $IBlockExtension$$Interface, $InjectedBlockExtension$$Interface, $EnchantmentStatBlock$$Interface, $BlockKJS$$Interface, $AccessorMixinBlock$$Interface, $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "asItem"(): $Item
/**
 * 
 * @deprecated
 */
public "initializeClient"(arg0: $Consumer$$Type<($IClientBlockExtensions)>): void
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "builtInRegistryHolder"(): $Holder$Reference<($Block)>
public static "stateById"(arg0: integer): $BlockState
public static "byItem"(arg0: $Item$$Type): $Block
public static "pushEntitiesUp"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $LevelAccessor$$Type, arg3: $BlockPos$$Type): $BlockState
public static "updateFromNeighbourShapes"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): $BlockState
public static "updateOrDestroy"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $LevelAccessor$$Type, arg3: $BlockPos$$Type, arg4: integer): void
public static "updateOrDestroy"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $LevelAccessor$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
public static "isExceptionForConnection"(arg0: $BlockState$$Type): boolean
public static "shouldRenderFace"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $BlockPos$$Type): boolean
public static "canSupportRigidBlock"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public static "canSupportCenter"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public static "isFaceFull"(arg0: $VoxelShape$$Type, arg1: $Direction$$Type): boolean
public static "isShapeFullBlock"(arg0: $VoxelShape$$Type): boolean
public static "getDrops"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): $List<($ItemStack)>
public static "getDrops"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): $List<($ItemStack)>
public static "popResource"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type): void
public static "popResourceFromFace"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $ItemStack$$Type): void
public "popExperience"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: integer): void
/**
 * 
 * @deprecated
 */
public "getExplosionResistance"(): float
public "wasExploded"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): void
public "playerDestroy"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockEntity$$Type, arg5: $ItemStack$$Type): void
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "isPossibleToRespawnInThis"(arg0: $BlockState$$Type): boolean
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "handler$cda000$ftbultimine$onPlayerWillDestroy"(level: $Level$$Type, blockPos: $BlockPos$$Type, blockState: $BlockState$$Type, player: $Player$$Type, cir: $CallbackInfoReturnable$$Type): void
public "handlePrecipitation"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Biome$Precipitation$$Type): void
/**
 * 
 * @deprecated
 */
public "dropFromExplosion"(arg0: $Explosion$$Type): boolean
public "withPropertiesOf"(arg0: $BlockState$$Type): $BlockState
public static "copyProperty"<T extends $Comparable<(object)>>(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Property$$Type<(T)>): $BlockState
public "hasDynamicShape"(): boolean
public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "getBlockBuilder"(): $BlockBuilder
public "setBlockBuilder"(b: $BlockBuilder$$Type): void
public "getTypeData"(): $Map
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "setNameKey"(arg0: StringJS): void
public "lootr$spawnDestroyParticles"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getName"(): $MutableComponent
public "toString"(): StringJS
public static "getId"(arg0: $BlockState$$Type): Special.Block
public "destroy"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public static "box"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $VoxelShape
public "getStateDefinition"(): $StateDefinition<($Block), ($BlockState)>
public "getDescriptionId"(): StringJS
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
/**
 * 
 * @deprecated
 */
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public "defaultBlockState"(): $BlockState
public "getFriction"(): float
public "getId"(): Special.Block
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "stepOn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type): void
public "getJumpFactor"(): float
public "getSpeedFactor"(): float
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public static "dropResources"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): void
public static "dropResources"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): void
public static "dropResources"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): void
public "getBlockPathType"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type): $PathType
public "getAdjacentBlockPathType"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type, arg4: $PathType$$Type): $PathType
public "hidesNeighborFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $Direction$$Type): boolean
public "supportsExternalFaceHiding"(arg0: $BlockState$$Type): boolean
public "getExplosionResistance"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type): float
public "ignitedByLava"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "isStickyBlock"(arg0: $BlockState$$Type): boolean
public "getFlammability"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "hasDynamicLightEmission"(arg0: $BlockState$$Type): boolean
public "isLadder"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $LivingEntity$$Type): boolean
public "makesOpenTrapdoorAboveClimbable"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "canHarvestBlock"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): boolean
public "onDestroyedByPlayer"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type, arg4: boolean, arg5: $FluidState$$Type): boolean
public "onDestroyedByPushReaction"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $FluidState$$Type): void
public "getRespawnPosition"(arg0: $BlockState$$Type, arg1: $EntityType$$Type<(never)>, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: float): $Optional<($ServerPlayer$RespawnPosAngle)>
public "canSustainPlant"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $BlockState$$Type): $TriState
public "onTreeGrow"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg3: $RandomSource$$Type, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): boolean
public "isFertile"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "isConduitFrame"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type): boolean
public "isPortalFrame"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "getExpDrop"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): integer
public "getEnchantPowerBonus"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): float
public "getBeaconColorMultiplier"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type): integer
public "getStateAtViewpoint"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Vec3$$Type): $BlockState
public "isSlimeBlock"(arg0: $BlockState$$Type): boolean
public "canStickTo"(arg0: $BlockState$$Type, arg1: $BlockState$$Type): boolean
public "isFlammable"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "onCaughtFire"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $LivingEntity$$Type): void
public "getFireSpreadSpeed"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "isFireSource"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "canEntityDestroy"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "canDropFromExplosion"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type): boolean
public "onBlockExploded"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type): void
public "shouldDisplayFluidOverlay"(arg0: $BlockState$$Type, arg1: $BlockAndTintGetter$$Type, arg2: $BlockPos$$Type, arg3: $FluidState$$Type): boolean
public "getToolModifiedState"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type, arg2: $ItemAbility$$Type, arg3: boolean): $BlockState
public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "canBeHydrated"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $FluidState$$Type, arg4: $BlockPos$$Type): boolean
public "getMapColor"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $MapColor$$Type): $MapColor
public "getAppearance"(arg0: $BlockState$$Type, arg1: $BlockAndTintGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $BlockState$$Type, arg5: $BlockPos$$Type): $BlockState
public "getBubbleColumnDirection"(arg0: $BlockState$$Type): $BubbleColumnDirection
public "shouldHideAdjacentFluidFace"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $FluidState$$Type): boolean
public "isEmpty"(arg0: $BlockState$$Type): boolean
public "rotate"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $Rotation$$Type): $BlockState
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "addLandingEffects"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $LivingEntity$$Type, arg5: integer): boolean
public "getSoundType"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): $SoundType
public "isScaffolding"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $LivingEntity$$Type): boolean
public "isBed"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $LivingEntity$$Type): boolean
public "setBedOccupied"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $LivingEntity$$Type, arg4: boolean): void
public "getBedDirection"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): $Direction
public "getFriction"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): float
public "collisionExtendsVertically"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "addRunningEffects"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "onNeighborChange"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type): void
public "getWeakChanges"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "isBurning"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "getLightEmission"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): integer
public "onBlockStateChange"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type): void
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "arch$holder"(): $Holder<($Block)>
public "getTableParticle"(arg0: $BlockState$$Type): $ParticleOptions
public "getMaxEnchantingPower"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): float
public "getQuantaBonus"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): float
public "getArcanaBonus"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): float
public "getBonusClues"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): integer
public "getBlacklistedEnchantments"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): $Set<($Holder<($Enchantment)>)>
public "spawnTableParticle"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type): void
public "allowsTreasure"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "providesStability"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getBlockStates"(): $List<($BlockState)>
public "setDestroySpeed"(v: float): void
public "setLightEmission"(v: integer): void
public "setRequiresTool"(v: boolean): void
public "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
public "getBlock"(): $Block
public "moreculling$customShouldDrawFace"(arg0: $BlockGetter$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: $Direction$$Type): $Optional<(boolean)>
public "moreculling$usesCustomShouldDrawFace"(arg0: $BlockState$$Type): boolean
public "arch$registryName"(): $ResourceLocation
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "explosionResistance"(): float
get "blockBuilder"(): $BlockBuilder
set "blockBuilder"(value: $BlockBuilder$$Type)
get "typeData"(): $Map
set "nameKey"(value: StringJS)
get "name"(): $MutableComponent
get "stateDefinition"(): $StateDefinition<($Block), ($BlockState)>
get "descriptionId"(): StringJS
get "friction"(): float
get "id"(): Special.Block
get "jumpFactor"(): float
get "speedFactor"(): float
get "blockStates"(): $List<($BlockState)>
set "destroySpeed"(value: float)
set "lightEmission"(value: integer)
set "requiresTool"(value: boolean)
get "block"(): $Block
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.Block
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.BlockTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Block$$Type = (Special.Block);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Block$$Original = $Block;}
declare module "net.minecraft.world.level.ChunkPos" {
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"

export class $ChunkPos {
static readonly "ZERO": $ChunkPos
static readonly "REGION_MAX_INDEX": integer
static readonly "INVALID_CHUNK_POS": long
readonly "x": integer
static readonly "REGION_SIZE": integer
readonly "z": integer

constructor(arg0: integer, arg1: integer)
constructor(arg0: $BlockPos$$Type)
constructor(arg0: long)

public "getMaxBlockX"(): integer
public "getMaxBlockZ"(): integer
public "getMiddleBlockX"(): integer
public "getMiddleBlockZ"(): integer
public static "minFromRegion"(arg0: integer, arg1: integer): $ChunkPos
public static "maxFromRegion"(arg0: integer, arg1: integer): $ChunkPos
public "getRegionX"(): integer
public "getRegionZ"(): integer
public "getRegionLocalX"(): integer
public "getRegionLocalZ"(): integer
public "getBlockAt"(arg0: integer, arg1: integer, arg2: integer): $BlockPos
public "getMiddleBlockPosition"(arg0: integer): $BlockPos
public "getWorldPosition"(): $BlockPos
public static "rangeClosed"(arg0: $ChunkPos$$Type, arg1: integer): $Stream<($ChunkPos)>
public static "rangeClosed"(arg0: $ChunkPos$$Type, arg1: $ChunkPos$$Type): $Stream<($ChunkPos)>
public "toLong"(): long
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "hash"(arg0: integer, arg1: integer): integer
public static "getX"(arg0: long): integer
public static "getZ"(arg0: long): integer
public "getBlockX"(arg0: integer): integer
public "getBlockZ"(arg0: integer): integer
public "getMinBlockX"(): integer
public "getMinBlockZ"(): integer
public static "asLong"(arg0: $BlockPos$$Type): long
public static "asLong"(arg0: integer, arg1: integer): long
public "distanceSquared"(arg0: long): integer
public "distanceSquared"(arg0: $ChunkPos$$Type): integer
public "getChessboardDistance"(arg0: $ChunkPos$$Type): integer
public "getChessboardDistance"(arg0: integer, arg1: integer): integer
get "maxBlockX"(): integer
get "maxBlockZ"(): integer
get "middleBlockX"(): integer
get "middleBlockZ"(): integer
get "regionX"(): integer
get "regionZ"(): integer
get "regionLocalX"(): integer
get "regionLocalZ"(): integer
get "worldPosition"(): $BlockPos
get "minBlockX"(): integer
get "minBlockZ"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkPos$$Type = ($ChunkPos);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkPos$$Original = $ChunkPos;}
declare module "net.minecraft.world.level.storage.WorldData" {
import {$EndDragonFight$Data, $EndDragonFight$Data$$Type} from "net.minecraft.world.level.dimension.end.EndDragonFight$Data"
import {$LevelSettings} from "net.minecraft.world.level.LevelSettings"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$Difficulty, $Difficulty$$Type} from "net.minecraft.world.Difficulty"
import {$WorldOptions} from "net.minecraft.world.level.levelgen.WorldOptions"
import {$GameRules} from "net.minecraft.world.level.GameRules"
import {$ServerLevelData} from "net.minecraft.world.level.storage.ServerLevelData"
import {$Set} from "java.util.Set"
import {$Lifecycle} from "com.mojang.serialization.Lifecycle"
import {$GameType, $GameType$$Type} from "net.minecraft.world.level.GameType"
import {$WorldDataConfiguration, $WorldDataConfiguration$$Type} from "net.minecraft.world.level.WorldDataConfiguration"
import {$CrashReportCategory$$Type} from "net.minecraft.CrashReportCategory"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export interface $WorldData$$Interface {
get "gameType"(): $GameType
get "difficultyLocked"(): boolean
set "gameType"(value: $GameType$$Type)
get "flatWorld"(): boolean
get "levelName"(): StringJS
get "version"(): integer
get "hardcore"(): boolean
get "customBossEvents"(): $CompoundTag
set "customBossEvents"(value: $CompoundTag$$Type)
get "levelSettings"(): $LevelSettings
get "allowCommands"(): boolean
set "difficulty"(value: $Difficulty$$Type)
set "difficultyLocked"(value: boolean)
get "loadedPlayerTag"(): $CompoundTag
get "debugWorld"(): boolean
get "dataConfiguration"(): $WorldDataConfiguration
set "dataConfiguration"(value: $WorldDataConfiguration$$Type)
get "knownServerBrands"(): $Set<(StringJS)>
get "removedFeatureFlags"(): $Set<(StringJS)>
get "difficulty"(): $Difficulty
get "gameRules"(): $GameRules
}

export class $WorldData implements $WorldData$$Interface {
static readonly "ANVIL_VERSION_ID": integer
static readonly "MCREGION_VERSION_ID": integer

 "getGameType"(): $GameType
 "isDifficultyLocked"(): boolean
 "setGameType"(arg0: $GameType$$Type): void
 "worldGenOptions"(): $WorldOptions
 "endDragonFightData"(): $EndDragonFight$Data
 "setEndDragonFightData"(arg0: $EndDragonFight$Data$$Type): void
 "isFlatWorld"(): boolean
 "createTag"(arg0: $RegistryAccess$$Type, arg1: $CompoundTag$$Type): $CompoundTag
 "getLevelName"(): StringJS
 "getVersion"(): integer
 "isHardcore"(): boolean
 "enabledFeatures"(): $FeatureFlagSet
 "getStorageVersionName"(arg0: integer): StringJS
 "getCustomBossEvents"(): $CompoundTag
 "setCustomBossEvents"(arg0: $CompoundTag$$Type): void
 "overworldData"(): $ServerLevelData
 "getLevelSettings"(): $LevelSettings
 "isAllowCommands"(): boolean
 "setDifficulty"(arg0: $Difficulty$$Type): void
 "setDifficultyLocked"(arg0: boolean): void
 "getLoadedPlayerTag"(): $CompoundTag
 "isDebugWorld"(): boolean
 "worldGenSettingsLifecycle"(): $Lifecycle
 "getDataConfiguration"(): $WorldDataConfiguration
 "setDataConfiguration"(arg0: $WorldDataConfiguration$$Type): void
 "wasModded"(): boolean
 "getKnownServerBrands"(): $Set<(StringJS)>
 "getRemovedFeatureFlags"(): $Set<(StringJS)>
 "setModdedInfo"(arg0: StringJS, arg1: boolean): void
 "getDifficulty"(): $Difficulty
 "getGameRules"(): $GameRules
 "fillCrashReportCategory"(arg0: $CrashReportCategory$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldData$$Type = ($WorldData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldData$$Original = $WorldData;}
declare module "net.minecraft.world.level.block.TorchBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BaseTorchBlock} from "net.minecraft.world.level.block.BaseTorchBlock"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$SimpleParticleType$$Type} from "net.minecraft.core.particles.SimpleParticleType"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TorchBlock extends $BaseTorchBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TorchBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $SimpleParticleType$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($TorchBlock)>
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TorchBlock$$Type = ($TorchBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TorchBlock$$Original = $TorchBlock;}
declare module "net.minecraft.world.level.block.WallTorchBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$TorchBlock} from "net.minecraft.world.level.block.TorchBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$SimpleParticleType$$Type} from "net.minecraft.core.particles.SimpleParticleType"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WallTorchBlock extends $TorchBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WallTorchBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $SimpleParticleType$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "getShape"(arg0: $BlockState$$Type): $VoxelShape
public "getDescriptionId"(): StringJS
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($WallTorchBlock)>
public static "canSurvive"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallTorchBlock$$Type = ($WallTorchBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallTorchBlock$$Original = $WallTorchBlock;}
declare module "net.minecraft.world.level.levelgen.blending.Blender$DistanceGetter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Blender$DistanceGetter$$Interface {

(arg0: double, arg1: double, arg2: double): double
}

export class $Blender$DistanceGetter implements $Blender$DistanceGetter$$Interface {
 "getDistance"(arg0: double, arg1: double, arg2: double): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Blender$DistanceGetter$$Type = ((arg0: double, arg1: double, arg2: double) => double);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Blender$DistanceGetter$$Original = $Blender$DistanceGetter;}
declare module "net.minecraft.world.level.block.PoweredBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PoweredBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PoweredBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($PoweredBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoweredBlock$$Type = ($PoweredBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PoweredBlock$$Original = $PoweredBlock;}
declare module "net.minecraft.world.level.block.BuddingAmethystBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$AmethystBlock} from "net.minecraft.world.level.block.AmethystBlock"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BuddingAmethystBlock extends $AmethystBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BuddingAmethystBlock)>
static readonly "GROWTH_CHANCE": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "randomTick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "canClusterGrowAtState"(arg0: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($BuddingAmethystBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuddingAmethystBlock$$Type = ($BuddingAmethystBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuddingAmethystBlock$$Original = $BuddingAmethystBlock;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.AxisAlignedLinearPosTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$PosRuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.PosRuleTest"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AxisAlignedLinearPosTest extends $PosRuleTest {
static readonly "CODEC": $MapCodec<($AxisAlignedLinearPosTest)>

constructor(arg0: float, arg1: float, arg2: integer, arg3: integer, arg4: $Direction$Axis$$Type)

public "test"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AxisAlignedLinearPosTest$$Type = ($AxisAlignedLinearPosTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AxisAlignedLinearPosTest$$Original = $AxisAlignedLinearPosTest;}
declare module "net.minecraft.world.level.block.ChiseledBookShelfBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$ChiseledBookShelfBlockEntity$$Type} from "net.minecraft.world.level.block.entity.ChiseledBookShelfBlockEntity"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec2} from "net.minecraft.world.phys.Vec2"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$OptionalInt} from "java.util.OptionalInt"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $ChiseledBookShelfBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ChiseledBookShelfBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BOOKS_PER_ROW": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "SLOT_OCCUPIED_PROPERTIES": $List<($BooleanProperty)>
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getHitSlot"(arg0: $BlockHitResult$$Type, arg1: $BlockState$$Type): $OptionalInt
public static "addBook"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Player$$Type, arg3: $ChiseledBookShelfBlockEntity$$Type, arg4: $ItemStack$$Type, arg5: integer): void
public static "removeBook"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Player$$Type, arg3: $ChiseledBookShelfBlockEntity$$Type, arg4: integer): void
public static "getRelativeHitCoordinatesForBlockFace"(arg0: $BlockHitResult$$Type, arg1: $Direction$$Type): $Optional<($Vec2)>
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "codec"(): $MapCodec<($ChiseledBookShelfBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChiseledBookShelfBlock$$Type = ($ChiseledBookShelfBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChiseledBookShelfBlock$$Original = $ChiseledBookShelfBlock;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.MatchingBlockTagPredicate" {
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StateTestingPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.StateTestingPredicate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MatchingBlockTagPredicate extends $StateTestingPredicate {
static readonly "CODEC": $MapCodec<($MatchingBlockTagPredicate)>

public "type"(): $BlockPredicateType<(never)>
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatchingBlockTagPredicate$$Type = ($MatchingBlockTagPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MatchingBlockTagPredicate$$Original = $MatchingBlockTagPredicate;}
declare module "net.minecraft.world.level.block.entity.BlastFurnaceBlockEntity" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$Component} from "net.minecraft.network.chat.Component"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AbstractFurnaceBlockEntity} from "net.minecraft.world.level.block.entity.AbstractFurnaceBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlastFurnaceBlockEntity extends $AbstractFurnaceBlockEntity {
static readonly "DATA_LIT_DURATION": integer
static readonly "DATA_COOKING_TOTAL_TIME": integer
static readonly "DATA_COOKING_PROGRESS": integer
static readonly "BURN_TIME_STANDARD": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode
static readonly "NUM_DATA_VALUES": integer
 "litTime": integer
static readonly "DATA_LIT_TIME": integer
static readonly "BURN_COOL_SPEED": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public static "tryClear"(arg0: any): void
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlastFurnaceBlockEntity$$Type = ($BlastFurnaceBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlastFurnaceBlockEntity$$Original = $BlastFurnaceBlockEntity;}
declare module "net.minecraft.world.level.block.KelpBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$LiquidBlockContainer$$Interface} from "net.minecraft.world.level.block.LiquidBlockContainer"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GrowingPlantHeadBlock} from "net.minecraft.world.level.block.GrowingPlantHeadBlock"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $KelpBlock extends $GrowingPlantHeadBlock implements $LiquidBlockContainer$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($KelpBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "codec"(): $MapCodec<($KelpBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KelpBlock$$Type = ($KelpBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KelpBlock$$Original = $KelpBlock;}
declare module "net.minecraft.world.level.block.MultifaceSpreader$SpreadConfig" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$MultifaceSpreader$SpreadType} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadType"
import {$MultifaceSpreader$SpreadPos$$Type} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadPos"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $MultifaceSpreader$SpreadConfig$$Interface {
get "spreadTypes"(): ($MultifaceSpreader$SpreadType)[]
}

export class $MultifaceSpreader$SpreadConfig implements $MultifaceSpreader$SpreadConfig$$Interface {
 "getStateForPlacement"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): $BlockState
 "hasFace"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
 "canSpreadInto"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $MultifaceSpreader$SpreadPos$$Type): boolean
 "isOtherBlockValidAsSource"(arg0: $BlockState$$Type): boolean
 "getSpreadTypes"(): ($MultifaceSpreader$SpreadType)[]
 "placeBlock"(arg0: $LevelAccessor$$Type, arg1: $MultifaceSpreader$SpreadPos$$Type, arg2: $BlockState$$Type, arg3: boolean): boolean
 "canSpreadFrom"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceSpreader$SpreadConfig$$Type = ($MultifaceSpreader$SpreadConfig);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceSpreader$SpreadConfig$$Original = $MultifaceSpreader$SpreadConfig;}
declare module "net.minecraft.world.level.block.AirBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $AirBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($AirBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($AirBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AirBlock$$Type = ($AirBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AirBlock$$Original = $AirBlock;}
declare module "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement" {
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$List, $List$$Type} from "java.util.List"
import {$SinglePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.SinglePoolElement"
import {$EmptyPoolElement} from "net.minecraft.world.level.levelgen.structure.pools.EmptyPoolElement"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$ListPoolElement} from "net.minecraft.world.level.levelgen.structure.pools.ListPoolElement"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$StructureProcessorList$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorList"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$FeaturePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.FeaturePoolElement"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplatePool$Projection, $StructureTemplatePool$Projection$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection"
import {$LegacySinglePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.LegacySinglePoolElement"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $StructurePoolElement {
static readonly "CODEC": $Codec<($StructurePoolElement)>

public "handleDataMarker"(arg0: $LevelAccessor$$Type, arg1: $StructureTemplate$StructureBlockInfo$$Type, arg2: $BlockPos$$Type, arg3: $Rotation$$Type, arg4: $RandomSource$$Type, arg5: $BoundingBox$$Type): void
public "getGroundLevelDelta"(): integer
public "getShuffledJigsawBlocks"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: $RandomSource$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "setProjection"(arg0: $StructureTemplatePool$Projection$$Type): $StructurePoolElement
public "getProjection"(): $StructureTemplatePool$Projection
public "place"(arg0: $StructureTemplateManager$$Type, arg1: $WorldGenLevel$$Type, arg2: $StructureManager$$Type, arg3: $ChunkGenerator$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type, arg6: $Rotation$$Type, arg7: $BoundingBox$$Type, arg8: $RandomSource$$Type, arg9: $LiquidSettings$$Type, arg10: boolean): boolean
public static "list"(arg0: $List$$Type<($Function$$Type<($StructureTemplatePool$Projection$$Type), ($StructurePoolElement$$Type)>)>): $Function<($StructureTemplatePool$Projection), ($ListPoolElement)>
public static "single"(arg0: StringJS, arg1: $LiquidSettings$$Type): $Function<($StructureTemplatePool$Projection), ($SinglePoolElement)>
public static "single"(arg0: StringJS): $Function<($StructureTemplatePool$Projection), ($SinglePoolElement)>
public static "single"(arg0: StringJS, arg1: $Holder$$Type<($StructureProcessorList)>, arg2: $LiquidSettings$$Type): $Function<($StructureTemplatePool$Projection), ($SinglePoolElement)>
public static "single"(arg0: StringJS, arg1: $Holder$$Type<($StructureProcessorList)>): $Function<($StructureTemplatePool$Projection), ($SinglePoolElement)>
public static "empty"(): $Function<($StructureTemplatePool$Projection), ($EmptyPoolElement)>
public static "feature"(arg0: $Holder$$Type<($PlacedFeature)>): $Function<($StructureTemplatePool$Projection), ($FeaturePoolElement)>
public "getType"(): $StructurePoolElementType<(never)>
public "getSize"(arg0: $StructureTemplateManager$$Type, arg1: $Rotation$$Type): $Vec3i
public static "legacy"(arg0: StringJS, arg1: $Holder$$Type<($StructureProcessorList)>): $Function<($StructureTemplatePool$Projection), ($LegacySinglePoolElement)>
public static "legacy"(arg0: StringJS): $Function<($StructureTemplatePool$Projection), ($LegacySinglePoolElement)>
public "getBoundingBox"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BoundingBox
get "groundLevelDelta"(): integer
set "projection"(value: $StructureTemplatePool$Projection$$Type)
get "projection"(): $StructureTemplatePool$Projection
get "type"(): $StructurePoolElementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePoolElement$$Type = ($StructurePoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePoolElement$$Original = $StructurePoolElement;}
declare module "net.minecraft.world.level.levelgen.structure.structures.MineshaftStructure$Type" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $MineshaftStructure$Type extends $Enum<($MineshaftStructure$Type)> implements $StringRepresentable$$Interface {
static readonly "MESA": $MineshaftStructure$Type
static readonly "CODEC": $Codec<($MineshaftStructure$Type)>
static readonly "NORMAL": $MineshaftStructure$Type

public "getPlanksState"(): $BlockState
public "getWoodState"(): $BlockState
public "getFenceState"(): $BlockState
public "getName"(): StringJS
public static "values"(): ($MineshaftStructure$Type)[]
public static "valueOf"(arg0: StringJS): $MineshaftStructure$Type
public "getSerializedName"(): StringJS
public static "byId"(arg0: integer): $MineshaftStructure$Type
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "planksState"(): $BlockState
get "woodState"(): $BlockState
get "fenceState"(): $BlockState
get "name"(): StringJS
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MineshaftStructure$Type$$Type = (("normal") | ("mesa"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MineshaftStructure$Type$$Original = $MineshaftStructure$Type;}
declare module "net.minecraft.world.level.levelgen.structure.StructureType" {
import {$NetherFossilStructure} from "net.minecraft.world.level.levelgen.structure.structures.NetherFossilStructure"
import {$MineshaftStructure} from "net.minecraft.world.level.levelgen.structure.structures.MineshaftStructure"
import {$StrongholdStructure} from "net.minecraft.world.level.levelgen.structure.structures.StrongholdStructure"
import {$ShipwreckStructure} from "net.minecraft.world.level.levelgen.structure.structures.ShipwreckStructure"
import {$NetherFortressStructure} from "net.minecraft.world.level.levelgen.structure.structures.NetherFortressStructure"
import {$EndCityStructure} from "net.minecraft.world.level.levelgen.structure.structures.EndCityStructure"
import {$DesertPyramidStructure} from "net.minecraft.world.level.levelgen.structure.structures.DesertPyramidStructure"
import {$JungleTempleStructure} from "net.minecraft.world.level.levelgen.structure.structures.JungleTempleStructure"
import {$IglooStructure} from "net.minecraft.world.level.levelgen.structure.structures.IglooStructure"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$SwampHutStructure} from "net.minecraft.world.level.levelgen.structure.structures.SwampHutStructure"
import {$JigsawStructure} from "net.minecraft.world.level.levelgen.structure.structures.JigsawStructure"
import {$RuinedPortalStructure} from "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalStructure"
import {$OceanRuinStructure} from "net.minecraft.world.level.levelgen.structure.structures.OceanRuinStructure"
import {$OceanMonumentStructure} from "net.minecraft.world.level.levelgen.structure.structures.OceanMonumentStructure"
import {$WoodlandMansionStructure} from "net.minecraft.world.level.levelgen.structure.structures.WoodlandMansionStructure"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BuriedTreasureStructure} from "net.minecraft.world.level.levelgen.structure.structures.BuriedTreasureStructure"

export interface $StructureType$$Interface<S extends $Structure> {

(): $MapCodec$$Type<(S)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructureType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructureTypeTag
}

export class $StructureType<S extends $Structure> implements $StructureType$$Interface {
static readonly "STRONGHOLD": $StructureType<($StrongholdStructure)>
static readonly "RUINED_PORTAL": $StructureType<($RuinedPortalStructure)>
static readonly "MINESHAFT": $StructureType<($MineshaftStructure)>
static readonly "NETHER_FOSSIL": $StructureType<($NetherFossilStructure)>
static readonly "IGLOO": $StructureType<($IglooStructure)>
static readonly "SHIPWRECK": $StructureType<($ShipwreckStructure)>
static readonly "SWAMP_HUT": $StructureType<($SwampHutStructure)>
static readonly "JIGSAW": $StructureType<($JigsawStructure)>
static readonly "JUNGLE_TEMPLE": $StructureType<($JungleTempleStructure)>
static readonly "FORTRESS": $StructureType<($NetherFortressStructure)>
static readonly "OCEAN_MONUMENT": $StructureType<($OceanMonumentStructure)>
static readonly "DESERT_PYRAMID": $StructureType<($DesertPyramidStructure)>
static readonly "END_CITY": $StructureType<($EndCityStructure)>
static readonly "WOODLAND_MANSION": $StructureType<($WoodlandMansionStructure)>
static readonly "BURIED_TREASURE": $StructureType<($BuriedTreasureStructure)>
static readonly "OCEAN_RUIN": $StructureType<($OceanRuinStructure)>

 "codec"(): $MapCodec<(S)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureType$$Type<S> = (Special.WorldgenStructureType) | (() => $MapCodec$$Type<(S)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureType$$Original<S> = $StructureType<(S)>;}
declare module "net.minecraft.world.level.levelgen.GenerationStep$Decoration" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $GenerationStep$Decoration extends $Enum<($GenerationStep$Decoration)> implements $StringRepresentable$$Interface {
static readonly "RAW_GENERATION": $GenerationStep$Decoration
static readonly "UNDERGROUND_STRUCTURES": $GenerationStep$Decoration
static readonly "LOCAL_MODIFICATIONS": $GenerationStep$Decoration
static readonly "TOP_LAYER_MODIFICATION": $GenerationStep$Decoration
static readonly "CODEC": $Codec<($GenerationStep$Decoration)>
static readonly "UNDERGROUND_DECORATION": $GenerationStep$Decoration
static readonly "LAKES": $GenerationStep$Decoration
static readonly "SURFACE_STRUCTURES": $GenerationStep$Decoration
static readonly "STRONGHOLDS": $GenerationStep$Decoration
static readonly "FLUID_SPRINGS": $GenerationStep$Decoration
static readonly "VEGETAL_DECORATION": $GenerationStep$Decoration
static readonly "UNDERGROUND_ORES": $GenerationStep$Decoration

public "getName"(): StringJS
public static "values"(): ($GenerationStep$Decoration)[]
public static "valueOf"(arg0: StringJS): $GenerationStep$Decoration
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "name"(): StringJS
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenerationStep$Decoration$$Type = (("raw_generation") | ("lakes") | ("local_modifications") | ("underground_structures") | ("surface_structures") | ("strongholds") | ("underground_ores") | ("underground_decoration") | ("fluid_springs") | ("vegetal_decoration") | ("top_layer_modification"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GenerationStep$Decoration$$Original = $GenerationStep$Decoration;}
declare module "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$ConfiguredFeature, $ConfiguredFeature$$Type} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FeatureConfiguration, $FeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $FeaturePlaceContext<FC extends $FeatureConfiguration> {
constructor(arg0: ($ConfiguredFeature$$Type<(never), (never)>)?, arg1: $WorldGenLevel$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BlockPos$$Type, arg5: FC)

public "chunkGenerator"(): $ChunkGenerator
public "topFeature"(): $Optional<($ConfiguredFeature<(never), (never)>)>
public "origin"(): $BlockPos
public "level"(): $WorldGenLevel
public "random"(): $RandomSource
public "config"(): FC
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeaturePlaceContext$$Type<FC> = ($FeaturePlaceContext<(FC)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeaturePlaceContext$$Original<FC> = $FeaturePlaceContext<(FC)>;}
declare module "net.minecraft.world.level.levelgen.feature.IcebergFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration, $BlockStateConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $IcebergFeature extends $Feature<($BlockStateConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($BlockStateConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($BlockStateConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IcebergFeature$$Type = ($IcebergFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IcebergFeature$$Original = $IcebergFeature;}
declare module "net.minecraft.world.level.pathfinder.PathTypeCache" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $PathTypeCache {
constructor()

public "invalidate"(arg0: $BlockPos$$Type): void
public "getOrCompute"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $PathType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathTypeCache$$Type = ($PathTypeCache);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathTypeCache$$Original = $PathTypeCache;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.UnobstructedPredicate" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type, $BlockPredicate$$Interface} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Record} from "java.lang.Record"

export class $UnobstructedPredicate extends $Record implements $BlockPredicate$$Interface {
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
public "type"(): $BlockPredicateType<(never)>
public "or"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "negate"(): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "and"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "test"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnobstructedPredicate$$Type = ({"offset"?: $Vec3i$$Type}) | ([offset?: $Vec3i$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UnobstructedPredicate$$Original = $UnobstructedPredicate;}
declare module "net.minecraft.world.level.block.BigDripleafStemBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $BigDripleafStemBlock extends $HorizontalDirectionalBlock implements $BonemealableBlock$$Interface, $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BigDripleafStemBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($BigDripleafStemBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BigDripleafStemBlock$$Type = ($BigDripleafStemBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BigDripleafStemBlock$$Original = $BigDripleafStemBlock;}
declare module "net.minecraft.world.level.gameevent.GameEvent$Context" {
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Record} from "java.lang.Record"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $GameEvent$Context extends $Record {
constructor(arg0: $Entity$$Type, arg1: $BlockState$$Type)

public "sourceEntity"(): $Entity
public "affectedState"(): $BlockState
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"(arg0: $Entity$$Type, arg1: $BlockState$$Type): $GameEvent$Context
public static "of"(arg0: $Entity$$Type): $GameEvent$Context
public static "of"(arg0: $BlockState$$Type): $GameEvent$Context
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEvent$Context$$Type = ({"affectedState"?: $BlockState$$Type, "sourceEntity"?: $Entity$$Type}) | ([affectedState?: $BlockState$$Type, sourceEntity?: $Entity$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEvent$Context$$Original = $GameEvent$Context;}
declare module "net.minecraft.world.level.block.RenderShape" {
import {$Enum} from "java.lang.Enum"

export class $RenderShape extends $Enum<($RenderShape)> {
static readonly "INVISIBLE": $RenderShape
static readonly "MODEL": $RenderShape
static readonly "ENTITYBLOCK_ANIMATED": $RenderShape

public static "values"(): ($RenderShape)[]
public static "valueOf"(arg0: StringJS): $RenderShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderShape$$Type = (("invisible") | ("entityblock_animated") | ("model"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RenderShape$$Original = $RenderShape;}
declare module "net.minecraft.world.level.block.SmallDripleafBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$DoubleBlockHalf} from "net.minecraft.world.level.block.state.properties.DoubleBlockHalf"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$DoublePlantBlock} from "net.minecraft.world.level.block.DoublePlantBlock"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $SmallDripleafBlock extends $DoublePlantBlock implements $BonemealableBlock$$Interface, $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SmallDripleafBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($DoubleBlockHalf)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "codec"(): $MapCodec<($SmallDripleafBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmallDripleafBlock$$Type = ($SmallDripleafBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmallDripleafBlock$$Original = $SmallDripleafBlock;}
declare module "net.minecraft.world.level.block.entity.StructureBlockEntity" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$StructureMode, $StructureMode$$Type} from "net.minecraft.world.level.block.state.properties.StructureMode"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StructureBlockEntity extends $BlockEntity {
static readonly "AUTHOR_TAG": StringJS
static readonly "MAX_OFFSET_PER_AXIS": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
static readonly "MAX_SIZE_PER_AXIS": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "usedBy"(arg0: $Player$$Type): boolean
public "createdBy"(arg0: $LivingEntity$$Type): void
public "unloadStructure"(): void
public "isPowered"(): boolean
public "setPowered"(arg0: boolean): void
public "placeStructure"(arg0: $ServerLevel$$Type): void
public "saveStructure"(): boolean
public "saveStructure"(arg0: boolean): boolean
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getStructureName"(): StringJS
public "setStructureName"(arg0: StringJS): void
public "setStructureName"(arg0: $ResourceLocation$$Type): void
public "hasStructureName"(): boolean
public "getStructurePos"(): $BlockPos
public "setStructurePos"(arg0: $BlockPos$$Type): void
public "getStructureSize"(): $Vec3i
public "setStructureSize"(arg0: $Vec3i$$Type): void
public "setMirror"(arg0: $Mirror$$Type): void
public "setRotation"(arg0: $Rotation$$Type): void
public "getMetaData"(): StringJS
public "setMetaData"(arg0: StringJS): void
public "isIgnoreEntities"(): boolean
public "setIgnoreEntities"(arg0: boolean): void
public "getIntegrity"(): float
public "setIntegrity"(arg0: float): void
public "detectSize"(): boolean
public static "createRandom"(arg0: long): $RandomSource
public "placeStructureIfSameSize"(arg0: $ServerLevel$$Type): boolean
public "loadStructureInfo"(arg0: $ServerLevel$$Type): boolean
public "isStructureLoadable"(): boolean
public "getShowAir"(): boolean
public "setShowAir"(arg0: boolean): void
public "getShowBoundingBox"(): boolean
public "setShowBoundingBox"(arg0: boolean): void
public "setMode"(arg0: $StructureMode$$Type): void
public "getMode"(): $StructureMode
public "setSeed"(arg0: long): void
public "getSeed"(): long
public "getMirror"(): $Mirror
public "getRotation"(): $Rotation
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "powered"(): boolean
set "powered"(value: boolean)
get "structureName"(): StringJS
set "structureName"(value: StringJS)
set "structureName"(value: $ResourceLocation$$Type)
get "structurePos"(): $BlockPos
set "structurePos"(value: $BlockPos$$Type)
get "structureSize"(): $Vec3i
set "structureSize"(value: $Vec3i$$Type)
set "mirror"(value: $Mirror$$Type)
set "rotation"(value: $Rotation$$Type)
get "metaData"(): StringJS
set "metaData"(value: StringJS)
get "ignoreEntities"(): boolean
set "ignoreEntities"(value: boolean)
get "integrity"(): float
set "integrity"(value: float)
get "structureLoadable"(): boolean
get "showAir"(): boolean
set "showAir"(value: boolean)
get "showBoundingBox"(): boolean
set "showBoundingBox"(value: boolean)
set "mode"(value: $StructureMode$$Type)
get "mode"(): $StructureMode
set "seed"(value: long)
get "seed"(): long
get "mirror"(): $Mirror
get "rotation"(): $Rotation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureBlockEntity$$Type = ($StructureBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureBlockEntity$$Original = $StructureBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $SpringConfiguration implements $FeatureConfiguration$$Interface {
readonly "holeCount": integer
static readonly "CODEC": $Codec<($SpringConfiguration)>
readonly "rockCount": integer
readonly "requiresBlockBelow": boolean
readonly "state": $FluidState
readonly "validBlocks": $HolderSet<($Block)>

constructor(arg0: $FluidState$$Type, arg1: boolean, arg2: integer, arg3: integer, arg4: $HolderSet$$Type<($Block)>)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpringConfiguration$$Type = ($SpringConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpringConfiguration$$Original = $SpringConfiguration;}
declare module "net.minecraft.world.level.block.ChestBlock" {
import {$ChestBlockEntity, $ChestBlockEntity$$Type} from "net.minecraft.world.level.block.entity.ChestBlockEntity"
import {$ChestType} from "net.minecraft.world.level.block.state.properties.ChestType"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$AbstractChestBlock} from "net.minecraft.world.level.block.AbstractChestBlock"
import {$DoubleBlockCombiner$NeighborCombineResult} from "net.minecraft.world.level.block.DoubleBlockCombiner$NeighborCombineResult"
import {$DoubleBlockCombiner$BlockType} from "net.minecraft.world.level.block.DoubleBlockCombiner$BlockType"
import {$DoubleBlockCombiner$Combiner} from "net.minecraft.world.level.block.DoubleBlockCombiner$Combiner"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Float2FloatFunction} from "it.unimi.dsi.fastutil.floats.Float2FloatFunction"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Container} from "net.minecraft.world.Container"
import {$LidBlockEntity$$Type} from "net.minecraft.world.level.block.entity.LidBlockEntity"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $ChestBlock extends $AbstractChestBlock<($ChestBlockEntity)> implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ChestBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "EVENT_SET_OPEN_COUNT": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "TYPE": $EnumProperty<($ChestType)>

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $Supplier$$Type<($BlockEntityType$$Type<($ChestBlockEntity$$Type)>)>)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "blockEntityType"(): $BlockEntityType<($ChestBlockEntity)>
public static "isChestBlockedAt"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): boolean
public static "opennessCombiner"(arg0: $LidBlockEntity$$Type): $DoubleBlockCombiner$Combiner<($ChestBlockEntity), ($Float2FloatFunction)>
public static "getConnectedDirection"(arg0: $BlockState$$Type): $Direction
public static "getBlockType"(arg0: $BlockState$$Type): $DoubleBlockCombiner$BlockType
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "getContainer"(arg0: $ChestBlock$$Type, arg1: $BlockState$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: boolean): $Container
public "combine"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: boolean): $DoubleBlockCombiner$NeighborCombineResult<($ChestBlockEntity)>
public "codec"(): $MapCodec<($ChestBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestBlock$$Type = ($ChestBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestBlock$$Original = $ChestBlock;}
declare module "net.minecraft.world.level.block.state.StateHolder" {
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Optional} from "java.util.Optional"
import {$FastMapStateHolder$$Interface} from "malte0811.ferritecore.ducks.FastMapStateHolder"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$StateHolderAccessor$$Interface as $StateHolderAccessor$0$$Interface} from "io.wispforest.accessories.mixin.StateHolderAccessor"
import {$Reference2ObjectMap, $Reference2ObjectMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectMap"
import {$Map$Entry} from "java.util.Map$Entry"
import {$FastMap, $FastMap$$Type} from "malte0811.ferritecore.fastmap.FastMap"
import {$Table, $Table$$Type} from "com.google.common.collect.Table"
import {$StateHolderAccessor$$Interface} from "com.simibubi.create.foundation.mixin.accessor.StateHolderAccessor"
import {$Function} from "java.util.function.Function"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $StateHolder<O, S> implements $StateHolderAccessor$0$$Interface, $FastMapStateHolder$$Interface, $StateHolderAccessor$$Interface {
static readonly "PROPERTIES_TAG": StringJS
static readonly "PROPERTY_ENTRY_TO_STRING_FUNCTION": $Function<($Map$Entry<($Property<(never)>), ($Comparable<(never)>)>), (StringJS)>
static readonly "NAME_TAG": StringJS

public "getOptionalValue"<T extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>): $Optional<(T)>
public "redirect$fam000$ferritecore$getNeighborFromFastMap"(arg0: $Table$$Type, arg1: any, arg2: any): any
public "trySetValue"<T extends $Comparable<(object)>, V extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>, arg1: V): S
public "populateNeighbours"(arg0: $Map$$Type): void
public "getStateMap"(): $FastMap
public "getStateIndex"(): integer
public "getVanillaPropertyMap"(): $Reference2ObjectMap
public "setStateMap"(arg0: $FastMap$$Type): void
public "setStateIndex"(arg0: integer): void
public "setNeighborTable"(arg0: $Table$$Type): void
public "getNeighborTable"(): $Table
public "accessories$owner"(): any
public "accessories$propertiesCodec"(): $MapCodec
public "getValues"(): $Map<($Property<(never)>), ($Comparable<(never)>)>
public "toString"(): StringJS
public "getValue"<T extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>): T
public "getProperties"(): $Collection<($Property<(never)>)>
public "setValue"<T extends $Comparable<(object)>, V extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>, arg1: V): S
public "getOwner"(): any
public "hasProperty"<T extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>): boolean
public "cycle"<T extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>): S
public "replacePropertyMap"(arg0: $Reference2ObjectMap$$Type): void
get "stateMap"(): $FastMap
get "stateIndex"(): integer
get "vanillaPropertyMap"(): $Reference2ObjectMap
set "stateMap"(value: $FastMap$$Type)
set "stateIndex"(value: integer)
set "neighborTable"(value: $Table$$Type)
get "neighborTable"(): $Table
get "values"(): $Map<($Property<(never)>), ($Comparable<(never)>)>
get "properties"(): $Collection<($Property<(never)>)>
get "owner"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StateHolder$$Type<O, S> = ($StateHolder<(O), (S)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StateHolder$$Original<O, S> = $StateHolder<(O), (S)>;}
declare module "net.minecraft.world.level.block.TripWireHookBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TripWireHookBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TripWireHookBlock)>
static readonly "ATTACHED": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public static "calculateState"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: boolean, arg4: boolean, arg5: integer, arg6: $BlockState$$Type): void
public "codec"(): $MapCodec<($TripWireHookBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TripWireHookBlock$$Type = ($TripWireHookBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TripWireHookBlock$$Original = $TripWireHookBlock;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.MegaJungleFoliagePlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $MegaJungleFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($MegaJungleFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: integer)

public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MegaJungleFoliagePlacer$$Type = ($MegaJungleFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MegaJungleFoliagePlacer$$Original = $MegaJungleFoliagePlacer;}
declare module "net.minecraft.world.level.block.entity.AbstractFurnaceBlockEntity" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$BaseContainerBlockEntity} from "net.minecraft.world.level.block.entity.BaseContainerBlockEntity"
import {$ContainerData} from "net.minecraft.world.inventory.ContainerData"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$AbstractFurnaceBlockEntityAccess$$Interface} from "snownee.jade.mixin.AbstractFurnaceBlockEntityAccess"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$RecipeManager$CachedCheck} from "net.minecraft.world.item.crafting.RecipeManager$CachedCheck"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$Either$$Type} from "com.mojang.datafixers.util.Either"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$AbstractFurnaceBlockEntityAccess$$Interface as $AbstractFurnaceBlockEntityAccess$0$$Interface} from "me.desht.pneumaticcraft.mixin.accessors.AbstractFurnaceBlockEntityAccess"
import {$ObjIntConsumer$$Type} from "java.util.function.ObjIntConsumer"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Map} from "java.util.Map"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$StackedContentsCompatible$$Interface} from "net.minecraft.world.inventory.StackedContentsCompatible"
import {$WorldlyContainer$$Interface} from "net.minecraft.world.WorldlyContainer"
import {$SetChangedHandlingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SetChangedHandlingBlockEntity"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$RecipeCraftingHolder$$Interface} from "net.minecraft.world.inventory.RecipeCraftingHolder"
import {$FurnaceTEAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.FurnaceTEAccess"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$StackedContents$$Type} from "net.minecraft.world.entity.player.StackedContents"

export class $AbstractFurnaceBlockEntity extends $BaseContainerBlockEntity implements $WorldlyContainer$$Interface, $RecipeCraftingHolder$$Interface, $StackedContentsCompatible$$Interface, $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface, $SleepingBlockEntity$$Interface, $SetChangedHandlingBlockEntity$$Interface, $AbstractFurnaceBlockEntityAccess$0$$Interface, $FurnaceTEAccess$$Interface, $AbstractFurnaceBlockEntityAccess$$Interface {
static readonly "DATA_LIT_DURATION": integer
static readonly "DATA_COOKING_TOTAL_TIME": integer
static readonly "DATA_COOKING_PROGRESS": integer
static readonly "BURN_TIME_STANDARD": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode
static readonly "NUM_DATA_VALUES": integer
 "litTime": integer
static readonly "DATA_LIT_TIME": integer
static readonly "BURN_COOL_SPEED": integer

public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $AbstractFurnaceBlockEntity$$Type): void
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public static "invalidateCache"(): void
public "getRecipesToAwardAndPopExperience"(arg0: $ServerLevel$$Type, arg1: $Vec3$$Type): $List<($RecipeHolder<(never)>)>
public "lithium$handleSetChanged"(): void
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
/**
 * 
 * @deprecated
 */
public static "getFuel"(): $Map<($Item), (integer)>
public static "buildFuels"(arg0: $ObjIntConsumer$$Type<($Either<($Item), ($TagKey<($Item)>)>)>): void
public "setRecipeUsed"(arg0: $RecipeHolder$$Type<(never)>): void
public "fillStackedContents"(arg0: $StackedContents$$Type): void
public static "isFuel"(arg0: $ItemStack$$Type): boolean
public "getSlotsForFace"(arg0: $Direction$$Type): (integer)[]
public "canPlaceItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "canTakeItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "getRecipeUsed"(): $RecipeHolder<(never)>
public "awardUsedRecipes"(arg0: $Player$$Type, arg1: $List$$Type<($ItemStack$$Type)>): void
public "awardUsedRecipesAndPopExperience"(arg0: $ServerPlayer$$Type): void
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "getLitTime"(): integer
public "setLitTime"(arg0: integer): void
public "setLitDuration"(arg0: integer): void
public "getCookingProgress"(): integer
public "getQuickCheck"(): $RecipeManager$CachedCheck
public "getDataAccess"(): $ContainerData
public "getCookingTotalTime"(): integer
public "getContainerSize"(): integer
public "setRecipeUsed"(arg0: $Level$$Type, arg1: $ServerPlayer$$Type, arg2: $RecipeHolder$$Type<(never)>): boolean
public "generateLootLithium"(): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$startSleeping"(): boolean
public "wakeUpNow"(): void
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "sleepOnlyCurrentTick"(): void
public "isSleeping"(): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public static "tryClear"(arg0: any): void
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
public static get "fuel"(): $Map<($Item), (integer)>
set "recipeUsed"(value: $RecipeHolder$$Type<(never)>)
get "recipeUsed"(): $RecipeHolder<(never)>
set "litDuration"(value: integer)
get "cookingProgress"(): integer
get "quickCheck"(): $RecipeManager$CachedCheck
get "dataAccess"(): $ContainerData
get "cookingTotalTime"(): integer
get "containerSize"(): integer
set "ticker"(value: $TickingBlockEntity$$Type)
get "sleeping"(): boolean
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractFurnaceBlockEntity$$Type = ($AbstractFurnaceBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractFurnaceBlockEntity$$Original = $AbstractFurnaceBlockEntity;}
declare module "net.minecraft.world.level.block.entity.ChiseledBookShelfBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container, $Container$$Type, $Container$$Interface} from "net.minecraft.world.Container"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$LithiumTransferConditionInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumTransferConditionInventory"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ChiseledBookShelfBlockEntity extends $BlockEntity implements $Container$$Interface, $LithiumTransferConditionInventory$$Interface {
static readonly "MAX_BOOKS_IN_STORAGE": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "clearContent"(): void
public "getLastInteractedSlot"(): integer
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "lithium$itemInsertionTestRequiresStackSize1"(): boolean
public "getItem"(arg0: integer): $ItemStack
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "isEmpty"(): boolean
public "count"(): integer
public "getMaxStackSize"(): integer
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
public "stillValid"(arg0: $Player$$Type): boolean
public "getContainerSize"(): integer
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "startOpen"(arg0: $Player$$Type): void
public "stopOpen"(arg0: $Player$$Type): void
public "countItem"(arg0: $Item$$Type): integer
public "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
public "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "getMaxStackSize"(arg0: $ItemStack$$Type): integer
public "setChanged"(): void
public static "tryClear"(arg0: any): void
public "self"(): $Container
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "getSlotLimit"(slot: integer): integer
public "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
public "clear"(): void
public "getWidth"(): integer
public "getHeight"(): integer
public "getBlock"(level: $Level$$Type): $LevelBlock
public "setChanged"(): void
public "asContainer"(): $Container
public "setTransferCooldown"(arg0: long): void
public "canReceiveTransferCooldown"(): boolean
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "clear"(match: $ItemPredicate$$Type): void
public "find"(match: $ItemPredicate$$Type): integer
public "find"(): integer
public "count"(match: $ItemPredicate$$Type): integer
public "count"(): integer
public "countNonEmpty"(): integer
public "countNonEmpty"(match: $ItemPredicate$$Type): integer
public "getAllItems"(): $List<($ItemStack)>
get "lastInteractedSlot"(): integer
get "empty"(): boolean
get "maxStackSize"(): integer
get "containerSize"(): integer
get "changed"(): void
get "mutable"(): boolean
get "slots"(): integer
get "width"(): integer
get "height"(): integer
get "changed"(): void
set "transferCooldown"(value: long)
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChiseledBookShelfBlockEntity$$Type = ($ChiseledBookShelfBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChiseledBookShelfBlockEntity$$Original = $ChiseledBookShelfBlockEntity;}
declare module "net.minecraft.world.level.block.WaterlilyBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $WaterlilyBlock extends $BushBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WaterlilyBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($WaterlilyBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterlilyBlock$$Type = ($WaterlilyBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WaterlilyBlock$$Original = $WaterlilyBlock;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour" {
import {$MapColor} from "net.minecraft.world.level.material.MapColor"
import {$FeatureFlagSet, $FeatureFlagSet$$Type} from "net.minecraft.world.flag.FeatureFlagSet"
import {$List} from "java.util.List"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Holder} from "net.minecraft.core.Holder"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockBehaviourKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockBehaviourKJS"
import {$Function$$Type} from "java.util.function.Function"
import {$FeatureElement$$Interface} from "net.minecraft.world.flag.FeatureElement"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Map} from "java.util.Map"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviourInvoker$$Interface} from "org.embeddedt.modernfix.common.mixin.perf.reduce_blockstate_cache_rebuilds.BlockBehaviourInvoker"
import {$BlockBehaviourAccessor$$Interface} from "com.simibubi.create.foundation.mixin.accessor.BlockBehaviourAccessor"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RecordCodecBuilder} from "com.mojang.serialization.codecs.RecordCodecBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ShapeUpdateHandlingBlockBehaviour$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.ShapeUpdateHandlingBlockBehaviour"

export class $BlockBehaviour implements $FeatureElement$$Interface, $BlockBehaviourInvoker$$Interface, $BlockBehaviourKJS$$Interface, $ShapeUpdateHandlingBlockBehaviour$$Interface, $BlockBehaviourAccessor$$Interface {
constructor(arg0: $BlockBehaviour$Properties$$Type)

public "asItem"(): $Item
public static "simpleCodec"<B extends $Block>(arg0: $Function$$Type<($BlockBehaviour$Properties), (B)>): $MapCodec<(B)>
public "setHasCollision"(arg0: boolean): void
public "setExplosionResistance"(arg0: float): void
public "setIsRandomlyTicking"(arg0: boolean): void
public "setRandomTickCallback"(callback: $Consumer$$Type): void
public "setSoundType"(arg0: $SoundType$$Type): void
public "setFriction"(arg0: float): void
public "setSpeedFactor"(arg0: float): void
public "setJumpFactor"(arg0: float): void
public static "propertiesCodec"<B extends $Block>(): $RecordCodecBuilder<(B), ($BlockBehaviour$Properties)>
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "defaultMapColor"(): $MapColor
public "defaultDestroyTime"(): float
public "invokeGetFluidState"(arg0: $BlockState$$Type): $FluidState
public "invokeIsRandomlyTicking"(arg0: $BlockState$$Type): boolean
public "create$getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "properties"(): $BlockBehaviour$Properties
public "requiredFeatures"(): $FeatureFlagSet
public "getLootTable"(): $ResourceKey<($LootTable)>
public "isEnabled"(arg0: $FeatureFlagSet$$Type): boolean
public "lithium$handleShapeUpdate"(arg0: $LevelReader$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: $BlockState$$Type): void
public "getTypeData"(): $Map<(StringJS), (any)>
public "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
public "getRegistry"(): $Registry<($Block)>
public "asHolder"(): $Holder<($Block)>
public "getKey"(): $ResourceKey<($Block)>
public "getId"(): StringJS
public "getBlock"(): $Block
public "getIdLocation"(): $ResourceLocation
public "getMod"(): StringJS
public "getTagKeys"(): $List<($TagKey<($Block)>)>
public "getTags"(): $List<($ResourceLocation)>
public "hasTag"(tag: $ResourceLocation$$Type): boolean
public "specialEquals"(o: any, shallow: boolean): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
set "hasCollision"(value: boolean)
set "explosionResistance"(value: float)
set "isRandomlyTicking"(value: boolean)
set "randomTickCallback"(value: $Consumer$$Type)
set "soundType"(value: $SoundType$$Type)
set "friction"(value: float)
set "speedFactor"(value: float)
set "jumpFactor"(value: float)
get "lootTable"(): $ResourceKey<($LootTable)>
get "typeData"(): $Map<(StringJS), (any)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "key"(): $ResourceKey<($Block)>
get "id"(): StringJS
get "block"(): $Block
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$$Type = ($BlockBehaviour);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$$Original = $BlockBehaviour;}
declare module "net.minecraft.world.level.block.BarrierBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BarrierBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BarrierBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($BarrierBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BarrierBlock$$Type = ($BarrierBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BarrierBlock$$Original = $BarrierBlock;}
declare module "net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator" {
import {$NoiseGeneratorSettings, $NoiseGeneratorSettings$$Type} from "net.minecraft.world.level.levelgen.NoiseGeneratorSettings"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$List, $List$$Type} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Blender$$Type} from "net.minecraft.world.level.levelgen.blending.Blender"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$Supplier} from "java.util.function.Supplier"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BiomeManager$$Type} from "net.minecraft.world.level.biome.BiomeManager"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$FeatureSorter$StepFeatureData} from "net.minecraft.world.level.biome.FeatureSorter$StepFeatureData"
import {$NoiseColumn} from "net.minecraft.world.level.NoiseColumn"
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$ChunkGenerator} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$WorldGenRegion$$Type} from "net.minecraft.server.level.WorldGenRegion"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $NoiseBasedChunkGenerator extends $ChunkGenerator {
 "featuresPerStep": $Supplier<($List<($FeatureSorter$StepFeatureData)>)>
static readonly "CODEC": $MapCodec<($NoiseBasedChunkGenerator)>

constructor(arg0: $BiomeSource$$Type, arg1: $Holder$$Type<($NoiseGeneratorSettings)>)

public "getGenDepth"(): integer
public "createBiomes"(arg0: $RandomState$$Type, arg1: $Blender$$Type, arg2: $StructureManager$$Type, arg3: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
public "getBaseColumn"(arg0: integer, arg1: integer, arg2: $LevelHeightAccessor$$Type, arg3: $RandomState$$Type): $NoiseColumn
public "getBaseHeight"(arg0: integer, arg1: integer, arg2: $Heightmap$Types$$Type, arg3: $LevelHeightAccessor$$Type, arg4: $RandomState$$Type): integer
public "generatorSettings"(): $Holder<($NoiseGeneratorSettings)>
public "addDebugScreenInfo"(arg0: $List$$Type<(StringJS)>, arg1: $RandomState$$Type, arg2: $BlockPos$$Type): void
public "buildSurface"(arg0: $WorldGenRegion$$Type, arg1: $StructureManager$$Type, arg2: $RandomState$$Type, arg3: $ChunkAccess$$Type): void
public "buildSurface"(arg0: $ChunkAccess$$Type, arg1: $WorldGenerationContext$$Type, arg2: $RandomState$$Type, arg3: $StructureManager$$Type, arg4: $BiomeManager$$Type, arg5: $Registry$$Type<($Biome$$Type)>, arg6: $Blender$$Type): void
public "applyCarvers"(arg0: $WorldGenRegion$$Type, arg1: long, arg2: $RandomState$$Type, arg3: $BiomeManager$$Type, arg4: $StructureManager$$Type, arg5: $ChunkAccess$$Type, arg6: $GenerationStep$Carving$$Type): void
public "fillFromNoise"(arg0: $Blender$$Type, arg1: $RandomState$$Type, arg2: $StructureManager$$Type, arg3: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
public "spawnOriginalMobs"(arg0: $WorldGenRegion$$Type): void
public "getMinY"(): integer
public "stable"(arg0: $ResourceKey$$Type<($NoiseGeneratorSettings)>): boolean
public "getSeaLevel"(): integer
get "genDepth"(): integer
get "minY"(): integer
get "seaLevel"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseBasedChunkGenerator$$Type = ($NoiseBasedChunkGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseBasedChunkGenerator$$Original = $NoiseBasedChunkGenerator;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$RangeChoice" {
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$Record} from "java.lang.Record"
import {$DensityFunction, $DensityFunction$$Type, $DensityFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction"

export class $DensityFunctions$RangeChoice extends $Record implements $DensityFunction$$Interface {
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
public "cube"(): $DensityFunction
public "halfNegative"(): $DensityFunction
public "quarterNegative"(): $DensityFunction
public "squeeze"(): $DensityFunction
public "maxValue"(): double
public "abs"(): $DensityFunction
public "clamp"(arg0: double, arg1: double): $DensityFunction
public "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
public "square"(): $DensityFunction
public "minValue"(): double
public "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
public "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$RangeChoice$$Type = ({"input"?: $DensityFunction$$Type, "whenOutOfRange"?: $DensityFunction$$Type, "whenInRange"?: $DensityFunction$$Type, "minInclusive"?: double, "maxExclusive"?: double}) | ([input?: $DensityFunction$$Type, whenOutOfRange?: $DensityFunction$$Type, whenInRange?: $DensityFunction$$Type, minInclusive?: double, maxExclusive?: double]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$RangeChoice$$Original = $DensityFunctions$RangeChoice;}
declare module "net.minecraft.world.level.GameRules$Category" {
import {$Enum} from "java.lang.Enum"

export class $GameRules$Category extends $Enum<($GameRules$Category)> {
static readonly "PLAYER": $GameRules$Category
static readonly "DROPS": $GameRules$Category
static readonly "MOBS": $GameRules$Category
static readonly "CHAT": $GameRules$Category
static readonly "UPDATES": $GameRules$Category
static readonly "MISC": $GameRules$Category
static readonly "SPAWNING": $GameRules$Category

public static "values"(): ($GameRules$Category)[]
public static "valueOf"(arg0: StringJS): $GameRules$Category
public "getDescriptionId"(): StringJS
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$Category$$Type = (("player") | ("mobs") | ("spawning") | ("drops") | ("updates") | ("chat") | ("misc"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$Category$$Original = $GameRules$Category;}
declare module "net.minecraft.world.level.levelgen.placement.NoiseThresholdCountPlacement" {
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$RepeatingPlacement} from "net.minecraft.world.level.levelgen.placement.RepeatingPlacement"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $NoiseThresholdCountPlacement extends $RepeatingPlacement {
static readonly "CODEC": $MapCodec<($NoiseThresholdCountPlacement)>

public "type"(): $PlacementModifierType<(never)>
public static "of"(arg0: double, arg1: integer, arg2: integer): $NoiseThresholdCountPlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseThresholdCountPlacement$$Type = ($NoiseThresholdCountPlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseThresholdCountPlacement$$Original = $NoiseThresholdCountPlacement;}
declare module "net.minecraft.world.level.block.FireBlock" {
import {$LocalBooleanRef$$Type} from "com.llamalad7.mixinextras.sugar.ref.LocalBooleanRef"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$FireBlockAccessor$$Interface} from "net.mehvahdjukaar.supplementaries.mixins.neoforge.FireBlockAccessor"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FireBlockAccessor$$Interface as $FireBlockAccessor$0$$Interface} from "com.starfish_studios.another_furniture.mixin.neoforge.FireBlockAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockPos$MutableBlockPos$$Type} from "net.minecraft.core.BlockPos$MutableBlockPos"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Operation$$Type} from "com.llamalad7.mixinextras.injector.wrapoperation.Operation"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BaseFireBlock} from "net.minecraft.world.level.block.BaseFireBlock"

export class $FireBlock extends $BaseFireBlock implements $FireBlockAccessor$$Interface, $FireBlockAccessor$0$$Interface {
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "SOUTH": $BooleanProperty
static readonly "UP": $BooleanProperty
static readonly "EAST": $BooleanProperty
static readonly "AGE": $IntegerProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FireBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "getBurnOdds"(arg0: $BlockState$$Type): integer
public "getIgniteOdds"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): integer
/**
 * 
 * @deprecated
 */
public "getIgniteOdds"(arg0: $BlockState$$Type): integer
public "wrapOperation$bbc000$supplementaries$supp$doIgniteLumisene"(level: $ServerLevel$$Type, pos: $BlockPos$$Type, fireState: $BlockState$$Type, i: integer, original: $Operation$$Type, isLiquid: $LocalBooleanRef$$Type): boolean
public "getStateWithAge"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: integer): $BlockState
public "canCatchFire"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "isNearRain"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public "modifyExpressionValue$bbc000$supplementaries$supp$igniteLumisene"(odds: integer, level: $ServerLevel$$Type, pos: $BlockPos$MutableBlockPos$$Type, isLiquid: $LocalBooleanRef$$Type): integer
public "setFlammable"(arg0: $Block$$Type, arg1: integer, arg2: integer): void
public "invokeTryCatchFire"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: integer, arg3: $RandomSource$$Type, arg4: integer, arg5: $Direction$$Type): void
public "invokeSetFlammable"(arg0: $Block$$Type, arg1: integer, arg2: integer): void
public static "bootStrap"(): void
public "codec"(): $MapCodec<($FireBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireBlock$$Type = ($FireBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FireBlock$$Original = $FireBlock;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTestType" {
import {$RandomBlockMatchTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RandomBlockMatchTest"
import {$AlwaysTrueTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.AlwaysTrueTest"
import {$BlockStateMatchTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.BlockStateMatchTest"
import {$BlockMatchTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.BlockMatchTest"
import {$RandomBlockStateMatchTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RandomBlockStateMatchTest"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$TagMatchTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.TagMatchTest"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export interface $RuleTestType$$Interface<P extends $RuleTest> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.RuleTest
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.RuleTestTag
}

export class $RuleTestType<P extends $RuleTest> implements $RuleTestType$$Interface {
static readonly "ALWAYS_TRUE_TEST": $RuleTestType<($AlwaysTrueTest)>
static readonly "TAG_TEST": $RuleTestType<($TagMatchTest)>
static readonly "BLOCKSTATE_TEST": $RuleTestType<($BlockStateMatchTest)>
static readonly "RANDOM_BLOCK_TEST": $RuleTestType<($RandomBlockMatchTest)>
static readonly "BLOCK_TEST": $RuleTestType<($BlockMatchTest)>
static readonly "RANDOM_BLOCKSTATE_TEST": $RuleTestType<($RandomBlockStateMatchTest)>

static "register"<P extends $RuleTest>(arg0: StringJS, arg1: $MapCodec$$Type<(P)>): $RuleTestType<(P)>
 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleTestType$$Type<P> = (Special.RuleTest) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleTestType$$Original<P> = $RuleTestType<(P)>;}
declare module "net.minecraft.world.level.block.AzaleaBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AzaleaBlock extends $BushBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($AzaleaBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "codec"(): $MapCodec<($AzaleaBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AzaleaBlock$$Type = ($AzaleaBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AzaleaBlock$$Original = $AzaleaBlock;}
declare module "net.minecraft.world.level.levelgen.feature.HugeFungusFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration, $HugeFungusConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $HugeFungusFeature extends $Feature<($HugeFungusConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($HugeFungusConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($HugeFungusConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HugeFungusFeature$$Type = ($HugeFungusFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HugeFungusFeature$$Original = $HugeFungusFeature;}
declare module "net.minecraft.world.level.block.TurtleEggBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TurtleEggBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TurtleEggBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "MAX_HATCH_LEVEL": integer
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "MIN_EGGS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "EGGS": $IntegerProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "HATCH": $IntegerProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "MAX_EGGS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "playerDestroy"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockEntity$$Type, arg5: $ItemStack$$Type): void
public static "onSand"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public static "isSand"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "codec"(): $MapCodec<($TurtleEggBlock)>
public "stepOn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type): void
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TurtleEggBlock$$Type = ($TurtleEggBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TurtleEggBlock$$Original = $TurtleEggBlock;}
declare module "net.minecraft.world.level.chunk.ChunkGenerator" {
import {$ChunkGeneratorStructureState, $ChunkGeneratorStructureState$$Type} from "net.minecraft.world.level.chunk.ChunkGeneratorStructureState"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$StructureSet$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSet"
import {$Optional} from "java.util.Optional"
import {$List, $List$$Type} from "java.util.List"
import {$WeightedRandomList} from "net.minecraft.util.random.WeightedRandomList"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Blender$$Type} from "net.minecraft.world.level.levelgen.blending.Blender"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BiomeSource, $BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$ConcentricRingsStructurePlacement$$Type} from "net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStructurePlacement"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier} from "java.util.function.Supplier"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$BiomeGenerationSettings, $BiomeGenerationSettings$$Type} from "net.minecraft.world.level.biome.BiomeGenerationSettings"
import {$Set$$Type} from "java.util.Set"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$HolderLookup$$Type} from "net.minecraft.core.HolderLookup"
import {$BiomeManager$$Type} from "net.minecraft.world.level.biome.BiomeManager"
import {$Pair} from "com.mojang.datafixers.util.Pair"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$FeatureSorter$StepFeatureData} from "net.minecraft.world.level.biome.FeatureSorter$StepFeatureData"
import {$MobSpawnSettings$SpawnerData} from "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData"
import {$NoiseColumn} from "net.minecraft.world.level.NoiseColumn"
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$WorldGenRegion$$Type} from "net.minecraft.server.level.WorldGenRegion"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $ChunkGenerator {
 "featuresPerStep": $Supplier<($List<($FeatureSorter$StepFeatureData)>)>
static readonly "CODEC": $Codec<($ChunkGenerator)>

constructor(arg0: $BiomeSource$$Type, arg1: $Function$$Type<($Holder<($Biome)>), ($BiomeGenerationSettings$$Type)>)
constructor(arg0: $BiomeSource$$Type)

public "createState"(arg0: $HolderLookup$$Type<($StructureSet$$Type)>, arg1: $RandomState$$Type, arg2: long): $ChunkGeneratorStructureState
public "getBiomeSource"(): $BiomeSource
public "findNearestMapStructure"(arg0: $ServerLevel$$Type, arg1: $HolderSet$$Type<($Structure)>, arg2: $BlockPos$$Type, arg3: integer, arg4: boolean): $Pair<($BlockPos), ($Holder<($Structure)>)>
public "getGenDepth"(): integer
public "getFirstOccupiedHeight"(arg0: integer, arg1: integer, arg2: $Heightmap$Types$$Type, arg3: $LevelHeightAccessor$$Type, arg4: $RandomState$$Type): integer
public "createBiomes"(arg0: $RandomState$$Type, arg1: $Blender$$Type, arg2: $StructureManager$$Type, arg3: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
public "getBaseColumn"(arg0: integer, arg1: integer, arg2: $LevelHeightAccessor$$Type, arg3: $RandomState$$Type): $NoiseColumn
public "getBaseHeight"(arg0: integer, arg1: integer, arg2: $Heightmap$Types$$Type, arg3: $LevelHeightAccessor$$Type, arg4: $RandomState$$Type): integer
/**
 * 
 * @deprecated
 */
public "getBiomeGenerationSettings"(arg0: $Holder$$Type<($Biome)>): $BiomeGenerationSettings
public "addDebugScreenInfo"(arg0: $List$$Type<(StringJS)>, arg1: $RandomState$$Type, arg2: $BlockPos$$Type): void
public "buildSurface"(arg0: $WorldGenRegion$$Type, arg1: $StructureManager$$Type, arg2: $RandomState$$Type, arg3: $ChunkAccess$$Type): void
public "applyCarvers"(arg0: $WorldGenRegion$$Type, arg1: long, arg2: $RandomState$$Type, arg3: $BiomeManager$$Type, arg4: $StructureManager$$Type, arg5: $ChunkAccess$$Type, arg6: $GenerationStep$Carving$$Type): void
public "fillFromNoise"(arg0: $Blender$$Type, arg1: $RandomState$$Type, arg2: $StructureManager$$Type, arg3: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
public "spawnOriginalMobs"(arg0: $WorldGenRegion$$Type): void
public "refreshFeaturesPerStep"(): void
public "getTypeNameForDataFixer"(): $Optional<($ResourceKey<($MapCodec<($ChunkGenerator)>)>)>
public "getNearestGeneratedStructure"(arg0: $Set$$Type<($Holder$$Type<($Structure$$Type)>)>, arg1: $ServerLevel$$Type, arg2: $StructureManager$$Type, arg3: $BlockPos$$Type, arg4: boolean, arg5: $ConcentricRingsStructurePlacement$$Type): $Pair<($BlockPos), ($Holder<($Structure)>)>
public "applyBiomeDecoration"(arg0: $WorldGenLevel$$Type, arg1: $ChunkAccess$$Type, arg2: $StructureManager$$Type): void
public "getSpawnHeight"(arg0: $LevelHeightAccessor$$Type): integer
public "getMobsAt"(arg0: $Holder$$Type<($Biome)>, arg1: $StructureManager$$Type, arg2: $MobCategory$$Type, arg3: $BlockPos$$Type): $WeightedRandomList<($MobSpawnSettings$SpawnerData)>
public "createStructures"(arg0: $RegistryAccess$$Type, arg1: $ChunkGeneratorStructureState$$Type, arg2: $StructureManager$$Type, arg3: $ChunkAccess$$Type, arg4: $StructureTemplateManager$$Type): void
public "createReferences"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkAccess$$Type): void
public "getFirstFreeHeight"(arg0: integer, arg1: integer, arg2: $Heightmap$Types$$Type, arg3: $LevelHeightAccessor$$Type, arg4: $RandomState$$Type): integer
public "getMinY"(): integer
public "validate"(): void
public "getSeaLevel"(): integer
get "biomeSource"(): $BiomeSource
get "genDepth"(): integer
get "typeNameForDataFixer"(): $Optional<($ResourceKey<($MapCodec<($ChunkGenerator)>)>)>
get "minY"(): integer
get "seaLevel"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkGenerator$$Type = ($ChunkGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkGenerator$$Original = $ChunkGenerator;}
declare module "net.minecraft.world.level.storage.loot.providers.number.NumberProvider" {
import {$LootContextParam} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$LootNumberProviderType} from "net.minecraft.world.level.storage.loot.providers.number.LootNumberProviderType"
import {$LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$Set} from "java.util.Set"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootContextUser$$Interface} from "net.minecraft.world.level.storage.loot.LootContextUser"

export interface $NumberProvider$$Interface extends $LootContextUser$$Interface {
get "type"(): $LootNumberProviderType
get "referencedContextParams"(): $Set<($LootContextParam<(never)>)>
}

export class $NumberProvider implements $NumberProvider$$Interface {
 "getInt"(arg0: $LootContext$$Type): integer
 "getFloat"(arg0: $LootContext$$Type): float
 "getType"(): $LootNumberProviderType
 "getReferencedContextParams"(): $Set<($LootContextParam<(never)>)>
 "validate"(arg0: $ValidationContext$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumberProvider$$Type = (double) | ([min: double, max: double]) | ({"min": double, "max": double}) | ({"n": double, "p": double}) | ({"value": double});
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NumberProvider$$Original = $NumberProvider;}
declare module "net.minecraft.world.level.LevelSimulatedRW" {
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Optional} from "java.util.Optional"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelWriter$$Interface} from "net.minecraft.world.level.LevelWriter"
import {$LevelSimulatedReader$$Interface} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $LevelSimulatedRW$$Interface extends $LevelSimulatedReader$$Interface, $LevelWriter$$Interface {
}

export class $LevelSimulatedRW implements $LevelSimulatedRW$$Interface {
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelSimulatedRW$$Type = ($LevelSimulatedRW);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelSimulatedRW$$Original = $LevelSimulatedRW;}
declare module "net.minecraft.world.level.block.entity.BannerBlockEntity" {
import {$Nameable$$Interface} from "net.minecraft.world.Nameable"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$BannerPatternLayers} from "net.minecraft.world.level.block.entity.BannerPatternLayers"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$Component} from "net.minecraft.network.chat.Component"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BannerBlockEntity extends $BlockEntity implements $Nameable$$Interface {
static readonly "MAX_PATTERNS": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $DyeColor$$Type)

public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "fromItem"(arg0: $ItemStack$$Type, arg1: $DyeColor$$Type): void
public "getPatterns"(): $BannerPatternLayers
public "getBaseColor"(): $DyeColor
public "getItem"(): $ItemStack
public "getName"(): $Component
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "getCustomName"(): $Component
public "getDisplayName"(): $Component
public "hasCustomName"(): boolean
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "patterns"(): $BannerPatternLayers
get "baseColor"(): $DyeColor
get "item"(): $ItemStack
get "name"(): $Component
get "customName"(): $Component
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BannerBlockEntity$$Type = ($BannerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BannerBlockEntity$$Original = $BannerBlockEntity;}
declare module "net.minecraft.world.level.block.entity.BeaconBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$MobEffect} from "net.minecraft.world.effect.MobEffect"
import {$Holder} from "net.minecraft.core.Holder"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Nameable$$Interface} from "net.minecraft.world.Nameable"
import {$BeaconBlockEntity$BeaconBeamSection} from "net.minecraft.world.level.block.entity.BeaconBlockEntity$BeaconBeamSection"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BeaconBlockEntity extends $BlockEntity implements $MenuProvider$$Interface, $Nameable$$Interface {
 "beamSections": $List<($BeaconBlockEntity$BeaconBeamSection)>
 "primaryPower": $Holder<($MobEffect)>
static readonly "BEACON_EFFECTS": $List<($List<($Holder<($MobEffect)>)>)>
 "secondaryPower": $Holder<($MobEffect)>
static readonly "DATA_SECONDARY": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
static readonly "NUM_DATA_VALUES": integer
static readonly "DATA_LEVELS": integer
 "levels": integer
static readonly "DATA_PRIMARY": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getBeamSections"(): $List<($BeaconBlockEntity$BeaconBeamSection)>
public static "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BeaconBlockEntity$$Type): void
public "setLevel"(arg0: $Level$$Type): void
public "getName"(): $Component
public "getDisplayName"(): $Component
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public static "playSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type): void
public "setRemoved"(): void
public "getCustomName"(): $Component
public "setCustomName"(arg0: $Component$$Type): void
public "hasCustomName"(): boolean
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
get "updatePacket"(): $ClientboundBlockEntityDataPacket
set "level"(value: $Level$$Type)
get "displayName"(): $Component
get "removed"(): void
get "customName"(): $Component
set "customName"(value: $Component$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeaconBlockEntity$$Type = ($BeaconBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeaconBlockEntity$$Original = $BeaconBlockEntity;}
declare module "net.minecraft.world.level.block.BushBlock" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$IBushBlockMixin$$Interface} from "com.buuz135.industrial.mixin.IBushBlockMixin"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BushBlock extends $Block implements $IBushBlockMixin$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "invokeMayPlaceOn"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BushBlock$$Type = ($BushBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BushBlock$$Original = $BushBlock;}
declare module "net.minecraft.world.level.block.EndGatewayBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Portal$Transition} from "net.minecraft.world.level.block.Portal$Transition"
import {$Portal$$Interface} from "net.minecraft.world.level.block.Portal"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$DimensionTransition} from "net.minecraft.world.level.portal.DimensionTransition"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $EndGatewayBlock extends $BaseEntityBlock implements $Portal$$Interface, $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($EndGatewayBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($EndGatewayBlock)>
public "getPortalDestination"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type, arg2: $BlockPos$$Type): $DimensionTransition
public "getPortalTransitionTime"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type): integer
public "getLocalTransition"(): $Portal$Transition
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "localTransition"(): $Portal$Transition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndGatewayBlock$$Type = ($EndGatewayBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndGatewayBlock$$Original = $EndGatewayBlock;}
declare module "net.minecraft.world.level.levelgen.placement.InSquarePlacement" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $InSquarePlacement extends $PlacementModifier {
static readonly "CODEC": $MapCodec<($InSquarePlacement)>

constructor()

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
public "type"(): $PlacementModifierType<(never)>
public static "spread"(): $InSquarePlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InSquarePlacement$$Type = ($InSquarePlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InSquarePlacement$$Original = $InSquarePlacement;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.AlwaysTrueTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AlwaysTrueTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($AlwaysTrueTest)>
static readonly "INSTANCE": $AlwaysTrueTest

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlwaysTrueTest$$Type = ($AlwaysTrueTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AlwaysTrueTest$$Original = $AlwaysTrueTest;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$Clamp" {
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$Record} from "java.lang.Record"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"
import {$DensityFunctions$PureTransformer$$Interface} from "net.minecraft.world.level.levelgen.DensityFunctions$PureTransformer"

export class $DensityFunctions$Clamp extends $Record implements $DensityFunctions$PureTransformer$$Interface {
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
public "cube"(): $DensityFunction
public "halfNegative"(): $DensityFunction
public "quarterNegative"(): $DensityFunction
public "squeeze"(): $DensityFunction
public "maxValue"(): double
public "abs"(): $DensityFunction
public "clamp"(arg0: double, arg1: double): $DensityFunction
public "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
public "square"(): $DensityFunction
public "minValue"(): double
public "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
public "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$Clamp$$Type = ({"maxValue"?: double, "minValue"?: double, "input"?: $DensityFunction$$Type}) | ([maxValue?: double, minValue?: double, input?: $DensityFunction$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$Clamp$$Original = $DensityFunctions$Clamp;}
declare module "net.minecraft.world.level.dimension.LevelStem" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"
import {$DimensionType, $DimensionType$$Type} from "net.minecraft.world.level.dimension.DimensionType"

export class $LevelStem extends $Record {
static readonly "CODEC": $Codec<($LevelStem)>
static readonly "OVERWORLD": $ResourceKey<($LevelStem)>
static readonly "NETHER": $ResourceKey<($LevelStem)>
static readonly "END": $ResourceKey<($LevelStem)>

constructor(arg0: $Holder$$Type<($DimensionType)>, arg1: $ChunkGenerator$$Type)

public "type"(): $Holder<($DimensionType)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "generator"(): $ChunkGenerator
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.Dimension
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.DimensionTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelStem$$Type = ({"generator"?: $ChunkGenerator$$Type, "type"?: $Holder$$Type<($DimensionType)>}) | ([generator?: $ChunkGenerator$$Type, type?: $Holder$$Type<($DimensionType)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelStem$$Original = $LevelStem;}
declare module "net.minecraft.world.level.levelgen.WorldgenRandom" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PositionalRandomFactory} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"
import {$LegacyRandomSource} from "net.minecraft.world.level.levelgen.LegacyRandomSource"

export class $WorldgenRandom extends $LegacyRandomSource {
constructor(arg0: $RandomSource$$Type)

public static "seedSlimeChunk"(arg0: integer, arg1: integer, arg2: long, arg3: long): $RandomSource
public "setLargeFeatureWithSalt"(arg0: long, arg1: integer, arg2: integer, arg3: integer): void
public "setLargeFeatureSeed"(arg0: long, arg1: integer, arg2: integer): void
public "setDecorationSeed"(arg0: long, arg1: integer, arg2: integer): long
public "setFeatureSeed"(arg0: long, arg1: integer, arg2: integer): void
public "fork"(): $RandomSource
public "setSeed"(arg0: long): void
public "next"(arg0: integer): integer
public "getCount"(): integer
public "forkPositional"(): $PositionalRandomFactory
public static "create"(): $RandomSource
public static "create"(arg0: long): $RandomSource
/**
 * 
 * @deprecated
 */
public static "createThreadSafe"(): $RandomSource
public static "createNewThreadLocalInstance"(): $RandomSource
set "seed"(value: long)
get "count"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldgenRandom$$Type = ($WorldgenRandom);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldgenRandom$$Original = $WorldgenRandom;}
declare module "net.minecraft.world.level.storage.loot.entries.LootPoolEntryType" {
import {$LootPoolEntryContainer, $LootPoolEntryContainer$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $LootPoolEntryType extends $Record {
constructor(arg0: $MapCodec$$Type<($LootPoolEntryContainer$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "codec"(): $MapCodec<($LootPoolEntryContainer)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.LootPoolEntryType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.LootPoolEntryTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPoolEntryType$$Type = (Special.LootPoolEntryType) | ({"codec"?: $MapCodec$$Type<($LootPoolEntryContainer$$Type)>}) | ([codec?: $MapCodec$$Type<($LootPoolEntryContainer$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootPoolEntryType$$Original = $LootPoolEntryType;}
declare module "net.minecraft.world.level.block.entity.TrappedChestBlockEntity" {
import {$ChestBlockEntity} from "net.minecraft.world.level.block.entity.ChestBlockEntity"
import {$Level} from "net.minecraft.world.level.Level"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$Component} from "net.minecraft.network.chat.Component"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TrappedChestBlockEntity extends $ChestBlockEntity {
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "lithium$emitRemoved"(): void
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitContentModified"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "tryClear"(arg0: any): void
get "changed"(): void
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrappedChestBlockEntity$$Type = ($TrappedChestBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrappedChestBlockEntity$$Original = $TrappedChestBlockEntity;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.NotPredicate" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type, $BlockPredicate$$Interface} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NotPredicate implements $BlockPredicate$$Interface {
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
public "type"(): $BlockPredicateType<(never)>
public "or"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "negate"(): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "and"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "test"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotPredicate$$Type = ($NotPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NotPredicate$$Original = $NotPredicate;}
declare module "net.minecraft.world.level.block.BambooSaplingBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BambooSaplingBlock extends $Block implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BambooSaplingBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($BambooSaplingBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BambooSaplingBlock$$Type = ($BambooSaplingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BambooSaplingBlock$$Original = $BambooSaplingBlock;}
declare module "net.minecraft.world.level.levelgen.structure.pools.DimensionPadding" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $DimensionPadding extends $Record {
static readonly "ZERO": $DimensionPadding
static readonly "CODEC": $Codec<($DimensionPadding)>

constructor(arg0: integer)
constructor(arg0: integer, arg1: integer)

public "hasEqualTopAndBottom"(): boolean
public "bottom"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "top"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionPadding$$Type = ({"bottom"?: integer, "top"?: integer}) | ([bottom?: integer, top?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionPadding$$Original = $DimensionPadding;}
declare module "net.minecraft.world.level.block.NyliumBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NyliumBlock extends $Block implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($NyliumBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getType"(): $BonemealableBlock$Type
public "codec"(): $MapCodec<($NyliumBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NyliumBlock$$Type = ($NyliumBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NyliumBlock$$Original = $NyliumBlock;}
declare module "net.minecraft.world.level.block.state.properties.DoubleBlockHalf" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Direction} from "net.minecraft.core.Direction"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $DoubleBlockHalf extends $Enum<($DoubleBlockHalf)> implements $StringRepresentable$$Interface {
static readonly "UPPER": $DoubleBlockHalf
static readonly "LOWER": $DoubleBlockHalf

public "getDirectionToOther"(): $Direction
public "getOtherHalf"(): $DoubleBlockHalf
public "toString"(): StringJS
public static "values"(): ($DoubleBlockHalf)[]
public static "valueOf"(arg0: StringJS): $DoubleBlockHalf
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "directionToOther"(): $Direction
get "otherHalf"(): $DoubleBlockHalf
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBlockHalf$$Type = (("upper") | ("lower"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoubleBlockHalf$$Original = $DoubleBlockHalf;}
declare module "net.minecraft.world.level.block.LeavesBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$LeavesCulling$$Interface} from "ca.fxco.moreculling.api.block.LeavesCulling"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$IShearable$$Interface} from "net.neoforged.neoforge.common.IShearable"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$OptionalInt} from "java.util.OptionalInt"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $LeavesBlock extends $Block implements $SimpleWaterloggedBlock$$Interface, $IShearable$$Interface, $LeavesCulling$$Interface, $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "DISTANCE": $IntegerProperty
static readonly "PERSISTENT": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($LeavesBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "DECAY_DISTANCE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "skipRendering"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$customShouldDrawFace"(arg0: $BlockGetter$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: $Direction$$Type): $Optional
public "moreculling$usesCustomShouldDrawFace"(arg0: $BlockState$$Type): boolean
public static "getOptionalDistanceAt"(arg0: $BlockState$$Type): $OptionalInt
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($LeavesBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "onSheared"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): $List<($ItemStack)>
public "isShearable"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): boolean
public "handler$cik000$apothic_enchanting$apoth_handleShearFortune"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "handler$cik000$apothic_enchanting$apoth_handleShearEnchantments"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "spawnShearedDrop"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type): void
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LeavesBlock$$Type = ($LeavesBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LeavesBlock$$Original = $LeavesBlock;}
declare module "net.minecraft.world.level.block.entity.BeaconBlockEntity$BeaconBeamSection" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $BeaconBlockEntity$BeaconBeamSection {
constructor(arg0: integer)

public "getHeight"(): integer
public "getColor"(): integer
get "height"(): integer
get "color"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeaconBlockEntity$BeaconBeamSection$$Type = ($BeaconBlockEntity$BeaconBeamSection);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeaconBlockEntity$BeaconBeamSection$$Original = $BeaconBlockEntity$BeaconBeamSection;}
declare module "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StructureProcessorList, $StructureProcessorList$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorList"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $FossilFeatureConfiguration implements $FeatureConfiguration$$Interface {
readonly "overlayStructures": $List<($ResourceLocation)>
readonly "overlayProcessors": $Holder<($StructureProcessorList)>
static readonly "CODEC": $Codec<($FossilFeatureConfiguration)>
readonly "maxEmptyCornersAllowed": integer
readonly "fossilStructures": $List<($ResourceLocation)>
readonly "fossilProcessors": $Holder<($StructureProcessorList)>

constructor(arg0: $List$$Type<($ResourceLocation$$Type)>, arg1: $List$$Type<($ResourceLocation$$Type)>, arg2: $Holder$$Type<($StructureProcessorList)>, arg3: $Holder$$Type<($StructureProcessorList)>, arg4: integer)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FossilFeatureConfiguration$$Type = ($FossilFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FossilFeatureConfiguration$$Original = $FossilFeatureConfiguration;}
declare module "net.minecraft.world.level.chunk.PalettedContainerRO$PackedData" {
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List, $List$$Type} from "java.util.List"
import {$LongStream, $LongStream$$Type} from "java.util.stream.LongStream"
import {$Record} from "java.lang.Record"

export class $PalettedContainerRO$PackedData<T> extends $Record {
constructor(arg0: $List$$Type<(T)>, arg1: ($LongStream$$Type)?)

public "paletteEntries"(): $List<(T)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "storage"(): $Optional<($LongStream)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainerRO$PackedData$$Type<T> = ({"storage"?: ($LongStream$$Type)?, "paletteEntries"?: $List$$Type<(T)>}) | ([storage?: ($LongStream$$Type)?, paletteEntries?: $List$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainerRO$PackedData$$Original<T> = $PalettedContainerRO$PackedData<(T)>;}
declare module "net.minecraft.world.level.CustomSpawner" {
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"

export interface $CustomSpawner$$Interface {

(arg0: $ServerLevel, arg1: boolean, arg2: boolean): integer
}

export class $CustomSpawner implements $CustomSpawner$$Interface {
 "tick"(arg0: $ServerLevel$$Type, arg1: boolean, arg2: boolean): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomSpawner$$Type = ((arg0: $ServerLevel, arg1: boolean, arg2: boolean) => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomSpawner$$Original = $CustomSpawner;}
declare module "net.minecraft.world.level.block.PinkPetalsBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $PinkPetalsBlock extends $BushBlock implements $BonemealableBlock$$Interface {
static readonly "MIN_FLOWERS": integer
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PinkPetalsBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "AMOUNT": $IntegerProperty
static readonly "MAX_FLOWERS": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "canBeReplaced"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "codec"(): $MapCodec<($PinkPetalsBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PinkPetalsBlock$$Type = ($PinkPetalsBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PinkPetalsBlock$$Original = $PinkPetalsBlock;}
declare module "net.minecraft.world.level.LightLayer" {
import {$Enum} from "java.lang.Enum"

export class $LightLayer extends $Enum<($LightLayer)> {
static readonly "SKY": $LightLayer
static readonly "BLOCK": $LightLayer

public static "values"(): ($LightLayer)[]
public static "valueOf"(arg0: StringJS): $LightLayer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightLayer$$Type = (("sky") | ("block"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightLayer$$Original = $LightLayer;}
declare module "net.minecraft.world.level.levelgen.DensityFunction$SimpleFunction" {
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction, $DensityFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunction$SimpleFunction$$Interface extends $DensityFunction$$Interface {
}

export class $DensityFunction$SimpleFunction implements $DensityFunction$SimpleFunction$$Interface {
 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
 "cube"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "squeeze"(): $DensityFunction
 "maxValue"(): double
 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "square"(): $DensityFunction
 "minValue"(): double
 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$SimpleFunction$$Type = ($DensityFunction$SimpleFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$SimpleFunction$$Original = $DensityFunction$SimpleFunction;}
declare module "net.minecraft.world.level.levelgen.BitRandomSource" {
import {$RandomSource, $RandomSource$$Interface} from "net.minecraft.util.RandomSource"
import {$PositionalRandomFactory} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"

export interface $BitRandomSource$$Interface extends $RandomSource$$Interface {
set "seed"(value: long)
}

export class $BitRandomSource implements $BitRandomSource$$Interface {
static readonly "FLOAT_MULTIPLIER": float
static readonly "DOUBLE_MULTIPLIER": double

 "nextFloat"(): float
 "next"(arg0: integer): integer
 "nextDouble"(): double
 "nextInt"(): integer
 "nextInt"(arg0: integer): integer
 "nextLong"(): long
 "nextBoolean"(): boolean
 "fork"(): $RandomSource
 "setSeed"(arg0: long): void
 "nextGaussian"(): double
static "create"(): $RandomSource
static "create"(arg0: long): $RandomSource
 "nextInt"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
static "createThreadSafe"(): $RandomSource
 "triangle"(arg0: double, arg1: double): double
 "nextIntBetweenInclusive"(arg0: integer, arg1: integer): integer
 "forkPositional"(): $PositionalRandomFactory
static "createNewThreadLocalInstance"(): $RandomSource
 "consumeCount"(arg0: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BitRandomSource$$Type = ($BitRandomSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BitRandomSource$$Original = $BitRandomSource;}
declare module "net.minecraft.world.level.block.SeagrassBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IShearable$$Interface} from "net.neoforged.neoforge.common.IShearable"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$LiquidBlockContainer$$Interface} from "net.minecraft.world.level.block.LiquidBlockContainer"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SeagrassBlock extends $BushBlock implements $BonemealableBlock$$Interface, $LiquidBlockContainer$$Interface, $IShearable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SeagrassBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "codec"(): $MapCodec<($SeagrassBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public "onSheared"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): $List<($ItemStack)>
public "isShearable"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): boolean
public "handler$cik000$apothic_enchanting$apoth_handleShearFortune"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "handler$cik000$apothic_enchanting$apoth_handleShearEnchantments"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "spawnShearedDrop"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeagrassBlock$$Type = ($SeagrassBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SeagrassBlock$$Original = $SeagrassBlock;}
declare module "net.minecraft.world.level.chunk.PalettedContainer$Configuration" {
import {$PalettedContainer$Data} from "net.minecraft.world.level.chunk.PalettedContainer$Data"
import {$Palette$Factory, $Palette$Factory$$Type} from "net.minecraft.world.level.chunk.Palette$Factory"
import {$IdMap$$Type} from "net.minecraft.core.IdMap"
import {$PaletteResize$$Type} from "net.minecraft.world.level.chunk.PaletteResize"
import {$Record} from "java.lang.Record"

export class $PalettedContainer$Configuration<T> extends $Record {
public "createData"(arg0: $IdMap$$Type<(T)>, arg1: $PaletteResize$$Type<(T)>, arg2: integer): $PalettedContainer$Data<(T)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "factory"(): $Palette$Factory
public "bits"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainer$Configuration$$Type<T> = ({"bits"?: integer, "factory"?: $Palette$Factory$$Type}) | ([bits?: integer, factory?: $Palette$Factory$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainer$Configuration$$Original<T> = $PalettedContainer$Configuration<(T)>;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockStatePredicate$$Type} from "dev.latvian.mods.kubejs.block.state.BlockStatePredicate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RuleTest {
static readonly "CODEC": $Codec<($RuleTest)>

constructor()

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleTest$$Type = ($BlockStatePredicate) | ($CompoundTag$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleTest$$Original = $RuleTest;}
declare module "net.minecraft.world.level.levelgen.WorldgenRandom$Algorithm" {
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Enum} from "java.lang.Enum"

export class $WorldgenRandom$Algorithm extends $Enum<($WorldgenRandom$Algorithm)> {
static readonly "LEGACY": $WorldgenRandom$Algorithm
static readonly "XOROSHIRO": $WorldgenRandom$Algorithm

public static "values"(): ($WorldgenRandom$Algorithm)[]
public static "valueOf"(arg0: StringJS): $WorldgenRandom$Algorithm
public "newInstance"(arg0: long): $RandomSource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldgenRandom$Algorithm$$Type = (("legacy") | ("xoroshiro"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldgenRandom$Algorithm$$Original = $WorldgenRandom$Algorithm;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.RandomBlockStateMatchTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RandomBlockStateMatchTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($RandomBlockStateMatchTest)>

constructor(arg0: $BlockState$$Type, arg1: float)

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomBlockStateMatchTest$$Type = ($RandomBlockStateMatchTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomBlockStateMatchTest$$Original = $RandomBlockStateMatchTest;}
declare module "net.minecraft.world.level.block.entity.BeehiveBlockEntity$BeeReleaseStatus" {
import {$Enum} from "java.lang.Enum"

export class $BeehiveBlockEntity$BeeReleaseStatus extends $Enum<($BeehiveBlockEntity$BeeReleaseStatus)> {
static readonly "BEE_RELEASED": $BeehiveBlockEntity$BeeReleaseStatus
static readonly "EMERGENCY": $BeehiveBlockEntity$BeeReleaseStatus
static readonly "HONEY_DELIVERED": $BeehiveBlockEntity$BeeReleaseStatus

public static "values"(): ($BeehiveBlockEntity$BeeReleaseStatus)[]
public static "valueOf"(arg0: StringJS): $BeehiveBlockEntity$BeeReleaseStatus
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeehiveBlockEntity$BeeReleaseStatus$$Type = (("honey_delivered") | ("bee_released") | ("emergency"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeehiveBlockEntity$BeeReleaseStatus$$Original = $BeehiveBlockEntity$BeeReleaseStatus;}
declare module "net.minecraft.world.level.block.WebBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$IShearable$$Interface} from "net.neoforged.neoforge.common.IShearable"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $WebBlock extends $Block implements $IShearable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WebBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($WebBlock)>
public "onSheared"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): $List<($ItemStack)>
public "isShearable"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): boolean
public "handler$cik000$apothic_enchanting$apoth_handleShearFortune"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "handler$cik000$apothic_enchanting$apoth_handleShearEnchantments"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "spawnShearedDrop"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebBlock$$Type = ($WebBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WebBlock$$Original = $WebBlock;}
declare module "net.minecraft.world.level.block.SmokerBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$AbstractFurnaceBlock} from "net.minecraft.world.level.block.AbstractFurnaceBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SmokerBlock extends $AbstractFurnaceBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SmokerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($SmokerBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmokerBlock$$Type = ($SmokerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmokerBlock$$Original = $SmokerBlock;}
declare module "net.minecraft.world.level.block.MossBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MossBlock extends $Block implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($MossBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getType"(): $BonemealableBlock$Type
public "codec"(): $MapCodec<($MossBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MossBlock$$Type = ($MossBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MossBlock$$Original = $MossBlock;}
declare module "net.minecraft.world.level.levelgen.feature.ScatteredOreFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration, $OreConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $ScatteredOreFeature extends $Feature<($OreConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

public "place"(arg0: $FeaturePlaceContext$$Type<($OreConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScatteredOreFeature$$Type = ($ScatteredOreFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScatteredOreFeature$$Original = $ScatteredOreFeature;}
declare module "net.minecraft.world.level.block.FlowerBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$List} from "java.util.List"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$SuspiciousEffectHolder, $SuspiciousEffectHolder$$Interface} from "net.minecraft.world.level.block.SuspiciousEffectHolder"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$SuspiciousStewEffects, $SuspiciousStewEffects$$Type} from "net.minecraft.world.item.component.SuspiciousStewEffects"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $FlowerBlock extends $BushBlock implements $SuspiciousEffectHolder$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FlowerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $Holder$$Type<($MobEffect)>, arg1: float, arg2: $BlockBehaviour$Properties$$Type)
constructor(arg0: $SuspiciousStewEffects$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getSuspiciousEffects"(): $SuspiciousStewEffects
public "codec"(): $MapCodec<($FlowerBlock)>
public static "getAllEffectHolders"(): $List<($SuspiciousEffectHolder)>
public static "tryGet"(arg0: $ItemLike$$Type): $SuspiciousEffectHolder
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "suspiciousEffects"(): $SuspiciousStewEffects
public static get "allEffectHolders"(): $List<($SuspiciousEffectHolder)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlowerBlock$$Type = ($FlowerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlowerBlock$$Original = $FlowerBlock;}
declare module "net.minecraft.world.level.block.entity.SkullBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Optional} from "java.util.Optional"
import {$UUID$$Type} from "java.util.UUID"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$Executor, $Executor$$Type} from "java.util.concurrent.Executor"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Services$$Type} from "net.minecraft.server.Services"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$ResolvableProfile, $ResolvableProfile$$Type} from "net.minecraft.world.item.component.ResolvableProfile"

export class $SkullBlockEntity extends $BlockEntity {
static readonly "CHECKED_MAIN_THREAD_EXECUTOR": $Executor
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "getNoteBlockSound"(): $ResourceLocation
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getOwnerProfile"(): $ResolvableProfile
public static "fetchGameProfile"(arg0: StringJS): $CompletableFuture<($Optional<($GameProfile)>)>
public static "fetchGameProfile"(arg0: $UUID$$Type): $CompletableFuture<($Optional<($GameProfile)>)>
public "setOwner"(arg0: $ResolvableProfile$$Type): void
public static "clear"(): void
public static "setup"(arg0: $Services$$Type, arg1: $Executor$$Type): void
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "getAnimation"(arg0: float): float
public static "animation"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SkullBlockEntity$$Type): void
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "noteBlockSound"(): $ResourceLocation
get "ownerProfile"(): $ResolvableProfile
set "owner"(value: $ResolvableProfile$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SkullBlockEntity$$Type = ($SkullBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SkullBlockEntity$$Original = $SkullBlockEntity;}
declare module "net.minecraft.world.level.block.SoulSandBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $SoulSandBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SoulSandBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($SoulSandBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoulSandBlock$$Type = ($SoulSandBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoulSandBlock$$Original = $SoulSandBlock;}
declare module "net.minecraft.world.level.chunk.status.ChunkStatus" {
import {$Heightmap$Types} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$List} from "java.util.List"
import {$EnumSet} from "java.util.EnumSet"
import {$ChunkType} from "net.minecraft.world.level.chunk.status.ChunkType"

export class $ChunkStatus {
static readonly "LIGHT": $ChunkStatus
static readonly "NOISE": $ChunkStatus
static readonly "MAX_STRUCTURE_DISTANCE": integer
static readonly "SPAWN": $ChunkStatus
static readonly "FULL": $ChunkStatus
static readonly "FEATURES": $ChunkStatus
static readonly "STRUCTURE_STARTS": $ChunkStatus
static readonly "STRUCTURE_REFERENCES": $ChunkStatus
static readonly "FINAL_HEIGHTMAPS": $EnumSet<($Heightmap$Types)>
static readonly "SURFACE": $ChunkStatus
static readonly "INITIALIZE_LIGHT": $ChunkStatus
static readonly "BIOMES": $ChunkStatus
static readonly "CARVERS": $ChunkStatus
static readonly "EMPTY": $ChunkStatus

public "heightmapsAfter"(): $EnumSet<($Heightmap$Types)>
public static "getStatusList"(): $List<($ChunkStatus)>
public "getChunkType"(): $ChunkType
public "isOrBefore"(arg0: $ChunkStatus$$Type): boolean
public "isAfter"(arg0: $ChunkStatus$$Type): boolean
public "isBefore"(arg0: $ChunkStatus$$Type): boolean
public "getName"(): StringJS
public "toString"(): StringJS
public static "max"(arg0: $ChunkStatus$$Type, arg1: $ChunkStatus$$Type): $ChunkStatus
public "getParent"(): $ChunkStatus
public "getIndex"(): integer
public static "byName"(arg0: StringJS): $ChunkStatus
public "isOrAfter"(arg0: $ChunkStatus$$Type): boolean
public static get "statusList"(): $List<($ChunkStatus)>
get "chunkType"(): $ChunkType
get "name"(): StringJS
get "parent"(): $ChunkStatus
get "index"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.ChunkStatus
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.ChunkStatusTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkStatus$$Type = (Special.ChunkStatus);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkStatus$$Original = $ChunkStatus;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationInfo" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $VibrationInfo extends $Record {
static readonly "CODEC": $Codec<($VibrationInfo)>

constructor(arg0: $Holder$$Type<($GameEvent)>, arg1: float, arg2: $Vec3$$Type, arg3: $Entity$$Type)
constructor(arg0: $Holder$$Type<($GameEvent)>, arg1: float, arg2: $Vec3$$Type, arg3: $UUID$$Type, arg4: $UUID$$Type)
constructor(arg0: $Holder$$Type<($GameEvent)>, arg1: float, arg2: $Vec3$$Type, arg3: $UUID$$Type, arg4: $UUID$$Type, arg5: $Entity$$Type)

public "projectileOwnerUuid"(): $UUID
public "getProjectileOwner"(arg0: $ServerLevel$$Type): $Optional<($Entity)>
public "entity"(): $Entity
public "getEntity"(arg0: $ServerLevel$$Type): $Optional<($Entity)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "pos"(): $Vec3
public "distance"(): float
public "uuid"(): $UUID
public "gameEvent"(): $Holder<($GameEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationInfo$$Type = ({"distance"?: float, "entity"?: $Entity$$Type, "projectileOwnerUuid"?: $UUID$$Type, "gameEvent"?: $Holder$$Type<($GameEvent)>, "uuid"?: $UUID$$Type, "pos"?: $Vec3$$Type}) | ([distance?: float, entity?: $Entity$$Type, projectileOwnerUuid?: $UUID$$Type, gameEvent?: $Holder$$Type<($GameEvent)>, uuid?: $UUID$$Type, pos?: $Vec3$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationInfo$$Original = $VibrationInfo;}
declare module "net.minecraft.world.level.block.WallBlock" {
import {$WallSide} from "net.minecraft.world.level.block.state.properties.WallSide"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $WallBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "SOUTH_WALL": $EnumProperty<($WallSide)>
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WallBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST_WALL": $EnumProperty<($WallSide)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "NORTH_WALL": $EnumProperty<($WallSide)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "EAST_WALL": $EnumProperty<($WallSide)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UP": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "connectsTo"(arg0: $BlockState$$Type, arg1: boolean, arg2: $Direction$$Type): boolean
public "codec"(): $MapCodec<($WallBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallBlock$$Type = ($WallBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallBlock$$Original = $WallBlock;}
declare module "net.minecraft.world.level.block.NoteBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$NoteBlockInstrument} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $NoteBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($NoteBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "NOTE_VOLUME": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "INSTRUMENT": $EnumProperty<($NoteBlockInstrument)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "NOTE": $IntegerProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "getPitchFromNote"(arg0: integer): float
public "codec"(): $MapCodec<($NoteBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoteBlock$$Type = ($NoteBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoteBlock$$Original = $NoteBlock;}
declare module "net.minecraft.world.level.saveddata.SavedData" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$File$$Type} from "java.io.File"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $SavedData {
constructor()

public "setDirty"(arg0: boolean): void
public "setDirty"(): void
public "isDirty"(): boolean
public "save"(arg0: $File$$Type, arg1: $HolderLookup$Provider$$Type): void
public "save"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
set "dirty"(value: boolean)
get "dirty"(): void
get "dirty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SavedData$$Type = ($SavedData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SavedData$$Original = $SavedData;}
declare module "net.minecraft.world.level.biome.Climate$ParameterPoint" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Climate$Parameter, $Climate$Parameter$$Type} from "net.minecraft.world.level.biome.Climate$Parameter"
import {$Record} from "java.lang.Record"

export class $Climate$ParameterPoint extends $Record {
static readonly "CODEC": $Codec<($Climate$ParameterPoint)>

constructor(arg0: $Climate$Parameter$$Type, arg1: $Climate$Parameter$$Type, arg2: $Climate$Parameter$$Type, arg3: $Climate$Parameter$$Type, arg4: $Climate$Parameter$$Type, arg5: $Climate$Parameter$$Type, arg6: long)

public "temperature"(): $Climate$Parameter
public "humidity"(): $Climate$Parameter
public "continentalness"(): $Climate$Parameter
public "erosion"(): $Climate$Parameter
public "weirdness"(): $Climate$Parameter
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "offset"(): long
public "depth"(): $Climate$Parameter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Climate$ParameterPoint$$Type = ({"erosion"?: $Climate$Parameter$$Type, "weirdness"?: $Climate$Parameter$$Type, "offset"?: long, "continentalness"?: $Climate$Parameter$$Type, "humidity"?: $Climate$Parameter$$Type, "depth"?: $Climate$Parameter$$Type, "temperature"?: $Climate$Parameter$$Type}) | ([erosion?: $Climate$Parameter$$Type, weirdness?: $Climate$Parameter$$Type, offset?: long, continentalness?: $Climate$Parameter$$Type, humidity?: $Climate$Parameter$$Type, depth?: $Climate$Parameter$$Type, temperature?: $Climate$Parameter$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Climate$ParameterPoint$$Original = $Climate$ParameterPoint;}
declare module "net.minecraft.world.level.storage.loot.entries.ComposableEntryContainer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ComposableEntryContainer$$Interface {
}

export class $ComposableEntryContainer implements $ComposableEntryContainer$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComposableEntryContainer$$Type = ($ComposableEntryContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComposableEntryContainer$$Original = $ComposableEntryContainer;}
declare module "net.minecraft.world.level.block.BasePressurePlateBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BasePressurePlateBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "isPossibleToRespawnInThis"(arg0: $BlockState$$Type): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasePressurePlateBlock$$Type = ($BasePressurePlateBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasePressurePlateBlock$$Original = $BasePressurePlateBlock;}
declare module "net.minecraft.world.level.block.entity.TheEndGatewayBlockEntity" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TheEndPortalBlockEntity} from "net.minecraft.world.level.block.entity.TheEndPortalBlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TheEndGatewayBlockEntity extends $TheEndPortalBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "shouldRenderFace"(arg0: $Direction$$Type): boolean
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public static "beamAnimationTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $TheEndGatewayBlockEntity$$Type): void
public static "portalTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $TheEndGatewayBlockEntity$$Type): void
public "getParticleAmount"(): integer
public "isCoolingDown"(): boolean
public static "triggerCooldown"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $TheEndGatewayBlockEntity$$Type): void
public "getPortalPosition"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): $Vec3
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "isSpawning"(): boolean
public "getSpawnPercent"(arg0: float): float
public "setExitPosition"(arg0: $BlockPos$$Type, arg1: boolean): void
public "getCooldownPercent"(arg0: float): float
public "triggerEvent"(arg0: integer, arg1: integer): boolean
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "particleAmount"(): integer
get "coolingDown"(): boolean
get "spawning"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TheEndGatewayBlockEntity$$Type = ($TheEndGatewayBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TheEndGatewayBlockEntity$$Original = $TheEndGatewayBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record} from "java.lang.Record"

export class $SculkPatchConfiguration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($SculkPatchConfiguration)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: $IntProvider$$Type, arg6: float)

public "spreadRounds"(): integer
public "growthRounds"(): integer
public "chargeCount"(): integer
public "amountPerCharge"(): integer
public "spreadAttempts"(): integer
public "catalystChance"(): float
public "extraRareGrowths"(): $IntProvider
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkPatchConfiguration$$Type = ({"chargeCount"?: integer, "extraRareGrowths"?: $IntProvider$$Type, "spreadAttempts"?: integer, "spreadRounds"?: integer, "growthRounds"?: integer, "catalystChance"?: float, "amountPerCharge"?: integer}) | ([chargeCount?: integer, extraRareGrowths?: $IntProvider$$Type, spreadAttempts?: integer, spreadRounds?: integer, growthRounds?: integer, catalystChance?: float, amountPerCharge?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkPatchConfiguration$$Original = $SculkPatchConfiguration;}
declare module "net.minecraft.world.level.block.FenceBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Map} from "java.util.Map"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$CrossCollisionBlock} from "net.minecraft.world.level.block.CrossCollisionBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FenceBlock extends $CrossCollisionBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FenceBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($BooleanProperty)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "SOUTH": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "EAST": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "connectsTo"(arg0: $BlockState$$Type, arg1: boolean, arg2: $Direction$$Type): boolean
public "handler$bik000$create_connected$hasProperties"(arg0: $CallbackInfoReturnable$$Type): void
public "codec"(): $MapCodec<($FenceBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceBlock$$Type = ($FenceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FenceBlock$$Original = $FenceBlock;}
declare module "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner$StateAccessor" {
import {$TrialSpawnerState, $TrialSpawnerState$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$Level$$Type} from "net.minecraft.world.level.Level"

export interface $TrialSpawner$StateAccessor$$Interface {
get "state"(): $TrialSpawnerState
}

export class $TrialSpawner$StateAccessor implements $TrialSpawner$StateAccessor$$Interface {
 "markUpdated"(): void
 "getState"(): $TrialSpawnerState
 "setState"(arg0: $Level$$Type, arg1: $TrialSpawnerState$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawner$StateAccessor$$Type = ($TrialSpawner$StateAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawner$StateAccessor$$Original = $TrialSpawner$StateAccessor;}
declare module "net.minecraft.world.level.storage.loot.LootParams$DynamicDrop" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LootParams$DynamicDrop$$Interface {

(arg0: $Consumer<($ItemStack)>): void
}

export class $LootParams$DynamicDrop implements $LootParams$DynamicDrop$$Interface {
 "add"(arg0: $Consumer$$Type<($ItemStack)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootParams$DynamicDrop$$Type = ((arg0: $Consumer<($ItemStack)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootParams$DynamicDrop$$Original = $LootParams$DynamicDrop;}
declare module "net.minecraft.world.level.levelgen.placement.HeightRangePlacement" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $HeightRangePlacement extends $PlacementModifier {
static readonly "CODEC": $MapCodec<($HeightRangePlacement)>

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
public "type"(): $PlacementModifierType<(never)>
public static "of"(arg0: $HeightProvider$$Type): $HeightRangePlacement
public static "uniform"(arg0: $VerticalAnchor$$Type, arg1: $VerticalAnchor$$Type): $HeightRangePlacement
public static "triangle"(arg0: $VerticalAnchor$$Type, arg1: $VerticalAnchor$$Type): $HeightRangePlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeightRangePlacement$$Type = ($HeightRangePlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HeightRangePlacement$$Original = $HeightRangePlacement;}
declare module "net.minecraft.world.level.levelgen.heightproviders.VeryBiasedToBottomHeight" {
import {$HeightProviderType} from "net.minecraft.world.level.levelgen.heightproviders.HeightProviderType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $VeryBiasedToBottomHeight extends $HeightProvider {
static readonly "CODEC": $MapCodec<($VeryBiasedToBottomHeight)>

public "toString"(): StringJS
public static "of"(arg0: $VerticalAnchor$$Type, arg1: $VerticalAnchor$$Type, arg2: integer): $VeryBiasedToBottomHeight
public "getType"(): $HeightProviderType<(never)>
public "sample"(arg0: $RandomSource$$Type, arg1: $WorldGenerationContext$$Type): integer
get "type"(): $HeightProviderType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VeryBiasedToBottomHeight$$Type = ($VeryBiasedToBottomHeight);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VeryBiasedToBottomHeight$$Original = $VeryBiasedToBottomHeight;}
declare module "net.minecraft.world.level.material.WaterFluid" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Optional} from "java.util.Optional"
import {$FlowingFluid} from "net.minecraft.world.level.material.FlowingFluid"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Holder} from "net.minecraft.core.Holder"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$ParticleOptions} from "net.minecraft.core.particles.ParticleOptions"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $WaterFluid extends $FlowingFluid {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty

constructor()

public "canBeReplacedWith"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Fluid$$Type, arg4: $Direction$$Type): boolean
public "getTickDelay"(arg0: $LevelReader$$Type): integer
public "getPickupSound"(): $Optional<($SoundEvent)>
public "isSame"(arg0: $Fluid$$Type): boolean
public "getDropOff"(arg0: $LevelReader$$Type): integer
public "getSlopeFindDistance"(arg0: $LevelReader$$Type): integer
public "getFlowing"(): $Fluid
public "getSource"(): $Fluid
public "getBucket"(): $Item
public "animateTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type, arg3: $RandomSource$$Type): void
public "createLegacyBlock"(arg0: $FluidState$$Type): $BlockState
public "getDripParticle"(): $ParticleOptions
public "asHolder"(): $Holder
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
get "pickupSound"(): $Optional<($SoundEvent)>
get "flowing"(): $Fluid
get "source"(): $Fluid
get "bucket"(): $Item
get "dripParticle"(): $ParticleOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterFluid$$Type = ($WaterFluid);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WaterFluid$$Original = $WaterFluid;}
declare module "net.minecraft.world.level.block.DoublePlantBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DoubleBlockHalf} from "net.minecraft.world.level.block.state.properties.DoubleBlockHalf"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DoublePlantBlock extends $BushBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DoublePlantBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($DoubleBlockHalf)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "playerDestroy"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockEntity$$Type, arg5: $ItemStack$$Type): void
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public static "placeAt"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: integer): void
public static "copyWaterloggedFrom"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
public "codec"(): $MapCodec<($DoublePlantBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoublePlantBlock$$Type = ($DoublePlantBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoublePlantBlock$$Original = $DoublePlantBlock;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.AppendStatic" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RuleBlockEntityModifier$$Interface} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RuleBlockEntityModifierType} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifierType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AppendStatic implements $RuleBlockEntityModifier$$Interface {
static readonly "CODEC": $MapCodec<($AppendStatic)>

constructor(arg0: $CompoundTag$$Type)

public "apply"(arg0: $RandomSource$$Type, arg1: $CompoundTag$$Type): $CompoundTag
public "getType"(): $RuleBlockEntityModifierType<(never)>
get "type"(): $RuleBlockEntityModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AppendStatic$$Type = ($AppendStatic);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AppendStatic$$Original = $AppendStatic;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ReplaceBlockConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($ReplaceBlockConfiguration)>
readonly "targetStates": $List<($OreConfiguration$TargetBlockState)>

constructor(arg0: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>)
constructor(arg0: $BlockState$$Type, arg1: $BlockState$$Type)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplaceBlockConfiguration$$Type = ($ReplaceBlockConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplaceBlockConfiguration$$Original = $ReplaceBlockConfiguration;}
declare module "net.minecraft.world.level.block.HugeMushroomBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $HugeMushroomBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "DOWN": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($HugeMushroomBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "SOUTH": $BooleanProperty
static readonly "UP": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "EAST": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($HugeMushroomBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HugeMushroomBlock$$Type = ($HugeMushroomBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HugeMushroomBlock$$Original = $HugeMushroomBlock;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationSystem" {
import {$ToIntFunction} from "java.util.function.ToIntFunction"
import {$VibrationSystem$Data} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Data"
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$List} from "java.util.List"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$VibrationSystem$User} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$User"

export interface $VibrationSystem$$Interface {
get "vibrationUser"(): $VibrationSystem$User
get "vibrationData"(): $VibrationSystem$Data
}

export class $VibrationSystem implements $VibrationSystem$$Interface {
static readonly "DEFAULT_VIBRATION_FREQUENCY": integer
static readonly "RESONANCE_EVENTS": $List<($ResourceKey<($GameEvent)>)>
/**
 * 
 * @deprecated
 */
static readonly "VIBRATION_FREQUENCY_FOR_EVENT": $ToIntFunction<($ResourceKey<($GameEvent)>)>

static "getResonanceEventByFrequency"(arg0: integer): $ResourceKey<($GameEvent)>
 "getVibrationUser"(): $VibrationSystem$User
 "getVibrationData"(): $VibrationSystem$Data
static "getGameEventFrequency"(arg0: $ResourceKey$$Type<($GameEvent)>): integer
static "getGameEventFrequency"(arg0: $Holder$$Type<($GameEvent)>): integer
static "getRedstoneStrengthForDistance"(arg0: float, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationSystem$$Type = ($VibrationSystem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationSystem$$Original = $VibrationSystem;}
declare module "net.minecraft.world.level.levelgen.placement.RandomOffsetPlacement" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $RandomOffsetPlacement extends $PlacementModifier {
static readonly "CODEC": $MapCodec<($RandomOffsetPlacement)>

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
public "type"(): $PlacementModifierType<(never)>
public static "of"(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type): $RandomOffsetPlacement
public static "horizontal"(arg0: $IntProvider$$Type): $RandomOffsetPlacement
public static "vertical"(arg0: $IntProvider$$Type): $RandomOffsetPlacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomOffsetPlacement$$Type = ($RandomOffsetPlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomOffsetPlacement$$Original = $RandomOffsetPlacement;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $DripstoneClusterConfiguration implements $FeatureConfiguration$$Interface {
readonly "chanceOfDripstoneColumnAtMaxDistanceFromCenter": float
readonly "heightDeviation": integer
static readonly "CODEC": $Codec<($DripstoneClusterConfiguration)>
readonly "density": $FloatProvider
readonly "dripstoneBlockLayerThickness": $IntProvider
readonly "maxStalagmiteStalactiteHeightDiff": integer
readonly "floorToCeilingSearchRange": integer
readonly "wetness": $FloatProvider
readonly "radius": $IntProvider
readonly "maxDistanceFromCenterAffectingHeightBias": integer
readonly "maxDistanceFromEdgeAffectingChanceOfDripstoneColumn": integer
readonly "height": $IntProvider

constructor(arg0: integer, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type, arg3: integer, arg4: integer, arg5: $IntProvider$$Type, arg6: $FloatProvider$$Type, arg7: $FloatProvider$$Type, arg8: float, arg9: integer, arg10: integer)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DripstoneClusterConfiguration$$Type = ($DripstoneClusterConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DripstoneClusterConfiguration$$Original = $DripstoneClusterConfiguration;}
declare module "net.minecraft.world.level.storage.LevelStorageSource$LevelCandidates" {
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Iterator} from "java.util.Iterator"
import {$Spliterator} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$LevelStorageSource$LevelDirectory, $LevelStorageSource$LevelDirectory$$Type} from "net.minecraft.world.level.storage.LevelStorageSource$LevelDirectory"
import {$Record} from "java.lang.Record"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $LevelStorageSource$LevelCandidates extends $Record implements $Iterable$$Interface<($LevelStorageSource$LevelDirectory)> {
constructor(levels: $List$$Type<($LevelStorageSource$LevelDirectory$$Type)>)

public "levels"(): $List<($LevelStorageSource$LevelDirectory)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $Iterator<($LevelStorageSource$LevelDirectory)>
public "spliterator"(): $Spliterator<($LevelStorageSource$LevelDirectory)>
public "forEach"(arg0: $Consumer$$Type<($LevelStorageSource$LevelDirectory)>): void
[Symbol.iterator](): IterableIterator<$LevelStorageSource$LevelDirectory>;
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelStorageSource$LevelCandidates$$Type = ({"levels"?: $List$$Type<($LevelStorageSource$LevelDirectory$$Type)>}) | ([levels?: $List$$Type<($LevelStorageSource$LevelDirectory$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelStorageSource$LevelCandidates$$Original = $LevelStorageSource$LevelCandidates;}
declare module "net.minecraft.world.level.levelgen.feature.BlockBlobFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration, $BlockStateConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $BlockBlobFeature extends $Feature<($BlockStateConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($BlockStateConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($BlockStateConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBlobFeature$$Type = ($BlockBlobFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBlobFeature$$Original = $BlockBlobFeature;}
declare module "net.minecraft.world.level.NaturalSpawner$SpawnState" {
import {$Object2IntMap} from "it.unimi.dsi.fastutil.objects.Object2IntMap"
import {$MobCategory} from "net.minecraft.world.entity.MobCategory"

export class $NaturalSpawner$SpawnState {
public "getSpawnableChunkCount"(): integer
public "getMobCategoryCounts"(): $Object2IntMap<($MobCategory)>
get "spawnableChunkCount"(): integer
get "mobCategoryCounts"(): $Object2IntMap<($MobCategory)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NaturalSpawner$SpawnState$$Type = ($NaturalSpawner$SpawnState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NaturalSpawner$SpawnState$$Original = $NaturalSpawner$SpawnState;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.MatchingFluidsPredicate" {
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$StateTestingPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.StateTestingPredicate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MatchingFluidsPredicate extends $StateTestingPredicate {
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatchingFluidsPredicate$$Type = ($MatchingFluidsPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MatchingFluidsPredicate$$Original = $MatchingFluidsPredicate;}
declare module "net.minecraft.world.level.block.CarpetBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CarpetBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CarpetBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($CarpetBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarpetBlock$$Type = ($CarpetBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarpetBlock$$Original = $CarpetBlock;}
declare module "net.minecraft.world.level.block.BellBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$BellAttachType} from "net.minecraft.world.level.block.state.properties.BellAttachType"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $BellBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "ATTACHMENT": $EnumProperty<($BellAttachType)>
 "item": $Item
static readonly "CODEC": $MapCodec<($BellBlock)>
static readonly "EVENT_BELL_RING": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "attemptToRing"(arg0: $Entity$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "attemptToRing"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "onHit"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockHitResult$$Type, arg3: $Player$$Type, arg4: boolean): boolean
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "codec"(): $MapCodec<($BellBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BellBlock$$Type = ($BellBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BellBlock$$Original = $BellBlock;}
declare module "net.minecraft.world.level.block.SlabBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SlabType} from "net.minecraft.world.level.block.state.properties.SlabType"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SlabBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SlabBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "TYPE": $EnumProperty<($SlabType)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "codec"(): $MapCodec<($SlabBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlabBlock$$Type = ($SlabBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlabBlock$$Original = $SlabBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.DesertPyramidStructure" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$SinglePieceStructure} from "net.minecraft.world.level.levelgen.structure.SinglePieceStructure"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$PiecesContainer$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $DesertPyramidStructure extends $SinglePieceStructure {
static readonly "CODEC": $MapCodec<($DesertPyramidStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "afterPlace"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BoundingBox$$Type, arg5: $ChunkPos$$Type, arg6: $PiecesContainer$$Type): void
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DesertPyramidStructure$$Type = ($DesertPyramidStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DesertPyramidStructure$$Original = $DesertPyramidStructure;}
declare module "net.minecraft.world.level.block.RedStoneOreBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RedStoneOreBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RedStoneOreBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getExpDrop"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): integer
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($RedStoneOreBlock)>
public "stepOn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedStoneOreBlock$$Type = ($RedStoneOreBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedStoneOreBlock$$Original = $RedStoneOreBlock;}
declare module "net.minecraft.world.level.levelgen.structure.StructurePieceAccessor" {
import {$BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$StructurePiece, $StructurePiece$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePiece"

export interface $StructurePieceAccessor$$Interface {
}

export class $StructurePieceAccessor implements $StructurePieceAccessor$$Interface {
 "addPiece"(arg0: $StructurePiece$$Type): void
 "findCollisionPiece"(arg0: $BoundingBox$$Type): $StructurePiece
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePieceAccessor$$Type = ($StructurePieceAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePieceAccessor$$Original = $StructurePieceAccessor;}
declare module "net.minecraft.world.level.block.Fallable" {
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $Fallable$$Interface {
}

export class $Fallable implements $Fallable$$Interface {
 "onLand"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $FallingBlockEntity$$Type): void
 "onBrokenAfterFall"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FallingBlockEntity$$Type): void
 "getFallDamageSource"(arg0: $Entity$$Type): $DamageSource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Fallable$$Type = ($Fallable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Fallable$$Original = $Fallable;}
declare module "net.minecraft.world.level.levelgen.feature.TreeFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration, $TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $TreeFeature extends $Feature<($TreeConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($TreeConfiguration$$Type)>)

public static "validTreePos"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type): boolean
public static "isAirOrLeaves"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type): boolean
public "place"(arg0: $FeaturePlaceContext$$Type<($TreeConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeFeature$$Type = ($TreeFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeFeature$$Original = $TreeFeature;}
declare module "net.minecraft.world.level.block.EntityBlock" {
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $EntityBlock$$Interface {

(arg0: $BlockPos, arg1: $BlockState): $BlockEntity$$Type
}

export class $EntityBlock implements $EntityBlock$$Interface {
 "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
 "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
 "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityBlock$$Type = ((arg0: $BlockPos, arg1: $BlockState) => $BlockEntity$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityBlock$$Original = $EntityBlock;}
declare module "net.minecraft.world.level.Level" {
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$DamageSources} from "net.minecraft.world.damagesource.DamageSources"
import {$ExplosionDamageCalculator$$Type} from "net.minecraft.world.level.ExplosionDamageCalculator"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ChunkRandomSource$$Interface} from "net.caffeinemc.mods.lithium.common.world.ChunkRandomSource"
import {$Stream} from "java.util.stream.Stream"
import {$TickRateManager} from "net.minecraft.world.TickRateManager"
import {$ArrayList} from "java.util.ArrayList"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$CrashReport$$Type} from "net.minecraft.CrashReport"
import {$Thread} from "java.lang.Thread"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$LevelAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.util.accessors.LevelAccessor"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$Packet$$Type} from "net.minecraft.network.protocol.Packet"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$CrashReportCategory} from "net.minecraft.CrashReportCategory"
import {$PotionBrewing} from "net.minecraft.world.item.alchemy.PotionBrewing"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$BlockSnapshot} from "net.neoforged.neoforge.common.util.BlockSnapshot"
import {$ChunkSource} from "net.minecraft.world.level.chunk.ChunkSource"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$TickPriority$$Type} from "net.minecraft.world.ticks.TickPriority"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$Level$ExplosionInteraction$$Type} from "net.minecraft.world.level.Level$ExplosionInteraction"
import {$Function$$Type} from "java.util.function.Function"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$ObjectOpenCustomHashSet} from "it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$Map} from "java.util.Map"
import {$BlockPos$MutableBlockPos$$Type} from "net.minecraft.core.BlockPos$MutableBlockPos"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$AttachmentHolder} from "net.neoforged.neoforge.attachment.AttachmentHolder"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$Iterable} from "java.lang.Iterable"
import {$MapId, $MapId$$Type} from "net.minecraft.world.level.saveddata.maps.MapId"
import {$LevelHeightAccessor, $LevelHeightAccessor$$Interface} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$ILevelExtension$$Interface} from "net.neoforged.neoforge.common.extensions.ILevelExtension"
import {$ProfilerFiller} from "net.minecraft.util.profiling.ProfilerFiller"
import {$PartEntity} from "net.neoforged.neoforge.entity.PartEntity"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$MapItemSavedData, $MapItemSavedData$$Type} from "net.minecraft.world.level.saveddata.maps.MapItemSavedData"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$RecipeManager} from "net.minecraft.world.item.crafting.RecipeManager"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelData} from "net.minecraft.world.level.storage.LevelData"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$GameRules} from "net.minecraft.world.level.GameRules"
import {$LithiumData$$Interface} from "net.caffeinemc.mods.lithium.common.world.LithiumData"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LevelChunk, $LevelChunk$$Type} from "net.minecraft.world.level.chunk.LevelChunk"
import {$LevelExtension$$Interface} from "dev.engine_room.flywheel.impl.extension.LevelExtension"
import {$LevelKJS$$Interface} from "dev.latvian.mods.kubejs.core.LevelKJS"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$LevelAccessor$$Interface as $LevelAccessor$0$$Interface} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockEntityGetter$$Interface} from "net.caffeinemc.mods.lithium.common.world.blockentity.BlockEntityGetter"
import {$ModelDataManager} from "net.neoforged.neoforge.client.model.data.ModelDataManager"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Trackable, $Trackable$$Interface} from "dev.uncandango.alltheleaks.mixin.Trackable"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$LithiumData$Data} from "net.caffeinemc.mods.lithium.common.world.LithiumData$Data"
import {$AttachedData} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$ExtendedWorld$$Interface} from "ca.spottedleaf.starlight.common.world.ExtendedWorld"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$LevelTickAccess} from "net.minecraft.world.ticks.LevelTickAccess"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$DifficultyInstance} from "net.minecraft.world.DifficultyInstance"
import {$Scoreboard} from "net.minecraft.world.scores.Scoreboard"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export class $Level extends $AttachmentHolder implements $LevelAccessor$0$$Interface, $AutoCloseable$$Interface, $ILevelExtension$$Interface, $ExtendedWorld$$Interface, $LevelKJS$$Interface, $ChunkRandomSource$$Interface, $LevelAccessor$$Interface, $BlockEntityGetter$$Interface, $LithiumData$$Interface, $LevelHeightAccessor$$Interface, $Trackable$$Interface, $LevelExtension$$Interface {
 "restoringBlockSnapshots": boolean
 "oThunderLevel": float
static readonly "LONG_PARTICLE_CLIP_RANGE": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "thunderLevel": float
readonly "random": $RandomSource
 "capturedBlockSnapshots": $ArrayList<($BlockSnapshot)>
static readonly "OVERWORLD": $ResourceKey<($Level)>
static readonly "TICKS_PER_DAY": integer
static readonly "MAX_ENTITY_SPAWN_Y": integer
static readonly "NETHER": $ResourceKey<($Level)>
 "oRainLevel": float
static readonly "RESOURCE_KEY_CODEC": $Codec<($ResourceKey<($Level)>)>
static readonly "MAX_BRIGHTNESS": integer
static readonly "END": $ResourceKey<($Level)>
static readonly "MAX_LEVEL_SIZE": integer
static readonly "SHORT_PARTICLE_CLIP_RANGE": integer
static readonly "MIN_ENTITY_SPAWN_Y": integer
readonly "blockEntityTickers": $List<($TickingBlockEntity)>
 "rainLevel": float
 "captureBlockSnapshots": boolean

public "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
public "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>, arg3: $List$$Type<(T)>): void
public "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
public "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>, arg3: $List$$Type<(T)>, arg4: integer): void
public "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
public "getDimensionKey"(): $ResourceKey<($Level)>
public "getEntity"(arg0: integer): $Entity
public "close"(): void
public "isDebug"(): boolean
public "isLoaded"(arg0: $BlockPos$$Type): boolean
public "disconnect"(): void
public "getProfiler"(): $ProfilerFiller
public "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
public "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "getLevelData"(): $LevelData
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getWorldBorder"(): $WorldBorder
public "tickRateManager"(): $TickRateManager
public "fillReportDetails"(arg0: $CrashReport$$Type): $CrashReportCategory
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "registryAccess"(): $RegistryAccess
public "getTime"(): long
public "atl$getBaseClass"(): $Class
public "getData"(): $AttachedData
public "damageSources"(): $DamageSources
public "isClientSide"(): boolean
public "shouldTickDeath"(arg0: $Entity$$Type): boolean
public "broadcastEntityEvent"(arg0: $Entity$$Type, arg1: byte): void
public "playSeededSound"(arg0: $Player$$Type, arg1: double, arg2: double, arg3: double, arg4: $Holder$$Type<($SoundEvent)>, arg5: $SoundSource$$Type, arg6: float, arg7: float, arg8: long): void
public "playSeededSound"(arg0: $Player$$Type, arg1: double, arg2: double, arg3: double, arg4: $SoundEvent$$Type, arg5: $SoundSource$$Type, arg6: float, arg7: float, arg8: long): void
public "playSeededSound"(arg0: $Player$$Type, arg1: $Entity$$Type, arg2: $Holder$$Type<($SoundEvent)>, arg3: $SoundSource$$Type, arg4: float, arg5: float, arg6: long): void
public "getScoreboard"(): $Scoreboard
public "getRandom"(): $RandomSource
public "addParticle"(arg0: $ParticleOptions$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): void
public "addParticle"(arg0: $ParticleOptions$$Type, arg1: boolean, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): void
public "broadcastDamageEvent"(arg0: $Entity$$Type, arg1: $DamageSource$$Type): void
public "playSound"(arg0: $Entity$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
public "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
public "playSound"(arg0: $Player$$Type, arg1: double, arg2: double, arg3: double, arg4: $SoundEvent$$Type, arg5: $SoundSource$$Type, arg6: float, arg7: float): void
public "playSound"(arg0: $Player$$Type, arg1: double, arg2: double, arg3: double, arg4: $Holder$$Type<($SoundEvent)>, arg5: $SoundSource$$Type, arg6: float, arg7: float): void
public "playSound"(arg0: $Player$$Type, arg1: $Entity$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
public "playSound"(arg0: $Player$$Type, arg1: double, arg2: double, arg3: double, arg4: $SoundEvent$$Type, arg5: $SoundSource$$Type): void
public "playLocalSound"(arg0: $BlockPos$$Type, arg1: $SoundEvent$$Type, arg2: $SoundSource$$Type, arg3: float, arg4: float, arg5: boolean): void
public "playLocalSound"(arg0: $Entity$$Type, arg1: $SoundEvent$$Type, arg2: $SoundSource$$Type, arg3: float, arg4: float): void
public "playLocalSound"(arg0: double, arg1: double, arg2: double, arg3: $SoundEvent$$Type, arg4: $SoundSource$$Type, arg5: float, arg6: float, arg7: boolean): void
public "getGameRules"(): $GameRules
public "getServer"(): $MinecraftServer
public "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "isDay"(): boolean
public "getDayTimeFraction"(): float
public "getDayTime"(): long
public static "isInSpawnableBounds"(arg0: $BlockPos$$Type): boolean
public "getSharedSpawnPos"(): $BlockPos
public "getChunkAt"(arg0: $BlockPos$$Type): $LevelChunk
public "isRainingAt"(arg0: $BlockPos$$Type): boolean
public "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional
public "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
public "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
public "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
public "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
public "mayInteract"(arg0: $Player$$Type, arg1: $BlockPos$$Type): boolean
public "getSharedSpawnAngle"(): float
public "getBiomeManager"(): $BiomeManager
public "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
public "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
public "addDestroyBlockEffect"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): void
public "setBlockAndUpdate"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): boolean
public "updateNeighborsAt"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
public "updateNeighborsAtExceptFromFacing"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: $Direction$$Type): void
public "neighborChanged"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: $BlockPos$$Type): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $Block$$Type, arg3: $BlockPos$$Type, arg4: boolean): void
public "neighborShapeChanged"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
public "getSeaLevel"(): integer
public "getLightEngine"(): $LevelLightEngine
public "dimensionType"(): $DimensionType
public "isNight"(): boolean
public "addAlwaysVisibleParticle"(arg0: $ParticleOptions$$Type, arg1: boolean, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): void
public "addAlwaysVisibleParticle"(arg0: $ParticleOptions$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): void
public "getSunAngle"(arg0: float): float
public "addBlockEntityTicker"(arg0: $TickingBlockEntity$$Type): void
public "addFreshBlockEntities"(arg0: $Collection$$Type<($BlockEntity$$Type)>): void
public "guardEntityTick"<T extends $Entity>(arg0: $Consumer$$Type<(T)>, arg1: T): void
public "shouldTickBlocksAt"(arg0: $BlockPos$$Type): boolean
public "shouldTickBlocksAt"(arg0: long): boolean
public "explode"(arg0: $Entity$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: boolean, arg6: $Level$ExplosionInteraction$$Type): $Explosion
public "explode"(arg0: $Entity$$Type, arg1: $DamageSource$$Type, arg2: $ExplosionDamageCalculator$$Type, arg3: $Vec3$$Type, arg4: float, arg5: boolean, arg6: $Level$ExplosionInteraction$$Type): $Explosion
public "explode"(arg0: $Entity$$Type, arg1: $DamageSource$$Type, arg2: $ExplosionDamageCalculator$$Type, arg3: double, arg4: double, arg5: double, arg6: float, arg7: boolean, arg8: $Level$ExplosionInteraction$$Type, arg9: $ParticleOptions$$Type, arg10: $ParticleOptions$$Type, arg11: $Holder$$Type<($SoundEvent)>): $Explosion
public "explode"(arg0: $Entity$$Type, arg1: $DamageSource$$Type, arg2: $ExplosionDamageCalculator$$Type, arg3: double, arg4: double, arg5: double, arg6: float, arg7: boolean, arg8: $Level$ExplosionInteraction$$Type, arg9: boolean, arg10: $ParticleOptions$$Type, arg11: $ParticleOptions$$Type, arg12: $Holder$$Type<($SoundEvent)>): $Explosion
public "explode"(arg0: $Entity$$Type, arg1: $DamageSource$$Type, arg2: $ExplosionDamageCalculator$$Type, arg3: double, arg4: double, arg5: double, arg6: float, arg7: boolean, arg8: $Level$ExplosionInteraction$$Type): $Explosion
public "explode"(arg0: $Entity$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: $Level$ExplosionInteraction$$Type): $Explosion
public "gatherChunkSourceStats"(): StringJS
public "setBlockEntity"(arg0: $BlockEntity$$Type): void
public "removeBlockEntity"(arg0: $BlockPos$$Type): void
public "loadedAndEntityCanStandOnFace"(arg0: $BlockPos$$Type, arg1: $Entity$$Type, arg2: $Direction$$Type): boolean
public "loadedAndEntityCanStandOn"(arg0: $BlockPos$$Type, arg1: $Entity$$Type): boolean
public "updateSkyBrightness"(): void
public "getRainLevel"(arg0: float): float
public "getThunderLevel"(arg0: float): float
public "setSpawnSettings"(arg0: boolean, arg1: boolean): void
public "blockEntityChanged"(arg0: $BlockPos$$Type): void
public "blockEvent"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer, arg3: integer): void
public "setThunderLevel"(arg0: float): void
public "setRainLevel"(arg0: float): void
public "getMapData"(arg0: $MapId$$Type): $MapItemSavedData
public "setMapData"(arg0: $MapId$$Type, arg1: $MapItemSavedData$$Type): void
public "getFreeMapId"(): $MapId
public "globalLevelEvent"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
public "destroyBlockProgress"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
public "createFireworks"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: $List$$Type<($FireworkExplosion$$Type)>): void
public "getCurrentDifficultyAt"(arg0: $BlockPos$$Type): $DifficultyInstance
public "getSkyDarken"(): integer
public "setSkyFlashTime"(arg0: integer): void
public "sendPacketToServer"(arg0: $Packet$$Type<(never)>): void
public "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
public "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
public "getRecipeManager"(): $RecipeManager
public "getBlockRandomPos"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $BlockPos
public "noSave"(): boolean
public "getProfilerSupplier"(): $Supplier<($ProfilerFiller)>
public "getMaxEntityRadius"(): double
public "increaseMaxEntityRadius"(arg0: double): double
public "isThundering"(): boolean
public "isRaining"(): boolean
public "dimensionTypeRegistration"(): $Holder<($DimensionType)>
public "isInWorldBounds"(arg0: $BlockPos$$Type): boolean
public "markAndNotifyBlock"(arg0: $BlockPos$$Type, arg1: $LevelChunk$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: integer, arg5: integer): void
public "setBlocksDirty"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type): void
public "sendBlockUpdated"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: integer): void
public "onBlockStateChange"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type): void
public "updateNeighbourForOutputSignal"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
public "nextSubTickCount"(): long
public "potionBrewing"(): $PotionBrewing
public "setDayTimeFraction"(arg0: float): void
public "getDayTimePerTick"(): float
public "setDayTimePerTick"(arg0: float): void
public "getChunkAtImmediately"(chunkX: integer, chunkZ: integer): $LevelChunk
public "getAnyChunkImmediately"(chunkX: integer, chunkZ: integer): $ChunkAccess
public "getMcEntities"(): $Iterable
public "getEntityByUUID"(id: $UUID$$Type): $Entity
public "getEntityByNetworkID"(id: integer): $Entity
public "lithium$getRandomPosInChunk"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $BlockPos$MutableBlockPos$$Type): void
public "lithium$getLoadedExistingBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "lithium$getData"(): $LithiumData$Data
public "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
public "flywheel$getAllLoadedEntities"(): $Iterable
public "getThread"(): $Thread
public "getChunkSource"(): $ChunkSource
public "gameEvent"(arg0: $ResourceKey$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
public "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $Vec3$$Type, arg2: $GameEvent$Context$$Type): void
public "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $BlockPos$$Type): void
public "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $Vec3$$Type): void
public "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
public "getDifficulty"(): $Difficulty
public "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type): void
public "levelEvent"(arg0: $Player$$Type, arg1: integer, arg2: $BlockPos$$Type, arg3: integer): void
public "levelEvent"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
public "hasChunk"(arg0: integer, arg1: integer): boolean
public "blockUpdated"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
public "dayTime"(): long
public "getBlockTicks"(): $LevelTickAccess<($Block)>
public "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer): void
public "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer, arg3: $TickPriority$$Type): void
public "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer, arg3: $TickPriority$$Type): void
public "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer): void
public "getFluidTicks"(): $LevelTickAccess<($Fluid)>
public "getDescription"(): $Component
public "getCapability"<T>(arg0: $BlockCapability$$Type<(T), (void)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockEntity$$Type): T
public "getCapability"<T, C>(arg0: $BlockCapability$$Type<(T), (C)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockEntity$$Type, arg4: C): T
public "getCapability"<T, C>(arg0: $BlockCapability$$Type<(T), (C)>, arg1: $BlockPos$$Type, arg2: C): T
public "getCapability"<T>(arg0: $BlockCapability$$Type<(T), (void)>, arg1: $BlockPos$$Type): T
public "getPartEntities"(): $Collection<($PartEntity<(never)>)>
public "getModelDataManager"(): $ModelDataManager
public "invalidateCapabilities"(arg0: $ChunkPos$$Type): void
public "invalidateCapabilities"(arg0: $BlockPos$$Type): void
public "getDescriptionKey"(): StringJS
public "self"(): $EntityGetter
public "tell"(message: $Component$$Type): void
public "setStatusMessage"(message: $Component$$Type): void
public "runCommand"(command: StringJS): void
public "runCommandSilent"(command: StringJS): void
public "setActivePostShader"(id: $ResourceLocation$$Type): void
public "getName"(): $Component
public "getBlock"(pos: $BlockPos$$Type): $LevelBlock
public "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
public "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
public "getSide"(): $ScriptType
public "getDimension"(): $ResourceLocation
public "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
public "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
public "isOverworld"(): boolean
public "setTime"(time: long): void
public "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
public "createEntity"(type: $EntityType$$Type<(never)>): $Entity
public "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
public "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
public "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
public "getHeight"(): integer
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
public "getMinBuildHeight"(): integer
public "getMaxBuildHeight"(): integer
public "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
public "isOutsideBuildHeight"(arg0: integer): boolean
public "getSectionIndex"(arg0: integer): integer
public "getSectionsCount"(): integer
public "getMaxSection"(): integer
public "getMinSection"(): integer
public "getSectionIndexFromSectionY"(arg0: integer): integer
public "getSectionYFromSectionIndex"(arg0: integer): integer
public "wrap"(): $WeakReference<($Trackable)>
public "startTracking"(): void
public static "startTracking"(arg0: any): void
public static "createWeakRefBasedSet"(): $ObjectOpenCustomHashSet<($WeakReference<($Trackable)>)>
public static "clearNullReferences"(): void
public static "getSummary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
public static "getAllLoadedEntities"(level: $Level$$Type): $Iterable<($Entity)>
public "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
public "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
public "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
public "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
public "getTimeOfDay"(arg0: float): float
public "getMoonBrightness"(): float
public "getMoonPhase"(): integer
public "getMcPlayers"(): $List<($Player)>
public "getPlayers"(): $EntityArrayList
public "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
public "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
public "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
public "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
public "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
public "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
public "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
public "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
public "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
public "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
public "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
public "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
public "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
public "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
public "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
public "getPlayerByUUID"(arg0: $UUID$$Type): $Player
public "enabledFeatures"(): $FeatureFlagSet
public "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
/**
 * 
 * @deprecated
 */
public "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "hasChunkAt"(arg0: $BlockPos$$Type): boolean
public "containsAnyLiquid"(arg0: $AABB$$Type): boolean
public "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
/**
 * 
 * @deprecated
 */
public "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
/**
 * 
 * @deprecated
 */
public "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
public "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
public "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
public "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
public "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
public "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
public "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
public "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
public "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
public "isWaterAt"(arg0: $BlockPos$$Type): boolean
public "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
public "getDisplayName"(): $Component
public "getEntities"(): $EntityArrayList
public "canSeeSky"(arg0: $BlockPos$$Type): boolean
public "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
public "getShade"(arg0: $Direction$$Type, arg1: boolean): float
public "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
public "noCollision"(arg0: $Entity$$Type): boolean
public "noCollision"(arg0: $AABB$$Type): boolean
public "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
public "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
public "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
public "isUnobstructed"(arg0: $Entity$$Type): boolean
public "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
public "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
public "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
public "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
public "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
public "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
public "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
public "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
public "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
public "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
public "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
public "addFreshEntity"(arg0: $Entity$$Type): boolean
public "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
public "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
public "clip"(arg0: $ClipContext$$Type): $BlockHitResult
public "getLightEmission"(arg0: $BlockPos$$Type): integer
public "getMaxLightLevel"(): integer
public "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
public "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
public "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
public "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
public "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
public "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
public "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
public "getModelData"(arg0: $BlockPos$$Type): $ModelData
get "dimensionKey"(): $ResourceKey<($Level)>
get "debug"(): boolean
get "profiler"(): $ProfilerFiller
get "levelData"(): $LevelData
get "worldBorder"(): $WorldBorder
get "time"(): long
get "data"(): $AttachedData
get "clientSide"(): boolean
get "scoreboard"(): $Scoreboard
get "gameRules"(): $GameRules
get "server"(): $MinecraftServer
get "day"(): boolean
get "dayTimeFraction"(): float
get "sharedSpawnPos"(): $BlockPos
get "sharedSpawnAngle"(): float
get "biomeManager"(): $BiomeManager
get "seaLevel"(): integer
get "lightEngine"(): $LevelLightEngine
get "night"(): boolean
set "blockEntity"(value: $BlockEntity$$Type)
get "freeMapId"(): $MapId
get "skyDarken"(): integer
set "skyFlashTime"(value: integer)
get "recipeManager"(): $RecipeManager
get "profilerSupplier"(): $Supplier<($ProfilerFiller)>
get "maxEntityRadius"(): double
get "thundering"(): boolean
get "raining"(): boolean
set "dayTimeFraction"(value: float)
get "dayTimePerTick"(): float
set "dayTimePerTick"(value: float)
get "mcEntities"(): $Iterable
get "thread"(): $Thread
get "chunkSource"(): $ChunkSource
get "difficulty"(): $Difficulty
get "blockTicks"(): $LevelTickAccess<($Block)>
get "fluidTicks"(): $LevelTickAccess<($Fluid)>
get "description"(): $Component
get "partEntities"(): $Collection<($PartEntity<(never)>)>
get "modelDataManager"(): $ModelDataManager
get "descriptionKey"(): StringJS
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "side"(): $ScriptType
get "dimension"(): $ResourceLocation
get "overworld"(): boolean
set "time"(value: long)
get "height"(): integer
get "minBuildHeight"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
public static get "summary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
get "moonBrightness"(): float
get "moonPhase"(): integer
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "displayName"(): $Component
get "entities"(): $EntityArrayList
get "maxLightLevel"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.Dimension
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.DimensionTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Level$$Type = (Special.Dimension);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Level$$Original = $Level;}
declare module "net.minecraft.world.level.block.BaseRailBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$IBaseRailBlockExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBaseRailBlockExtension"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$AbstractMinecart$$Type} from "net.minecraft.world.entity.vehicle.AbstractMinecart"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$RailShape, $RailShape$$Type} from "net.minecraft.world.level.block.state.properties.RailShape"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $BaseRailBlock extends $Block implements $SimpleWaterloggedBlock$$Interface, $IBaseRailBlockExtension$$Interface, $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
/**
 * 
 * @deprecated
 */
public "getShapeProperty"(): $Property<($RailShape)>
public "getRailDirection"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $AbstractMinecart$$Type): $RailShape
public "isStraight"(): boolean
public static "isRail"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public static "isRail"(arg0: $BlockState$$Type): boolean
public "isFlexibleRail"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "canMakeSlopes"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "getRailMaxSpeed"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $AbstractMinecart$$Type): float
public "onMinecartPass"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $AbstractMinecart$$Type): void
public "isValidRailShape"(arg0: $RailShape$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "shapeProperty"(): $Property<($RailShape)>
get "straight"(): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseRailBlock$$Type = ($BaseRailBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseRailBlock$$Original = $BaseRailBlock;}
declare module "net.minecraft.world.level.block.entity.StructureBlockEntity$UpdateType" {
import {$Enum} from "java.lang.Enum"

export class $StructureBlockEntity$UpdateType extends $Enum<($StructureBlockEntity$UpdateType)> {
static readonly "UPDATE_DATA": $StructureBlockEntity$UpdateType
static readonly "SAVE_AREA": $StructureBlockEntity$UpdateType
static readonly "LOAD_AREA": $StructureBlockEntity$UpdateType
static readonly "SCAN_AREA": $StructureBlockEntity$UpdateType

public static "values"(): ($StructureBlockEntity$UpdateType)[]
public static "valueOf"(arg0: StringJS): $StructureBlockEntity$UpdateType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureBlockEntity$UpdateType$$Type = (("update_data") | ("save_area") | ("load_area") | ("scan_area"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureBlockEntity$UpdateType$$Original = $StructureBlockEntity$UpdateType;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter" {
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $FoliagePlacer$FoliageSetter$$Interface {
}

export class $FoliagePlacer$FoliageSetter implements $FoliagePlacer$FoliageSetter$$Interface {
 "set"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): void
 "isSet"(arg0: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoliagePlacer$FoliageSetter$$Type = ($FoliagePlacer$FoliageSetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoliagePlacer$FoliageSetter$$Original = $FoliagePlacer$FoliageSetter;}
declare module "net.minecraft.world.level.block.PumpkinBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PumpkinBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PumpkinBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($PumpkinBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PumpkinBlock$$Type = ($PumpkinBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PumpkinBlock$$Original = $PumpkinBlock;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorType" {
import {$RuleProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleProcessor"
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$NopProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.NopProcessor"
import {$LavaSubmergedBlockProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.LavaSubmergedBlockProcessor"
import {$JigsawReplacementProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.JigsawReplacementProcessor"
import {$GravityProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.GravityProcessor"
import {$BlockIgnoreProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.BlockIgnoreProcessor"
import {$Holder} from "net.minecraft.core.Holder"
import {$CappedProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.CappedProcessor"
import {$BlockAgeProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.BlockAgeProcessor"
import {$StructureProcessorList} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorList"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlackstoneReplaceProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.BlackstoneReplaceProcessor"
import {$BlockRotProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.BlockRotProcessor"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ProtectedBlockProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.ProtectedBlockProcessor"

export interface $StructureProcessorType$$Interface<P extends $StructureProcessor> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructureProcessor
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructureProcessorTag
}

export class $StructureProcessorType<P extends $StructureProcessor> implements $StructureProcessorType$$Interface {
static readonly "BLOCK_AGE": $StructureProcessorType<($BlockAgeProcessor)>
static readonly "BLACKSTONE_REPLACE": $StructureProcessorType<($BlackstoneReplaceProcessor)>
static readonly "BLOCK_ROT": $StructureProcessorType<($BlockRotProcessor)>
static readonly "DIRECT_CODEC": $Codec<($StructureProcessorList)>
static readonly "LAVA_SUBMERGED_BLOCK": $StructureProcessorType<($LavaSubmergedBlockProcessor)>
static readonly "GRAVITY": $StructureProcessorType<($GravityProcessor)>
static readonly "JIGSAW_REPLACEMENT": $StructureProcessorType<($JigsawReplacementProcessor)>
static readonly "NOP": $StructureProcessorType<($NopProcessor)>
static readonly "BLOCK_IGNORE": $StructureProcessorType<($BlockIgnoreProcessor)>
static readonly "PROTECTED_BLOCKS": $StructureProcessorType<($ProtectedBlockProcessor)>
static readonly "CAPPED": $StructureProcessorType<($CappedProcessor)>
static readonly "LIST_OBJECT_CODEC": $Codec<($StructureProcessorList)>
static readonly "LIST_CODEC": $Codec<($Holder<($StructureProcessorList)>)>
static readonly "RULE": $StructureProcessorType<($RuleProcessor)>
static readonly "SINGLE_CODEC": $Codec<($StructureProcessor)>

static "register"<P extends $StructureProcessor>(arg0: StringJS, arg1: $MapCodec$$Type<(P)>): $StructureProcessorType<(P)>
 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureProcessorType$$Type<P> = (Special.WorldgenStructureProcessor) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureProcessorType$$Original<P> = $StructureProcessorType<(P)>;}
declare module "net.minecraft.world.level.levelgen.placement.SurfaceWaterDepthFilter" {
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$PlacementFilter} from "net.minecraft.world.level.levelgen.placement.PlacementFilter"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SurfaceWaterDepthFilter extends $PlacementFilter {
static readonly "CODEC": $MapCodec<($SurfaceWaterDepthFilter)>

public static "forMaxDepth"(arg0: integer): $SurfaceWaterDepthFilter
public "type"(): $PlacementModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceWaterDepthFilter$$Type = ($SurfaceWaterDepthFilter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SurfaceWaterDepthFilter$$Original = $SurfaceWaterDepthFilter;}
declare module "net.minecraft.world.level.levelgen.structure.structures.NetherFortressStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$WeightedRandomList} from "net.minecraft.util.random.WeightedRandomList"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MobSpawnSettings$SpawnerData} from "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $NetherFortressStructure extends $Structure {
static readonly "FORTRESS_ENEMIES": $WeightedRandomList<($MobSpawnSettings$SpawnerData)>
static readonly "CODEC": $MapCodec<($NetherFortressStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherFortressStructure$$Type = ($NetherFortressStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherFortressStructure$$Original = $NetherFortressStructure;}
declare module "net.minecraft.world.level.levelgen.heightproviders.UniformHeight" {
import {$HeightProviderType} from "net.minecraft.world.level.levelgen.heightproviders.HeightProviderType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $UniformHeight extends $HeightProvider {
static readonly "CODEC": $MapCodec<($UniformHeight)>

public "toString"(): StringJS
public static "of"(arg0: $VerticalAnchor$$Type, arg1: $VerticalAnchor$$Type): $UniformHeight
public "getType"(): $HeightProviderType<(never)>
public "sample"(arg0: $RandomSource$$Type, arg1: $WorldGenerationContext$$Type): integer
get "type"(): $HeightProviderType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniformHeight$$Type = ($UniformHeight);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UniformHeight$$Original = $UniformHeight;}
declare module "net.minecraft.world.level.block.MultifaceSpreader$SpreadPredicate" {
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$MultifaceSpreader$SpreadPos, $MultifaceSpreader$SpreadPos$$Type} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadPos"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export interface $MultifaceSpreader$SpreadPredicate$$Interface {

(arg0: $BlockGetter, arg1: $BlockPos, arg2: $MultifaceSpreader$SpreadPos): boolean
}

export class $MultifaceSpreader$SpreadPredicate implements $MultifaceSpreader$SpreadPredicate$$Interface {
 "test"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $MultifaceSpreader$SpreadPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceSpreader$SpreadPredicate$$Type = ((arg0: $BlockGetter, arg1: $BlockPos, arg2: $MultifaceSpreader$SpreadPos) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceSpreader$SpreadPredicate$$Original = $MultifaceSpreader$SpreadPredicate;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType" {
import {$DualNoiseProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.DualNoiseProvider"
import {$RandomizedIntStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.RandomizedIntStateProvider"
import {$NoiseThresholdProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseThresholdProvider"
import {$WeightedStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.WeightedStateProvider"
import {$BlockStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$NoiseProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseProvider"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$SimpleStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.SimpleStateProvider"
import {$RotatedBlockProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.RotatedBlockProvider"

export class $BlockStateProviderType<P extends $BlockStateProvider> {
static readonly "RANDOMIZED_INT_STATE_PROVIDER": $BlockStateProviderType<($RandomizedIntStateProvider)>
static readonly "DUAL_NOISE_PROVIDER": $BlockStateProviderType<($DualNoiseProvider)>
static readonly "ROTATED_BLOCK_PROVIDER": $BlockStateProviderType<($RotatedBlockProvider)>
static readonly "SIMPLE_STATE_PROVIDER": $BlockStateProviderType<($SimpleStateProvider)>
static readonly "WEIGHTED_STATE_PROVIDER": $BlockStateProviderType<($WeightedStateProvider)>
static readonly "NOISE_THRESHOLD_PROVIDER": $BlockStateProviderType<($NoiseThresholdProvider)>
static readonly "NOISE_PROVIDER": $BlockStateProviderType<($NoiseProvider)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenBlockStateProviderType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenBlockStateProviderTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateProviderType$$Type<P> = (Special.WorldgenBlockStateProviderType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateProviderType$$Original<P> = $BlockStateProviderType<(P)>;}
declare module "net.minecraft.world.level.entity.PersistentEntitySectionManager" {
import {$EntitySectionStorage} from "net.minecraft.world.level.entity.EntitySectionStorage"
import {$UUID$$Type} from "java.util.UUID"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$Long2ObjectMap} from "it.unimi.dsi.fastutil.longs.Long2ObjectMap"
import {$Visibility, $Visibility$$Type} from "net.minecraft.world.level.entity.Visibility"
import {$PersistentEntitySectionManagerAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.util.accessors.PersistentEntitySectionManagerAccessor"
import {$LevelEntityGetter} from "net.minecraft.world.level.entity.LevelEntityGetter"
import {$LevelCallback$$Type} from "net.minecraft.world.level.entity.LevelCallback"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$FullChunkStatus$$Type} from "net.minecraft.server.level.FullChunkStatus"
import {$EntityPersistentStorage, $EntityPersistentStorage$$Type} from "net.minecraft.world.level.entity.EntityPersistentStorage"
import {$Writer$$Type} from "java.io.Writer"
import {$PersistentEntitySectionManagerAccessor$$Interface as $PersistentEntitySectionManagerAccessor$0$$Interface} from "net.caffeinemc.mods.lithium.mixin.minimal_nonvanilla.spawning.PersistentEntitySectionManagerAccessor"
import {$EntityAccess, $EntityAccess$$Type} from "net.minecraft.world.level.entity.EntityAccess"
import {$PersistentEntitySectionManagerAccessor$$Interface as $PersistentEntitySectionManagerAccessor$1$$Interface} from "net.caffeinemc.mods.lithium.mixin.util.entity_movement_tracking.PersistentEntitySectionManagerAccessor"
import {$Class$$Type} from "java.lang.Class"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream$$Type} from "java.util.stream.Stream"

export class $PersistentEntitySectionManager<T extends $EntityAccess> implements $AutoCloseable$$Interface, $PersistentEntitySectionManagerAccessor$0$$Interface, $PersistentEntitySectionManagerAccessor$$Interface, $PersistentEntitySectionManagerAccessor$1$$Interface {
readonly "chunkVisibility": $Long2ObjectMap<($Visibility)>
readonly "permanentStorage": $EntityPersistentStorage<(T)>

constructor(arg0: $Class$$Type<(T)>, arg1: $LevelCallback$$Type<(T)>, arg2: $EntityPersistentStorage$$Type<(T)>)

public "updateChunkStatus"(arg0: $ChunkPos$$Type, arg1: $Visibility$$Type): void
public "updateChunkStatus"(arg0: $ChunkPos$$Type, arg1: $FullChunkStatus$$Type): void
public "saveAll"(): void
public "autoSave"(): void
public "addNewEntityWithoutEvent"(arg0: T): boolean
public "addNewEntity"(arg0: T): boolean
public "dumpSections"(arg0: $Writer$$Type): void
public "addLegacyChunkEntities"(arg0: $Stream$$Type<(T)>): void
public "addWorldGenChunkEntities"(arg0: $Stream$$Type<(T)>): void
public "areEntitiesLoaded"(arg0: long): boolean
public "canPositionTick"(arg0: $BlockPos$$Type): boolean
public "canPositionTick"(arg0: $ChunkPos$$Type): boolean
public "getCache"(): $EntitySectionStorage
public "tick"(): void
public "count"(): integer
public "close"(): void
public "isLoaded"(arg0: $UUID$$Type): boolean
public "gatherStats"(): StringJS
public "getEntityGetter"(): $LevelEntityGetter<(T)>
get "cache"(): $EntitySectionStorage
get "entityGetter"(): $LevelEntityGetter<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PersistentEntitySectionManager$$Type<T> = ($PersistentEntitySectionManager<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PersistentEntitySectionManager$$Original<T> = $PersistentEntitySectionManager<(T)>;}
declare module "net.minecraft.world.level.block.BonemealableBlock$Type" {
import {$Enum} from "java.lang.Enum"

export class $BonemealableBlock$Type extends $Enum<($BonemealableBlock$Type)> {
static readonly "GROWER": $BonemealableBlock$Type
static readonly "NEIGHBOR_SPREADER": $BonemealableBlock$Type

public static "values"(): ($BonemealableBlock$Type)[]
public static "valueOf"(arg0: StringJS): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BonemealableBlock$Type$$Type = (("neighbor_spreader") | ("grower"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BonemealableBlock$Type$$Original = $BonemealableBlock$Type;}
declare module "net.minecraft.world.level.block.SculkSpreader$ChargeCursor" {
import {$SculkSpreader$$Type} from "net.minecraft.world.level.block.SculkSpreader"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Direction} from "net.minecraft.core.Direction"
import {$Set} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $SculkSpreader$ChargeCursor {
static readonly "CODEC": $Codec<($SculkSpreader$ChargeCursor)>
static readonly "MAX_CURSOR_DECAY_DELAY": integer

constructor(arg0: $BlockPos$$Type, arg1: integer)

public "getFacingData"(): $Set<($Direction)>
public "getCharge"(): integer
public "getDecayDelay"(): integer
public "update"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type, arg3: $SculkSpreader$$Type, arg4: boolean): void
public "getPos"(): $BlockPos
get "facingData"(): $Set<($Direction)>
get "charge"(): integer
get "decayDelay"(): integer
get "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkSpreader$ChargeCursor$$Type = ($SculkSpreader$ChargeCursor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkSpreader$ChargeCursor$$Original = $SculkSpreader$ChargeCursor;}
declare module "net.minecraft.world.level.block.MangroveRootsBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$LeavesCulling$$Interface} from "ca.fxco.moreculling.api.block.LeavesCulling"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $MangroveRootsBlock extends $Block implements $SimpleWaterloggedBlock$$Interface, $LeavesCulling$$Interface, $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($MangroveRootsBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "moreculling$customShouldDrawFace"(arg0: $BlockGetter$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: $Direction$$Type): $Optional
public "moreculling$usesCustomShouldDrawFace"(arg0: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($MangroveRootsBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MangroveRootsBlock$$Type = ($MangroveRootsBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MangroveRootsBlock$$Original = $MangroveRootsBlock;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration" {
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"

export interface $FeatureConfiguration$$Interface {
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}

export class $FeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "NONE": $NoneFeatureConfiguration

 "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeatureConfiguration$$Type = ($FeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeatureConfiguration$$Original = $FeatureConfiguration;}
declare module "net.minecraft.world.level.levelgen.feature.DripstoneClusterFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration, $DripstoneClusterConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $DripstoneClusterFeature extends $Feature<($DripstoneClusterConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($DripstoneClusterConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($DripstoneClusterConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DripstoneClusterFeature$$Type = ($DripstoneClusterFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DripstoneClusterFeature$$Original = $DripstoneClusterFeature;}
declare module "net.minecraft.world.level.biome.BiomeManager$NoiseBiomeSource" {
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export interface $BiomeManager$NoiseBiomeSource$$Interface {

(arg0: integer, arg1: integer, arg2: integer): $Holder$$Type<($Biome$$Type)>
}

export class $BiomeManager$NoiseBiomeSource implements $BiomeManager$NoiseBiomeSource$$Interface {
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeManager$NoiseBiomeSource$$Type = ((arg0: integer, arg1: integer, arg2: integer) => $Holder$$Type<($Biome$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeManager$NoiseBiomeSource$$Original = $BiomeManager$NoiseBiomeSource;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Data" {
import {$VibrationInfo, $VibrationInfo$$Type} from "net.minecraft.world.level.gameevent.vibrations.VibrationInfo"
import {$Codec} from "com.mojang.serialization.Codec"
import {$VibrationSelector} from "net.minecraft.world.level.gameevent.vibrations.VibrationSelector"

export class $VibrationSystem$Data {
static "CODEC": $Codec<($VibrationSystem$Data)>
static readonly "NBT_TAG_KEY": StringJS

constructor()

public "getSelectionStrategy"(): $VibrationSelector
public "getCurrentVibration"(): $VibrationInfo
public "shouldReloadVibrationParticle"(): boolean
public "setCurrentVibration"(arg0: $VibrationInfo$$Type): void
public "getTravelTimeInTicks"(): integer
public "setTravelTimeInTicks"(arg0: integer): void
public "decrementTravelTime"(): void
public "setReloadVibrationParticle"(arg0: boolean): void
get "selectionStrategy"(): $VibrationSelector
get "currentVibration"(): $VibrationInfo
set "currentVibration"(value: $VibrationInfo$$Type)
get "travelTimeInTicks"(): integer
set "travelTimeInTicks"(value: integer)
set "reloadVibrationParticle"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationSystem$Data$$Type = ($VibrationSystem$Data);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationSystem$Data$$Original = $VibrationSystem$Data;}
declare module "net.minecraft.world.level.block.entity.SculkShriekerBlockEntity" {
import {$VibrationSystem$Data} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Data"
import {$GameEventListener$Provider$$Interface} from "net.minecraft.world.level.gameevent.GameEventListener$Provider"
import {$VibrationSystem$Listener} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Listener"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$VibrationSystem$User} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$User"
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$VibrationSystem$$Interface} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SculkShriekerBlockEntity extends $BlockEntity implements $GameEventListener$Provider$$Interface<($VibrationSystem$Listener)>, $VibrationSystem$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getVibrationUser"(): $VibrationSystem$User
public "getVibrationData"(): $VibrationSystem$Data
public static "tryGetPlayer"(arg0: $Entity$$Type): $ServerPlayer
public "tryRespond"(arg0: $ServerLevel$$Type): void
public "tryShriek"(arg0: $ServerLevel$$Type, arg1: $ServerPlayer$$Type): void
public "getListener"(): $VibrationSystem$Listener
public static "getResonanceEventByFrequency"(arg0: integer): $ResourceKey<($GameEvent)>
public static "getGameEventFrequency"(arg0: $ResourceKey$$Type<($GameEvent)>): integer
public static "getGameEventFrequency"(arg0: $Holder$$Type<($GameEvent)>): integer
public static "getRedstoneStrengthForDistance"(arg0: float, arg1: integer): integer
get "vibrationUser"(): $VibrationSystem$User
get "vibrationData"(): $VibrationSystem$Data
get "listener"(): $VibrationSystem$Listener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkShriekerBlockEntity$$Type = ($SculkShriekerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkShriekerBlockEntity$$Original = $SculkShriekerBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.SpikeFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$List} from "java.util.List"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration, $SpikeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$SpikeFeature$EndSpike} from "net.minecraft.world.level.levelgen.feature.SpikeFeature$EndSpike"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $SpikeFeature extends $Feature<($SpikeConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "NUMBER_OF_SPIKES": integer
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($SpikeConfiguration$$Type)>)

public static "getSpikesForLevel"(arg0: $WorldGenLevel$$Type): $List<($SpikeFeature$EndSpike)>
public "place"(arg0: $FeaturePlaceContext$$Type<($SpikeConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpikeFeature$$Type = ($SpikeFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpikeFeature$$Original = $SpikeFeature;}
declare module "net.minecraft.world.level.block.TntBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TntBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TntBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "UNSTABLE": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "wasExploded"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): void
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "dropFromExplosion"(arg0: $Explosion$$Type): boolean
public "onCaughtFire"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $LivingEntity$$Type): void
public "codec"(): $MapCodec<($TntBlock)>
/**
 * 
 * @deprecated
 */
public static "explode"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TntBlock$$Type = ($TntBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TntBlock$$Original = $TntBlock;}
declare module "net.minecraft.world.level.storage.LevelData" {
import {$GameRules} from "net.minecraft.world.level.GameRules"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$CrashReportCategory$$Type} from "net.minecraft.CrashReportCategory"

export interface $LevelData$$Interface {
get "difficultyLocked"(): boolean
set "raining"(value: boolean)
get "hardcore"(): boolean
get "gameTime"(): long
get "difficulty"(): $Difficulty
get "gameRules"(): $GameRules
get "dayTime"(): long
get "spawnPos"(): $BlockPos
get "spawnAngle"(): float
get "thundering"(): boolean
get "raining"(): boolean
}

export class $LevelData implements $LevelData$$Interface {
 "isDifficultyLocked"(): boolean
 "setRaining"(arg0: boolean): void
 "isHardcore"(): boolean
 "getGameTime"(): long
 "getDifficulty"(): $Difficulty
 "getGameRules"(): $GameRules
 "getDayTime"(): long
 "fillCrashReportCategory"(arg0: $CrashReportCategory$$Type, arg1: $LevelHeightAccessor$$Type): void
 "getSpawnPos"(): $BlockPos
 "getSpawnAngle"(): float
 "isThundering"(): boolean
 "isRaining"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelData$$Type = ($LevelData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelData$$Original = $LevelData;}
declare module "net.minecraft.world.level.block.LeverBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$FaceAttachedHorizontalDirectionalBlock} from "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LeverBlock extends $FaceAttachedHorizontalDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LeverBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($AttachFace)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "pull"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): void
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($LeverBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LeverBlock$$Type = ($LeverBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LeverBlock$$Original = $LeverBlock;}
declare module "net.minecraft.world.level.block.BarrelBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BarrelBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BarrelBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($BarrelBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BarrelBlock$$Type = ($BarrelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BarrelBlock$$Original = $BarrelBlock;}
declare module "net.minecraft.world.level.DataPackConfig" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$List, $List$$Type} from "java.util.List"

export class $DataPackConfig {
static readonly "CODEC": $Codec<($DataPackConfig)>
static readonly "DEFAULT": $DataPackConfig

constructor(arg0: $List$$Type<(StringJS)>, arg1: $List$$Type<(StringJS)>)

public "getEnabled"(): $List<(StringJS)>
public "getDisabled"(): $List<(StringJS)>
public "addModPacks"(arg0: $List$$Type<(StringJS)>): void
get "enabled"(): $List<(StringJS)>
get "disabled"(): $List<(StringJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataPackConfig$$Type = ($DataPackConfig);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataPackConfig$$Original = $DataPackConfig;}
declare module "net.minecraft.world.level.block.GrassBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$SpreadingSnowyDirtBlock} from "net.minecraft.world.level.block.SpreadingSnowyDirtBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $GrassBlock extends $SpreadingSnowyDirtBlock implements $BonemealableBlock$$Interface {
static readonly "SNOWY": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($GrassBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getType"(): $BonemealableBlock$Type
public "codec"(): $MapCodec<($GrassBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GrassBlock$$Type = ($GrassBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GrassBlock$$Original = $GrassBlock;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseThresholdProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List$$Type} from "java.util.List"
import {$NoiseBasedStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseBasedStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NoiseThresholdProvider extends $NoiseBasedStateProvider {
static readonly "CODEC": $MapCodec<($NoiseThresholdProvider)>

constructor(arg0: long, arg1: $NormalNoise$NoiseParameters$$Type, arg2: float, arg3: float, arg4: float, arg5: $BlockState$$Type, arg6: $List$$Type<($BlockState$$Type)>, arg7: $List$$Type<($BlockState$$Type)>)

public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseThresholdProvider$$Type = ($NoiseThresholdProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseThresholdProvider$$Original = $NoiseThresholdProvider;}
declare module "net.minecraft.world.level.block.VineBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$IShearable$$Interface} from "net.neoforged.neoforge.common.IShearable"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $VineBlock extends $Block implements $IShearable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($VineBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($BooleanProperty)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UP": $BooleanProperty
static readonly "SOUTH": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "EAST": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "isAcceptableNeighbour"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public static "getPropertyForFace"(arg0: $Direction$$Type): $BooleanProperty
public "codec"(): $MapCodec<($VineBlock)>
public "onSheared"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): $List<($ItemStack)>
public "isShearable"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): boolean
public "handler$cik000$apothic_enchanting$apoth_handleShearFortune"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "handler$cik000$apothic_enchanting$apoth_handleShearEnchantments"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "spawnShearedDrop"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VineBlock$$Type = ($VineBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VineBlock$$Original = $VineBlock;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BooleanProperty$$Type} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelSimulatedReader, $LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$ObjectArrayList} from "it.unimi.dsi.fastutil.objects.ObjectArrayList"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TreeDecorator$Context {
constructor(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $Set$$Type<($BlockPos$$Type)>, arg4: $Set$$Type<($BlockPos$$Type)>, arg5: $Set$$Type<($BlockPos$$Type)>)

public "leaves"(): $ObjectArrayList<($BlockPos)>
public "logs"(): $ObjectArrayList<($BlockPos)>
public "placeVine"(arg0: $BlockPos$$Type, arg1: $BooleanProperty$$Type): void
public "level"(): $LevelSimulatedReader
public "roots"(): $ObjectArrayList<($BlockPos)>
public "random"(): $RandomSource
public "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): void
public "isAir"(arg0: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeDecorator$Context$$Type = ($TreeDecorator$Context);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeDecorator$Context$$Original = $TreeDecorator$Context;}
declare module "net.minecraft.world.level.levelgen.structure.structures.ShipwreckStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $ShipwreckStructure extends $Structure {
static readonly "CODEC": $MapCodec<($ShipwreckStructure)>
readonly "isBeached": boolean
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type, arg1: boolean)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShipwreckStructure$$Type = ($ShipwreckStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShipwreckStructure$$Original = $ShipwreckStructure;}
declare module "net.minecraft.world.level.material.MapColor$Brightness" {
import {$Enum} from "java.lang.Enum"

export class $MapColor$Brightness extends $Enum<($MapColor$Brightness)> {
static readonly "LOWEST": $MapColor$Brightness
static readonly "HIGH": $MapColor$Brightness
static readonly "LOW": $MapColor$Brightness
readonly "modifier": integer
readonly "id": integer
static readonly "NORMAL": $MapColor$Brightness

public static "values"(): ($MapColor$Brightness)[]
public static "valueOf"(arg0: StringJS): $MapColor$Brightness
public static "byId"(arg0: integer): $MapColor$Brightness
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapColor$Brightness$$Type = (("low") | ("normal") | ("high") | ("lowest"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapColor$Brightness$$Original = $MapColor$Brightness;}
declare module "net.minecraft.world.level.storage.LevelDataAndDimensions" {
import {$WorldData, $WorldData$$Type} from "net.minecraft.world.level.storage.WorldData"
import {$WorldDimensions$Complete, $WorldDimensions$Complete$$Type} from "net.minecraft.world.level.levelgen.WorldDimensions$Complete"
import {$Record} from "java.lang.Record"

export class $LevelDataAndDimensions extends $Record {
constructor(arg0: $WorldData$$Type, arg1: $WorldDimensions$Complete$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "dimensions"(): $WorldDimensions$Complete
public "worldData"(): $WorldData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelDataAndDimensions$$Type = ({"worldData"?: $WorldData$$Type, "dimensions"?: $WorldDimensions$Complete$$Type}) | ([worldData?: $WorldData$$Type, dimensions?: $WorldDimensions$Complete$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelDataAndDimensions$$Original = $LevelDataAndDimensions;}
declare module "net.minecraft.world.level.block.state.properties.DripstoneThickness" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $DripstoneThickness extends $Enum<($DripstoneThickness)> implements $StringRepresentable$$Interface {
static readonly "TIP_MERGE": $DripstoneThickness
static readonly "FRUSTUM": $DripstoneThickness
static readonly "TIP": $DripstoneThickness
static readonly "MIDDLE": $DripstoneThickness
static readonly "BASE": $DripstoneThickness

public "toString"(): StringJS
public static "values"(): ($DripstoneThickness)[]
public static "valueOf"(arg0: StringJS): $DripstoneThickness
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DripstoneThickness$$Type = (("tip_merge") | ("tip") | ("frustum") | ("middle") | ("base"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DripstoneThickness$$Original = $DripstoneThickness;}
declare module "net.minecraft.world.level.entity.EntityTickList" {
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $EntityTickList {
constructor()

public "remove"(arg0: $Entity$$Type): void
public "add"(arg0: $Entity$$Type): void
public "contains"(arg0: $Entity$$Type): boolean
public "forEach"(arg0: $Consumer$$Type<($Entity)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTickList$$Type = ($EntityTickList);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityTickList$$Original = $EntityTickList;}
declare module "net.minecraft.world.level.levelgen.feature.SeaPickleFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration, $CountConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $SeaPickleFeature extends $Feature<($CountConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($CountConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($CountConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeaPickleFeature$$Type = ($SeaPickleFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SeaPickleFeature$$Original = $SeaPickleFeature;}
declare module "net.minecraft.world.level.levelgen.placement.PlacementModifier" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$Codec} from "com.mojang.serialization.Codec"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"

export class $PlacementModifier {
static readonly "CODEC": $Codec<($PlacementModifier)>

constructor()

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
public "type"(): $PlacementModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacementModifier$$Type = ($PlacementModifier);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacementModifier$$Original = $PlacementModifier;}
declare module "net.minecraft.world.level.border.WorldBorder" {
import {$List} from "java.util.List"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$WorldBorder$Settings, $WorldBorder$Settings$$Type} from "net.minecraft.world.level.border.WorldBorder$Settings"
import {$Operation$$Type} from "com.llamalad7.mixinextras.injector.wrapoperation.Operation"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BorderStatus} from "net.minecraft.world.level.border.BorderStatus"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WorldBorder$BorderExtent, $WorldBorder$BorderExtent$$Type} from "net.minecraft.world.level.border.WorldBorder$BorderExtent"
import {$BorderChangeListener, $BorderChangeListener$$Type} from "net.minecraft.world.level.border.BorderChangeListener"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export class $WorldBorder {
readonly "listeners": $List<($BorderChangeListener)>
static readonly "DEFAULT_SETTINGS": $WorldBorder$Settings
static readonly "MAX_SIZE": double
static readonly "MAX_CENTER_COORDINATE": double

constructor()

public "setAbsoluteMaxSize"(arg0: integer): void
public "clampToBounds"(arg0: double, arg1: double, arg2: double): $BlockPos
public "clampToBounds"(arg0: $BlockPos$$Type): $BlockPos
public "clampToBounds"(arg0: $Vec3$$Type): $BlockPos
public "getMaxX"(): double
public "getMinZ"(): double
public "getMaxZ"(): double
public "setCenter"(arg0: double, arg1: double): void
public "getLerpRemainingTime"(): long
public "getLerpTarget"(): double
public "lerpSizeBetween"(arg0: double, arg1: double, arg2: long): void
public "getAbsoluteMaxSize"(): integer
public "setDamageSafeZone"(arg0: double): void
public "setDamagePerBlock"(arg0: double): void
public "getLerpSpeed"(): double
public "getWarningTime"(): integer
public "setWarningTime"(arg0: integer): void
public "getWarningBlocks"(): integer
public "setWarningBlocks"(arg0: integer): void
public "wrapOperation$djd000$lithium$getUpdatedArea"(arg0: $WorldBorder$BorderExtent$$Type, arg1: $Operation$$Type): $WorldBorder$BorderExtent
public "createSettings"(): $WorldBorder$Settings
public "applySettings"(arg0: $WorldBorder$Settings$$Type): void
public "setSize"(arg0: double): void
public "getMinX"(): double
public "tick"(): void
public "getSize"(): double
public "removeListener"(arg0: $BorderChangeListener$$Type): void
public "addListener"(arg0: $BorderChangeListener$$Type): void
public "getStatus"(): $BorderStatus
public "isWithinBounds"(arg0: $Vec3$$Type): boolean
public "isWithinBounds"(arg0: $AABB$$Type): boolean
public "isWithinBounds"(arg0: $ChunkPos$$Type): boolean
public "isWithinBounds"(arg0: double, arg1: double): boolean
public "isWithinBounds"(arg0: $BlockPos$$Type): boolean
public "isWithinBounds"(arg0: double, arg1: double, arg2: double): boolean
public "getCollisionShape"(): $VoxelShape
public "getDistanceToBorder"(arg0: double, arg1: double): double
public "getDistanceToBorder"(arg0: $Entity$$Type): double
public "getDamageSafeZone"(): double
public "getDamagePerBlock"(): double
public "isInsideCloseToBorder"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "getCenterX"(): double
public "getCenterZ"(): double
set "absoluteMaxSize"(value: integer)
get "maxX"(): double
get "minZ"(): double
get "maxZ"(): double
get "lerpRemainingTime"(): long
get "lerpTarget"(): double
get "absoluteMaxSize"(): integer
set "damageSafeZone"(value: double)
set "damagePerBlock"(value: double)
get "lerpSpeed"(): double
get "warningTime"(): integer
set "warningTime"(value: integer)
get "warningBlocks"(): integer
set "warningBlocks"(value: integer)
set "size"(value: double)
get "minX"(): double
get "size"(): double
get "status"(): $BorderStatus
get "collisionShape"(): $VoxelShape
get "damageSafeZone"(): double
get "damagePerBlock"(): double
get "centerX"(): double
get "centerZ"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldBorder$$Type = ($WorldBorder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldBorder$$Original = $WorldBorder;}
declare module "net.minecraft.world.level.block.SnowyDirtBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $SnowyDirtBlock extends $Block {
static readonly "SNOWY": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SnowyDirtBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SnowyDirtBlock$$Type = ($SnowyDirtBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SnowyDirtBlock$$Original = $SnowyDirtBlock;}
declare module "net.minecraft.world.level.block.CaveVinesBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$CaveVines$$Interface} from "net.minecraft.world.level.block.CaveVines"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ToIntFunction} from "java.util.function.ToIntFunction"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GrowingPlantHeadBlock} from "net.minecraft.world.level.block.GrowingPlantHeadBlock"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CaveVinesBlock extends $GrowingPlantHeadBlock implements $BonemealableBlock$$Interface, $CaveVines$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CaveVinesBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($CaveVinesBlock)>
public static "emission"(arg0: integer): $ToIntFunction<($BlockState)>
public static "hasGlowBerries"(arg0: $BlockState$$Type): boolean
public static "use"(arg0: $Entity$$Type, arg1: $BlockState$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaveVinesBlock$$Type = ($CaveVinesBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CaveVinesBlock$$Original = $CaveVinesBlock;}
declare module "net.minecraft.world.level.block.BrushableBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Fallable$$Interface} from "net.minecraft.world.level.block.Fallable"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BrushableBlock extends $BaseEntityBlock implements $Fallable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BrushableBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "TICK_DELAY": integer
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $Block$$Type, arg1: $SoundEvent$$Type, arg2: $SoundEvent$$Type, arg3: $BlockBehaviour$Properties$$Type)

public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getTurnsInto"(): $Block
public "getBrushSound"(): $SoundEvent
public "getBrushCompletedSound"(): $SoundEvent
public "onBrokenAfterFall"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FallingBlockEntity$$Type): void
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($BrushableBlock)>
public "onLand"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $FallingBlockEntity$$Type): void
public "getFallDamageSource"(arg0: $Entity$$Type): $DamageSource
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "turnsInto"(): $Block
get "brushSound"(): $SoundEvent
get "brushCompletedSound"(): $SoundEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrushableBlock$$Type = ($BrushableBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BrushableBlock$$Original = $BrushableBlock;}
declare module "net.minecraft.world.level.storage.loot.providers.number.LootNumberProviderType" {
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$NumberProvider, $NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Record} from "java.lang.Record"

export class $LootNumberProviderType extends $Record {
constructor(arg0: $MapCodec$$Type<($NumberProvider$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "codec"(): $MapCodec<($NumberProvider)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.LootNumberProviderType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.LootNumberProviderTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootNumberProviderType$$Type = (Special.LootNumberProviderType) | ({"codec"?: $MapCodec$$Type<($NumberProvider$$Type)>}) | ([codec?: $MapCodec$$Type<($NumberProvider$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootNumberProviderType$$Original = $LootNumberProviderType;}
declare module "net.minecraft.world.level.ClipBlockStateContext" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ClipBlockStateContext {
constructor(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $Predicate$$Type<($BlockState)>)

public "getFrom"(): $Vec3
public "getTo"(): $Vec3
public "isTargetBlock"(): $Predicate<($BlockState)>
get "from"(): $Vec3
get "to"(): $Vec3
get "targetBlock"(): $Predicate<($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipBlockStateContext$$Type = ($ClipBlockStateContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipBlockStateContext$$Original = $ClipBlockStateContext;}
declare module "net.minecraft.world.level.levelgen.feature.RandomSelectorFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration, $RandomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $RandomSelectorFeature extends $Feature<($RandomFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($RandomFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($RandomFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomSelectorFeature$$Type = ($RandomSelectorFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomSelectorFeature$$Original = $RandomSelectorFeature;}
declare module "net.minecraft.world.level.levelgen.structure.pools.LegacySinglePoolElement" {
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$SinglePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.SinglePoolElement"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $LegacySinglePoolElement extends $SinglePoolElement {
static readonly "CODEC": $MapCodec<($LegacySinglePoolElement)>

public "toString"(): StringJS
public "getType"(): $StructurePoolElementType<(never)>
get "type"(): $StructurePoolElementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacySinglePoolElement$$Type = ($LegacySinglePoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LegacySinglePoolElement$$Original = $LegacySinglePoolElement;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$GeodeLayerSettings, $GeodeLayerSettings$$Type} from "net.minecraft.world.level.levelgen.GeodeLayerSettings"
import {$GeodeCrackSettings, $GeodeCrackSettings$$Type} from "net.minecraft.world.level.levelgen.GeodeCrackSettings"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$GeodeBlockSettings, $GeodeBlockSettings$$Type} from "net.minecraft.world.level.levelgen.GeodeBlockSettings"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $GeodeConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($GeodeConfiguration)>
readonly "geodeLayerSettings": $GeodeLayerSettings
readonly "useAlternateLayer0Chance": double
readonly "pointOffset": $IntProvider
readonly "minGenOffset": integer
readonly "noiseMultiplier": double
readonly "maxGenOffset": integer
readonly "usePotentialPlacementsChance": double
readonly "geodeBlockSettings": $GeodeBlockSettings
readonly "geodeCrackSettings": $GeodeCrackSettings
readonly "invalidBlocksThreshold": integer
readonly "placementsRequireLayer0Alternate": boolean
static readonly "CHANCE_RANGE": $Codec<(double)>
readonly "distributionPoints": $IntProvider
readonly "outerWallDistance": $IntProvider

constructor(arg0: $GeodeBlockSettings$$Type, arg1: $GeodeLayerSettings$$Type, arg2: $GeodeCrackSettings$$Type, arg3: double, arg4: double, arg5: boolean, arg6: $IntProvider$$Type, arg7: $IntProvider$$Type, arg8: $IntProvider$$Type, arg9: integer, arg10: integer, arg11: double, arg12: integer)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeConfiguration$$Type = ($GeodeConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeodeConfiguration$$Original = $GeodeConfiguration;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$User" {
import {$PositionSource} from "net.minecraft.world.level.gameevent.PositionSource"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export interface $VibrationSystem$User$$Interface {
get "positionSource"(): $PositionSource
get "listenableEvents"(): $TagKey<($GameEvent)>
get "listenerRadius"(): integer
}

export class $VibrationSystem$User implements $VibrationSystem$User$$Interface {
 "canReceiveVibration"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $Holder$$Type<($GameEvent)>, arg3: $GameEvent$Context$$Type): boolean
 "getPositionSource"(): $PositionSource
 "requiresAdjacentChunksToBeTicking"(): boolean
 "getListenableEvents"(): $TagKey<($GameEvent)>
 "canTriggerAvoidVibration"(): boolean
 "getListenerRadius"(): integer
 "onReceiveVibration"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $Holder$$Type<($GameEvent)>, arg3: $Entity$$Type, arg4: $Entity$$Type, arg5: float): void
 "calculateTravelTimeInTicks"(arg0: float): integer
 "isValidVibration"(arg0: $Holder$$Type<($GameEvent)>, arg1: $GameEvent$Context$$Type): boolean
 "onDataChanged"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationSystem$User$$Type = ($VibrationSystem$User);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationSystem$User$$Original = $VibrationSystem$User;}
declare module "net.minecraft.world.level.levelgen.feature.EndIslandFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $EndIslandFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndIslandFeature$$Type = ($EndIslandFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndIslandFeature$$Original = $EndIslandFeature;}
declare module "net.minecraft.world.level.block.entity.JigsawBlockEntity" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StructureTemplatePool, $StructureTemplatePool$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool"
import {$JigsawBlockEntity$JointType, $JigsawBlockEntity$JointType$$Type} from "net.minecraft.world.level.block.entity.JigsawBlockEntity$JointType"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $JigsawBlockEntity extends $BlockEntity {
static readonly "TARGET": StringJS
static readonly "FINAL_STATE": StringJS
static readonly "SELECTION_PRIORITY": StringJS
static readonly "POOL": StringJS
static readonly "PLACEMENT_PRIORITY": StringJS
static readonly "ATTACHMENTS_NBT_KEY": StringJS
static readonly "JOINT": StringJS
static readonly "NAME": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "getFinalState"(): StringJS
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getJoint"(): $JigsawBlockEntity$JointType
public "getPlacementPriority"(): integer
public "getSelectionPriority"(): integer
public "setPool"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>): void
public "setFinalState"(arg0: StringJS): void
public "setJoint"(arg0: $JigsawBlockEntity$JointType$$Type): void
public "setPlacementPriority"(arg0: integer): void
public "setSelectionPriority"(arg0: integer): void
public "getName"(): $ResourceLocation
public "setName"(arg0: $ResourceLocation$$Type): void
public "getPool"(): $ResourceKey<($StructureTemplatePool)>
public "getTarget"(): $ResourceLocation
public "setTarget"(arg0: $ResourceLocation$$Type): void
public "generate"(arg0: $ServerLevel$$Type, arg1: integer, arg2: boolean): void
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "finalState"(): StringJS
get "joint"(): $JigsawBlockEntity$JointType
get "placementPriority"(): integer
get "selectionPriority"(): integer
set "pool"(value: $ResourceKey$$Type<($StructureTemplatePool)>)
set "finalState"(value: StringJS)
set "joint"(value: $JigsawBlockEntity$JointType$$Type)
set "placementPriority"(value: integer)
set "selectionPriority"(value: integer)
get "name"(): $ResourceLocation
set "name"(value: $ResourceLocation$$Type)
get "pool"(): $ResourceKey<($StructureTemplatePool)>
get "target"(): $ResourceLocation
set "target"(value: $ResourceLocation$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JigsawBlockEntity$$Type = ($JigsawBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JigsawBlockEntity$$Original = $JigsawBlockEntity;}
declare module "net.minecraft.world.level.block.CarrotBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$CropBlock} from "net.minecraft.world.level.block.CropBlock"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CarrotBlock extends $CropBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CarrotBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($CarrotBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarrotBlock$$Type = ($CarrotBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarrotBlock$$Original = $CarrotBlock;}
declare module "net.minecraft.world.level.block.TripWireBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TripWireBlock extends $Block {
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "SOUTH": $BooleanProperty
static readonly "EAST": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TripWireBlock)>
static readonly "ATTACHED": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "POWERED": $BooleanProperty
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "DISARMED": $BooleanProperty

constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "shouldConnectTo"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "codec"(): $MapCodec<($TripWireBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TripWireBlock$$Type = ($TripWireBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TripWireBlock$$Original = $TripWireBlock;}
declare module "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector" {
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlayerDetector$EntitySelector, $PlayerDetector$EntitySelector$$Type} from "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector$EntitySelector"

export interface $PlayerDetector$$Interface {

(arg0: $ServerLevel, arg1: $PlayerDetector$EntitySelector, arg2: $BlockPos, arg3: double, arg4: boolean): $List$$Type<($UUID$$Type)>
}

export class $PlayerDetector implements $PlayerDetector$$Interface {
static readonly "INCLUDING_CREATIVE_PLAYERS": $PlayerDetector
static readonly "NO_CREATIVE_PLAYERS": $PlayerDetector
static readonly "SHEEP": $PlayerDetector

 "detect"(arg0: $ServerLevel$$Type, arg1: $PlayerDetector$EntitySelector$$Type, arg2: $BlockPos$$Type, arg3: double, arg4: boolean): $List<($UUID)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerDetector$$Type = ((arg0: $ServerLevel, arg1: $PlayerDetector$EntitySelector, arg2: $BlockPos, arg3: double, arg4: boolean) => $List$$Type<($UUID$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerDetector$$Original = $PlayerDetector;}
declare module "net.minecraft.world.level.levelgen.placement.BlockPredicateFilter" {
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$PlacementFilter} from "net.minecraft.world.level.levelgen.placement.PlacementFilter"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $BlockPredicateFilter extends $PlacementFilter {
static readonly "CODEC": $MapCodec<($BlockPredicateFilter)>

public "type"(): $PlacementModifierType<(never)>
public static "forPredicate"(arg0: $BlockPredicate$$Type): $BlockPredicateFilter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPredicateFilter$$Type = ($BlockPredicateFilter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPredicateFilter$$Original = $BlockPredicateFilter;}
declare module "net.minecraft.world.level.saveddata.maps.MapId" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Record} from "java.lang.Record"

export class $MapId extends $Record {
static readonly "CODEC": $Codec<($MapId)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($MapId)>

constructor(arg0: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): integer
public "key"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapId$$Type = ({"id"?: integer}) | ([id?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapId$$Original = $MapId;}
declare module "net.minecraft.world.level.block.entity.CommandBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BaseCommandBlock} from "net.minecraft.world.level.BaseCommandBlock"
import {$CommandBlockEntity$Mode} from "net.minecraft.world.level.block.entity.CommandBlockEntity$Mode"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CommandBlockEntity extends $BlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getCommandBlock"(): $BaseCommandBlock
public "setAutomatic"(arg0: boolean): void
public "isPowered"(): boolean
public "setPowered"(arg0: boolean): void
public "markConditionMet"(): boolean
public "wasConditionMet"(): boolean
public "isConditional"(): boolean
public "onModeSwitch"(): void
public "getMode"(): $CommandBlockEntity$Mode
public "isAutomatic"(): boolean
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "onlyOpCanSetNbt"(): boolean
get "commandBlock"(): $BaseCommandBlock
set "automatic"(value: boolean)
get "powered"(): boolean
set "powered"(value: boolean)
get "conditional"(): boolean
get "mode"(): $CommandBlockEntity$Mode
get "automatic"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandBlockEntity$$Type = ($CommandBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandBlockEntity$$Original = $CommandBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.MegaPineFoliagePlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $MegaPineFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($MegaPineFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type)

public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MegaPineFoliagePlacer$$Type = ($MegaPineFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MegaPineFoliagePlacer$$Original = $MegaPineFoliagePlacer;}
declare module "net.minecraft.world.level.block.state.properties.BedPart" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BedPart extends $Enum<($BedPart)> implements $StringRepresentable$$Interface {
static readonly "HEAD": $BedPart
static readonly "FOOT": $BedPart

public "toString"(): StringJS
public static "values"(): ($BedPart)[]
public static "valueOf"(arg0: StringJS): $BedPart
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BedPart$$Type = (("head") | ("foot"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BedPart$$Original = $BedPart;}
declare module "net.minecraft.world.level.SignalGetter" {
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $SignalGetter$$Interface extends $BlockGetter$$Interface {
get "maxLightLevel"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $SignalGetter implements $SignalGetter$$Interface {
static readonly "DIRECTIONS": ($Direction)[]

 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getHeight"(): integer
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMinBuildHeight"(): integer
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignalGetter$$Type = ($SignalGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignalGetter$$Original = $SignalGetter;}
declare module "net.minecraft.world.level.ClipContext$Block" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Enum} from "java.lang.Enum"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$ClipContext$ShapeGetter$$Interface} from "net.minecraft.world.level.ClipContext$ShapeGetter"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ClipContext$Block extends $Enum<($ClipContext$Block)> implements $ClipContext$ShapeGetter$$Interface {
static readonly "COLLIDER": $ClipContext$Block
static readonly "FALLDAMAGE_RESETTING": $ClipContext$Block
static readonly "OUTLINE": $ClipContext$Block
static readonly "VISUAL": $ClipContext$Block

public "get"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public static "values"(): ($ClipContext$Block)[]
public static "valueOf"(arg0: StringJS): $ClipContext$Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipContext$Block$$Type = (("collider") | ("outline") | ("visual") | ("falldamage_resetting"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipContext$Block$$Original = $ClipContext$Block;}
declare module "net.minecraft.world.level.block.entity.BlockEntityTicker" {
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockEntityTicker$$Interface<T extends $BlockEntity> {

(arg0: $Level, arg1: $BlockPos, arg2: $BlockState, arg3: T): void
}

export class $BlockEntityTicker<T extends $BlockEntity> implements $BlockEntityTicker$$Interface {
 "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: T): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityTicker$$Type<T> = ((arg0: $Level, arg1: $BlockPos, arg2: $BlockState, arg3: T) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityTicker$$Original<T> = $BlockEntityTicker<(T)>;}
declare module "net.minecraft.world.level.block.EndPortalBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Portal$Transition} from "net.minecraft.world.level.block.Portal$Transition"
import {$Portal$$Interface} from "net.minecraft.world.level.block.Portal"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$DimensionTransition} from "net.minecraft.world.level.portal.DimensionTransition"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EndPortalBlock extends $BaseEntityBlock implements $Portal$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($EndPortalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($EndPortalBlock)>
public "getPortalDestination"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type, arg2: $BlockPos$$Type): $DimensionTransition
public "getPortalTransitionTime"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type): integer
public "getLocalTransition"(): $Portal$Transition
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "localTransition"(): $Portal$Transition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndPortalBlock$$Type = ($EndPortalBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndPortalBlock$$Original = $EndPortalBlock;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.LinearPosTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PosRuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.PosRuleTest"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $LinearPosTest extends $PosRuleTest {
static readonly "CODEC": $MapCodec<($LinearPosTest)>

constructor(arg0: float, arg1: float, arg2: integer, arg3: integer)

public "test"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LinearPosTest$$Type = ($LinearPosTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LinearPosTest$$Original = $LinearPosTest;}
declare module "net.minecraft.world.level.gameevent.EntityPositionSource" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PositionSource$$Interface} from "net.minecraft.world.level.gameevent.PositionSource"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$PositionSourceType} from "net.minecraft.world.level.gameevent.PositionSourceType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $EntityPositionSource implements $PositionSource$$Interface {
static readonly "CODEC": $MapCodec<($EntityPositionSource)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($EntityPositionSource)>

constructor(arg0: $Entity$$Type, arg1: float)

public "getPosition"(arg0: $Level$$Type): $Optional<($Vec3)>
public "getType"(): $PositionSourceType<($EntityPositionSource)>
get "type"(): $PositionSourceType<($EntityPositionSource)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityPositionSource$$Type = ($EntityPositionSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityPositionSource$$Original = $EntityPositionSource;}
declare module "net.minecraft.world.level.ServerLevelAccessor" {
import {$Iterable} from "java.lang.Iterable"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$LevelData} from "net.minecraft.world.level.storage.LevelData"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$LevelAccessor$$Interface} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ChunkSource} from "net.minecraft.world.level.chunk.ChunkSource"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$TickPriority$$Type} from "net.minecraft.world.ticks.TickPriority"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$Class$$Type} from "java.lang.Class"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$LevelTickAccess} from "net.minecraft.world.ticks.LevelTickAccess"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$DifficultyInstance} from "net.minecraft.world.DifficultyInstance"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $ServerLevelAccessor$$Interface extends $LevelAccessor$$Interface {
get "level"(): $ServerLevel
get "levelData"(): $LevelData
get "chunkSource"(): $ChunkSource
get "random"(): $RandomSource
get "difficulty"(): $Difficulty
get "server"(): $MinecraftServer
get "blockTicks"(): $LevelTickAccess<($Block)>
get "fluidTicks"(): $LevelTickAccess<($Fluid)>
get "moonBrightness"(): float
get "moonPhase"(): integer
get "height"(): integer
get "clientSide"(): boolean
get "minBuildHeight"(): integer
get "biomeManager"(): $BiomeManager
get "seaLevel"(): integer
get "skyDarken"(): integer
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "entities"(): $EntityArrayList
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $ServerLevelAccessor implements $ServerLevelAccessor$$Interface {
 "addFreshEntityWithPassengers"(arg0: $Entity$$Type): void
 "getLevel"(): $ServerLevel
 "getLevelData"(): $LevelData
 "getChunkSource"(): $ChunkSource
 "gameEvent"(arg0: $ResourceKey$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $Vec3$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $BlockPos$$Type): void
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $Vec3$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "getRandom"(): $RandomSource
 "addParticle"(arg0: $ParticleOptions$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): void
 "getDifficulty"(): $Difficulty
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type): void
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
 "getServer"(): $MinecraftServer
 "levelEvent"(arg0: $Player$$Type, arg1: integer, arg2: $BlockPos$$Type, arg3: integer): void
 "levelEvent"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
 "neighborShapeChanged"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
 "hasChunk"(arg0: integer, arg1: integer): boolean
 "getCurrentDifficultyAt"(arg0: $BlockPos$$Type): $DifficultyInstance
 "blockUpdated"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
 "nextSubTickCount"(): long
 "dayTime"(): long
 "getBlockTicks"(): $LevelTickAccess<($Block)>
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer): void
 "getFluidTicks"(): $LevelTickAccess<($Fluid)>
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getTimeOfDay"(arg0: float): float
 "getMoonBrightness"(): float
 "getMoonPhase"(): integer
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
 "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
 "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
 "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
 "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
 "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
 "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
 "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
 "getPlayerByUUID"(arg0: $UUID$$Type): $Player
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
 "enabledFeatures"(): $FeatureFlagSet
 "registryAccess"(): $RegistryAccess
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "isClientSide"(): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getBiomeManager"(): $BiomeManager
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "dimensionType"(): $DimensionType
 "getSkyDarken"(): integer
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "self"(): $EntityGetter
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getWorldBorder"(): $WorldBorder
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntities"(): $EntityArrayList
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLevelAccessor$$Type = ($ServerLevelAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerLevelAccessor$$Original = $ServerLevelAccessor;}
declare module "net.minecraft.world.level.storage.loot.LootPool$Builder" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$LootItemFunction} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$LootPoolEntryContainer} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$LootPool} from "net.minecraft.world.level.storage.loot.LootPool"
import {$LootItemFunction$Builder$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction$Builder"
import {$FunctionUserBuilder, $FunctionUserBuilder$$Interface} from "net.minecraft.world.level.storage.loot.functions.FunctionUserBuilder"
import {$NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$Function$$Type} from "java.util.function.Function"
import {$ImmutableList$Builder} from "com.google.common.collect.ImmutableList$Builder"
import {$LootPoolEntryContainer$Builder$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer$Builder"
import {$ConditionUserBuilder$$Interface} from "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder"
import {$LootItemCondition} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export class $LootPool$Builder implements $FunctionUserBuilder$$Interface<($LootPool$Builder)>, $ConditionUserBuilder$$Interface<($LootPool$Builder)> {
readonly "entries": $ImmutableList$Builder<($LootPoolEntryContainer)>
readonly "functions": $ImmutableList$Builder<($LootItemFunction)>
readonly "conditions": $ImmutableList$Builder<($LootItemCondition)>

constructor()

public "setRolls"(arg0: $NumberProvider$$Type): $LootPool$Builder
public "setBonusRolls"(arg0: $NumberProvider$$Type): $LootPool$Builder
public "when"(arg0: $LootItemCondition$Builder$$Type): $LootPool$Builder
public "name"(arg0: StringJS): $LootPool$Builder
public "add"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $LootPool$Builder
public "apply"(arg0: $LootItemFunction$Builder$$Type): $FunctionUserBuilder
public "unwrap"(): $FunctionUserBuilder
public "build"(): $LootPool
public "apply"<E>(arg0: (E)[], arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): $LootPool$Builder
public "apply"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): $LootPool$Builder
public "when"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemCondition$Builder$$Type)>): $LootPool$Builder
set "rolls"(value: $NumberProvider$$Type)
set "bonusRolls"(value: $NumberProvider$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPool$Builder$$Type = ($LootPool$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootPool$Builder$$Original = $LootPool$Builder;}
declare module "net.minecraft.world.level.block.IceBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$HalfTransparentBlock} from "net.minecraft.world.level.block.HalfTransparentBlock"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $IceBlock extends $HalfTransparentBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($IceBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "playerDestroy"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockEntity$$Type, arg5: $ItemStack$$Type): void
public static "meltsInto"(): $BlockState
public "codec"(): $MapCodec<($IceBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IceBlock$$Type = ($IceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IceBlock$$Original = $IceBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.SwampHutStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $SwampHutStructure extends $Structure {
static readonly "CODEC": $MapCodec<($SwampHutStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SwampHutStructure$$Type = ($SwampHutStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SwampHutStructure$$Original = $SwampHutStructure;}
declare module "net.minecraft.world.level.block.JigsawBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$EntityBlock$$Interface} from "net.minecraft.world.level.block.EntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$GameMasterBlock$$Interface} from "net.minecraft.world.level.block.GameMasterBlock"
import {$Direction} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$FrontAndTop} from "net.minecraft.core.FrontAndTop"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $JigsawBlock extends $Block implements $EntityBlock$$Interface, $GameMasterBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($JigsawBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "ORIENTATION": $EnumProperty<($FrontAndTop)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "getFrontFacing"(arg0: $BlockState$$Type): $Direction
public static "getTopFacing"(arg0: $BlockState$$Type): $Direction
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "canAttach"(arg0: $StructureTemplate$StructureBlockInfo$$Type, arg1: $StructureTemplate$StructureBlockInfo$$Type): boolean
public "codec"(): $MapCodec<($JigsawBlock)>
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JigsawBlock$$Type = ($JigsawBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JigsawBlock$$Original = $JigsawBlock;}
declare module "net.minecraft.world.level.block.BaseFireBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BaseFireBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: float)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public static "canBePlacedAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public static "getState"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $BlockState
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseFireBlock$$Type = ($BaseFireBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseFireBlock$$Original = $BaseFireBlock;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List$$Type} from "java.util.List"
import {$NoiseBasedStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseBasedStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NoiseProvider extends $NoiseBasedStateProvider {
static readonly "CODEC": $MapCodec<($NoiseProvider)>

constructor(arg0: long, arg1: $NormalNoise$NoiseParameters$$Type, arg2: float, arg3: $List$$Type<($BlockState$$Type)>)

public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseProvider$$Type = ($NoiseProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseProvider$$Original = $NoiseProvider;}
declare module "net.minecraft.world.level.block.FrogspawnBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $FrogspawnBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FrogspawnBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "setHatchDelay"(arg0: integer, arg1: integer): void
public static "setDefaultHatchDelay"(): void
public "codec"(): $MapCodec<($FrogspawnBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static get "defaultHatchDelay"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrogspawnBlock$$Type = ($FrogspawnBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FrogspawnBlock$$Original = $FrogspawnBlock;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$LevelStorageSource$LevelStorageAccess$$Type} from "net.minecraft.world.level.storage.LevelStorageSource$LevelStorageAccess"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Optional} from "java.util.Optional"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Path} from "java.nio.file.Path"
import {$Stream} from "java.util.stream.Stream"
import {$StructureTemplate} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"
import {$HolderGetter$$Type} from "net.minecraft.core.HolderGetter"
import {$ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"

export class $StructureTemplateManager {
static readonly "STRUCTURE_RESOURCE_DIRECTORY_NAME": StringJS

constructor(arg0: $ResourceManager$$Type, arg1: $LevelStorageSource$LevelStorageAccess$$Type, arg2: $DataFixer$$Type, arg3: $HolderGetter$$Type<($Block$$Type)>)

public "listTemplates"(): $Stream<($ResourceLocation)>
public "createAndValidatePathToGeneratedStructure"(arg0: $ResourceLocation$$Type, arg1: StringJS): $Path
public "readStructure"(arg0: $CompoundTag$$Type): $StructureTemplate
public "getOrCreate"(arg0: $ResourceLocation$$Type): $StructureTemplate
public "remove"(arg0: $ResourceLocation$$Type): void
public "get"(arg0: $ResourceLocation$$Type): $Optional<($StructureTemplate)>
public "save"(arg0: $ResourceLocation$$Type): boolean
public "onResourceManagerReload"(arg0: $ResourceManager$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplateManager$$Type = ($StructureTemplateManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplateManager$$Original = $StructureTemplateManager;}
declare module "net.minecraft.world.level.levelgen.feature.WeightedPlacedFeature" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $WeightedPlacedFeature {
static readonly "CODEC": $Codec<($WeightedPlacedFeature)>
readonly "chance": float
readonly "feature": $Holder<($PlacedFeature)>

constructor(arg0: $Holder$$Type<($PlacedFeature)>, arg1: float)

public "place"(arg0: $WorldGenLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeightedPlacedFeature$$Type = ($WeightedPlacedFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeightedPlacedFeature$$Original = $WeightedPlacedFeature;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.RotatedBlockProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $RotatedBlockProvider extends $BlockStateProvider {
static readonly "CODEC": $MapCodec<($RotatedBlockProvider)>

constructor(arg0: $Block$$Type)

public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotatedBlockProvider$$Type = ($RotatedBlockProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RotatedBlockProvider$$Original = $RotatedBlockProvider;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.NopProcessor" {
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $NopProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($NopProcessor)>
static readonly "INSTANCE": $NopProcessor

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NopProcessor$$Type = ($NopProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NopProcessor$$Original = $NopProcessor;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.BushFoliagePlacer" {
import {$BlobFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.BlobFoliagePlacer"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $BushFoliagePlacer extends $BlobFoliagePlacer {
static readonly "CODEC": $MapCodec<($BushFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BushFoliagePlacer$$Type = ($BushFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BushFoliagePlacer$$Original = $BushFoliagePlacer;}
declare module "net.minecraft.world.level.biome.MultiNoiseBiomeSourceParameterList$Preset$SourceProvider" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider$$Interface {
}

export class $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider implements $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider$$Type = ($MultiNoiseBiomeSourceParameterList$Preset$SourceProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider$$Original = $MultiNoiseBiomeSourceParameterList$Preset$SourceProvider;}
declare module "net.minecraft.world.level.block.SmithingTableBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$CraftingTableBlock} from "net.minecraft.world.level.block.CraftingTableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $SmithingTableBlock extends $CraftingTableBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SmithingTableBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($SmithingTableBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmithingTableBlock$$Type = ($SmithingTableBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmithingTableBlock$$Original = $SmithingTableBlock;}
declare module "net.minecraft.world.level.block.EquipableCarvedPumpkinBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$CarvedPumpkinBlock} from "net.minecraft.world.level.block.CarvedPumpkinBlock"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Holder} from "net.minecraft.core.Holder"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Equipable, $Equipable$$Interface} from "net.minecraft.world.item.Equipable"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$EquipmentSlot} from "net.minecraft.world.entity.EquipmentSlot"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $EquipableCarvedPumpkinBlock extends $CarvedPumpkinBlock implements $Equipable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($EquipableCarvedPumpkinBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($EquipableCarvedPumpkinBlock)>
public "getEquipmentSlot"(): $EquipmentSlot
public "swapWithEquipmentSlot"(arg0: $Item$$Type, arg1: $Level$$Type, arg2: $Player$$Type, arg3: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public "getEquipSound"(): $Holder<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "equipmentSlot"(): $EquipmentSlot
get "equipSound"(): $Holder<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EquipableCarvedPumpkinBlock$$Type = ($EquipableCarvedPumpkinBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EquipableCarvedPumpkinBlock$$Original = $EquipableCarvedPumpkinBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.WoodlandMansionStructure" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$Optional} from "java.util.Optional"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$PiecesContainer$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $WoodlandMansionStructure extends $Structure {
static readonly "CODEC": $MapCodec<($WoodlandMansionStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "afterPlace"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BoundingBox$$Type, arg5: $ChunkPos$$Type, arg6: $PiecesContainer$$Type): void
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WoodlandMansionStructure$$Type = ($WoodlandMansionStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WoodlandMansionStructure$$Original = $WoodlandMansionStructure;}
declare module "net.minecraft.world.level.block.CraftingTableBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CraftingTableBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CraftingTableBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($CraftingTableBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingTableBlock$$Type = ($CraftingTableBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CraftingTableBlock$$Original = $CraftingTableBlock;}
declare module "net.minecraft.world.level.block.state.StateDefinition" {
import {$Collection} from "java.util.Collection"
import {$Comparable} from "java.lang.Comparable"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ImmutableList} from "com.google.common.collect.ImmutableList"
import {$StateHolder} from "net.minecraft.world.level.block.state.StateHolder"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $StateDefinition<O, S extends $StateHolder<(object), (object)>> {
 "owner": O

public static "appendPropertyCodec"<S extends $StateHolder<(object), (object)>, T extends $Comparable<(object)>>(arg0: $MapCodec$$Type<(S)>, arg1: $Supplier$$Type<(S)>, arg2: StringJS, arg3: $Property$$Type<(T)>): $MapCodec<(S)>
public "getProperty"(arg0: StringJS): $Property<(never)>
public "toString"(): StringJS
public "getProperties"(): $Collection<($Property<(never)>)>
public "getOwner"(): O
public "any"(): S
public "getPossibleStates"(): $ImmutableList<(S)>
get "properties"(): $Collection<($Property<(never)>)>
get "possibleStates"(): $ImmutableList<(S)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StateDefinition$$Type<O, S> = ($StateDefinition<(O), (S)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StateDefinition$$Original<O, S> = $StateDefinition<(O), (S)>;}
declare module "net.minecraft.world.level.block.TargetBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $TargetBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TargetBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($TargetBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TargetBlock$$Type = ($TargetBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TargetBlock$$Original = $TargetBlock;}
declare module "net.minecraft.world.level.gameevent.BlockPositionSource$Type" {
import {$BlockPositionSource} from "net.minecraft.world.level.gameevent.BlockPositionSource"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PositionSource} from "net.minecraft.world.level.gameevent.PositionSource"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PositionSourceType, $PositionSourceType$$Type, $PositionSourceType$$Interface} from "net.minecraft.world.level.gameevent.PositionSourceType"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $BlockPositionSource$Type implements $PositionSourceType$$Interface<($BlockPositionSource)> {
constructor()

public "streamCodec"(): $StreamCodec<($ByteBuf), ($BlockPositionSource)>
public "codec"(): $MapCodec<($BlockPositionSource)>
public static "register"<S extends $PositionSourceType<(object)>, T extends $PositionSource>(arg0: StringJS, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPositionSource$Type$$Type = ($BlockPositionSource$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPositionSource$Type$$Original = $BlockPositionSource$Type;}
declare module "net.minecraft.world.level.block.WeatheringCopperTrapDoorBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Enum} from "java.lang.Enum"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$Half} from "net.minecraft.world.level.block.state.properties.Half"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$WeatheringCopper$$Interface} from "net.minecraft.world.level.block.WeatheringCopper"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$TrapDoorBlock} from "net.minecraft.world.level.block.TrapDoorBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$WeatheringCopper$WeatherState$$Type} from "net.minecraft.world.level.block.WeatheringCopper$WeatherState"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WeatheringCopperTrapDoorBlock extends $TrapDoorBlock implements $WeatheringCopper$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WeatheringCopperTrapDoorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($Half)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockSetType$$Type, arg1: $WeatheringCopper$WeatherState$$Type, arg2: $BlockBehaviour$Properties$$Type)

public "getAge"(): $Enum
public "codec"(): $MapCodec<($WeatheringCopperTrapDoorBlock)>
public "getChanceModifier"(): float
public "getNext"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getNext"(arg0: $Block$$Type): $Optional<($Block)>
public static "getFirst"(arg0: $BlockState$$Type): $BlockState
public static "getFirst"(arg0: $Block$$Type): $Block
public static "getPrevious"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getPrevious"(arg0: $Block$$Type): $Optional<($Block)>
public "changeOverTime"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getNextState"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($BlockState)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "age"(): $Enum
get "chanceModifier"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatheringCopperTrapDoorBlock$$Type = ($WeatheringCopperTrapDoorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeatheringCopperTrapDoorBlock$$Original = $WeatheringCopperTrapDoorBlock;}
declare module "net.minecraft.world.level.levelgen.structure.pools.SinglePoolElement" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$List} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructurePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$StructureTemplate} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplate$StructureBlockInfo} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SinglePoolElement extends $StructurePoolElement {
static readonly "CODEC": $MapCodec<($SinglePoolElement)>

public "getShuffledJigsawBlocks"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: $RandomSource$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "getDataMarkers"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: boolean): $List<($StructureTemplate$StructureBlockInfo)>
public "place"(arg0: $StructureTemplateManager$$Type, arg1: $WorldGenLevel$$Type, arg2: $StructureManager$$Type, arg3: $ChunkGenerator$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type, arg6: $Rotation$$Type, arg7: $BoundingBox$$Type, arg8: $RandomSource$$Type, arg9: $LiquidSettings$$Type, arg10: boolean): boolean
public "toString"(): StringJS
public "getType"(): $StructurePoolElementType<(never)>
public "getSize"(arg0: $StructureTemplateManager$$Type, arg1: $Rotation$$Type): $Vec3i
public "getTemplate"(arg0: $StructureTemplateManager$$Type): $StructureTemplate
public "getBoundingBox"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BoundingBox
get "type"(): $StructurePoolElementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SinglePoolElement$$Type = ($SinglePoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SinglePoolElement$$Original = $SinglePoolElement;}
declare module "net.minecraft.world.level.block.TransparentBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$HalfTransparentBlock} from "net.minecraft.world.level.block.HalfTransparentBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $TransparentBlock extends $HalfTransparentBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TransparentBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransparentBlock$$Type = ($TransparentBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TransparentBlock$$Original = $TransparentBlock;}
declare module "net.minecraft.world.level.chunk.status.ChunkStatusTask" {
import {$ChunkStep, $ChunkStep$$Type} from "net.minecraft.world.level.chunk.status.ChunkStep"
import {$CompletableFuture, $CompletableFuture$$Type} from "java.util.concurrent.CompletableFuture"
import {$WorldGenContext, $WorldGenContext$$Type} from "net.minecraft.world.level.chunk.status.WorldGenContext"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$StaticCache2D, $StaticCache2D$$Type} from "net.minecraft.util.StaticCache2D"
import {$GenerationChunkHolder, $GenerationChunkHolder$$Type} from "net.minecraft.server.level.GenerationChunkHolder"

export interface $ChunkStatusTask$$Interface {

(arg0: $WorldGenContext, arg1: $ChunkStep, arg2: $StaticCache2D<($GenerationChunkHolder)>, arg3: $ChunkAccess): $CompletableFuture$$Type<($ChunkAccess$$Type)>
}

export class $ChunkStatusTask implements $ChunkStatusTask$$Interface {
 "doWork"(arg0: $WorldGenContext$$Type, arg1: $ChunkStep$$Type, arg2: $StaticCache2D$$Type<($GenerationChunkHolder$$Type)>, arg3: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkStatusTask$$Type = ((arg0: $WorldGenContext, arg1: $ChunkStep, arg2: $StaticCache2D<($GenerationChunkHolder)>, arg3: $ChunkAccess) => $CompletableFuture$$Type<($ChunkAccess$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkStatusTask$$Original = $ChunkStatusTask;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.BlockIgnoreProcessor" {
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $BlockIgnoreProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($BlockIgnoreProcessor)>
static readonly "STRUCTURE_AND_AIR": $BlockIgnoreProcessor
static readonly "AIR": $BlockIgnoreProcessor
static readonly "STRUCTURE_BLOCK": $BlockIgnoreProcessor

constructor(arg0: $List$$Type<($Block$$Type)>)

public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIgnoreProcessor$$Type = ($BlockIgnoreProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockIgnoreProcessor$$Original = $BlockIgnoreProcessor;}
declare module "net.minecraft.world.level.levelgen.BelowZeroRetrogen" {
import {$ProtoChunk$$Type} from "net.minecraft.world.level.chunk.ProtoChunk"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$BiomeResolver, $BiomeResolver$$Type} from "net.minecraft.world.level.biome.BiomeResolver"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ChunkStatus} from "net.minecraft.world.level.chunk.status.ChunkStatus"

export class $BelowZeroRetrogen {
static readonly "CODEC": $Codec<($BelowZeroRetrogen)>
static readonly "UPGRADE_HEIGHT_ACCESSOR": $LevelHeightAccessor

public "targetStatus"(): $ChunkStatus
public static "getBiomeResolver"(arg0: $BiomeResolver$$Type, arg1: $ChunkAccess$$Type): $BiomeResolver
public "hasBedrockHole"(arg0: integer, arg1: integer): boolean
public static "replaceOldBedrock"(arg0: $ProtoChunk$$Type): void
public "hasBedrockHoles"(): boolean
public "applyBedrockMask"(arg0: $ProtoChunk$$Type): void
public static "read"(arg0: $CompoundTag$$Type): $BelowZeroRetrogen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BelowZeroRetrogen$$Type = ($BelowZeroRetrogen);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BelowZeroRetrogen$$Original = $BelowZeroRetrogen;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$Ap2" {
import {$DensityFunctions$TwoArgumentSimpleFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunctions$TwoArgumentSimpleFunction"
import {$DensityFunctions$TwoArgumentSimpleFunction$Type$$Type} from "net.minecraft.world.level.levelgen.DensityFunctions$TwoArgumentSimpleFunction$Type"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$Record} from "java.lang.Record"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"

export class $DensityFunctions$Ap2 extends $Record implements $DensityFunctions$TwoArgumentSimpleFunction$$Interface {
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
public "cube"(): $DensityFunction
public "halfNegative"(): $DensityFunction
public "quarterNegative"(): $DensityFunction
public "squeeze"(): $DensityFunction
public "maxValue"(): double
public "abs"(): $DensityFunction
public "clamp"(arg0: double, arg1: double): $DensityFunction
public "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
public "square"(): $DensityFunction
public "minValue"(): double
public "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
public "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$Ap2$$Type = ({"argument2"?: $DensityFunction$$Type, "type"?: $DensityFunctions$TwoArgumentSimpleFunction$Type$$Type, "maxValue"?: double, "argument1"?: $DensityFunction$$Type, "minValue"?: double}) | ([argument2?: $DensityFunction$$Type, type?: $DensityFunctions$TwoArgumentSimpleFunction$Type$$Type, maxValue?: double, argument1?: $DensityFunction$$Type, minValue?: double]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$Ap2$$Original = $DensityFunctions$Ap2;}
declare module "net.minecraft.world.level.GameRules$Type" {
import {$RequiredArgumentBuilder} from "com.mojang.brigadier.builder.RequiredArgumentBuilder"
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"
import {$GameRules$GameRuleTypeVisitor$$Type} from "net.minecraft.world.level.GameRules$GameRuleTypeVisitor"
import {$GameRules$Key$$Type} from "net.minecraft.world.level.GameRules$Key"
import {$CommandSourceStack} from "net.minecraft.commands.CommandSourceStack"

export class $GameRules$Type<T extends $GameRules$Value<(object)>> {
public "callVisitor"(arg0: $GameRules$GameRuleTypeVisitor$$Type, arg1: $GameRules$Key$$Type<(T)>): void
public "createRule"(): T
public "createArgument"(arg0: StringJS): $RequiredArgumentBuilder<($CommandSourceStack), (never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$Type$$Type<T> = ($GameRules$Type<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$Type$$Original<T> = $GameRules$Type<(T)>;}
declare module "net.minecraft.world.level.levelgen.RandomSupport$Seed128bit" {
import {$Record} from "java.lang.Record"

export class $RandomSupport$Seed128bit extends $Record {
constructor(arg0: long, arg1: long)

public "seedLo"(): long
public "seedHi"(): long
public "xor"(arg0: $RandomSupport$Seed128bit$$Type): $RandomSupport$Seed128bit
public "xor"(arg0: long, arg1: long): $RandomSupport$Seed128bit
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "mixed"(): $RandomSupport$Seed128bit
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomSupport$Seed128bit$$Type = ({"seedLo"?: long, "seedHi"?: long}) | ([seedLo?: long, seedHi?: long]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomSupport$Seed128bit$$Original = $RandomSupport$Seed128bit;}
declare module "net.minecraft.world.level.block.entity.EnderChestBlockEntity" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LidBlockEntity$$Interface} from "net.minecraft.world.level.block.entity.LidBlockEntity"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EnderChestBlockEntity extends $BlockEntity implements $LidBlockEntity$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "lidAnimateTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $EnderChestBlockEntity$$Type): void
public "recheckOpen"(): void
public "startOpen"(arg0: $Player$$Type): void
public "stopOpen"(arg0: $Player$$Type): void
public "getOpenNess"(arg0: float): float
public "stillValid"(arg0: $Player$$Type): boolean
public "triggerEvent"(arg0: integer, arg1: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnderChestBlockEntity$$Type = ($EnderChestBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnderChestBlockEntity$$Original = $EnderChestBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration" {
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$RuleBasedBlockStateProvider, $RuleBasedBlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.RuleBasedBlockStateProvider"
import {$Record} from "java.lang.Record"

export class $DiskConfiguration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($DiskConfiguration)>

constructor(arg0: $RuleBasedBlockStateProvider$$Type, arg1: $BlockPredicate$$Type, arg2: $IntProvider$$Type, arg3: integer)

public "stateProvider"(): $RuleBasedBlockStateProvider
public "halfHeight"(): integer
public "equals"(arg0: any): boolean
public "target"(): $BlockPredicate
public "toString"(): StringJS
public "hashCode"(): integer
public "radius"(): $IntProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiskConfiguration$$Type = ({"target"?: $BlockPredicate$$Type, "halfHeight"?: integer, "stateProvider"?: $RuleBasedBlockStateProvider$$Type, "radius"?: $IntProvider$$Type}) | ([target?: $BlockPredicate$$Type, halfHeight?: integer, stateProvider?: $RuleBasedBlockStateProvider$$Type, radius?: $IntProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiskConfiguration$$Original = $DiskConfiguration;}
declare module "net.minecraft.world.level.storage.loot.LootParams$Builder" {
import {$LootContextParam$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LootParams$DynamicDrop$$Type} from "net.minecraft.world.level.storage.loot.LootParams$DynamicDrop"
import {$LootParams} from "net.minecraft.world.level.storage.loot.LootParams"
import {$LootContextParamSet$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet"

export class $LootParams$Builder {
 "luck": float

constructor(arg0: $ServerLevel$$Type)

public "getOptionalParameter"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "withDynamicDrop"(arg0: $ResourceLocation$$Type, arg1: $LootParams$DynamicDrop$$Type): $LootParams$Builder
public "getLevel"(): $ServerLevel
public "create"(arg0: $LootContextParamSet$$Type): $LootParams
public "getParameter"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "withParameter"<T>(arg0: $LootContextParam$$Type<(T)>, arg1: T): $LootParams$Builder
public "withOptionalParameter"<T>(arg0: $LootContextParam$$Type<(T)>, arg1: T): $LootParams$Builder
public "withLuck"(arg0: float): $LootParams$Builder
get "level"(): $ServerLevel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootParams$Builder$$Type = ($LootParams$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootParams$Builder$$Original = $LootParams$Builder;}
declare module "net.minecraft.world.level.portal.DimensionTransition$PostDimensionTransition" {
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"

export interface $DimensionTransition$PostDimensionTransition$$Interface {

(arg0: $Entity): void
}

export class $DimensionTransition$PostDimensionTransition implements $DimensionTransition$PostDimensionTransition$$Interface {
 "then"(arg0: $DimensionTransition$PostDimensionTransition$$Type): $DimensionTransition$PostDimensionTransition
 "onTransition"(arg0: $Entity$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionTransition$PostDimensionTransition$$Type = ((arg0: $Entity) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionTransition$PostDimensionTransition$$Original = $DimensionTransition$PostDimensionTransition;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StructureTemplate$StructureBlockInfo extends $Record {
constructor(pos: $BlockPos$$Type, state: $BlockState$$Type, nbt: $CompoundTag$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "state"(): $BlockState
public "pos"(): $BlockPos
public "nbt"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplate$StructureBlockInfo$$Type = ({"state"?: $BlockState$$Type, "nbt"?: $CompoundTag$$Type, "pos"?: $BlockPos$$Type}) | ([state?: $BlockState$$Type, nbt?: $CompoundTag$$Type, pos?: $BlockPos$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplate$StructureBlockInfo$$Original = $StructureTemplate$StructureBlockInfo;}
declare module "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$StructurePiece, $StructurePiece$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePiece"
import {$StructurePieceSerializationContext, $StructurePieceSerializationContext$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext"

export interface $StructurePieceType$$Interface {

(arg0: $StructurePieceSerializationContext, arg1: $CompoundTag): $StructurePiece$$Type
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructurePiece
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructurePieceTag
}

export class $StructurePieceType implements $StructurePieceType$$Interface {
static readonly "NETHER_FORTRESS_BRIDGE_STRAIGHT": $StructurePieceType
static readonly "NETHER_FORTRESS_STAIRS_ROOM": $StructurePieceType
static readonly "STRONGHOLD_LEFT_TURN": $StructurePieceType
static readonly "STRONGHOLD_FIVE_CROSSING": $StructurePieceType
static readonly "NETHER_FORTRESS_BRIDGE_END_FILLER": $StructurePieceType
static readonly "OCEAN_MONUMENT_WING_ROOM": $StructurePieceType
static readonly "JIGSAW": $StructurePieceType
static readonly "OCEAN_MONUMENT_DOUBLE_YZ_ROOM": $StructurePieceType
static readonly "BURIED_TREASURE_PIECE": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_CORRIDOR_STAIRS": $StructurePieceType
static readonly "OCEAN_MONUMENT_BUILDING": $StructurePieceType
static readonly "NETHER_FORTRESS_MONSTER_THRONE": $StructurePieceType
static readonly "STRONGHOLD_LIBRARY": $StructurePieceType
static readonly "STRONGHOLD_ROOM_CROSSING": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR_CROSSING": $StructurePieceType
static readonly "OCEAN_MONUMENT_ENTRY_ROOM": $StructurePieceType
static readonly "STRONGHOLD_FILLER_CORRIDOR": $StructurePieceType
static readonly "JUNGLE_PYRAMID_PIECE": $StructurePieceType
static readonly "MINE_SHAFT_CROSSING": $StructurePieceType
static readonly "NETHER_FORTRESS_BRIDGE_CROSSING": $StructurePieceType
static readonly "RUINED_PORTAL": $StructurePieceType
static readonly "STRONGHOLD_STRAIGHT_STAIRS_DOWN": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR_RIGHT_TURN": $StructurePieceType
static readonly "STRONGHOLD_PORTAL_ROOM": $StructurePieceType
static readonly "OCEAN_MONUMENT_CORE_ROOM": $StructurePieceType
static readonly "WOODLAND_MANSION_PIECE": $StructurePieceType
static readonly "NETHER_FORTRESS_START": $StructurePieceType
static readonly "OCEAN_MONUMENT_DOUBLE_X_ROOM": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR": $StructurePieceType
static readonly "STRONGHOLD_CHEST_CORRIDOR": $StructurePieceType
static readonly "NETHER_FORTRESS_ROOM_CROSSING": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_ENTRANCE": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR_LEFT_TURN": $StructurePieceType
static readonly "OCEAN_MONUMENT_SIMPLE_ROOM": $StructurePieceType
static readonly "STRONGHOLD_STRAIGHT": $StructurePieceType
static readonly "MINE_SHAFT_STAIRS": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_STALK_ROOM": $StructurePieceType
static readonly "MINE_SHAFT_CORRIDOR": $StructurePieceType
static readonly "OCEAN_MONUMENT_DOUBLE_XY_ROOM": $StructurePieceType
static readonly "SHIPWRECK_PIECE": $StructurePieceType
static readonly "OCEAN_MONUMENT_DOUBLE_Z_ROOM": $StructurePieceType
static readonly "MINE_SHAFT_ROOM": $StructurePieceType
static readonly "OCEAN_RUIN": $StructurePieceType
static readonly "STRONGHOLD_PRISON_HALL": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_CORRIDOR_T_BALCONY": $StructurePieceType
static readonly "OCEAN_MONUMENT_DOUBLE_Y_ROOM": $StructurePieceType
static readonly "NETHER_FOSSIL": $StructurePieceType
static readonly "IGLOO": $StructurePieceType
static readonly "OCEAN_MONUMENT_SIMPLE_TOP_ROOM": $StructurePieceType
static readonly "STRONGHOLD_STAIRS_DOWN": $StructurePieceType
static readonly "SWAMPLAND_HUT": $StructurePieceType
static readonly "DESERT_PYRAMID_PIECE": $StructurePieceType
static readonly "END_CITY_PIECE": $StructurePieceType
static readonly "STRONGHOLD_START": $StructurePieceType
static readonly "OCEAN_MONUMENT_PENTHOUSE": $StructurePieceType
static readonly "STRONGHOLD_RIGHT_TURN": $StructurePieceType

 "load"(arg0: $StructurePieceSerializationContext$$Type, arg1: $CompoundTag$$Type): $StructurePiece
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePieceType$$Type = (Special.WorldgenStructurePiece) | ((arg0: $StructurePieceSerializationContext, arg1: $CompoundTag) => $StructurePiece$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePieceType$$Original = $StructurePieceType;}
declare module "net.minecraft.world.level.saveddata.maps.MapDecoration" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MapDecorationType, $MapDecorationType$$Type} from "net.minecraft.world.level.saveddata.maps.MapDecorationType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $MapDecoration extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MapDecoration)>

constructor(arg0: $Holder$$Type<($MapDecorationType)>, arg1: byte, arg2: byte, arg3: byte, arg4: ($Component$$Type)?)

public "renderOnFrame"(): boolean
public "getSpriteLocation"(): $ResourceLocation
public "name"(): $Optional<($Component)>
public "type"(): $Holder<($MapDecorationType)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "x"(): byte
public "y"(): byte
public "rot"(): byte
get "spriteLocation"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapDecoration$$Type = ({"x"?: byte, "rot"?: byte, "y"?: byte, "type"?: $Holder$$Type<($MapDecorationType)>, "name"?: ($Component$$Type)?}) | ([x?: byte, rot?: byte, y?: byte, type?: $Holder$$Type<($MapDecorationType)>, name?: ($Component$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapDecoration$$Original = $MapDecoration;}
declare module "net.minecraft.world.level.block.StandingSignBlock" {
import {$SignBlock} from "net.minecraft.world.level.block.SignBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$WoodType$$Type} from "net.minecraft.world.level.block.state.properties.WoodType"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StandingSignBlock extends $SignBlock {
static readonly "ROTATION": $IntegerProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($StandingSignBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $WoodType$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getYRotationDegrees"(arg0: $BlockState$$Type): float
public "codec"(): $MapCodec<($StandingSignBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StandingSignBlock$$Type = ($StandingSignBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StandingSignBlock$$Original = $StandingSignBlock;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseBasedStateProvider" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"

export class $NoiseBasedStateProvider extends $BlockStateProvider {
static readonly "CODEC": $Codec<($BlockStateProvider)>

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseBasedStateProvider$$Type = ($NoiseBasedStateProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseBasedStateProvider$$Original = $NoiseBasedStateProvider;}
declare module "net.minecraft.world.level.block.entity.vault.VaultState" {
import {$VaultServerData$$Type} from "net.minecraft.world.level.block.entity.vault.VaultServerData"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$VaultSharedData$$Type} from "net.minecraft.world.level.block.entity.vault.VaultSharedData"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$VaultConfig$$Type} from "net.minecraft.world.level.block.entity.vault.VaultConfig"

export class $VaultState extends $Enum<($VaultState)> implements $StringRepresentable$$Interface {
static readonly "ACTIVE": $VaultState
static readonly "INACTIVE": $VaultState
static readonly "EJECTING": $VaultState
static readonly "UNLOCKING": $VaultState

public "lightLevel"(): integer
public "tickAndGetNext"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $VaultConfig$$Type, arg3: $VaultServerData$$Type, arg4: $VaultSharedData$$Type): $VaultState
public static "values"(): ($VaultState)[]
public static "valueOf"(arg0: StringJS): $VaultState
public "getSerializedName"(): StringJS
public "onTransition"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $VaultState$$Type, arg3: $VaultConfig$$Type, arg4: $VaultSharedData$$Type, arg5: boolean): void
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultState$$Type = (("inactive") | ("active") | ("unlocking") | ("ejecting"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultState$$Original = $VaultState;}
declare module "net.minecraft.world.level.block.entity.CalibratedSculkSensorBlockEntity" {
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$SculkSensorBlockEntity} from "net.minecraft.world.level.block.entity.SculkSensorBlockEntity"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$VibrationSystem$User} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$User"

export class $CalibratedSculkSensorBlockEntity extends $SculkSensorBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "createVibrationUser"(): $VibrationSystem$User
public "getListener"(): $GameEventListener
public static "getResonanceEventByFrequency"(arg0: integer): $ResourceKey<($GameEvent)>
public static "getGameEventFrequency"(arg0: $ResourceKey$$Type<($GameEvent)>): integer
public static "getGameEventFrequency"(arg0: $Holder$$Type<($GameEvent)>): integer
public static "getRedstoneStrengthForDistance"(arg0: float, arg1: integer): integer
get "listener"(): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CalibratedSculkSensorBlockEntity$$Type = ($CalibratedSculkSensorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CalibratedSculkSensorBlockEntity$$Original = $CalibratedSculkSensorBlockEntity;}
declare module "net.minecraft.world.level.levelgen.GeodeLayerSettings" {
import {$Codec} from "com.mojang.serialization.Codec"

export class $GeodeLayerSettings {
readonly "filling": double
static readonly "CODEC": $Codec<($GeodeLayerSettings)>
readonly "outerLayer": double
readonly "innerLayer": double
readonly "middleLayer": double

constructor(arg0: double, arg1: double, arg2: double, arg3: double)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeLayerSettings$$Type = ($GeodeLayerSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeodeLayerSettings$$Original = $GeodeLayerSettings;}
declare module "net.minecraft.world.level.levelgen.feature.SimpleRandomSelectorFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration, $SimpleRandomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $SimpleRandomSelectorFeature extends $Feature<($SimpleRandomFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($SimpleRandomFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($SimpleRandomFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleRandomSelectorFeature$$Type = ($SimpleRandomSelectorFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleRandomSelectorFeature$$Original = $SimpleRandomSelectorFeature;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.PosRuleTestType" {
import {$PosRuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.PosRuleTest"
import {$LinearPosTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.LinearPosTest"
import {$PosAlwaysTrueTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.PosAlwaysTrueTest"
import {$AxisAlignedLinearPosTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.AxisAlignedLinearPosTest"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export interface $PosRuleTestType$$Interface<P extends $PosRuleTest> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.PosRuleTest
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.PosRuleTestTag
}

export class $PosRuleTestType<P extends $PosRuleTest> implements $PosRuleTestType$$Interface {
static readonly "ALWAYS_TRUE_TEST": $PosRuleTestType<($PosAlwaysTrueTest)>
static readonly "AXIS_ALIGNED_LINEAR_POS_TEST": $PosRuleTestType<($AxisAlignedLinearPosTest)>
static readonly "LINEAR_POS_TEST": $PosRuleTestType<($LinearPosTest)>

static "register"<P extends $PosRuleTest>(arg0: StringJS, arg1: $MapCodec$$Type<(P)>): $PosRuleTestType<(P)>
 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PosRuleTestType$$Type<P> = (Special.PosRuleTest) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PosRuleTestType$$Original<P> = $PosRuleTestType<(P)>;}
declare module "net.minecraft.world.level.block.AbstractChestBlock" {
import {$ChestBlockEntity} from "net.minecraft.world.level.block.entity.ChestBlockEntity"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DoubleBlockCombiner$NeighborCombineResult} from "net.minecraft.world.level.block.DoubleBlockCombiner$NeighborCombineResult"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractChestBlock<E extends $BlockEntity> extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "combine"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: boolean): $DoubleBlockCombiner$NeighborCombineResult<($ChestBlockEntity)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractChestBlock$$Type<E> = ($AbstractChestBlock<(E)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractChestBlock$$Original<E> = $AbstractChestBlock<(E)>;}
declare module "net.minecraft.world.level.levelgen.structure.structures.BuriedTreasureStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $BuriedTreasureStructure extends $Structure {
static readonly "CODEC": $MapCodec<($BuriedTreasureStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuriedTreasureStructure$$Type = ($BuriedTreasureStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuriedTreasureStructure$$Original = $BuriedTreasureStructure;}
declare module "net.minecraft.world.level.block.entity.DispenserBlockEntity" {
import {$DispenserBlockEntityAccessor$$Interface} from "net.mehvahdjukaar.moonlight.core.mixins.accessor.DispenserBlockEntityAccessor"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Level} from "net.minecraft.world.level.Level"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type, $InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$Component} from "net.minecraft.network.chat.Component"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DispenserBlockEntity extends $RandomizableContainerBlockEntity implements $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface, $DispenserBlockEntityAccessor$$Interface {
static readonly "CONTAINER_SIZE": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getRandomSlot"(arg0: $RandomSource$$Type): integer
public "getItems"(): $NonNullList
public "handler$dil002$lithium$setInventoryStackListReplacement"(arg0: $NonNullList$$Type, arg1: $CallbackInfo$$Type): void
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "insertItem"(arg0: $ItemStack$$Type): $ItemStack
public "getContainerSize"(): integer
public "generateLootLithium"(): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public "lithium$emitRemoved"(): void
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitContentModified"(): void
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "tryClear"(arg0: any): void
get "items"(): $NonNullList
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "containerSize"(): integer
get "changed"(): void
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DispenserBlockEntity$$Type = ($DispenserBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DispenserBlockEntity$$Original = $DispenserBlockEntity;}
declare module "net.minecraft.world.level.levelgen.blending.BlendingData" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$WorldGenRegion$$Type} from "net.minecraft.server.level.WorldGenRegion"
import {$Set} from "java.util.Set"
import {$Direction8} from "net.minecraft.core.Direction8"

export class $BlendingData {
static readonly "CODEC": $Codec<($BlendingData)>

public static "sideByGenerationAge"(arg0: $WorldGenLevel$$Type, arg1: integer, arg2: integer, arg3: boolean): $Set<($Direction8)>
public "getAreaWithOldGeneration"(): $LevelHeightAccessor
public static "getOrUpdateBlendingData"(arg0: $WorldGenRegion$$Type, arg1: integer, arg2: integer): $BlendingData
get "areaWithOldGeneration"(): $LevelHeightAccessor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlendingData$$Type = ($BlendingData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlendingData$$Original = $BlendingData;}
declare module "net.minecraft.world.level.gameevent.BlockPositionSource" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PositionSource$$Interface} from "net.minecraft.world.level.gameevent.PositionSource"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PositionSourceType} from "net.minecraft.world.level.gameevent.PositionSourceType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $BlockPositionSource implements $PositionSource$$Interface {
static readonly "CODEC": $MapCodec<($BlockPositionSource)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($BlockPositionSource)>

constructor(arg0: $BlockPos$$Type)

public "getPosition"(arg0: $Level$$Type): $Optional<($Vec3)>
public "getType"(): $PositionSourceType<($BlockPositionSource)>
get "type"(): $PositionSourceType<($BlockPositionSource)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPositionSource$$Type = ($BlockPositionSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPositionSource$$Original = $BlockPositionSource;}
declare module "net.minecraft.world.level.levelgen.PositionalRandomFactory" {
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$StringBuilder$$Type} from "java.lang.StringBuilder"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export interface $PositionalRandomFactory$$Interface {
}

export class $PositionalRandomFactory implements $PositionalRandomFactory$$Interface {
 "at"(arg0: $BlockPos$$Type): $RandomSource
 "at"(arg0: integer, arg1: integer, arg2: integer): $RandomSource
 "parityConfigString"(arg0: $StringBuilder$$Type): void
 "fromHashOf"(arg0: StringJS): $RandomSource
 "fromHashOf"(arg0: $ResourceLocation$$Type): $RandomSource
 "fromSeed"(arg0: long): $RandomSource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PositionalRandomFactory$$Type = ($PositionalRandomFactory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PositionalRandomFactory$$Original = $PositionalRandomFactory;}
declare module "net.minecraft.world.level.storage.loot.functions.LootItemFunction" {
import {$BiFunction, $BiFunction$$Type, $BiFunction$$Interface} from "java.util.function.BiFunction"
import {$LootContextParam} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$LootContext, $LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Function$$Type} from "java.util.function.Function"
import {$Set} from "java.util.Set"
import {$LootItemFunctionType} from "net.minecraft.world.level.storage.loot.functions.LootItemFunctionType"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootContextUser$$Interface} from "net.minecraft.world.level.storage.loot.LootContextUser"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LootItemFunction$$Interface extends $LootContextUser$$Interface, $BiFunction$$Interface<($ItemStack), ($LootContext), ($ItemStack)> {
get "type"(): $LootItemFunctionType<($LootItemFunction)>
get "referencedContextParams"(): $Set<($LootContextParam<(never)>)>
}

export class $LootItemFunction implements $LootItemFunction$$Interface {
 "getType"(): $LootItemFunctionType<($LootItemFunction)>
static "decorate"(arg0: $BiFunction$$Type<($ItemStack), ($LootContext), ($ItemStack$$Type)>, arg1: $Consumer$$Type<($ItemStack)>, arg2: $LootContext$$Type): $Consumer<($ItemStack)>
 "getReferencedContextParams"(): $Set<($LootContextParam<(never)>)>
 "validate"(arg0: $ValidationContext$$Type): void
 "apply"(arg0: $ItemStack$$Type, arg1: $LootContext$$Type): $ItemStack
 "andThen"<V>(arg0: $Function$$Type<($ItemStack), (V)>): $BiFunction<($ItemStack), ($LootContext), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemFunction$$Type = ($LootItemFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemFunction$$Original = $LootItemFunction;}
declare module "net.minecraft.world.level.biome.BiomeSpecialEffects$GrassColorModifier" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ExtensionInfo} from "net.neoforged.fml.common.asm.enumextension.ExtensionInfo"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$IExtensibleEnum$$Interface} from "net.neoforged.fml.common.asm.enumextension.IExtensibleEnum"

export class $BiomeSpecialEffects$GrassColorModifier extends $Enum<($BiomeSpecialEffects$GrassColorModifier)> implements $StringRepresentable$$Interface, $IExtensibleEnum$$Interface {
static readonly "CODEC": $Codec<($BiomeSpecialEffects$GrassColorModifier)>
static readonly "SWAMP": $BiomeSpecialEffects$GrassColorModifier
static readonly "NONE": $BiomeSpecialEffects$GrassColorModifier
static readonly "DARK_FOREST": $BiomeSpecialEffects$GrassColorModifier

public "modifyColor"(arg0: double, arg1: double, arg2: integer): integer
public "getName"(): StringJS
public static "values"(): ($BiomeSpecialEffects$GrassColorModifier)[]
public static "valueOf"(arg0: StringJS): $BiomeSpecialEffects$GrassColorModifier
public static "getExtensionInfo"(): $ExtensionInfo
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "name"(): StringJS
public static get "extensionInfo"(): $ExtensionInfo
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeSpecialEffects$GrassColorModifier$$Type = (("none") | ("dark_forest") | ("swamp"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeSpecialEffects$GrassColorModifier$$Original = $BiomeSpecialEffects$GrassColorModifier;}
declare module "net.minecraft.world.level.chunk.PalettedContainerRO" {
import {$PalettedContainer$CountConsumer$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$CountConsumer"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$PalettedContainerRO$PackedData} from "net.minecraft.world.level.chunk.PalettedContainerRO$PackedData"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$PalettedContainer$Strategy$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$Strategy"
import {$PalettedContainer} from "net.minecraft.world.level.chunk.PalettedContainer"
import {$IdMap$$Type} from "net.minecraft.core.IdMap"
import {$Consumer$$Type} from "java.util.function.Consumer"

export interface $PalettedContainerRO$$Interface<T> {
get "serializedSize"(): integer
}

export class $PalettedContainerRO<T> implements $PalettedContainerRO$$Interface {
 "maybeHas"(arg0: $Predicate$$Type<(T)>): boolean
 "getSerializedSize"(): integer
 "getAll"(arg0: $Consumer$$Type<(T)>): void
 "pack"(arg0: $IdMap$$Type<(T)>, arg1: $PalettedContainer$Strategy$$Type): $PalettedContainerRO$PackedData<(T)>
 "recreate"(): $PalettedContainer<(T)>
 "get"(arg0: integer, arg1: integer, arg2: integer): T
 "count"(arg0: $PalettedContainer$CountConsumer$$Type<(T)>): void
 "write"(arg0: $FriendlyByteBuf$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainerRO$$Type<T> = ($PalettedContainerRO<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainerRO$$Original<T> = $PalettedContainerRO<(T)>;}
declare module "net.minecraft.world.level.NoiseColumn" {
import {$BlockColumn$$Interface} from "net.minecraft.world.level.chunk.BlockColumn"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NoiseColumn implements $BlockColumn$$Interface {
constructor(arg0: integer, arg1: ($BlockState$$Type)[])

public "getBlock"(arg0: integer): $BlockState
public "setBlock"(arg0: integer, arg1: $BlockState$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseColumn$$Type = ($NoiseColumn);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseColumn$$Original = $NoiseColumn;}
declare module "net.minecraft.world.level.storage.loot.LootContextUser" {
import {$LootContextParam} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$Set} from "java.util.Set"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"

export interface $LootContextUser$$Interface {
get "referencedContextParams"(): $Set<($LootContextParam<(never)>)>
}

export class $LootContextUser implements $LootContextUser$$Interface {
 "getReferencedContextParams"(): $Set<($LootContextParam<(never)>)>
 "validate"(arg0: $ValidationContext$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContextUser$$Type = ($LootContextUser);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContextUser$$Original = $LootContextUser;}
declare module "net.minecraft.world.level.block.MangrovePropaguleBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$TreeGrower$$Type} from "net.minecraft.world.level.block.grower.TreeGrower"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$SaplingBlock} from "net.minecraft.world.level.block.SaplingBlock"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $MangrovePropaguleBlock extends $SaplingBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($MangrovePropaguleBlock)>
static readonly "STAGE": $IntegerProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "HANGING": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $TreeGrower$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "createNewHangingPropagule"(): $BlockState
public static "createNewHangingPropagule"(arg0: integer): $BlockState
public "codec"(): $MapCodec<($MangrovePropaguleBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MangrovePropaguleBlock$$Type = ($MangrovePropaguleBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MangrovePropaguleBlock$$Original = $MangrovePropaguleBlock;}
declare module "net.minecraft.world.level.levelgen.feature.MonsterRoomFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $MonsterRoomFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MonsterRoomFeature$$Type = ($MonsterRoomFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MonsterRoomFeature$$Original = $MonsterRoomFeature;}
declare module "net.minecraft.world.level.BaseSpawner" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SimpleWeightedRandomList} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$BaseSpawnerAccessor$$Interface} from "dev.shadowsoffire.apotheosis.mixin.BaseSpawnerAccessor"
import {$IOwnedSpawner$$Interface} from "net.neoforged.neoforge.common.extensions.IOwnedSpawner"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Either} from "com.mojang.datafixers.util.Either"
import {$SpawnData, $SpawnData$$Type} from "net.minecraft.world.level.SpawnData"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BaseSpawnerAccess$$Interface} from "me.desht.pneumaticcraft.mixin.accessors.BaseSpawnerAccess"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $BaseSpawner implements $IOwnedSpawner$$Interface, $BaseSpawnerAccess$$Interface, $BaseSpawnerAccessor$$Interface {
 "spawnDelay": integer
 "oSpin": double
 "spin": double
 "maxNearbyEntities": integer
 "requiredPlayerRange": integer
static readonly "SPAWN_DATA_TAG": StringJS
 "maxSpawnDelay": integer
 "spawnCount": integer
 "minSpawnDelay": integer
 "spawnPotentials": $SimpleWeightedRandomList<($SpawnData)>
 "spawnRange": integer
 "nextSpawnData": $SpawnData

constructor()

public "serverTick"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): void
public "getSpin"(): double
public "getOrCreateDisplayEntity"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $Entity
public "getRequiredPlayerRange"(): integer
public "onEventTriggered"(arg0: $Level$$Type, arg1: integer): boolean
public "setEntityId"(arg0: $EntityType$$Type<(never)>, arg1: $Level$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): void
public "getOrCreateNextSpawnData"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $SpawnData
public "isNearPlayer"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public "broadcastEvent"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: integer): void
public "getoSpin"(): double
public "getNextSpawnData"(): $SpawnData
public "setRequiredPlayerRange"(arg0: integer): void
public "getSpawnDelay"(): integer
public "setSpawnDelay"(arg0: integer): void
public "setOSpin"(arg0: double): void
public "callSetNextSpawnData"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $SpawnData$$Type): void
public "load"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $CompoundTag$$Type): void
public "save"(arg0: $CompoundTag$$Type): $CompoundTag
public "getOwner"(): $Either<($BlockEntity), ($Entity)>
public "clientTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
set "OSpin"(value: double)
get "owner"(): $Either<($BlockEntity), ($Entity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseSpawner$$Type = ($BaseSpawner);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseSpawner$$Original = $BaseSpawner;}
declare module "net.minecraft.world.level.block.GrindstoneBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$FaceAttachedHorizontalDirectionalBlock} from "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $GrindstoneBlock extends $FaceAttachedHorizontalDirectionalBlock {
static readonly "FLOOR_EAST_WEST_GRINDSTONE": $VoxelShape
static readonly "WALL_WEST_LEFT_POST": $VoxelShape
static readonly "WALL_NORTH_RIGHT_POST": $VoxelShape
static readonly "CEILING_EAST_WEST_RIGHT_LEG": $VoxelShape
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "WALL_WEST_RIGHT_POST": $VoxelShape
static readonly "UPDATE_INVISIBLE": integer
static readonly "FLOOR_NORTH_SOUTH_LEFT_LEG": $VoxelShape
static readonly "CEILING_NORTH_SOUTH_LEFT_PIVOT": $VoxelShape
static readonly "CEILING_NORTH_SOUTH_GRINDSTONE": $VoxelShape
static readonly "UPDATE_LIMIT": integer
static readonly "WALL_SOUTH_LEFT_POST": $VoxelShape
static readonly "WALL_SOUTH_ALL_LEGS": $VoxelShape
static readonly "FLOOR_EAST_WEST_LEFT_POST": $VoxelShape
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "WALL_SOUTH_GRINDSTONE": $VoxelShape
static readonly "FLOOR_EAST_WEST_LEFT_PIVOT": $VoxelShape
static readonly "WALL_EAST_LEFT_POST": $VoxelShape
static readonly "FLOOR_EAST_WEST_RIGHT_LEG": $VoxelShape
static readonly "WALL_SOUTH_RIGHT_LEG": $VoxelShape
static readonly "CEILING_NORTH_SOUTH_RIGHT_LEG": $VoxelShape
static readonly "FLOOR_NORTH_SOUTH_RIGHT_PIVOT": $VoxelShape
static readonly "CEILING_NORTH_SOUTH_LEFT_LEG": $VoxelShape
 "item": $Item
static readonly "CODEC": $MapCodec<($GrindstoneBlock)>
static readonly "WALL_NORTH_LEFT_LEG": $VoxelShape
static readonly "WALL_WEST_LEFT_PIVOT": $VoxelShape
static readonly "WALL_EAST_LEFT_LEG": $VoxelShape
static readonly "WALL_NORTH_GRINDSTONE": $VoxelShape
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "FLOOR_EAST_WEST_RIGHT_PIVOT": $VoxelShape
static readonly "WALL_SOUTH_LEFT_LEG": $VoxelShape
static readonly "CEILING_EAST_WEST_GRINDSTONE": $VoxelShape
static readonly "INSTANT": float
static readonly "WALL_WEST_LEFT_LEG": $VoxelShape
static readonly "WALL_NORTH_RIGHT_LEG": $VoxelShape
static readonly "WALL_EAST_RIGHT_POST": $VoxelShape
static readonly "FLOOR_NORTH_SOUTH_RIGHT_LEG": $VoxelShape
static readonly "WALL_EAST_RIGHT_PIVOT": $VoxelShape
static readonly "FLOOR_NORTH_SOUTH_LEFT_POST": $VoxelShape
static readonly "CEILING_NORTH_SOUTH_LEFT_POST": $VoxelShape
static readonly "CEILING_EAST_WEST_ALL_LEGS": $VoxelShape
static readonly "CEILING_NORTH_SOUTH_RIGHT_PIVOT": $VoxelShape
static readonly "WALL_SOUTH_RIGHT_POST": $VoxelShape
static readonly "WALL_NORTH_RIGHT_PIVOT": $VoxelShape
static readonly "CEILING_NORTH_SOUTH_RIGHT_POST": $VoxelShape
static readonly "FLOOR_NORTH_SOUTH_GRINDSTONE": $VoxelShape
static readonly "WALL_EAST_LEFT_PIVOT": $VoxelShape
static readonly "CEILING_EAST_WEST_LEFT_PIVOT": $VoxelShape
static readonly "CEILING_EAST_WEST_LEFT_LEG": $VoxelShape
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "WALL_EAST_RIGHT_LEG": $VoxelShape
static readonly "WALL_NORTH_LEFT_PIVOT": $VoxelShape
static readonly "CEILING_EAST_WEST_LEFT_POST": $VoxelShape
static readonly "UPDATE_ALL": integer
static readonly "WALL_WEST_RIGHT_PIVOT": $VoxelShape
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "FLOOR_EAST_WEST_LEFT_LEG": $VoxelShape
static readonly "CEILING_EAST_WEST_RIGHT_PIVOT": $VoxelShape
static readonly "FLOOR_NORTH_SOUTH_LEFT_PIVOT": $VoxelShape
static readonly "UPDATE_IMMEDIATE": integer
static readonly "CEILING_NORTH_SOUTH_ALL_LEGS": $VoxelShape
static readonly "WALL_WEST_RIGHT_LEG": $VoxelShape
static readonly "WALL_SOUTH_RIGHT_PIVOT": $VoxelShape
static readonly "WALL_NORTH_LEFT_POST": $VoxelShape
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "FLOOR_EAST_WEST_RIGHT_POST": $VoxelShape
static readonly "WALL_WEST_ALL_LEGS": $VoxelShape
static readonly "WALL_WEST_GRINDSTONE": $VoxelShape
static readonly "WALL_EAST_ALL_LEGS": $VoxelShape
static readonly "FLOOR_NORTH_SOUTH_RIGHT_POST": $VoxelShape
static readonly "WALL_SOUTH_LEFT_PIVOT": $VoxelShape
static readonly "FLOOR_NORTH_SOUTH_ALL_LEGS": $VoxelShape
static readonly "CEILING_EAST_WEST_RIGHT_POST": $VoxelShape
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "FLOOR_EAST_WEST_ALL_LEGS": $VoxelShape
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "WALL_NORTH_ALL_LEGS": $VoxelShape
static readonly "FACE": $EnumProperty<($AttachFace)>
static readonly "WALL_EAST_GRINDSTONE": $VoxelShape

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($GrindstoneBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GrindstoneBlock$$Type = ($GrindstoneBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GrindstoneBlock$$Original = $GrindstoneBlock;}
declare module "net.minecraft.world.level.block.state.properties.DirectionProperty" {
import {$Collection$$Type} from "java.util.Collection"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"

export class $DirectionProperty extends $EnumProperty<($Direction)> {
public static "create"(arg0: StringJS, ...arg1: ($Direction$$Type)[]): $DirectionProperty
public static "create"(arg0: StringJS, arg1: $Collection$$Type<($Direction$$Type)>): $DirectionProperty
public static "create"(arg0: StringJS): $DirectionProperty
public static "create"(arg0: StringJS, arg1: $Predicate$$Type<($Direction)>): $DirectionProperty
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionProperty$$Type = ($DirectionProperty);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectionProperty$$Original = $DirectionProperty;}
declare module "net.minecraft.world.level.block.state.properties.NoteBlockInstrument" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$Holder} from "net.minecraft.core.Holder"

export class $NoteBlockInstrument extends $Enum<($NoteBlockInstrument)> implements $StringRepresentable$$Interface {
static readonly "BASS": $NoteBlockInstrument
static readonly "DIDGERIDOO": $NoteBlockInstrument
static readonly "BASEDRUM": $NoteBlockInstrument
static readonly "XYLOPHONE": $NoteBlockInstrument
static readonly "PIGLIN": $NoteBlockInstrument
static readonly "IRON_XYLOPHONE": $NoteBlockInstrument
static readonly "BIT": $NoteBlockInstrument
static readonly "CHIME": $NoteBlockInstrument
static readonly "PLING": $NoteBlockInstrument
static readonly "SNARE": $NoteBlockInstrument
static readonly "SKELETON": $NoteBlockInstrument
static readonly "WITHER_SKELETON": $NoteBlockInstrument
static readonly "GUITAR": $NoteBlockInstrument
static readonly "CUSTOM_HEAD": $NoteBlockInstrument
static readonly "BANJO": $NoteBlockInstrument
static readonly "CREEPER": $NoteBlockInstrument
static readonly "HARP": $NoteBlockInstrument
static readonly "ZOMBIE": $NoteBlockInstrument
static readonly "DRAGON": $NoteBlockInstrument
static readonly "HAT": $NoteBlockInstrument
static readonly "BELL": $NoteBlockInstrument
static readonly "COW_BELL": $NoteBlockInstrument
static readonly "FLUTE": $NoteBlockInstrument

public "getSoundEvent"(): $Holder<($SoundEvent)>
public "isTunable"(): boolean
public "hasCustomSound"(): boolean
public "worksAboveNoteBlock"(): boolean
public static "values"(): ($NoteBlockInstrument)[]
public static "valueOf"(arg0: StringJS): $NoteBlockInstrument
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "soundEvent"(): $Holder<($SoundEvent)>
get "tunable"(): boolean
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoteBlockInstrument$$Type = (("harp") | ("basedrum") | ("snare") | ("hat") | ("bass") | ("flute") | ("bell") | ("guitar") | ("chime") | ("xylophone") | ("iron_xylophone") | ("cow_bell") | ("didgeridoo") | ("bit") | ("banjo") | ("pling") | ("zombie") | ("skeleton") | ("creeper") | ("dragon") | ("wither_skeleton") | ("piglin") | ("custom_head"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoteBlockInstrument$$Original = $NoteBlockInstrument;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.CappedProcessor" {
import {$ServerLevelAccessor$$Type} from "net.minecraft.world.level.ServerLevelAccessor"
import {$StructureProcessor, $StructureProcessor$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$List, $List$$Type} from "java.util.List"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $CappedProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($CappedProcessor)>

constructor(arg0: $StructureProcessor$$Type, arg1: $IntProvider$$Type)

public "finalizeProcessing"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>, arg4: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>, arg5: $StructurePlaceSettings$$Type): $List<($StructureTemplate$StructureBlockInfo)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CappedProcessor$$Type = ($CappedProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CappedProcessor$$Original = $CappedProcessor;}
declare module "net.minecraft.world.level.LevelSimulatedReader" {
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Optional} from "java.util.Optional"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $LevelSimulatedReader$$Interface {
}

export class $LevelSimulatedReader implements $LevelSimulatedReader$$Interface {
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelSimulatedReader$$Type = ($LevelSimulatedReader);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelSimulatedReader$$Original = $LevelSimulatedReader;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LayerConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($LayerConfiguration)>
readonly "state": $BlockState
readonly "height": integer

constructor(arg0: integer, arg1: $BlockState$$Type)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LayerConfiguration$$Type = ($LayerConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LayerConfiguration$$Original = $LayerConfiguration;}
declare module "net.minecraft.world.level.levelgen.DensityFunction" {
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$Holder} from "net.minecraft.core.Holder"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"

export interface $DensityFunction$$Interface {
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenDensityFunction
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenDensityFunctionTag
}

export class $DensityFunction implements $DensityFunction$$Interface {
static readonly "CODEC": $Codec<($Holder<($DensityFunction)>)>
static readonly "DIRECT_CODEC": $Codec<($DensityFunction)>
static readonly "HOLDER_HELPER_CODEC": $Codec<($DensityFunction)>

 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "cube"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "squeeze"(): $DensityFunction
 "maxValue"(): double
 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "square"(): $DensityFunction
 "minValue"(): double
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$$Type = (Special.WorldgenDensityFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$$Original = $DensityFunction;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $NoneFeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($NoneFeatureConfiguration)>
static readonly "INSTANCE": $NoneFeatureConfiguration

constructor()

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoneFeatureConfiguration$$Type = ($NoneFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoneFeatureConfiguration$$Original = $NoneFeatureConfiguration;}
declare module "net.minecraft.world.level.block.DirectionalBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $DirectionalBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionalBlock$$Type = ($DirectionalBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectionalBlock$$Original = $DirectionalBlock;}
declare module "net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ShulkerBoxBlockEntity$AnimationStatus} from "net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity$AnimationStatus"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$WorldlyContainer$$Interface} from "net.minecraft.world.WorldlyContainer"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type, $InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $ShulkerBoxBlockEntity extends $RandomizableContainerBlockEntity implements $WorldlyContainer$$Interface, $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface, $SleepingBlockEntity$$Interface {
static readonly "EVENT_SET_OPEN_COUNT": integer
static readonly "CONTAINER_SIZE": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
static readonly "COLUMNS": integer
static readonly "OPENING_TICK_LENGTH": integer
 "lockKey": $LockCode
static readonly "MAX_LID_HEIGHT": float
static readonly "MAX_LID_ROTATION": float
static readonly "ROWS": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)
constructor(arg0: $DyeColor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getAnimationStatus"(): $ShulkerBoxBlockEntity$AnimationStatus
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "startOpen"(arg0: $Player$$Type): void
public "stopOpen"(arg0: $Player$$Type): void
public "getSlotsForFace"(arg0: $Direction$$Type): (integer)[]
public "canPlaceItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "canTakeItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "handler$din004$lithium$setInventoryStackListReplacement"(arg0: $NonNullList$$Type, arg1: $CallbackInfo$$Type): void
public "loadFromTag"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "handler$bcg000$supplementaries$supp$preventInsertion"(index: integer, itemStackIn: $ItemStack$$Type, direction: $Direction$$Type, info: $CallbackInfoReturnable$$Type): void
public static "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $ShulkerBoxBlockEntity$$Type): void
public "isClosed"(): boolean
public "getColor"(): $DyeColor
public "getBoundingBox"(arg0: $BlockState$$Type): $AABB
public "getContainerSize"(): integer
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "getProgress"(arg0: float): float
public "generateLootLithium"(): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$startSleeping"(): boolean
public "wakeUpNow"(): void
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "sleepOnlyCurrentTick"(): void
public "isSleeping"(): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public "lithium$emitRemoved"(): void
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitContentModified"(): void
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "tryClear"(arg0: any): void
get "animationStatus"(): $ShulkerBoxBlockEntity$AnimationStatus
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "closed"(): boolean
get "color"(): $DyeColor
get "containerSize"(): integer
set "ticker"(value: $TickingBlockEntity$$Type)
get "sleeping"(): boolean
get "changed"(): void
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShulkerBoxBlockEntity$$Type = ($ShulkerBoxBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShulkerBoxBlockEntity$$Original = $ShulkerBoxBlockEntity;}
declare module "net.minecraft.world.level.levelgen.synth.BlendedNoise" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$DensityFunction$SimpleFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction$SimpleFunction"
import {$StringBuilder$$Type} from "java.lang.StringBuilder"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction} from "net.minecraft.world.level.levelgen.DensityFunction"

export class $BlendedNoise implements $DensityFunction$SimpleFunction$$Interface {
static readonly "CODEC": $KeyDispatchDataCodec<($BlendedNoise)>

constructor(arg0: $RandomSource$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double)

public static "createUnseeded"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): $BlendedNoise
public "withNewRandom"(arg0: $RandomSource$$Type): $BlendedNoise
public "maxValue"(): double
public "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
public "minValue"(): double
public "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
public "parityConfigString"(arg0: $StringBuilder$$Type): void
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
public "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
public "cube"(): $DensityFunction
public "halfNegative"(): $DensityFunction
public "quarterNegative"(): $DensityFunction
public "squeeze"(): $DensityFunction
public "abs"(): $DensityFunction
public "clamp"(arg0: double, arg1: double): $DensityFunction
public "square"(): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlendedNoise$$Type = ($BlendedNoise);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlendedNoise$$Original = $BlendedNoise;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.RuleBasedBlockStateProvider$Rule" {
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Record} from "java.lang.Record"

export class $RuleBasedBlockStateProvider$Rule extends $Record {
static readonly "CODEC": $Codec<($RuleBasedBlockStateProvider$Rule)>

constructor(arg0: $BlockPredicate$$Type, arg1: $BlockStateProvider$$Type)

public "ifTrue"(): $BlockPredicate
public "then"(): $BlockStateProvider
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleBasedBlockStateProvider$Rule$$Type = ({"ifTrue"?: $BlockPredicate$$Type, "then"?: $BlockStateProvider$$Type}) | ([ifTrue?: $BlockPredicate$$Type, then?: $BlockStateProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleBasedBlockStateProvider$Rule$$Original = $RuleBasedBlockStateProvider$Rule;}
declare module "net.minecraft.world.level.block.HalfTransparentBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $HalfTransparentBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($HalfTransparentBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HalfTransparentBlock$$Type = ($HalfTransparentBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HalfTransparentBlock$$Original = $HalfTransparentBlock;}
declare module "net.minecraft.world.level.block.SoulFireBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BaseFireBlock} from "net.minecraft.world.level.block.BaseFireBlock"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SoulFireBlock extends $BaseFireBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SoulFireBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "canSurviveOnBlock"(arg0: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($SoulFireBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoulFireBlock$$Type = ($SoulFireBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoulFireBlock$$Original = $SoulFireBlock;}
declare module "net.minecraft.world.level.chunk.LevelChunkSection" {
import {$Climate$Sampler$$Type} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$BiomeResolver$$Type} from "net.minecraft.world.level.biome.BiomeResolver"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$PalettedContainer, $PalettedContainer$$Type} from "net.minecraft.world.level.chunk.PalettedContainer"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$PalettedContainerRO, $PalettedContainerRO$$Type} from "net.minecraft.world.level.chunk.PalettedContainerRO"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LevelChunkSection {
static readonly "SECTION_WIDTH": integer
static readonly "SECTION_HEIGHT": integer
static readonly "BIOME_CONTAINER_BITS": integer
static readonly "SECTION_SIZE": integer
readonly "states": $PalettedContainer<($BlockState)>

constructor(arg0: $PalettedContainer$$Type<($BlockState$$Type)>, arg1: $PalettedContainerRO$$Type<($Holder$$Type<($Biome$$Type)>)>)
constructor(arg0: $Registry$$Type<($Biome$$Type)>)

public "isRandomlyTicking"(): boolean
public "readBiomes"(arg0: $FriendlyByteBuf$$Type): void
public "maybeHas"(arg0: $Predicate$$Type<($BlockState)>): boolean
public "fillBiomesFromNoise"(arg0: $BiomeResolver$$Type, arg1: $Climate$Sampler$$Type, arg2: integer, arg3: integer, arg4: integer): void
public "getBiomes"(): $PalettedContainerRO<($Holder<($Biome)>)>
public "getSerializedSize"(): integer
public "recalcBlockCounts"(): void
public "isRandomlyTickingBlocks"(): boolean
public "isRandomlyTickingFluids"(): boolean
public "write"(arg0: $FriendlyByteBuf$$Type): void
public "read"(arg0: $FriendlyByteBuf$$Type): void
public "release"(): void
public "acquire"(): void
public "getStates"(): $PalettedContainer<($BlockState)>
public "getFluidState"(arg0: integer, arg1: integer, arg2: integer): $FluidState
public "getBlockState"(arg0: integer, arg1: integer, arg2: integer): $BlockState
public "setBlockState"(arg0: integer, arg1: integer, arg2: integer, arg3: $BlockState$$Type, arg4: boolean): $BlockState
public "setBlockState"(arg0: integer, arg1: integer, arg2: integer, arg3: $BlockState$$Type): $BlockState
public "hasOnlyAir"(): boolean
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
get "randomlyTicking"(): boolean
get "biomes"(): $PalettedContainerRO<($Holder<($Biome)>)>
get "serializedSize"(): integer
get "randomlyTickingBlocks"(): boolean
get "randomlyTickingFluids"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelChunkSection$$Type = ($LevelChunkSection);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelChunkSection$$Original = $LevelChunkSection;}
declare module "net.minecraft.world.level.levelgen.placement.EnvironmentScanPlacement" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $EnvironmentScanPlacement extends $PlacementModifier {
static readonly "CODEC": $MapCodec<($EnvironmentScanPlacement)>

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
public static "scanningFor"(arg0: $Direction$$Type, arg1: $BlockPredicate$$Type, arg2: integer): $EnvironmentScanPlacement
public static "scanningFor"(arg0: $Direction$$Type, arg1: $BlockPredicate$$Type, arg2: $BlockPredicate$$Type, arg3: integer): $EnvironmentScanPlacement
public "type"(): $PlacementModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnvironmentScanPlacement$$Type = ($EnvironmentScanPlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnvironmentScanPlacement$$Original = $EnvironmentScanPlacement;}
declare module "net.minecraft.world.level.block.HopperBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$ShapeUpdateHandlingBlockBehaviour$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.ShapeUpdateHandlingBlockBehaviour"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HopperBlock extends $BaseEntityBlock implements $ShapeUpdateHandlingBlockBehaviour$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($HopperBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "ENABLED": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "lithium$handleShapeUpdate"(arg0: $LevelReader$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: $BlockState$$Type): void
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($HopperBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HopperBlock$$Type = ($HopperBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HopperBlock$$Original = $HopperBlock;}
declare module "net.minecraft.world.level.block.entity.DaylightDetectorBlockEntity" {
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DaylightDetectorBlockEntity extends $BlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DaylightDetectorBlockEntity$$Type = ($DaylightDetectorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DaylightDetectorBlockEntity$$Original = $DaylightDetectorBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"

export class $NetherForestVegetationConfig extends $BlockPileConfiguration {
static readonly "CODEC": $Codec<($NetherForestVegetationConfig)>
readonly "spreadHeight": integer
readonly "spreadWidth": integer
readonly "stateProvider": $BlockStateProvider

constructor(arg0: $BlockStateProvider$$Type, arg1: integer, arg2: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherForestVegetationConfig$$Type = ($NetherForestVegetationConfig);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherForestVegetationConfig$$Original = $NetherForestVegetationConfig;}
declare module "net.minecraft.world.level.block.state.properties.ComparatorMode" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $ComparatorMode extends $Enum<($ComparatorMode)> implements $StringRepresentable$$Interface {
static readonly "COMPARE": $ComparatorMode
static readonly "SUBTRACT": $ComparatorMode

public "toString"(): StringJS
public static "values"(): ($ComparatorMode)[]
public static "valueOf"(arg0: StringJS): $ComparatorMode
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparatorMode$$Type = (("compare") | ("subtract"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComparatorMode$$Original = $ComparatorMode;}
declare module "net.minecraft.world.level.block.ComposterBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$WorldlyContainerHolder$$Interface} from "net.minecraft.world.WorldlyContainerHolder"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$WorldlyContainer} from "net.minecraft.world.WorldlyContainer"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Object2FloatMap} from "it.unimi.dsi.fastutil.objects.Object2FloatMap"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$ItemLike, $ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ComposterBlock extends $Block implements $WorldlyContainerHolder$$Interface {
static readonly "READY": integer
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ComposterBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "MIN_LEVEL": integer
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "LEVEL": $IntegerProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
/**
 * 
 * @deprecated
 */
static readonly "COMPOSTABLES": $Object2FloatMap<($ItemLike)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "MAX_LEVEL": integer
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "handleFill"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: boolean): void
public static "extractProduce"(arg0: $Entity$$Type, arg1: $BlockState$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): $BlockState
public "getContainer"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): $WorldlyContainer
public static "getValue"(arg0: $ItemStack$$Type): float
public static "add"(arg0: float, arg1: $ItemLike$$Type): void
public static "bootStrap"(): void
public "codec"(): $MapCodec<($ComposterBlock)>
public static "insertItem"(arg0: $Entity$$Type, arg1: $BlockState$$Type, arg2: $ServerLevel$$Type, arg3: $ItemStack$$Type, arg4: $BlockPos$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComposterBlock$$Type = ($ComposterBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComposterBlock$$Original = $ComposterBlock;}
declare module "net.minecraft.world.level.block.SignBlock" {
import {$WoodType} from "net.minecraft.world.level.block.state.properties.WoodType"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SignBlockEntity$$Type} from "net.minecraft.world.level.block.entity.SignBlockEntity"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SignBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "isPossibleToRespawnInThis"(arg0: $BlockState$$Type): boolean
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getYRotationDegrees"(arg0: $BlockState$$Type): float
public "getSignHitboxCenterPosition"(arg0: $BlockState$$Type): $Vec3
public static "getWoodType"(arg0: $Block$$Type): $WoodType
public "type"(): $WoodType
public "openTextEdit"(arg0: $Player$$Type, arg1: $SignBlockEntity$$Type, arg2: boolean): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignBlock$$Type = ($SignBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignBlock$$Original = $SignBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.OceanRuinStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"
import {$OceanRuinStructure$Type, $OceanRuinStructure$Type$$Type} from "net.minecraft.world.level.levelgen.structure.structures.OceanRuinStructure$Type"

export class $OceanRuinStructure extends $Structure {
readonly "largeProbability": float
readonly "clusterProbability": float
static readonly "CODEC": $MapCodec<($OceanRuinStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>
readonly "biomeTemp": $OceanRuinStructure$Type

constructor(arg0: $Structure$StructureSettings$$Type, arg1: $OceanRuinStructure$Type$$Type, arg2: float, arg3: float)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OceanRuinStructure$$Type = ($OceanRuinStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OceanRuinStructure$$Original = $OceanRuinStructure;}
declare module "net.minecraft.world.level.block.state.properties.BlockSetType" {
import {$BlockSetType$PressurePlateSensitivity, $BlockSetType$PressurePlateSensitivity$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType$PressurePlateSensitivity"
import {$Codec} from "com.mojang.serialization.Codec"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Stream} from "java.util.stream.Stream"
import {$Record} from "java.lang.Record"

export class $BlockSetType extends $Record {
static readonly "GOLD": $BlockSetType
static readonly "MANGROVE": $BlockSetType
static readonly "CODEC": $Codec<($BlockSetType)>
static readonly "BAMBOO": $BlockSetType
static readonly "ACACIA": $BlockSetType
static readonly "JUNGLE": $BlockSetType
static readonly "CRIMSON": $BlockSetType
static readonly "IRON": $BlockSetType
static readonly "COPPER": $BlockSetType
static readonly "DARK_OAK": $BlockSetType
static readonly "SPRUCE": $BlockSetType
static readonly "CHERRY": $BlockSetType
static readonly "BIRCH": $BlockSetType
static readonly "WARPED": $BlockSetType
static readonly "OAK": $BlockSetType
static readonly "POLISHED_BLACKSTONE": $BlockSetType
static readonly "STONE": $BlockSetType

constructor(arg0: StringJS)
constructor(arg0: StringJS, arg1: boolean, arg2: boolean, arg3: boolean, arg4: $BlockSetType$PressurePlateSensitivity$$Type, arg5: $SoundType$$Type, arg6: $SoundEvent$$Type, arg7: $SoundEvent$$Type, arg8: $SoundEvent$$Type, arg9: $SoundEvent$$Type, arg10: $SoundEvent$$Type, arg11: $SoundEvent$$Type, arg12: $SoundEvent$$Type, arg13: $SoundEvent$$Type)

public "soundType"(): $SoundType
public "trapdoorOpen"(): $SoundEvent
public "buttonClickOn"(): $SoundEvent
public "buttonClickOff"(): $SoundEvent
public "canButtonBeActivatedByArrows"(): boolean
public "canOpenByWindCharge"(): boolean
public "canOpenByHand"(): boolean
public "doorOpen"(): $SoundEvent
public "doorClose"(): $SoundEvent
public "pressurePlateSensitivity"(): $BlockSetType$PressurePlateSensitivity
public "pressurePlateClickOff"(): $SoundEvent
public "pressurePlateClickOn"(): $SoundEvent
public "trapdoorClose"(): $SoundEvent
public "name"(): StringJS
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public static "values"(): $Stream<($BlockSetType)>
public "hashCode"(): integer
public static "register"(arg0: $BlockSetType$$Type): $BlockSetType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockSetType$$Type = ({"doorOpen"?: $SoundEvent$$Type, "buttonClickOn"?: $SoundEvent$$Type, "soundType"?: $SoundType$$Type, "canOpenByHand"?: boolean, "pressurePlateClickOff"?: $SoundEvent$$Type, "doorClose"?: $SoundEvent$$Type, "trapdoorClose"?: $SoundEvent$$Type, "canOpenByWindCharge"?: boolean, "pressurePlateClickOn"?: $SoundEvent$$Type, "canButtonBeActivatedByArrows"?: boolean, "buttonClickOff"?: $SoundEvent$$Type, "pressurePlateSensitivity"?: $BlockSetType$PressurePlateSensitivity$$Type, "trapdoorOpen"?: $SoundEvent$$Type, "name"?: StringJS}) | ([doorOpen?: $SoundEvent$$Type, buttonClickOn?: $SoundEvent$$Type, soundType?: $SoundType$$Type, canOpenByHand?: boolean, pressurePlateClickOff?: $SoundEvent$$Type, doorClose?: $SoundEvent$$Type, trapdoorClose?: $SoundEvent$$Type, canOpenByWindCharge?: boolean, pressurePlateClickOn?: $SoundEvent$$Type, canButtonBeActivatedByArrows?: boolean, buttonClickOff?: $SoundEvent$$Type, pressurePlateSensitivity?: $BlockSetType$PressurePlateSensitivity$$Type, trapdoorOpen?: $SoundEvent$$Type, name?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockSetType$$Original = $BlockSetType;}
declare module "net.minecraft.world.level.chunk.ProtoChunk" {
import {$LevelLightEngine$$Type} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$UpgradeData$$Type} from "net.minecraft.world.level.chunk.UpgradeData"
import {$LevelHeightAccessor, $LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$List} from "java.util.List"
import {$Trackable} from "dev.uncandango.alltheleaks.mixin.Trackable"
import {$BelowZeroRetrogen, $BelowZeroRetrogen$$Type} from "net.minecraft.world.level.levelgen.BelowZeroRetrogen"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ChunkAccess$TicksToSave} from "net.minecraft.world.level.chunk.ChunkAccess$TicksToSave"
import {$ProtoChunkTicks$$Type} from "net.minecraft.world.ticks.ProtoChunkTicks"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$Holder} from "net.minecraft.core.Holder"
import {$TickContainerAccess} from "net.minecraft.world.ticks.TickContainerAccess"
import {$BlendingData$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Function$$Type} from "java.util.function.Function"
import {$CarvingMask, $CarvingMask$$Type} from "net.minecraft.world.level.chunk.CarvingMask"
import {$LevelChunkTicks} from "net.minecraft.world.ticks.LevelChunkTicks"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ObjectOpenCustomHashSet} from "it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ExtendedChunk$$Interface} from "ca.spottedleaf.starlight.common.chunk.ExtendedChunk"
import {$LevelChunkSection$$Type} from "net.minecraft.world.level.chunk.LevelChunkSection"
import {$ChunkStatus, $ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$SWMRNibbleArray, $SWMRNibbleArray$$Type} from "ca.spottedleaf.starlight.common.light.SWMRNibbleArray"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $ProtoChunk extends $ChunkAccess implements $ExtendedChunk$$Interface {
readonly "blockEntities": $Map<($BlockPos), ($BlockEntity)>
static readonly "NO_FILLED_SECTION": integer

constructor(arg0: $ChunkPos$$Type, arg1: $UpgradeData$$Type, arg2: $LevelHeightAccessor$$Type, arg3: $Registry$$Type<($Biome$$Type)>, arg4: $BlendingData$$Type)
constructor(arg0: $ChunkPos$$Type, arg1: $UpgradeData$$Type, arg2: ($LevelChunkSection$$Type)[], arg3: $ProtoChunkTicks$$Type<($Block$$Type)>, arg4: $ProtoChunkTicks$$Type<($Fluid$$Type)>, arg5: $LevelHeightAccessor$$Type, arg6: $Registry$$Type<($Biome$$Type)>, arg7: $BlendingData$$Type)

public "setPersistedStatus"(arg0: $ChunkStatus$$Type): void
public "setBelowZeroRetrogen"(arg0: $BelowZeroRetrogen$$Type): void
public "setCarvingMask"(arg0: $GenerationStep$Carving$$Type, arg1: $CarvingMask$$Type): void
public "setLightEngine"(arg0: $LevelLightEngine$$Type): void
public "markPosForPostprocessing"(arg0: $BlockPos$$Type): void
public "setStartForStructure"(arg0: $Structure$$Type, arg1: $StructureStart$$Type): void
public "getPersistedStatus"(): $ChunkStatus
public "getBelowZeroRetrogen"(): $BelowZeroRetrogen
public "addPackedPostProcess"(arg0: short, arg1: integer): void
public "getBlockEntityNbtForSaving"(arg0: $BlockPos$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "unpackBlockTicks"(): $LevelChunkTicks<($Block)>
public "unpackFluidTicks"(): $LevelChunkTicks<($Fluid)>
public "getBlockEntityNbts"(): $Map<($BlockPos), ($CompoundTag)>
public static "unpackOffsetCoordinates"(arg0: short, arg1: integer, arg2: $ChunkPos$$Type): $BlockPos
public "getTicksForSerialization"(): $ChunkAccess$TicksToSave
public "getHeightAccessorForGeneration"(): $LevelHeightAccessor
public "getBlockEntities"(): $Map<($BlockPos), ($BlockEntity)>
public "getCarvingMask"(arg0: $GenerationStep$Carving$$Type): $CarvingMask
public "getOrCreateCarvingMask"(arg0: $GenerationStep$Carving$$Type): $CarvingMask
public "getEntities"(): $List<($CompoundTag)>
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public static "packOffsetCoordinates"(arg0: $BlockPos$$Type): short
public "setBlockEntity"(arg0: $BlockEntity$$Type): void
public "removeBlockEntity"(arg0: $BlockPos$$Type): void
public "setBlockState"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: boolean): $BlockState
public "getBlockTicks"(): $TickContainerAccess<($Block)>
public "getFluidTicks"(): $TickContainerAccess<($Fluid)>
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "addEntity"(arg0: $CompoundTag$$Type): void
public "addEntity"(arg0: $Entity$$Type): void
public "getBlockNibbles"(): ($SWMRNibbleArray)[]
public "setBlockNibbles"(arg0: ($SWMRNibbleArray$$Type)[]): void
public "getSkyNibbles"(): ($SWMRNibbleArray)[]
public "setSkyNibbles"(arg0: ($SWMRNibbleArray$$Type)[]): void
public "getSkyEmptinessMap"(): (boolean)[]
public "setSkyEmptinessMap"(arg0: (boolean)[]): void
public "getBlockEmptinessMap"(): (boolean)[]
public "setBlockEmptinessMap"(arg0: (boolean)[]): void
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public static "startTracking"(arg0: any): void
public static "createWeakRefBasedSet"(): $ObjectOpenCustomHashSet<($WeakReference<($Trackable)>)>
public static "clearNullReferences"(): void
public static "getSummary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
set "persistedStatus"(value: $ChunkStatus$$Type)
set "belowZeroRetrogen"(value: $BelowZeroRetrogen$$Type)
set "lightEngine"(value: $LevelLightEngine$$Type)
get "persistedStatus"(): $ChunkStatus
get "belowZeroRetrogen"(): $BelowZeroRetrogen
get "blockEntityNbts"(): $Map<($BlockPos), ($CompoundTag)>
get "ticksForSerialization"(): $ChunkAccess$TicksToSave
get "heightAccessorForGeneration"(): $LevelHeightAccessor
get "entities"(): $List<($CompoundTag)>
set "blockEntity"(value: $BlockEntity$$Type)
get "blockTicks"(): $TickContainerAccess<($Block)>
get "fluidTicks"(): $TickContainerAccess<($Fluid)>
get "blockNibbles"(): ($SWMRNibbleArray)[]
set "blockNibbles"(value: ($SWMRNibbleArray$$Type)[])
get "skyNibbles"(): ($SWMRNibbleArray)[]
set "skyNibbles"(value: ($SWMRNibbleArray$$Type)[])
get "skyEmptinessMap"(): (boolean)[]
set "skyEmptinessMap"(value: (boolean)[])
get "blockEmptinessMap"(): (boolean)[]
set "blockEmptinessMap"(value: (boolean)[])
public static get "summary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProtoChunk$$Type = ($ProtoChunk);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProtoChunk$$Original = $ProtoChunk;}
declare module "net.minecraft.world.level.chunk.status.WorldGenContext" {
import {$ChunkTaskPriorityQueueSorter$Message, $ChunkTaskPriorityQueueSorter$Message$$Type} from "net.minecraft.server.level.ChunkTaskPriorityQueueSorter$Message"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$ThreadedLevelLightEngine, $ThreadedLevelLightEngine$$Type} from "net.minecraft.server.level.ThreadedLevelLightEngine"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$ProcessorHandle, $ProcessorHandle$$Type} from "net.minecraft.util.thread.ProcessorHandle"
import {$StructureTemplateManager, $StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Record} from "java.lang.Record"

export class $WorldGenContext extends $Record {
constructor(arg0: $ServerLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $StructureTemplateManager$$Type, arg3: $ThreadedLevelLightEngine$$Type, arg4: $ProcessorHandle$$Type<($ChunkTaskPriorityQueueSorter$Message$$Type<($Runnable$$Type)>)>)

public "structureManager"(): $StructureTemplateManager
public "level"(): $ServerLevel
public "mainThreadMailBox"(): $ProcessorHandle<($ChunkTaskPriorityQueueSorter$Message<($Runnable)>)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "generator"(): $ChunkGenerator
public "lightEngine"(): $ThreadedLevelLightEngine
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldGenContext$$Type = ({"structureManager"?: $StructureTemplateManager$$Type, "mainThreadMailBox"?: $ProcessorHandle$$Type<($ChunkTaskPriorityQueueSorter$Message$$Type<($Runnable$$Type)>)>, "lightEngine"?: $ThreadedLevelLightEngine$$Type, "generator"?: $ChunkGenerator$$Type, "level"?: $ServerLevel$$Type}) | ([structureManager?: $StructureTemplateManager$$Type, mainThreadMailBox?: $ProcessorHandle$$Type<($ChunkTaskPriorityQueueSorter$Message$$Type<($Runnable$$Type)>)>, lightEngine?: $ThreadedLevelLightEngine$$Type, generator?: $ChunkGenerator$$Type, level?: $ServerLevel$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldGenContext$$Original = $WorldGenContext;}
declare module "net.minecraft.world.level.block.entity.BaseContainerBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$LockCode, $LockCode$$Type} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$AccessorMixinBaseContainerBlockEntity$$Interface} from "noobanidus.mods.lootr.common.mixin.accessor.AccessorMixinBaseContainerBlockEntity"
import {$InventoryChangeEmitter$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeEmitter"
import {$BaseContainerBEAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.BaseContainerBEAccess"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Nameable$$Interface} from "net.minecraft.world.Nameable"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container, $Container$$Type, $Container$$Interface} from "net.minecraft.world.Container"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BaseContainerBlockEntityAccess$$Interface} from "me.desht.pneumaticcraft.mixin.accessors.BaseContainerBlockEntityAccess"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $BaseContainerBlockEntity extends $BlockEntity implements $Container$$Interface, $MenuProvider$$Interface, $Nameable$$Interface, $InventoryChangeEmitter$$Interface, $BaseContainerBlockEntityAccess$$Interface, $BaseContainerBEAccess$$Interface, $AccessorMixinBaseContainerBlockEntity$$Interface {
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode

public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "canOpen"(arg0: $Player$$Type): boolean
public "clearContent"(): void
public "lithium$emitRemoved"(): void
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitContentModified"(): void
public "handler$dij000$lithium$readNbtStackListReplacement"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $CallbackInfo$$Type): void
public static "canUnlock"(arg0: $Player$$Type, arg1: $LockCode$$Type, arg2: $Component$$Type): boolean
public "getLockKey"(): $LockCode
public "invokeGetItems"(): $NonNullList
public "setLockKey"(arg0: $LockCode$$Type): void
public "getItem"(arg0: integer): $ItemStack
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "getName"(): $Component
public "isEmpty"(): boolean
public "setName"(arg0: $Component$$Type): void
public "getDisplayName"(): $Component
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "stillValid"(arg0: $Player$$Type): boolean
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "getCustomName"(): $Component
public "startOpen"(arg0: $Player$$Type): void
public "stopOpen"(arg0: $Player$$Type): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "countItem"(arg0: $Item$$Type): integer
public "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
public "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "getMaxStackSize"(): integer
public "getMaxStackSize"(arg0: $ItemStack$$Type): integer
public "setChanged"(): void
public "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
public "getContainerSize"(): integer
public "hasCustomName"(): boolean
public "emitCallbackReplaced"(): void
public static "tryClear"(arg0: any): void
public "self"(): $Container
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "getSlotLimit"(slot: integer): integer
public "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
public "clear"(): void
public "getWidth"(): integer
public "getHeight"(): integer
public "getBlock"(level: $Level$$Type): $LevelBlock
public "setChanged"(): void
public "asContainer"(): $Container
public "setTransferCooldown"(arg0: long): void
public "canReceiveTransferCooldown"(): boolean
public "lithium$itemInsertionTestRequiresStackSize1"(): boolean
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "clear"(match: $ItemPredicate$$Type): void
public "find"(match: $ItemPredicate$$Type): integer
public "find"(): integer
public "count"(match: $ItemPredicate$$Type): integer
public "count"(): integer
public "countNonEmpty"(): integer
public "countNonEmpty"(match: $ItemPredicate$$Type): integer
public "getAllItems"(): $List<($ItemStack)>
get "empty"(): boolean
get "displayName"(): $Component
get "customName"(): $Component
get "maxStackSize"(): integer
get "changed"(): void
get "containerSize"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "width"(): integer
get "height"(): integer
get "changed"(): void
set "transferCooldown"(value: long)
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseContainerBlockEntity$$Type = ($BaseContainerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseContainerBlockEntity$$Original = $BaseContainerBlockEntity;}
declare module "net.minecraft.world.level.StructureManager" {
import {$StructureCheck$$Type} from "net.minecraft.world.level.levelgen.structure.StructureCheck"
import {$Map} from "java.util.Map"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$List} from "java.util.List"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$StructurePlacement$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$WorldOptions$$Type} from "net.minecraft.world.level.levelgen.WorldOptions"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$StructureAccess$$Type} from "net.minecraft.world.level.chunk.StructureAccess"
import {$StructureCheckResult} from "net.minecraft.world.level.levelgen.structure.StructureCheckResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$StructureStart, $StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$WorldGenRegion$$Type} from "net.minecraft.server.level.WorldGenRegion"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $StructureManager {
constructor(arg0: $LevelAccessor$$Type, arg1: $WorldOptions$$Type, arg2: $StructureCheck$$Type)

public "getAllStructuresAt"(arg0: $BlockPos$$Type): $Map<($Structure), ($LongSet)>
public "getStructureWithPieceAt"(arg0: $BlockPos$$Type, arg1: $TagKey$$Type<($Structure)>): $StructureStart
public "getStructureWithPieceAt"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($Holder<($Structure)>)>): $StructureStart
public "getStructureWithPieceAt"(arg0: $BlockPos$$Type, arg1: $Structure$$Type): $StructureStart
public "getStructureWithPieceAt"(arg0: $BlockPos$$Type, arg1: $HolderSet$$Type<($Structure)>): $StructureStart
public "getStartForStructure"(arg0: $SectionPos$$Type, arg1: $Structure$$Type, arg2: $StructureAccess$$Type): $StructureStart
public "setStartForStructure"(arg0: $SectionPos$$Type, arg1: $Structure$$Type, arg2: $StructureStart$$Type, arg3: $StructureAccess$$Type): void
public "addReferenceForStructure"(arg0: $SectionPos$$Type, arg1: $Structure$$Type, arg2: long, arg3: $StructureAccess$$Type): void
public "fillStartsForStructure"(arg0: $Structure$$Type, arg1: $LongSet$$Type, arg2: $Consumer$$Type<($StructureStart)>): void
public "startsForStructure"(arg0: $ChunkPos$$Type, arg1: $Predicate$$Type<($Structure)>): $List<($StructureStart)>
public "startsForStructure"(arg0: $SectionPos$$Type, arg1: $Structure$$Type): $List<($StructureStart)>
public "checkStructurePresence"(arg0: $ChunkPos$$Type, arg1: $Structure$$Type, arg2: $StructurePlacement$$Type, arg3: boolean): $StructureCheckResult
public "shouldGenerateStructures"(): boolean
public "structureHasPieceAt"(arg0: $BlockPos$$Type, arg1: $StructureStart$$Type): boolean
public "addReference"(arg0: $StructureStart$$Type): void
public "getStructureAt"(arg0: $BlockPos$$Type, arg1: $Structure$$Type): $StructureStart
public "hasAnyStructureAt"(arg0: $BlockPos$$Type): boolean
public "registryAccess"(): $RegistryAccess
public "forWorldGenRegion"(arg0: $WorldGenRegion$$Type): $StructureManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureManager$$Type = ($StructureManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureManager$$Original = $StructureManager;}
declare module "net.minecraft.world.level.levelgen.structure.StructurePiece" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$Mirror} from "net.minecraft.world.level.block.Mirror"
import {$List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Rotation} from "net.minecraft.world.level.block.Rotation"
import {$StructurePieceSerializationContext$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream$$Type} from "java.util.stream.Stream"
import {$StructurePieceType, $StructurePieceType$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType"
import {$StructurePieceAccessor$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePieceAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StructurePiece {
constructor(arg0: $StructurePieceType$$Type, arg1: $CompoundTag$$Type)

public "setOrientation"(arg0: $Direction$$Type): void
public "getOrientation"(): $Direction
public "getGenDepth"(): integer
public static "reorient"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
public "addChildren"(arg0: $StructurePiece$$Type, arg1: $StructurePieceAccessor$$Type, arg2: $RandomSource$$Type): void
public "setGenDepth"(arg0: integer): void
public "isCloseToChunk"(arg0: $ChunkPos$$Type, arg1: integer): boolean
public "getLocatorPosition"(): $BlockPos
public static "createBoundingBox"(arg0: $Stream$$Type<($StructurePiece$$Type)>): $BoundingBox
public static "findCollisionPiece"(arg0: $List$$Type<($StructurePiece$$Type)>, arg1: $BoundingBox$$Type): $StructurePiece
public "move"(arg0: integer, arg1: integer, arg2: integer): void
public "createTag"(arg0: $StructurePieceSerializationContext$$Type): $CompoundTag
public "getType"(): $StructurePieceType
public "getMirror"(): $Mirror
public "postProcess"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BoundingBox$$Type, arg5: $ChunkPos$$Type, arg6: $BlockPos$$Type): void
public "getRotation"(): $Rotation
public "getBoundingBox"(): $BoundingBox
set "orientation"(value: $Direction$$Type)
get "orientation"(): $Direction
get "genDepth"(): integer
set "genDepth"(value: integer)
get "locatorPosition"(): $BlockPos
get "type"(): $StructurePieceType
get "mirror"(): $Mirror
get "rotation"(): $Rotation
get "boundingBox"(): $BoundingBox
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePiece$$Type = ($StructurePiece);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePiece$$Original = $StructurePiece;}
declare module "net.minecraft.world.level.chunk.CarvingMask$Mask" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $CarvingMask$Mask$$Interface {

(arg0: integer, arg1: integer, arg2: integer): boolean
}

export class $CarvingMask$Mask implements $CarvingMask$Mask$$Interface {
 "test"(arg0: integer, arg1: integer, arg2: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarvingMask$Mask$$Type = ((arg0: integer, arg1: integer, arg2: integer) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarvingMask$Mask$$Original = $CarvingMask$Mask;}
declare module "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet$Builder" {
import {$LootContextParam$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$LootContextParamSet} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet"

export class $LootContextParamSet$Builder {
constructor()

public "build"(): $LootContextParamSet
public "optional"(arg0: $LootContextParam$$Type<(never)>): $LootContextParamSet$Builder
public "required"(arg0: $LootContextParam$$Type<(never)>): $LootContextParamSet$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContextParamSet$Builder$$Type = ($LootContextParamSet$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContextParamSet$Builder$$Original = $LootContextParamSet$Builder;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.AlterGroundDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AlterGroundDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($AlterGroundDecorator)>

constructor(arg0: $BlockStateProvider$$Type)

public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlterGroundDecorator$$Type = ($AlterGroundDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AlterGroundDecorator$$Original = $AlterGroundDecorator;}
declare module "net.minecraft.world.level.block.entity.BrewingStandBlockEntity" {
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$WorldlyContainer$$Interface} from "net.minecraft.world.WorldlyContainer"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SetChangedHandlingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SetChangedHandlingBlockEntity"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$Component} from "net.minecraft.network.chat.Component"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$BaseContainerBlockEntity} from "net.minecraft.world.level.block.entity.BaseContainerBlockEntity"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BrewingStandBlockEntity extends $BaseContainerBlockEntity implements $WorldlyContainer$$Interface, $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface, $SleepingBlockEntity$$Interface, $SetChangedHandlingBlockEntity$$Interface {
static readonly "DATA_BREW_TIME": integer
static readonly "DATA_FUEL_USES": integer
 "fuel": integer
 "brewTime": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode
static readonly "NUM_DATA_VALUES": integer
static readonly "FUEL_USES": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BrewingStandBlockEntity$$Type): void
public "lithium$handleSetChanged"(): void
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getSlotsForFace"(arg0: $Direction$$Type): (integer)[]
public "canPlaceItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "canTakeItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "getContainerSize"(): integer
public "generateLootLithium"(): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$startSleeping"(): boolean
public "wakeUpNow"(): void
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "sleepOnlyCurrentTick"(): void
public "isSleeping"(): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public static "tryClear"(arg0: any): void
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "containerSize"(): integer
set "ticker"(value: $TickingBlockEntity$$Type)
get "sleeping"(): boolean
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrewingStandBlockEntity$$Type = ($BrewingStandBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BrewingStandBlockEntity$$Original = $BrewingStandBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment" {
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $FoliagePlacer$FoliageAttachment {
constructor(arg0: $BlockPos$$Type, arg1: integer, arg2: boolean)

public "radiusOffset"(): integer
public "doubleTrunk"(): boolean
public "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoliagePlacer$FoliageAttachment$$Type = ($FoliagePlacer$FoliageAttachment);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoliagePlacer$FoliageAttachment$$Original = $FoliagePlacer$FoliageAttachment;}
declare module "net.minecraft.world.level.chunk.StructureAccess" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$StructureStart, $StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"

export interface $StructureAccess$$Interface {
set "allReferences"(value: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>)
get "allReferences"(): $Map<($Structure), ($LongSet)>
}

export class $StructureAccess implements $StructureAccess$$Interface {
 "getStartForStructure"(arg0: $Structure$$Type): $StructureStart
 "setStartForStructure"(arg0: $Structure$$Type, arg1: $StructureStart$$Type): void
 "getReferencesForStructure"(arg0: $Structure$$Type): $LongSet
 "addReferenceForStructure"(arg0: $Structure$$Type, arg1: long): void
 "setAllReferences"(arg0: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>): void
 "getAllReferences"(): $Map<($Structure), ($LongSet)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureAccess$$Type = ($StructureAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureAccess$$Original = $StructureAccess;}
declare module "net.minecraft.world.level.block.BambooStalkBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$BambooLeaves} from "net.minecraft.world.level.block.state.properties.BambooLeaves"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BambooStalkBlock extends $Block implements $BonemealableBlock$$Interface {
static readonly "LEAVES": $EnumProperty<($BambooLeaves)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "STAGE_DONE_GROWING": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
static readonly "AGE_THICK_BAMBOO": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "MAX_HEIGHT": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "AGE": $IntegerProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BambooStalkBlock)>
static readonly "STAGE": $IntegerProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "STAGE_GROWING": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "AGE_THIN_BAMBOO": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "codec"(): $MapCodec<($BambooStalkBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BambooStalkBlock$$Type = ($BambooStalkBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BambooStalkBlock$$Original = $BambooStalkBlock;}
declare module "net.minecraft.world.level.block.state.properties.Property$Value" {
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Record} from "java.lang.Record"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $Property$Value<T extends $Comparable<(object)>> extends $Record {
constructor(arg0: $Property$$Type<(T)>, arg1: T)

public "value"(): T
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "property"(): $Property<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Property$Value$$Type<T> = ({"property"?: $Property$$Type<(T)>, "value"?: T}) | ([property?: $Property$$Type<(T)>, value?: T]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Property$Value$$Original<T> = $Property$Value<(T)>;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor" {
import {$ServerLevelAccessor$$Type} from "net.minecraft.world.level.ServerLevelAccessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$StructureTemplate$StructureEntityInfo, $StructureTemplate$StructureEntityInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureEntityInfo"
import {$List, $List$$Type} from "java.util.List"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$StructureTemplate$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $StructureProcessor {
constructor()

/**
 * 
 * @deprecated
 */
public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
public "finalizeProcessing"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>, arg4: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>, arg5: $StructurePlaceSettings$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "processEntity"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $StructureTemplate$StructureEntityInfo$$Type, arg3: $StructureTemplate$StructureEntityInfo$$Type, arg4: $StructurePlaceSettings$$Type, arg5: $StructureTemplate$$Type): $StructureTemplate$StructureEntityInfo
public "process"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type, arg6: $StructureTemplate$$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureProcessor$$Type = ($StructureProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureProcessor$$Original = $StructureProcessor;}
declare module "net.minecraft.world.level.block.state.properties.Tilt" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $Tilt extends $Enum<($Tilt)> implements $StringRepresentable$$Interface {
static readonly "PARTIAL": $Tilt
static readonly "NONE": $Tilt
static readonly "UNSTABLE": $Tilt
static readonly "FULL": $Tilt

public "causesVibration"(): boolean
public static "values"(): ($Tilt)[]
public static "valueOf"(arg0: StringJS): $Tilt
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Tilt$$Type = (("none") | ("unstable") | ("partial") | ("full"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Tilt$$Original = $Tilt;}
declare module "net.minecraft.world.level.gameevent.GameEventListener$DeliveryMode" {
import {$Enum} from "java.lang.Enum"

export class $GameEventListener$DeliveryMode extends $Enum<($GameEventListener$DeliveryMode)> {
static readonly "UNSPECIFIED": $GameEventListener$DeliveryMode
static readonly "BY_DISTANCE": $GameEventListener$DeliveryMode

public static "values"(): ($GameEventListener$DeliveryMode)[]
public static "valueOf"(arg0: StringJS): $GameEventListener$DeliveryMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEventListener$DeliveryMode$$Type = (("unspecified") | ("by_distance"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEventListener$DeliveryMode$$Original = $GameEventListener$DeliveryMode;}
declare module "net.minecraft.world.level.block.BucketPickup" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$IBucketPickupExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBucketPickupExtension"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BucketPickup$$Interface extends $IBucketPickupExtension$$Interface {
get "pickupSound"(): $Optional<($SoundEvent)>
}

export class $BucketPickup implements $BucketPickup$$Interface {
/**
 * 
 * @deprecated
 */
 "getPickupSound"(): $Optional<($SoundEvent)>
 "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
 "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BucketPickup$$Type = ($BucketPickup);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BucketPickup$$Original = $BucketPickup;}
declare module "net.minecraft.world.level.storage.loot.LootDataType$Validator" {
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ValidationContext, $ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"

export interface $LootDataType$Validator$$Interface<T> {

(arg0: $ValidationContext, arg1: $ResourceKey<(T)>, arg2: T): void
}

export class $LootDataType$Validator<T> implements $LootDataType$Validator$$Interface {
 "run"(arg0: $ValidationContext$$Type, arg1: $ResourceKey$$Type<(T)>, arg2: T): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootDataType$Validator$$Type<T> = ((arg0: $ValidationContext, arg1: $ResourceKey<(T)>, arg2: T) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootDataType$Validator$$Original<T> = $LootDataType$Validator<(T)>;}
declare module "net.minecraft.world.level.ClipContext$ShapeGetter" {
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$CollisionContext, $CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $ClipContext$ShapeGetter$$Interface {

(arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos, arg3: $CollisionContext): $VoxelShape$$Type
}

export class $ClipContext$ShapeGetter implements $ClipContext$ShapeGetter$$Interface {
 "get"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipContext$ShapeGetter$$Type = ((arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos, arg3: $CollisionContext) => $VoxelShape$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipContext$ShapeGetter$$Original = $ClipContext$ShapeGetter;}
declare module "net.minecraft.world.level.block.CaveVinesPlantBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$CaveVines$$Interface} from "net.minecraft.world.level.block.CaveVines"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$GrowingPlantBodyBlock} from "net.minecraft.world.level.block.GrowingPlantBodyBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ToIntFunction} from "java.util.function.ToIntFunction"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CaveVinesPlantBlock extends $GrowingPlantBodyBlock implements $BonemealableBlock$$Interface, $CaveVines$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CaveVinesPlantBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($CaveVinesPlantBlock)>
public static "emission"(arg0: integer): $ToIntFunction<($BlockState)>
public static "hasGlowBerries"(arg0: $BlockState$$Type): boolean
public static "use"(arg0: $Entity$$Type, arg1: $BlockState$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): $InteractionResult
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaveVinesPlantBlock$$Type = ($CaveVinesPlantBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CaveVinesPlantBlock$$Original = $CaveVinesPlantBlock;}
declare module "net.minecraft.world.level.storage.loot.LootPool" {
import {$LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UnificationLookup$$Type} from "com.almostreliable.unified.api.unification.UnificationLookup"
import {$LootPoolEntryContainer} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$List} from "java.util.List"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NumberProvider, $NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LootUnificationHandler, $LootUnificationHandler$$Interface} from "com.almostreliable.unified.unification.loot.LootUnificationHandler"
import {$LootPool$Builder} from "net.minecraft.world.level.storage.loot.LootPool$Builder"
import {$Codec} from "com.mojang.serialization.Codec"

export class $LootPool implements $LootUnificationHandler$$Interface {
readonly "entries": $List<($LootPoolEntryContainer)>
static readonly "CODEC": $Codec<($LootPool)>

public "almostunified$unify"(lookup: $UnificationLookup$$Type): boolean
public "addRandomItems"(arg0: $Consumer$$Type<($ItemStack)>, arg1: $LootContext$$Type): void
public "getRolls"(): $NumberProvider
public "getBonusRolls"(): $NumberProvider
public "setRolls"(arg0: $NumberProvider$$Type): void
public "setBonusRolls"(arg0: $NumberProvider$$Type): void
public static "lootPool"(): $LootPool$Builder
public "getName"(): StringJS
public "validate"(arg0: $ValidationContext$$Type): void
public "isFrozen"(): boolean
public "freeze"(): void
public static "cast"(table: $LootTable$$Type): $LootUnificationHandler
public static "cast"(pool: $LootPool$$Type): $LootUnificationHandler
get "rolls"(): $NumberProvider
get "bonusRolls"(): $NumberProvider
set "rolls"(value: $NumberProvider$$Type)
set "bonusRolls"(value: $NumberProvider$$Type)
get "name"(): StringJS
get "frozen"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPool$$Type = ($LootPool);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootPool$$Original = $LootPool;}
declare module "net.minecraft.world.level.block.RedstoneWallTorchBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$RedstoneTorchBlock} from "net.minecraft.world.level.block.RedstoneTorchBlock"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RedstoneWallTorchBlock extends $RedstoneTorchBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RedstoneWallTorchBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "RESTART_DELAY": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "MAX_RECENT_TOGGLES": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "RECENT_TOGGLE_TIMER": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getDescriptionId"(): StringJS
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($RedstoneWallTorchBlock)>
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneWallTorchBlock$$Type = ($RedstoneWallTorchBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneWallTorchBlock$$Original = $RedstoneWallTorchBlock;}
declare module "net.minecraft.world.level.block.state.properties.DoorHingeSide" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $DoorHingeSide extends $Enum<($DoorHingeSide)> implements $StringRepresentable$$Interface {
static readonly "LEFT": $DoorHingeSide
static readonly "RIGHT": $DoorHingeSide

public "toString"(): StringJS
public static "values"(): ($DoorHingeSide)[]
public static "valueOf"(arg0: StringJS): $DoorHingeSide
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoorHingeSide$$Type = (("left") | ("right"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoorHingeSide$$Original = $DoorHingeSide;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.TrueBlockPredicate" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type, $BlockPredicate$$Interface} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TrueBlockPredicate implements $BlockPredicate$$Interface {
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
public "type"(): $BlockPredicateType<(never)>
public "or"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "negate"(): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "and"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "test"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrueBlockPredicate$$Type = ($TrueBlockPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrueBlockPredicate$$Original = $TrueBlockPredicate;}
declare module "net.minecraft.world.level.block.entity.DecoratedPotBlockEntity$WobbleStyle" {
import {$Enum} from "java.lang.Enum"

export class $DecoratedPotBlockEntity$WobbleStyle extends $Enum<($DecoratedPotBlockEntity$WobbleStyle)> {
readonly "duration": integer
static readonly "POSITIVE": $DecoratedPotBlockEntity$WobbleStyle
static readonly "NEGATIVE": $DecoratedPotBlockEntity$WobbleStyle

public static "values"(): ($DecoratedPotBlockEntity$WobbleStyle)[]
public static "valueOf"(arg0: StringJS): $DecoratedPotBlockEntity$WobbleStyle
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DecoratedPotBlockEntity$WobbleStyle$$Type = (("positive") | ("negative"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DecoratedPotBlockEntity$WobbleStyle$$Original = $DecoratedPotBlockEntity$WobbleStyle;}
declare module "net.minecraft.world.level.block.TallSeagrassBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$DoubleBlockHalf} from "net.minecraft.world.level.block.state.properties.DoubleBlockHalf"
import {$LiquidBlockContainer$$Interface} from "net.minecraft.world.level.block.LiquidBlockContainer"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$DoublePlantBlock} from "net.minecraft.world.level.block.DoublePlantBlock"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TallSeagrassBlock extends $DoublePlantBlock implements $LiquidBlockContainer$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TallSeagrassBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($DoubleBlockHalf)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($TallSeagrassBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TallSeagrassBlock$$Type = ($TallSeagrassBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TallSeagrassBlock$$Original = $TallSeagrassBlock;}
declare module "net.minecraft.world.level.block.state.properties.RailShape" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $RailShape extends $Enum<($RailShape)> implements $StringRepresentable$$Interface {
static readonly "NORTH_WEST": $RailShape
static readonly "ASCENDING_WEST": $RailShape
static readonly "NORTH_EAST": $RailShape
static readonly "NORTH_SOUTH": $RailShape
static readonly "SOUTH_EAST": $RailShape
static readonly "EAST_WEST": $RailShape
static readonly "SOUTH_WEST": $RailShape
static readonly "ASCENDING_EAST": $RailShape
static readonly "ASCENDING_SOUTH": $RailShape
static readonly "ASCENDING_NORTH": $RailShape

public "getName"(): StringJS
public "toString"(): StringJS
public static "values"(): ($RailShape)[]
public static "valueOf"(arg0: StringJS): $RailShape
public "isAscending"(): boolean
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "name"(): StringJS
get "ascending"(): boolean
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RailShape$$Type = (("north_south") | ("east_west") | ("ascending_east") | ("ascending_west") | ("ascending_north") | ("ascending_south") | ("south_east") | ("south_west") | ("north_west") | ("north_east"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RailShape$$Original = $RailShape;}
declare module "net.minecraft.world.level.block.entity.ComparatorBlockEntity" {
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ComparatorBlockEntity extends $BlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getOutputSignal"(): integer
public "setOutputSignal"(arg0: integer): void
get "outputSignal"(): integer
set "outputSignal"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparatorBlockEntity$$Type = ($ComparatorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComparatorBlockEntity$$Original = $ComparatorBlockEntity;}
declare module "net.minecraft.world.level.block.grower.TreeGrower" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Optional$$Type} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature$$Type} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TreeGrower {
static readonly "MANGROVE": $TreeGrower
static readonly "SPRUCE": $TreeGrower
static readonly "CHERRY": $TreeGrower
static readonly "CODEC": $Codec<($TreeGrower)>
static readonly "BIRCH": $TreeGrower
static readonly "JUNGLE": $TreeGrower
static readonly "ACACIA": $TreeGrower
static readonly "OAK": $TreeGrower
static readonly "AZALEA": $TreeGrower
static readonly "DARK_OAK": $TreeGrower

constructor(arg0: StringJS, arg1: ($ResourceKey$$Type<($ConfiguredFeature$$Type<(never), (never)>)>)?, arg2: ($ResourceKey$$Type<($ConfiguredFeature$$Type<(never), (never)>)>)?, arg3: ($ResourceKey$$Type<($ConfiguredFeature$$Type<(never), (never)>)>)?)
constructor(arg0: StringJS, arg1: float, arg2: ($ResourceKey$$Type<($ConfiguredFeature$$Type<(never), (never)>)>)?, arg3: ($ResourceKey$$Type<($ConfiguredFeature$$Type<(never), (never)>)>)?, arg4: ($ResourceKey$$Type<($ConfiguredFeature$$Type<(never), (never)>)>)?, arg5: ($ResourceKey$$Type<($ConfiguredFeature$$Type<(never), (never)>)>)?, arg6: ($ResourceKey$$Type<($ConfiguredFeature$$Type<(never), (never)>)>)?, arg7: ($ResourceKey$$Type<($ConfiguredFeature$$Type<(never), (never)>)>)?)

public "growTree"(arg0: $ServerLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeGrower$$Type = ($TreeGrower);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeGrower$$Original = $TreeGrower;}
declare module "net.minecraft.world.level.block.PiglinWallSkullBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$WallSkullBlock} from "net.minecraft.world.level.block.WallSkullBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PiglinWallSkullBlock extends $WallSkullBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PiglinWallSkullBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($PiglinWallSkullBlock)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PiglinWallSkullBlock$$Type = ($PiglinWallSkullBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PiglinWallSkullBlock$$Original = $PiglinWallSkullBlock;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.MatchingBlocksPredicate" {
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$StateTestingPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.StateTestingPredicate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MatchingBlocksPredicate extends $StateTestingPredicate {
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MatchingBlocksPredicate$$Type = ($MatchingBlocksPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MatchingBlocksPredicate$$Original = $MatchingBlocksPredicate;}
declare module "net.minecraft.world.level.block.TrappedChestBlock" {
import {$ChestType} from "net.minecraft.world.level.block.state.properties.ChestType"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ChestBlock} from "net.minecraft.world.level.block.ChestBlock"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TrappedChestBlock extends $ChestBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TrappedChestBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "EVENT_SET_OPEN_COUNT": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "TYPE": $EnumProperty<($ChestType)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($TrappedChestBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrappedChestBlock$$Type = ($TrappedChestBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrappedChestBlock$$Original = $TrappedChestBlock;}
declare module "net.minecraft.world.level.biome.MobSpawnSettings" {
import {$MobCategory, $MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$WeightedRandomList} from "net.minecraft.util.random.WeightedRandomList"
import {$Set} from "java.util.Set"
import {$MobSpawnSettings$SpawnerData} from "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MobSpawnSettings$MobSpawnCost} from "net.minecraft.world.level.biome.MobSpawnSettings$MobSpawnCost"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $MobSpawnSettings {
static readonly "CODEC": $MapCodec<($MobSpawnSettings)>
static readonly "EMPTY": $MobSpawnSettings
static readonly "EMPTY_MOB_LIST": $WeightedRandomList<($MobSpawnSettings$SpawnerData)>

public "getMobs"(arg0: $MobCategory$$Type): $WeightedRandomList<($MobSpawnSettings$SpawnerData)>
public "getSpawnerTypes"(): $Set<($MobCategory)>
public "getMobSpawnCost"(arg0: $EntityType$$Type<(never)>): $MobSpawnSettings$MobSpawnCost
public "getEntityTypes"(): $Set<($EntityType<(never)>)>
public "getCreatureProbability"(): float
get "spawnerTypes"(): $Set<($MobCategory)>
get "entityTypes"(): $Set<($EntityType<(never)>)>
get "creatureProbability"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnSettings$$Type = ($MobSpawnSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobSpawnSettings$$Original = $MobSpawnSettings;}
declare module "net.minecraft.world.level.saveddata.maps.MapDecorationType" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $MapDecorationType extends $Record {
static readonly "CODEC": $Codec<($Holder<($MapDecorationType)>)>
static readonly "NO_MAP_COLOR": integer
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Holder<($MapDecorationType)>)>

constructor(arg0: $ResourceLocation$$Type, arg1: boolean, arg2: integer, arg3: boolean, arg4: boolean)

public "assetId"(): $ResourceLocation
public "mapColor"(): integer
public "showOnItemFrame"(): boolean
public "explorationMapElement"(): boolean
public "trackCount"(): boolean
public "hasMapColor"(): boolean
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.MapDecorationType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.MapDecorationTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapDecorationType$$Type = (Special.MapDecorationType) | ({"trackCount"?: boolean, "explorationMapElement"?: boolean, "assetId"?: $ResourceLocation$$Type, "mapColor"?: integer, "showOnItemFrame"?: boolean}) | ([trackCount?: boolean, explorationMapElement?: boolean, assetId?: $ResourceLocation$$Type, mapColor?: integer, showOnItemFrame?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapDecorationType$$Original = $MapDecorationType;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.RuleBasedBlockStateProvider" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List, $List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"
import {$Record} from "java.lang.Record"
import {$RuleBasedBlockStateProvider$Rule, $RuleBasedBlockStateProvider$Rule$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.RuleBasedBlockStateProvider$Rule"

export class $RuleBasedBlockStateProvider extends $Record {
static readonly "CODEC": $Codec<($RuleBasedBlockStateProvider)>

constructor(arg0: $BlockStateProvider$$Type, arg1: $List$$Type<($RuleBasedBlockStateProvider$Rule$$Type)>)

public "rules"(): $List<($RuleBasedBlockStateProvider$Rule)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getState"(arg0: $WorldGenLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $BlockState
public "fallback"(): $BlockStateProvider
public static "simple"(arg0: $Block$$Type): $RuleBasedBlockStateProvider
public static "simple"(arg0: $BlockStateProvider$$Type): $RuleBasedBlockStateProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleBasedBlockStateProvider$$Type = ({"rules"?: $List$$Type<($RuleBasedBlockStateProvider$Rule$$Type)>, "fallback"?: $BlockStateProvider$$Type}) | ([rules?: $List$$Type<($RuleBasedBlockStateProvider$Rule$$Type)>, fallback?: $BlockStateProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleBasedBlockStateProvider$$Original = $RuleBasedBlockStateProvider;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.CherryFoliagePlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $CherryFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($CherryFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type, arg3: float, arg4: float, arg5: float, arg6: float)

public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CherryFoliagePlacer$$Type = ($CherryFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CherryFoliagePlacer$$Original = $CherryFoliagePlacer;}
declare module "net.minecraft.world.level.levelgen.structure.pools.alias.Random" {
import {$RandomGroup} from "net.minecraft.world.level.levelgen.structure.pools.alias.RandomGroup"
import {$Direct} from "net.minecraft.world.level.levelgen.structure.pools.alias.Direct"
import {$List$$Type} from "java.util.List"
import {$SimpleWeightedRandomList$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$StructureTemplatePool, $StructureTemplatePool$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PoolAliasBinding, $PoolAliasBinding$$Type, $PoolAliasBinding$$Interface} from "net.minecraft.world.level.levelgen.structure.pools.alias.PoolAliasBinding"
import {$Record} from "java.lang.Record"

export class $Random extends $Record implements $PoolAliasBinding$$Interface {
public "forEachResolved"(arg0: $RandomSource$$Type, arg1: $BiConsumer$$Type<($ResourceKey<($StructureTemplatePool)>), ($ResourceKey<($StructureTemplatePool)>)>): void
public static "randomGroup"(arg0: $SimpleWeightedRandomList$$Type<($List$$Type<($PoolAliasBinding$$Type)>)>): $RandomGroup
public static "direct"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>, arg1: $ResourceKey$$Type<($StructureTemplatePool)>): $Direct
public static "direct"(arg0: StringJS, arg1: StringJS): $Direct
public static "random"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>, arg1: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($StructureTemplatePool$$Type)>)>): $Random
public static "random"(arg0: StringJS, arg1: $SimpleWeightedRandomList$$Type<(StringJS)>): $Random
public "allTargets"(): $Stream<($ResourceKey<($StructureTemplatePool)>)>
public "codec"(): $MapCodec<($PoolAliasBinding)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Random$$Type = ({"alias"?: $ResourceKey$$Type<($StructureTemplatePool)>, "targets"?: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($StructureTemplatePool$$Type)>)>}) | ([alias?: $ResourceKey$$Type<($StructureTemplatePool)>, targets?: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($StructureTemplatePool$$Type)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Random$$Original = $Random;}
declare module "net.minecraft.world.level.block.LayeredCauldronBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$AbstractCauldronBlock} from "net.minecraft.world.level.block.AbstractCauldronBlock"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$CauldronInteraction$InteractionMap$$Type} from "net.minecraft.core.cauldron.CauldronInteraction$InteractionMap"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Biome$Precipitation$$Type} from "net.minecraft.world.level.biome.Biome$Precipitation"

export class $LayeredCauldronBlock extends $AbstractCauldronBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LayeredCauldronBlock)>
static readonly "MAX_FILL_LEVEL": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "LEVEL": $IntegerProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "MIN_FILL_LEVEL": integer

constructor(arg0: $Biome$Precipitation$$Type, arg1: $CauldronInteraction$InteractionMap$$Type, arg2: $BlockBehaviour$Properties$$Type)

public "handlePrecipitation"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Biome$Precipitation$$Type): void
public static "lowerFillLevel"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): void
public "isFull"(arg0: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($LayeredCauldronBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LayeredCauldronBlock$$Type = ($LayeredCauldronBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LayeredCauldronBlock$$Original = $LayeredCauldronBlock;}
declare module "net.minecraft.world.level.block.DropExperienceBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DropExperienceBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DropExperienceBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $IntProvider$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getExpDrop"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): integer
public "codec"(): $MapCodec<($DropExperienceBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropExperienceBlock$$Type = ($DropExperienceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DropExperienceBlock$$Original = $DropExperienceBlock;}
declare module "net.minecraft.world.level.block.entity.BlockEntityType$BlockEntitySupplier" {
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockEntityType$BlockEntitySupplier$$Interface<T extends $BlockEntity> {

(arg0: $BlockPos, arg1: $BlockState): T
}

export class $BlockEntityType$BlockEntitySupplier<T extends $BlockEntity> implements $BlockEntityType$BlockEntitySupplier$$Interface {
 "create"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityType$BlockEntitySupplier$$Type<T> = ((arg0: $BlockPos, arg1: $BlockState) => T);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityType$BlockEntitySupplier$$Original<T> = $BlockEntityType$BlockEntitySupplier<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.LeaveVineDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $LeaveVineDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($LeaveVineDecorator)>

constructor(arg0: float)

public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LeaveVineDecorator$$Type = ($LeaveVineDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LeaveVineDecorator$$Original = $LeaveVineDecorator;}
declare module "net.minecraft.world.level.chunk.storage.ChunkStorage" {
import {$DimensionDataStorage$$Type} from "net.minecraft.world.level.storage.DimensionDataStorage"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$RegionStorageInfo$$Type} from "net.minecraft.world.level.chunk.storage.RegionStorageInfo"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$ChunkScanAccess} from "net.minecraft.world.level.chunk.storage.ChunkScanAccess"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Path$$Type} from "java.nio.file.Path"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $ChunkStorage implements $AutoCloseable$$Interface {
static readonly "LAST_MONOLYTH_STRUCTURE_DATA_VERSION": integer

constructor(arg0: $RegionStorageInfo$$Type, arg1: $Path$$Type, arg2: $DataFixer$$Type, arg3: boolean)

public "flushWorker"(): void
public "upgradeChunkTag"(arg0: $ResourceKey$$Type<($Level)>, arg1: $Supplier$$Type<($DimensionDataStorage$$Type)>, arg2: $CompoundTag$$Type, arg3: ($ResourceKey$$Type<($MapCodec$$Type<($ChunkGenerator$$Type)>)>)?): $CompoundTag
public "isOldChunkAround"(arg0: $ChunkPos$$Type, arg1: integer): boolean
public static "injectDatafixingContext"(arg0: $CompoundTag$$Type, arg1: $ResourceKey$$Type<($Level)>, arg2: ($ResourceKey$$Type<($MapCodec$$Type<($ChunkGenerator$$Type)>)>)?): void
public "chunkScanner"(): $ChunkScanAccess
public "write"(arg0: $ChunkPos$$Type, arg1: $CompoundTag$$Type): $CompletableFuture<(void)>
public "read"(arg0: $ChunkPos$$Type): $CompletableFuture<($Optional<($CompoundTag)>)>
public "close"(): void
public static "getVersion"(arg0: $CompoundTag$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkStorage$$Type = ($ChunkStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkStorage$$Original = $ChunkStorage;}
declare module "net.minecraft.world.level.block.piston.PistonStructureResolver" {
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $PistonStructureResolver {
static readonly "MAX_PUSH_DEPTH": integer

constructor(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: boolean)

public "getToPush"(): $List<($BlockPos)>
public "getToDestroy"(): $List<($BlockPos)>
public "getPushDirection"(): $Direction
public "resolve"(): boolean
get "toPush"(): $List<($BlockPos)>
get "toDestroy"(): $List<($BlockPos)>
get "pushDirection"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonStructureResolver$$Type = ($PistonStructureResolver);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PistonStructureResolver$$Original = $PistonStructureResolver;}
declare module "net.minecraft.world.level.levelgen.structure.BoundingBox" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ChunkPos} from "net.minecraft.world.level.ChunkPos"
import {$Stream} from "java.util.stream.Stream"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $BoundingBox {
static readonly "CODEC": $Codec<($BoundingBox)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer)
constructor(arg0: $BlockPos$$Type)

public "intersectingChunks"(): $Stream<($ChunkPos)>
public "isInside"(arg0: $Vec3i$$Type): boolean
public "isInside"(arg0: integer, arg1: integer, arg2: integer): boolean
public static "infinite"(): $BoundingBox
/**
 * 
 * @deprecated
 */
public "encapsulate"(arg0: $BlockPos$$Type): $BoundingBox
/**
 * 
 * @deprecated
 */
public "encapsulate"(arg0: $BoundingBox$$Type): $BoundingBox
public "forAllCorners"(arg0: $Consumer$$Type<($BlockPos)>): void
public static "encapsulatingPositions"(arg0: $Iterable$$Type<($BlockPos$$Type)>): $Optional<($BoundingBox)>
public "getXSpan"(): integer
public "getYSpan"(): integer
public "getZSpan"(): integer
public static "fromCorners"(arg0: $Vec3i$$Type, arg1: $Vec3i$$Type): $BoundingBox
public "inflatedBy"(arg0: integer, arg1: integer, arg2: integer): $BoundingBox
public "inflatedBy"(arg0: integer): $BoundingBox
public static "encapsulatingBoxes"(arg0: $Iterable$$Type<($BoundingBox$$Type)>): $Optional<($BoundingBox)>
public static "orientBox"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: $Direction$$Type): $BoundingBox
/**
 * 
 * @deprecated
 */
public "move"(arg0: $Vec3i$$Type): $BoundingBox
/**
 * 
 * @deprecated
 */
public "move"(arg0: integer, arg1: integer, arg2: integer): $BoundingBox
public "minX"(): integer
public "minY"(): integer
public "intersects"(arg0: $BoundingBox$$Type): boolean
public "intersects"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
public "moved"(arg0: integer, arg1: integer, arg2: integer): $BoundingBox
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getLength"(): $Vec3i
public "maxX"(): integer
public "minZ"(): integer
public "maxY"(): integer
public "maxZ"(): integer
public "getCenter"(): $BlockPos
get "XSpan"(): integer
get "YSpan"(): integer
get "ZSpan"(): integer
get "length"(): $Vec3i
get "center"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoundingBox$$Type = ($BoundingBox);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BoundingBox$$Original = $BoundingBox;}
declare module "net.minecraft.world.level.block.WeatheringCopperSlabBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$SlabBlock} from "net.minecraft.world.level.block.SlabBlock"
import {$Enum} from "java.lang.Enum"
import {$Optional} from "java.util.Optional"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$SlabType} from "net.minecraft.world.level.block.state.properties.SlabType"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$WeatheringCopper$$Interface} from "net.minecraft.world.level.block.WeatheringCopper"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$WeatheringCopper$WeatherState$$Type} from "net.minecraft.world.level.block.WeatheringCopper$WeatherState"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WeatheringCopperSlabBlock extends $SlabBlock implements $WeatheringCopper$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WeatheringCopperSlabBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "TYPE": $EnumProperty<($SlabType)>

constructor(arg0: $WeatheringCopper$WeatherState$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getAge"(): $Enum
public "codec"(): $MapCodec<($WeatheringCopperSlabBlock)>
public "getChanceModifier"(): float
public "getNext"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getNext"(arg0: $Block$$Type): $Optional<($Block)>
public static "getFirst"(arg0: $BlockState$$Type): $BlockState
public static "getFirst"(arg0: $Block$$Type): $Block
public static "getPrevious"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getPrevious"(arg0: $Block$$Type): $Optional<($Block)>
public "changeOverTime"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getNextState"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($BlockState)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "age"(): $Enum
get "chanceModifier"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatheringCopperSlabBlock$$Type = ($WeatheringCopperSlabBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeatheringCopperSlabBlock$$Original = $WeatheringCopperSlabBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalPiece$VerticalPlacement" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $RuinedPortalPiece$VerticalPlacement extends $Enum<($RuinedPortalPiece$VerticalPlacement)> implements $StringRepresentable$$Interface {
static readonly "UNDERGROUND": $RuinedPortalPiece$VerticalPlacement
static readonly "ON_LAND_SURFACE": $RuinedPortalPiece$VerticalPlacement
static readonly "CODEC": $StringRepresentable$EnumCodec<($RuinedPortalPiece$VerticalPlacement)>
static readonly "IN_MOUNTAIN": $RuinedPortalPiece$VerticalPlacement
static readonly "PARTLY_BURIED": $RuinedPortalPiece$VerticalPlacement
static readonly "IN_NETHER": $RuinedPortalPiece$VerticalPlacement
static readonly "ON_OCEAN_FLOOR": $RuinedPortalPiece$VerticalPlacement

public "getName"(): StringJS
public static "values"(): ($RuinedPortalPiece$VerticalPlacement)[]
public static "valueOf"(arg0: StringJS): $RuinedPortalPiece$VerticalPlacement
public static "byName"(arg0: StringJS): $RuinedPortalPiece$VerticalPlacement
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "name"(): StringJS
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuinedPortalPiece$VerticalPlacement$$Type = (("on_land_surface") | ("partly_buried") | ("on_ocean_floor") | ("in_mountain") | ("underground") | ("in_nether"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuinedPortalPiece$VerticalPlacement$$Original = $RuinedPortalPiece$VerticalPlacement;}
declare module "net.minecraft.world.level.levelgen.feature.BlueIceFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $BlueIceFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlueIceFeature$$Type = ($BlueIceFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlueIceFeature$$Original = $BlueIceFeature;}
declare module "net.minecraft.world.level.block.DetectorRailBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$RailShape} from "net.minecraft.world.level.block.state.properties.RailShape"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BaseRailBlock} from "net.minecraft.world.level.block.BaseRailBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $DetectorRailBlock extends $BaseRailBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DetectorRailBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $EnumProperty<($RailShape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getShapeProperty"(): $Property<($RailShape)>
public "codec"(): $MapCodec<($DetectorRailBlock)>
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "shapeProperty"(): $Property<($RailShape)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorRailBlock$$Type = ($DetectorRailBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DetectorRailBlock$$Original = $DetectorRailBlock;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.MegaJungleTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$GiantTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.GiantTrunkPlacer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $MegaJungleTrunkPlacer extends $GiantTrunkPlacer {
static readonly "CODEC": $MapCodec<($MegaJungleTrunkPlacer)>
static readonly "MAX_HEIGHT": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MegaJungleTrunkPlacer$$Type = ($MegaJungleTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MegaJungleTrunkPlacer$$Original = $MegaJungleTrunkPlacer;}
declare module "net.minecraft.world.level.block.CoralFanBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BaseCoralFanBlock} from "net.minecraft.world.level.block.BaseCoralFanBlock"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CoralFanBlock extends $BaseCoralFanBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CoralFanBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($CoralFanBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoralFanBlock$$Type = ($CoralFanBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CoralFanBlock$$Original = $CoralFanBlock;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$StatePredicate" {
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockBehaviour$StatePredicate$$Interface {

(arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos): boolean
}

export class $BlockBehaviour$StatePredicate implements $BlockBehaviour$StatePredicate$$Interface {
 "test"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$StatePredicate$$Type = ((arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$StatePredicate$$Original = $BlockBehaviour$StatePredicate;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.BeehiveDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $BeehiveDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($BeehiveDecorator)>

constructor(arg0: float)

public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeehiveDecorator$$Type = ($BeehiveDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeehiveDecorator$$Original = $BeehiveDecorator;}
declare module "net.minecraft.world.level.entity.EntitySectionStorage" {
import {$Iterable} from "java.lang.Iterable"
import {$LongSet} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$LongStream} from "java.util.stream.LongStream"
import {$Visibility$$Type} from "net.minecraft.world.level.entity.Visibility"
import {$EntitySection, $EntitySection$$Type} from "net.minecraft.world.level.entity.EntitySection"
import {$AbortableIterationConsumer$$Type} from "net.minecraft.util.AbortableIterationConsumer"
import {$EntityAccess} from "net.minecraft.world.level.entity.EntityAccess"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$Class$$Type} from "java.lang.Class"
import {$ChunkAwareEntityIterable$$Interface} from "net.caffeinemc.mods.lithium.common.world.ChunkAwareEntityIterable"
import {$Stream} from "java.util.stream.Stream"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export class $EntitySectionStorage<T extends $EntityAccess> implements $ChunkAwareEntityIterable$$Interface {
constructor(arg0: $Class$$Type<(T)>, arg1: $Long2ObjectFunction$$Type<($Visibility$$Type)>)

public "lithium$IterateEntitiesInTrackedSections"(): $Iterable
public "getEntities"(arg0: $AABB$$Type, arg1: $AbortableIterationConsumer$$Type<(T)>): void
public "getEntities"<U extends $EntityAccess>(arg0: $EntityTypeTest$$Type<(T), (U)>, arg1: $AABB$$Type, arg2: $AbortableIterationConsumer$$Type<(U)>): void
public "getOrCreateSection"(arg0: long): $EntitySection<(T)>
public "handler$dgh000$lithium$forEachInBox"(arg0: $AABB$$Type, arg1: $AbortableIterationConsumer$$Type, arg2: $CallbackInfo$$Type, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): void
public "getExistingSectionsInChunk"(arg0: long): $Stream<($EntitySection<(T)>)>
public "getAllChunksWithExistingSections"(): $LongSet
public "getExistingSectionPositionsInChunk"(arg0: long): $LongStream
public "forEachAccessibleNonEmptySection"(arg0: $AABB$$Type, arg1: $AbortableIterationConsumer$$Type<($EntitySection<(T)>)>): void
public "remove"(arg0: long): void
public "count"(): integer
public "getSection"(arg0: long): $EntitySection<(T)>
get "allChunksWithExistingSections"(): $LongSet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySectionStorage$$Type<T> = ($EntitySectionStorage<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySectionStorage$$Original<T> = $EntitySectionStorage<(T)>;}
declare module "net.minecraft.world.level.chunk.LevelChunk$RebindableTickingBlockEntityWrapper" {
import {$TickingBlockEntity, $TickingBlockEntity$$Type, $TickingBlockEntity$$Interface} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$WrappedBlockEntityTickInvokerAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"

export class $LevelChunk$RebindableTickingBlockEntityWrapper implements $TickingBlockEntity$$Interface, $WrappedBlockEntityTickInvokerAccessor$$Interface {
public "tick"(): void
public "getType"(): StringJS
public "isRemoved"(): boolean
public "getPos"(): $BlockPos
public "callSetWrapped"(arg0: $TickingBlockEntity$$Type): void
public "getWrapped"(): $TickingBlockEntity
get "type"(): StringJS
get "removed"(): boolean
get "pos"(): $BlockPos
get "wrapped"(): $TickingBlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelChunk$RebindableTickingBlockEntityWrapper$$Type = ($LevelChunk$RebindableTickingBlockEntityWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelChunk$RebindableTickingBlockEntityWrapper$$Original = $LevelChunk$RebindableTickingBlockEntityWrapper;}
declare module "net.minecraft.world.level.biome.AmbientParticleSettings" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export class $AmbientParticleSettings {
static readonly "CODEC": $Codec<($AmbientParticleSettings)>

constructor(arg0: $ParticleOptions$$Type, arg1: float)

public "getOptions"(): $ParticleOptions
public "canSpawn"(arg0: $RandomSource$$Type): boolean
get "options"(): $ParticleOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AmbientParticleSettings$$Type = ($AmbientParticleSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AmbientParticleSettings$$Original = $AmbientParticleSettings;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.RuleProcessor" {
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$List$$Type} from "java.util.List"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ProcessorRule$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.ProcessorRule"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $RuleProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($RuleProcessor)>

constructor(arg0: $List$$Type<($ProcessorRule$$Type)>)

public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleProcessor$$Type = ($RuleProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleProcessor$$Original = $RuleProcessor;}
declare module "net.minecraft.world.level.block.FlowerPotBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Map} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FlowerPotBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FlowerPotBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "AABB_SIZE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "POTTED_BY_CONTENT": $Map<($Block), ($Block)>
static readonly "UPDATE_CLIENTS": integer

/**
 * 
 * @deprecated
 */
constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)
constructor(arg0: $Supplier$$Type<($FlowerPotBlock$$Type)>, arg1: $Supplier$$Type<($Block$$Type)>, arg2: $BlockBehaviour$Properties$$Type)

public "addPlant"(arg0: $ResourceLocation$$Type, arg1: $Supplier$$Type<($Block$$Type)>): void
public "getEmptyPot"(): $FlowerPotBlock
public "getFullPotsView"(): $Map<($ResourceLocation), ($Supplier<($Block)>)>
public "getPotted"(): $Block
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($FlowerPotBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "emptyPot"(): $FlowerPotBlock
get "fullPotsView"(): $Map<($ResourceLocation), ($Supplier<($Block)>)>
get "potted"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlowerPotBlock$$Type = ($FlowerPotBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlowerPotBlock$$Original = $FlowerPotBlock;}
declare module "net.minecraft.world.level.block.JukeboxBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $JukeboxBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($JukeboxBlock)>
static readonly "HAS_RECORD": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($JukeboxBlock)>
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JukeboxBlock$$Type = ($JukeboxBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JukeboxBlock$$Original = $JukeboxBlock;}
declare module "net.minecraft.world.level.block.Rotation" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List} from "java.util.List"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$OctahedralGroup} from "com.mojang.math.OctahedralGroup"

export class $Rotation extends $Enum<($Rotation)> implements $StringRepresentable$$Interface {
static readonly "COUNTERCLOCKWISE_90": $Rotation
static readonly "CODEC": $Codec<($Rotation)>
static readonly "CLOCKWISE_90": $Rotation
static readonly "CLOCKWISE_180": $Rotation
static readonly "NONE": $Rotation

public "getRotated"(arg0: $Rotation$$Type): $Rotation
public static "getShuffled"(arg0: $RandomSource$$Type): $List<($Rotation)>
public static "values"(): ($Rotation)[]
public static "valueOf"(arg0: StringJS): $Rotation
public "rotate"(arg0: integer, arg1: integer): integer
public "rotate"(arg0: $Direction$$Type): $Direction
public "getSerializedName"(): StringJS
public "rotation"(): $OctahedralGroup
public static "getRandom"(arg0: $RandomSource$$Type): $Rotation
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Rotation$$Type = (("none") | ("clockwise_90") | ("180") | ("counterclockwise_90"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Rotation$$Original = $Rotation;}
declare module "net.minecraft.world.level.biome.Climate$Parameter" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $Climate$Parameter extends $Record {
static readonly "CODEC": $Codec<($Climate$Parameter)>

constructor(arg0: long, arg1: long)

public static "point"(arg0: float): $Climate$Parameter
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "min"(): long
public "max"(): long
public "distance"(arg0: long): long
public "distance"(arg0: $Climate$Parameter$$Type): long
public "span"(arg0: $Climate$Parameter$$Type): $Climate$Parameter
public static "span"(arg0: float, arg1: float): $Climate$Parameter
public static "span"(arg0: $Climate$Parameter$$Type, arg1: $Climate$Parameter$$Type): $Climate$Parameter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Climate$Parameter$$Type = ({"max"?: long, "min"?: long}) | ([max?: long, min?: long]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Climate$Parameter$$Original = $Climate$Parameter;}
declare module "net.minecraft.world.level.block.TwistingVinesBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$GrowingPlantHeadBlock} from "net.minecraft.world.level.block.GrowingPlantHeadBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $TwistingVinesBlock extends $GrowingPlantHeadBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TwistingVinesBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $VoxelShape
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($TwistingVinesBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TwistingVinesBlock$$Type = ($TwistingVinesBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TwistingVinesBlock$$Original = $TwistingVinesBlock;}
declare module "net.minecraft.world.level.storage.DimensionDataStorage" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$File, $File$$Type} from "java.io.File"
import {$DataFixTypes$$Type} from "net.minecraft.util.datafix.DataFixTypes"
import {$DataStorageAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.DataStorageAccess"
import {$SavedData, $SavedData$$Type} from "net.minecraft.world.level.saveddata.SavedData"
import {$SavedData$Factory$$Type} from "net.minecraft.world.level.saveddata.SavedData$Factory"
import {$AccessorMixinDimensionDataStorage$$Interface} from "noobanidus.mods.lootr.common.mixin.accessor.AccessorMixinDimensionDataStorage"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"

export class $DimensionDataStorage implements $DataStorageAccess$$Interface, $AccessorMixinDimensionDataStorage$$Interface {
constructor(arg0: $File$$Type, arg1: $DataFixer$$Type, arg2: $HolderLookup$Provider$$Type)

public "invokeGetDataFile"(arg0: StringJS): $File
public "getCache"(): $Map
public "readTagFromDisk"(arg0: StringJS, arg1: $DataFixTypes$$Type, arg2: integer): $CompoundTag
public "get"<T extends $SavedData>(arg0: $SavedData$Factory$$Type<(T)>, arg1: StringJS): T
public "set"(arg0: StringJS, arg1: $SavedData$$Type): void
public "computeIfAbsent"<T extends $SavedData>(arg0: $SavedData$Factory$$Type<(T)>, arg1: StringJS): T
public "save"(): void
get "cache"(): $Map
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionDataStorage$$Type = ($DimensionDataStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionDataStorage$$Original = $DimensionDataStorage;}
declare module "net.minecraft.world.level.biome.MultiNoiseBiomeSourceParameterList" {
import {$Climate$ParameterList} from "net.minecraft.world.level.biome.Climate$ParameterList"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$MultiNoiseBiomeSourceParameterList$Preset, $MultiNoiseBiomeSourceParameterList$Preset$$Type} from "net.minecraft.world.level.biome.MultiNoiseBiomeSourceParameterList$Preset"
import {$Holder} from "net.minecraft.core.Holder"
import {$HolderGetter$$Type} from "net.minecraft.core.HolderGetter"

export class $MultiNoiseBiomeSourceParameterList {
static readonly "CODEC": $Codec<($Holder<($MultiNoiseBiomeSourceParameterList)>)>
static readonly "DIRECT_CODEC": $Codec<($MultiNoiseBiomeSourceParameterList)>

constructor(arg0: $MultiNoiseBiomeSourceParameterList$Preset$$Type, arg1: $HolderGetter$$Type<($Biome$$Type)>)

public static "knownPresets"(): $Map<($MultiNoiseBiomeSourceParameterList$Preset), ($Climate$ParameterList<($ResourceKey<($Biome)>)>)>
public "parameters"(): $Climate$ParameterList<($Holder<($Biome)>)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenMultiNoiseBiomeSourceParameterList
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenMultiNoiseBiomeSourceParameterListTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiNoiseBiomeSourceParameterList$$Type = (Special.WorldgenMultiNoiseBiomeSourceParameterList);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultiNoiseBiomeSourceParameterList$$Original = $MultiNoiseBiomeSourceParameterList;}
declare module "net.minecraft.world.level.entity.EntityTypeTest" {
import {$Class, $Class$$Type} from "java.lang.Class"

export interface $EntityTypeTest$$Interface<B, T> {
get "baseClass"(): $Class<(B)>
}

export class $EntityTypeTest<B, T> implements $EntityTypeTest$$Interface {
 "getBaseClass"(): $Class<(B)>
static "forExactClass"<B, T>(arg0: $Class$$Type<(T)>): $EntityTypeTest<(B), (T)>
static "forClass"<B, T>(arg0: $Class$$Type<(T)>): $EntityTypeTest<(B), (T)>
 "tryCast"(arg0: B): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTypeTest$$Type<B, T> = ($EntityTypeTest<(B), (T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityTypeTest$$Original<B, T> = $EntityTypeTest<(B), (T)>;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.DarkOakFoliagePlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $DarkOakFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($DarkOakFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type)

public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DarkOakFoliagePlacer$$Type = ($DarkOakFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DarkOakFoliagePlacer$$Original = $DarkOakFoliagePlacer;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType" {
import {$AllOfPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.AllOfPredicate"
import {$TrueBlockPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.TrueBlockPredicate"
import {$MatchingBlocksPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.MatchingBlocksPredicate"
import {$HasSturdyFacePredicate} from "net.minecraft.world.level.levelgen.blockpredicates.HasSturdyFacePredicate"
import {$MatchingFluidsPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.MatchingFluidsPredicate"
import {$SolidPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.SolidPredicate"
import {$UnobstructedPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.UnobstructedPredicate"
import {$ReplaceablePredicate} from "net.minecraft.world.level.levelgen.blockpredicates.ReplaceablePredicate"
import {$InsideWorldBoundsPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.InsideWorldBoundsPredicate"
import {$WouldSurvivePredicate} from "net.minecraft.world.level.levelgen.blockpredicates.WouldSurvivePredicate"
import {$BlockPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$NotPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.NotPredicate"
import {$MatchingBlockTagPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.MatchingBlockTagPredicate"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$AnyOfPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.AnyOfPredicate"

export interface $BlockPredicateType$$Interface<P extends $BlockPredicate> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.BlockPredicateType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.BlockPredicateTypeTag
}

export class $BlockPredicateType<P extends $BlockPredicate> implements $BlockPredicateType$$Interface {
static readonly "UNOBSTRUCTED": $BlockPredicateType<($UnobstructedPredicate)>
static readonly "MATCHING_BLOCK_TAG": $BlockPredicateType<($MatchingBlockTagPredicate)>
static readonly "MATCHING_BLOCKS": $BlockPredicateType<($MatchingBlocksPredicate)>
static readonly "INSIDE_WORLD_BOUNDS": $BlockPredicateType<($InsideWorldBoundsPredicate)>
static readonly "ALL_OF": $BlockPredicateType<($AllOfPredicate)>
static readonly "TRUE": $BlockPredicateType<($TrueBlockPredicate)>
static readonly "ANY_OF": $BlockPredicateType<($AnyOfPredicate)>
static readonly "HAS_STURDY_FACE": $BlockPredicateType<($HasSturdyFacePredicate)>
static readonly "NOT": $BlockPredicateType<($NotPredicate)>
static readonly "REPLACEABLE": $BlockPredicateType<($ReplaceablePredicate)>
static readonly "WOULD_SURVIVE": $BlockPredicateType<($WouldSurvivePredicate)>
static readonly "MATCHING_FLUIDS": $BlockPredicateType<($MatchingFluidsPredicate)>
static readonly "SOLID": $BlockPredicateType<($SolidPredicate)>

 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPredicateType$$Type<P> = (Special.BlockPredicateType) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPredicateType$$Original<P> = $BlockPredicateType<(P)>;}
declare module "net.minecraft.world.level.levelgen.Heightmap$Types" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Predicate} from "java.util.function.Predicate"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $Heightmap$Types extends $Enum<($Heightmap$Types)> implements $StringRepresentable$$Interface {
static readonly "OCEAN_FLOOR": $Heightmap$Types
static readonly "MOTION_BLOCKING_NO_LEAVES": $Heightmap$Types
static readonly "CODEC": $Codec<($Heightmap$Types)>
static readonly "MOTION_BLOCKING": $Heightmap$Types
static readonly "WORLD_SURFACE": $Heightmap$Types
static readonly "OCEAN_FLOOR_WG": $Heightmap$Types
static readonly "WORLD_SURFACE_WG": $Heightmap$Types

public "sendToClient"(): boolean
public "getSerializationKey"(): StringJS
public "keepAfterWorldgen"(): boolean
public static "values"(): ($Heightmap$Types)[]
public static "valueOf"(arg0: StringJS): $Heightmap$Types
public "isOpaque"(): $Predicate<($BlockState)>
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializationKey"(): StringJS
get "opaque"(): $Predicate<($BlockState)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Heightmap$Types$$Type = (("world_surface_wg") | ("world_surface") | ("ocean_floor_wg") | ("ocean_floor") | ("motion_blocking") | ("motion_blocking_no_leaves"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Heightmap$Types$$Original = $Heightmap$Types;}
declare module "net.minecraft.world.level.block.entity.JukeboxBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$ContainerSingleItem$BlockContainerSingleItem$$Interface} from "net.minecraft.world.ticks.ContainerSingleItem$BlockContainerSingleItem"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$JukeboxSongPlayer} from "net.minecraft.world.item.JukeboxSongPlayer"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $JukeboxBlockEntity extends $BlockEntity implements $Clearable$$Interface, $ContainerSingleItem$BlockContainerSingleItem$$Interface {
static readonly "SONG_ITEM_TAG_ID": StringJS
readonly "jukeboxSongPlayer": $JukeboxSongPlayer
static readonly "TICKS_SINCE_SONG_STARTED_TAG_ID": StringJS
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "popOutTheItem"(): void
public "getSongPlayer"(): $JukeboxSongPlayer
public "getComparatorOutput"(): integer
public "getTheItem"(): $ItemStack
public "setTheItem"(arg0: $ItemStack$$Type): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "onSongChanged"(): void
public "splitTheItem"(arg0: integer): $ItemStack
public "getContainerBlockEntity"(): $BlockEntity
public "setSongItemWithoutPlaying"(arg0: $ItemStack$$Type): void
public "tryForcePlaySong"(): void
public static "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $JukeboxBlockEntity$$Type): void
public "getMaxStackSize"(): integer
public "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
public "clearContent"(): void
public static "tryClear"(arg0: any): void
public "stillValid"(arg0: $Player$$Type): boolean
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "removeTheItem"(): $ItemStack
public "getItem"(arg0: integer): $ItemStack
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "isEmpty"(): boolean
public "getContainerSize"(): integer
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "startOpen"(arg0: $Player$$Type): void
public "stopOpen"(arg0: $Player$$Type): void
public "countItem"(arg0: $Item$$Type): integer
public "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
public "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "getMaxStackSize"(arg0: $ItemStack$$Type): integer
public "self"(): $Container
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "getSlotLimit"(slot: integer): integer
public "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
public "clear"(): void
public "getWidth"(): integer
public "getHeight"(): integer
public "getBlock"(level: $Level$$Type): $LevelBlock
public "setChanged"(): void
public "asContainer"(): $Container
public "setTransferCooldown"(arg0: long): void
public "canReceiveTransferCooldown"(): boolean
public "lithium$itemInsertionTestRequiresStackSize1"(): boolean
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "clear"(match: $ItemPredicate$$Type): void
public "find"(match: $ItemPredicate$$Type): integer
public "find"(): integer
public "count"(match: $ItemPredicate$$Type): integer
public "count"(): integer
public "countNonEmpty"(): integer
public "countNonEmpty"(match: $ItemPredicate$$Type): integer
public "getAllItems"(): $List<($ItemStack)>
get "songPlayer"(): $JukeboxSongPlayer
get "comparatorOutput"(): integer
get "theItem"(): $ItemStack
set "theItem"(value: $ItemStack$$Type)
get "containerBlockEntity"(): $BlockEntity
set "songItemWithoutPlaying"(value: $ItemStack$$Type)
get "maxStackSize"(): integer
get "empty"(): boolean
get "containerSize"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "width"(): integer
get "height"(): integer
get "changed"(): void
set "transferCooldown"(value: long)
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JukeboxBlockEntity$$Type = ($JukeboxBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JukeboxBlockEntity$$Original = $JukeboxBlockEntity;}
declare module "net.minecraft.world.level.levelgen.carver.CarvingContext" {
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$NoiseChunk$$Type} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$RandomState, $RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$SurfaceRules$RuleSource$$Type} from "net.minecraft.world.level.levelgen.SurfaceRules$RuleSource"
import {$NoiseBasedChunkGenerator$$Type} from "net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator"
import {$Function$$Type} from "java.util.function.Function"
import {$WorldGenerationContext} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $CarvingContext extends $WorldGenerationContext {
constructor(arg0: $NoiseBasedChunkGenerator$$Type, arg1: $RegistryAccess$$Type, arg2: $LevelHeightAccessor$$Type, arg3: $NoiseChunk$$Type, arg4: $RandomState$$Type, arg5: $SurfaceRules$RuleSource$$Type)

public "randomState"(): $RandomState
/**
 * 
 * @deprecated
 */
public "topMaterial"(arg0: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg1: $ChunkAccess$$Type, arg2: $BlockPos$$Type, arg3: boolean): $Optional<($BlockState)>
/**
 * 
 * @deprecated
 */
public "registryAccess"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarvingContext$$Type = ($CarvingContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarvingContext$$Original = $CarvingContext;}
declare module "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$List$$Type} from "java.util.List"
import {$DoubleList, $DoubleList$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleList"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $NormalNoise$NoiseParameters extends $Record {
static readonly "CODEC": $Codec<($Holder<($NormalNoise$NoiseParameters)>)>
static readonly "DIRECT_CODEC": $Codec<($NormalNoise$NoiseParameters)>

constructor(arg0: integer, arg1: $DoubleList$$Type)
constructor(arg0: integer, arg1: double, ...arg2: (double)[])
constructor(arg0: integer, arg1: $List$$Type<(double)>)

public "firstOctave"(): integer
public "amplitudes"(): $DoubleList
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenNoise
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenNoiseTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NormalNoise$NoiseParameters$$Type = (Special.WorldgenNoise) | ({"amplitudes"?: $DoubleList$$Type, "firstOctave"?: integer}) | ([amplitudes?: $DoubleList$$Type, firstOctave?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NormalNoise$NoiseParameters$$Original = $NormalNoise$NoiseParameters;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.ProcessorRule" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PosRuleTest$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.PosRuleTest"
import {$RuleBlockEntityModifier$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Passthrough} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.Passthrough"
import {$RuleTest$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ProcessorRule {
static readonly "CODEC": $Codec<($ProcessorRule)>
static readonly "DEFAULT_BLOCK_ENTITY_MODIFIER": $Passthrough

constructor(arg0: $RuleTest$$Type, arg1: $RuleTest$$Type, arg2: $BlockState$$Type)
constructor(arg0: $RuleTest$$Type, arg1: $RuleTest$$Type, arg2: $PosRuleTest$$Type, arg3: $BlockState$$Type, arg4: $RuleBlockEntityModifier$$Type)
constructor(arg0: $RuleTest$$Type, arg1: $RuleTest$$Type, arg2: $PosRuleTest$$Type, arg3: $BlockState$$Type)

public "getOutputState"(): $BlockState
public "getOutputTag"(arg0: $RandomSource$$Type, arg1: $CompoundTag$$Type): $CompoundTag
public "test"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: $RandomSource$$Type): boolean
get "outputState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProcessorRule$$Type = ($ProcessorRule);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProcessorRule$$Original = $ProcessorRule;}
declare module "net.minecraft.world.level.entity.ChunkStatusUpdateListener" {
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$FullChunkStatus, $FullChunkStatus$$Type} from "net.minecraft.server.level.FullChunkStatus"

export interface $ChunkStatusUpdateListener$$Interface {

(arg0: $ChunkPos, arg1: $FullChunkStatus): void
}

export class $ChunkStatusUpdateListener implements $ChunkStatusUpdateListener$$Interface {
 "onChunkStatusChange"(arg0: $ChunkPos$$Type, arg1: $FullChunkStatus$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkStatusUpdateListener$$Type = ((arg0: $ChunkPos, arg1: $FullChunkStatus) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkStatusUpdateListener$$Original = $ChunkStatusUpdateListener;}
declare module "net.minecraft.world.level.levelgen.WorldGenSettings" {
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$WorldDimensions, $WorldDimensions$$Type} from "net.minecraft.world.level.levelgen.WorldDimensions"
import {$WorldOptions, $WorldOptions$$Type} from "net.minecraft.world.level.levelgen.WorldOptions"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$Record} from "java.lang.Record"

export class $WorldGenSettings extends $Record {
static readonly "CODEC": $Codec<($WorldGenSettings)>

constructor(arg0: $WorldOptions$$Type, arg1: $WorldDimensions$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "encode"<T>(arg0: $DynamicOps$$Type<(T)>, arg1: $WorldOptions$$Type, arg2: $RegistryAccess$$Type): $DataResult<(T)>
public static "encode"<T>(arg0: $DynamicOps$$Type<(T)>, arg1: $WorldOptions$$Type, arg2: $WorldDimensions$$Type): $DataResult<(T)>
public "dimensions"(): $WorldDimensions
public "options"(): $WorldOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldGenSettings$$Type = ({"dimensions"?: $WorldDimensions$$Type, "options"?: $WorldOptions$$Type}) | ([dimensions?: $WorldDimensions$$Type, options?: $WorldOptions$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldGenSettings$$Original = $WorldGenSettings;}
declare module "net.minecraft.world.level.block.BaseEntityBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$EntityBlock$$Interface} from "net.minecraft.world.level.block.EntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BaseEntityBlock extends $Block implements $EntityBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$$Type, arg1: T): $GameEventListener
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseEntityBlock$$Type = ($BaseEntityBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseEntityBlock$$Original = $BaseEntityBlock;}
declare module "net.minecraft.world.level.saveddata.maps.MapItemSavedData$MapPatch" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional} from "java.util.Optional"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$MapItemSavedData$$Type} from "net.minecraft.world.level.saveddata.maps.MapItemSavedData"
import {$Record} from "java.lang.Record"

export class $MapItemSavedData$MapPatch extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($Optional<($MapItemSavedData$MapPatch)>)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: (byte)[])

public "mapColors"(): (byte)[]
public "applyToMap"(arg0: $MapItemSavedData$$Type): void
public "startX"(): integer
public "startY"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "width"(): integer
public "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapItemSavedData$MapPatch$$Type = ({"startX"?: integer, "startY"?: integer, "width"?: integer, "mapColors"?: (byte)[], "height"?: integer}) | ([startX?: integer, startY?: integer, width?: integer, mapColors?: (byte)[], height?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapItemSavedData$MapPatch$$Original = $MapItemSavedData$MapPatch;}
declare module "net.minecraft.world.level.levelgen.carver.NetherWorldCarver" {
import {$CaveWorldCarver} from "net.minecraft.world.level.levelgen.carver.CaveWorldCarver"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$WorldCarver} from "net.minecraft.world.level.levelgen.carver.WorldCarver"
import {$CaveCarverConfiguration, $CaveCarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CaveCarverConfiguration"
import {$CanyonCarverConfiguration} from "net.minecraft.world.level.levelgen.carver.CanyonCarverConfiguration"

export class $NetherWorldCarver extends $CaveWorldCarver {
static readonly "CAVE": $WorldCarver<($CaveCarverConfiguration)>
static readonly "CANYON": $WorldCarver<($CanyonCarverConfiguration)>
static readonly "NETHER_CAVE": $WorldCarver<($CaveCarverConfiguration)>

constructor(arg0: $Codec$$Type<($CaveCarverConfiguration$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherWorldCarver$$Type = ($NetherWorldCarver);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherWorldCarver$$Original = $NetherWorldCarver;}
declare module "net.minecraft.world.level.levelgen.carver.WorldCarver" {
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ConfiguredWorldCarver} from "net.minecraft.world.level.levelgen.carver.ConfiguredWorldCarver"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$CaveCarverConfiguration} from "net.minecraft.world.level.levelgen.carver.CaveCarverConfiguration"
import {$CanyonCarverConfiguration} from "net.minecraft.world.level.levelgen.carver.CanyonCarverConfiguration"
import {$Aquifer$$Type} from "net.minecraft.world.level.levelgen.Aquifer"
import {$CarvingContext$$Type} from "net.minecraft.world.level.levelgen.carver.CarvingContext"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$CarvingMask$$Type} from "net.minecraft.world.level.chunk.CarvingMask"
import {$CarverConfiguration, $CarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CarverConfiguration"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $WorldCarver<C extends $CarverConfiguration> {
static readonly "CAVE": $WorldCarver<($CaveCarverConfiguration)>
static readonly "CANYON": $WorldCarver<($CanyonCarverConfiguration)>
static readonly "NETHER_CAVE": $WorldCarver<($CaveCarverConfiguration)>

constructor(arg0: $Codec$$Type<(C)>)

public "configuredCodec"(): $MapCodec<($ConfiguredWorldCarver<(C)>)>
public "carve"(arg0: $CarvingContext$$Type, arg1: C, arg2: $ChunkAccess$$Type, arg3: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg4: $RandomSource$$Type, arg5: $Aquifer$$Type, arg6: $ChunkPos$$Type, arg7: $CarvingMask$$Type): boolean
public "isStartChunk"(arg0: C, arg1: $RandomSource$$Type): boolean
public "getRange"(): integer
public "configured"(arg0: C): $ConfiguredWorldCarver<(C)>
get "range"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenCarver
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenCarverTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldCarver$$Type<C> = (Special.WorldgenCarver);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldCarver$$Original<C> = $WorldCarver<(C)>;}
declare module "net.minecraft.world.level.block.DirtPathBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $DirtPathBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DirtPathBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($DirtPathBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirtPathBlock$$Type = ($DirtPathBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirtPathBlock$$Original = $DirtPathBlock;}
declare module "net.minecraft.world.level.block.CherryLeavesBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$LeavesBlock} from "net.minecraft.world.level.block.LeavesBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CherryLeavesBlock extends $LeavesBlock {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "DISTANCE": $IntegerProperty
static readonly "PERSISTENT": $BooleanProperty
 "item": $Item
static readonly "CODEC": $MapCodec<($CherryLeavesBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "DECAY_DISTANCE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($CherryLeavesBlock)>
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CherryLeavesBlock$$Type = ($CherryLeavesBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CherryLeavesBlock$$Original = $CherryLeavesBlock;}
declare module "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerData" {
import {$TrialSpawnerState$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Optional$$Type} from "java.util.Optional"
import {$UUID$$Type} from "java.util.UUID"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$TrialSpawner$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$SpawnData$$Type} from "net.minecraft.world.level.SpawnData"
import {$Set$$Type} from "java.util.Set"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$TrialSpawnerConfig$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerConfig"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $TrialSpawnerData {
static "MAP_CODEC": $MapCodec<($TrialSpawnerData)>
static readonly "TAG_SPAWN_DATA": StringJS
 "cooldownEndsAt": long

constructor(arg0: $Set$$Type<($UUID$$Type)>, arg1: $Set$$Type<($UUID$$Type)>, arg2: long, arg3: long, arg4: integer, arg5: ($SpawnData$$Type)?, arg6: ($ResourceKey$$Type<($LootTable$$Type)>)?)
constructor()

public "getSpin"(): double
public "getOrCreateDisplayEntity"(arg0: $TrialSpawner$$Type, arg1: $Level$$Type, arg2: $TrialSpawnerState$$Type): $Entity
public "hasMobToSpawn"(arg0: $TrialSpawner$$Type, arg1: $RandomSource$$Type): boolean
public "tryDetectPlayers"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $TrialSpawner$$Type): void
public "countAdditionalPlayers"(arg0: $BlockPos$$Type): integer
public "hasFinishedSpawningAllMobs"(arg0: $TrialSpawnerConfig$$Type, arg1: integer): boolean
public "haveAllCurrentMobsDied"(): boolean
public "isReadyToSpawnNextMob"(arg0: $ServerLevel$$Type, arg1: $TrialSpawnerConfig$$Type, arg2: integer): boolean
public "isReadyToOpenShutter"(arg0: $ServerLevel$$Type, arg1: float, arg2: integer): boolean
public "isReadyToEjectItems"(arg0: $ServerLevel$$Type, arg1: float, arg2: integer): boolean
public "isCooldownFinished"(arg0: $ServerLevel$$Type): boolean
public "getUpdateTag"(arg0: $TrialSpawnerState$$Type): $CompoundTag
public "setEntityId"(arg0: $TrialSpawner$$Type, arg1: $RandomSource$$Type, arg2: $EntityType$$Type<(never)>): void
public "resetAfterBecomingOminous"(arg0: $TrialSpawner$$Type, arg1: $ServerLevel$$Type): void
public "reset"(): void
public "getOSpin"(): double
get "spin"(): double
get "OSpin"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawnerData$$Type = ($TrialSpawnerData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawnerData$$Original = $TrialSpawnerData;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.AttachedToLeavesDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AttachedToLeavesDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($AttachedToLeavesDecorator)>

constructor(arg0: float, arg1: integer, arg2: integer, arg3: $BlockStateProvider$$Type, arg4: integer, arg5: $List$$Type<($Direction$$Type)>)

public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedToLeavesDecorator$$Type = ($AttachedToLeavesDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttachedToLeavesDecorator$$Original = $AttachedToLeavesDecorator;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$BlockStateBase" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$LootParams$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootParams$Builder"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Projectile$$Type} from "net.minecraft.world.entity.projectile.Projectile"
import {$MoreStateCulling$$Interface} from "ca.fxco.moreculling.api.blockstate.MoreStateCulling"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$IBlockState$$Interface} from "org.embeddedt.modernfix.duck.IBlockState"
import {$Stream} from "java.util.stream.Stream"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$IStateCacheAccessor$$Interface} from "xfacthd.framedblocks.api.block.cache.IStateCacheAccessor"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$PathComputationType$$Type} from "net.minecraft.world.level.pathfinder.PathComputationType"
import {$StateCache, $StateCache$$Type} from "xfacthd.framedblocks.api.block.cache.StateCache"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$StateCullingShapeCache$$Interface} from "ca.fxco.moreculling.api.blockstate.StateCullingShapeCache"
import {$StateHolder} from "net.minecraft.world.level.block.state.StateHolder"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$SupportType$$Type} from "net.minecraft.world.level.block.SupportType"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"
import {$MapColor} from "net.minecraft.world.level.material.MapColor"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Comparable} from "java.lang.Comparable"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$NoteBlockInstrument} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$MenuProvider} from "net.minecraft.world.MenuProvider"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function} from "java.util.function.Function"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$ExtendedAbstractBlockState$$Interface} from "ca.spottedleaf.starlight.common.blockstate.ExtendedAbstractBlockState"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockStateKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockStateKJS"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"

export class $BlockBehaviour$BlockStateBase extends $StateHolder<($Block), ($BlockState)> implements $IBlockState$$Interface, $ExtendedAbstractBlockState$$Interface, $MoreStateCulling$$Interface, $StateCullingShapeCache$$Interface, $BlockStateKJS$$Interface, $IStateCacheAccessor$$Interface {
static readonly "PROPERTIES_TAG": StringJS
static readonly "PROPERTY_ENTRY_TO_STRING_FUNCTION": $Function<($Map$Entry<($Property<(never)>), ($Comparable<(never)>)>), (StringJS)>
static readonly "NAME_TAG": StringJS

public "canBeReplaced"(arg0: $BlockPlaceContext$$Type): boolean
public "canBeReplaced"(arg0: $Fluid$$Type): boolean
public "canBeReplaced"(): boolean
public "updateShape"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $LevelAccessor$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type): $BlockState
public "skipRendering"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "getFaceOcclusionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): $VoxelShape
public "getDrops"(arg0: $LootParams$Builder$$Type): $List<($ItemStack)>
/**
 * 
 * @deprecated
 */
public "isSolid"(): boolean
public "canOcclude"(): boolean
public "moreculling$cantCullAgainst"(arg0: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $Direction$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
public "ignitedByLava"(): boolean
public "moreculling$customShouldDrawFace"(arg0: $BlockGetter$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: $Direction$$Type): $Optional
public "moreculling$usesCustomShouldDrawFace"(): boolean
public "setDestroySpeed"(arg0: float): void
public "setLightEmission"(arg0: integer): void
public "setRequiresTool"(arg0: boolean): void
public "onPlace"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: boolean): void
public "isRandomlyTicking"(): boolean
public "isPathfindable"(arg0: $PathComputationType$$Type): boolean
public "getMapColor"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $MapColor
public "spawnAfterBreak"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type, arg3: boolean): void
public "useWithoutItem"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockHitResult$$Type): $InteractionResult
public "useShapeForLightOcclusion"(): boolean
public "getOcclusionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "getBlockSupportShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "isSolidRender"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "propagatesSkylightDown"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getMenuProvider"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $MenuProvider
public "getShadeBrightness"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): float
public "getAnalogOutputSignal"(arg0: $Level$$Type, arg1: $BlockPos$$Type): integer
public "getVisualShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): $VoxelShape
public "randomTick"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public "getDestroyProgress"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): float
public "onProjectileHit"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockHitResult$$Type, arg3: $Projectile$$Type): void
public "isViewBlocking"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "hasPostProcess"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "emissiveRendering"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "isConditionallyFullOpaque"(): boolean
public "scalablelux$actuallyDynamicLightEmission"(): boolean
public "handler$fba000$ferritecore$cacheStateHead"(arg0: $CallbackInfo$$Type): void
public "handler$zoh000$scalablelux$initLightAccessState"(ci: $CallbackInfo$$Type): void
public "handler$fba000$ferritecore$cacheStateTail"(arg0: $CallbackInfo$$Type): void
public "getBlockHolder"(): $Holder<($Block)>
public "isValidSpawn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $EntityType$$Type<(never)>): boolean
public "hasLargeCollisionShape"(): boolean
public "handler$bmn000$oculus$getShadeBrightness"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $CallbackInfoReturnable$$Type): void
public "entityCanStandOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): boolean
public "modifyReturnValue$bcp000$supplementaries$supp$modifyPlanterOffset"(original: $Vec3$$Type, level: $BlockGetter$$Type, pos: $BlockPos$$Type): $Vec3
public "hasOffsetFunction"(): boolean
public "handleNeighborChanged"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Block$$Type, arg3: $BlockPos$$Type, arg4: boolean): void
public "handler$edk000$immersiveengineering$onBlockCollision"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type, arg3: $CallbackInfo$$Type): void
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "shouldSpawnTerrainParticles"(): boolean
public "isCacheInvalid"(): boolean
public "getOpacityIfCached"(): integer
public "moreculling$getFaceCullingShape"(arg0: $Direction$$Type): $VoxelShape
public "framedblocks$initCache"(arg0: $StateCache$$Type): void
public "framedblocks$getCache"(): $StateCache
public "initCache"(): void
public "tick"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public "getBlock"(): $Block
public "getSeed"(arg0: $BlockPos$$Type): long
public "getShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): $VoxelShape
public "getShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "clearCache"(): void
public "is"(arg0: $Holder$$Type<($Block)>): boolean
public "is"(arg0: $HolderSet$$Type<($Block)>): boolean
public "is"(arg0: $TagKey$$Type<($Block)>): boolean
public "is"(arg0: $TagKey$$Type<($Block)>, arg1: $Predicate$$Type<($BlockBehaviour$BlockStateBase)>): boolean
public "is"(arg0: $Block$$Type): boolean
public "is"(arg0: $ResourceKey$$Type<($Block)>): boolean
public "getOffset"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Vec3
/**
 * 
 * @deprecated
 */
public "rotate"(arg0: $Rotation$$Type): $BlockState
public "mirror"(arg0: $Mirror$$Type): $BlockState
public "getFluidState"(): $FluidState
public "getRenderShape"(): $RenderShape
public "isAir"(): boolean
public "attack"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Player$$Type): void
public "useItemOn"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $Player$$Type, arg3: $InteractionHand$$Type, arg4: $BlockHitResult$$Type): $ItemInteractionResult
public "hasBlockEntity"(): boolean
public "moreculling$initShapeCache"(): void
public "moreculling$canCull"(): boolean
public "instrument"(): $NoteBlockInstrument
public "getCollisionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): $VoxelShape
public "getCollisionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "getTags"(): $Stream<($TagKey<($Block)>)>
public "canSurvive"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
public "getSoundType"(): $SoundType
/**
 * 
 * @deprecated
 */
public "blocksMotion"(): boolean
public "getDestroySpeed"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): float
public "requiresCorrectToolForDrops"(): boolean
public "entityInside"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): void
public "isCollisionShapeFullBlock"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getPistonPushReaction"(): $PushReaction
public "onExplosionHit"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type, arg3: $BiConsumer$$Type<($ItemStack), ($BlockPos)>): void
public "onRemove"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: boolean): void
public "isSuffocating"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
public "liquid"(): boolean
public "entityCanStandOnFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type, arg3: $Direction$$Type): boolean
public "triggerEvent"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: integer, arg3: integer): boolean
public "isRedstoneConductor"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
public "getLightEmission"(): integer
public "getLightBlock"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): integer
public "hasAnalogOutputSignal"(): boolean
public "updateNeighbourShapes"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: integer): void
public "updateNeighbourShapes"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: integer, arg3: integer): void
public "updateIndirectNeighbourShapes"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: integer, arg3: integer): void
public "updateIndirectNeighbourShapes"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: integer): void
public "getDirectSignal"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): integer
public "isSignalSource"(): boolean
public "getSignal"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): integer
public "getInteractionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "isFaceSturdy"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $SupportType$$Type): boolean
public "isFaceSturdy"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
public "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
public "getRegistry"(): $Registry<($Block)>
public "asHolder"(): $Holder<($Block)>
public "randomTickOverride"(state: $BlockState$$Type, level: $ServerLevel$$Type, pos: $BlockPos$$Type, random: $RandomSource$$Type): boolean
public "getWebIconURL"(size: integer): $RelativeURL
public "toString"(): StringJS
public "getKey"(): $ResourceKey<($Block)>
public "getId"(): StringJS
public "getIdLocation"(): $ResourceLocation
public "getMod"(): StringJS
public "getTagKeys"(): $List<($TagKey<($Block)>)>
public "getTags"(): $List<($ResourceLocation)>
public "hasTag"(tag: $ResourceLocation$$Type): boolean
public "specialEquals"(o: any, shallow: boolean): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "solid"(): boolean
set "destroySpeed"(value: float)
set "lightEmission"(value: integer)
set "requiresTool"(value: boolean)
get "randomlyTicking"(): boolean
get "conditionallyFullOpaque"(): boolean
get "blockHolder"(): $Holder<($Block)>
get "cacheInvalid"(): boolean
get "opacityIfCached"(): integer
get "block"(): $Block
get "fluidState"(): $FluidState
get "renderShape"(): $RenderShape
get "air"(): boolean
get "tags"(): $Stream<($TagKey<($Block)>)>
get "soundType"(): $SoundType
get "pistonPushReaction"(): $PushReaction
get "lightEmission"(): integer
get "signalSource"(): boolean
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "key"(): $ResourceKey<($Block)>
get "id"(): StringJS
get "idLocation"(): $ResourceLocation
get "mod"(): StringJS
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$BlockStateBase$$Type = ($BlockBehaviour$BlockStateBase);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$BlockStateBase$$Original = $BlockBehaviour$BlockStateBase;}
declare module "net.minecraft.world.level.levelgen.feature.Feature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$FeatureConfiguration, $FeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$Function$$Type} from "java.util.function.Function"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $Feature<FC extends $FeatureConfiguration> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<(FC)>)

public static "isDirt"(arg0: $BlockState$$Type): boolean
public static "isReplaceable"(arg0: $TagKey$$Type<($Block)>): $Predicate<($BlockState)>
public "configuredCodec"(): $MapCodec<($ConfiguredFeature<(FC), ($Feature<(FC)>)>)>
public static "isGrassOrDirt"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type): boolean
public static "checkNeighbors"(arg0: $Function$$Type<($BlockPos), ($BlockState$$Type)>, arg1: $BlockPos$$Type, arg2: $Predicate$$Type<($BlockState)>): boolean
public static "isAdjacentToAir"(arg0: $Function$$Type<($BlockPos), ($BlockState$$Type)>, arg1: $BlockPos$$Type): boolean
public "place"(arg0: $FeaturePlaceContext$$Type<(FC)>): boolean
public "place"(arg0: FC, arg1: $WorldGenLevel$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BlockPos$$Type): boolean
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenFeature
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenFeatureTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Feature$$Type<FC> = (Special.WorldgenFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Feature$$Original<FC> = $Feature<(FC)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $BlockPileConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($BlockPileConfiguration)>
readonly "stateProvider": $BlockStateProvider

constructor(arg0: $BlockStateProvider$$Type)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPileConfiguration$$Type = ($BlockPileConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPileConfiguration$$Original = $BlockPileConfiguration;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.BlobFoliagePlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $BlobFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($BlobFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: integer)

public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlobFoliagePlacer$$Type = ($BlobFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlobFoliagePlacer$$Original = $BlobFoliagePlacer;}
declare module "net.minecraft.world.level.storage.loot.entries.EntryGroup$Builder" {
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$LootPoolEntryContainer} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$LootPoolEntryContainer$Builder, $LootPoolEntryContainer$Builder$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer$Builder"
import {$ConditionUserBuilder} from "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder"

export class $EntryGroup$Builder extends $LootPoolEntryContainer$Builder<($EntryGroup$Builder)> {
constructor(...arg0: ($LootPoolEntryContainer$Builder$$Type<(never)>)[])

public "append"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $EntryGroup$Builder
public "build"(): $LootPoolEntryContainer
public "when"(arg0: $LootItemCondition$Builder$$Type): $ConditionUserBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntryGroup$Builder$$Type = ($EntryGroup$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntryGroup$Builder$$Original = $EntryGroup$Builder;}
declare module "net.minecraft.world.level.levelgen.feature.featuresize.ThreeLayersFeatureSize" {
import {$OptionalInt$$Type} from "java.util.OptionalInt"
import {$FeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $ThreeLayersFeatureSize extends $FeatureSize {
static readonly "CODEC": $MapCodec<($ThreeLayersFeatureSize)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: $OptionalInt$$Type)

public "getSizeAtHeight"(arg0: integer, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThreeLayersFeatureSize$$Type = ($ThreeLayersFeatureSize);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThreeLayersFeatureSize$$Original = $ThreeLayersFeatureSize;}
declare module "net.minecraft.world.level.chunk.storage.SectionStorage" {
import {$Iterable} from "java.lang.Iterable"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$Runnable$$Type} from "java.lang.Runnable"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$SimpleRegionStorage$$Type} from "net.minecraft.world.level.chunk.storage.SimpleRegionStorage"
import {$ChunkIOErrorReporter$$Type} from "net.minecraft.world.level.chunk.storage.ChunkIOErrorReporter"
import {$Stream} from "java.util.stream.Stream"
import {$RegionBasedStorageSectionExtended$$Interface} from "net.caffeinemc.mods.lithium.common.world.interests.RegionBasedStorageSectionExtended"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $SectionStorage<R> implements $AutoCloseable$$Interface, $RegionBasedStorageSectionExtended$$Interface {
constructor(arg0: $SimpleRegionStorage$$Type, arg1: $Function$$Type<($Runnable), ($Codec$$Type<(R)>)>, arg2: $Function$$Type<($Runnable), (R)>, arg3: $RegistryAccess$$Type, arg4: $ChunkIOErrorReporter$$Type, arg5: $LevelHeightAccessor$$Type)

public "getOrLoad"(arg0: long): $Optional<(R)>
public "lithium$getWithinChunkColumn"(arg0: integer, arg1: integer): $Stream
public "lithium$getInChunkColumn"(arg0: integer, arg1: integer): $Iterable
public "remove"(arg0: long): void
public "flush"(arg0: $ChunkPos$$Type): void
public "close"(): void
public "hasWork"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SectionStorage$$Type<R> = ($SectionStorage<(R)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SectionStorage$$Original<R> = $SectionStorage<(R)>;}
declare module "net.minecraft.world.level.LevelHeightAccessor" {
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export interface $LevelHeightAccessor$$Interface {
get "height"(): integer
get "minBuildHeight"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $LevelHeightAccessor implements $LevelHeightAccessor$$Interface {
 "getHeight"(): integer
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMinBuildHeight"(): integer
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelHeightAccessor$$Type = ($LevelHeightAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelHeightAccessor$$Original = $LevelHeightAccessor;}
declare module "net.minecraft.world.level.saveddata.maps.MapItemSavedData$HoldingPlayer" {
import {$CustomMapData$Type$$Type} from "net.mehvahdjukaar.moonlight.api.map.CustomMapData$Type"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$MapId$$Type} from "net.minecraft.world.level.saveddata.maps.MapId"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Packet, $Packet$$Type} from "net.minecraft.network.protocol.Packet"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$MapItemSavedData$$Type} from "net.minecraft.world.level.saveddata.maps.MapItemSavedData"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$IHoldingPlayerExtension$$Interface} from "net.mehvahdjukaar.moonlight.core.misc.IHoldingPlayerExtension"

export class $MapItemSavedData$HoldingPlayer implements $IHoldingPlayerExtension$$Interface {
 "step": integer
readonly "player": $Player

public "handler$eae000$moonlight$initializeDirty"(mapItemSavedData: $MapItemSavedData$$Type, player: $Player$$Type, ci: $CallbackInfo$$Type): void
public "handler$eae000$moonlight$checkLocked"(mapId: $MapId$$Type, cir: $CallbackInfoReturnable$$Type): void
public "modifyReturnValue$eae000$moonlight$addExtraPacketData"(packet: $Packet$$Type, mapId: $MapId$$Type): $Packet
public "handler$eae000$moonlight$lockData"(x: integer, z: integer, ci: $CallbackInfo$$Type): void
public "handler$eae000$moonlight$sanityCheck"(x: integer, z: integer, ci: $CallbackInfo$$Type): void
public "moonlight$setCustomDataDirty"(type: $CustomMapData$Type$$Type, dirtySetter: $Consumer$$Type): void
public "moonlight$setCustomMarkersDirty"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapItemSavedData$HoldingPlayer$$Type = ($MapItemSavedData$HoldingPlayer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapItemSavedData$HoldingPlayer$$Original = $MapItemSavedData$HoldingPlayer;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $UnderwaterMagmaConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($UnderwaterMagmaConfiguration)>
readonly "floorSearchRange": integer
readonly "placementRadiusAroundFloor": integer
readonly "placementProbabilityPerValidPosition": float

constructor(arg0: integer, arg1: integer, arg2: float)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnderwaterMagmaConfiguration$$Type = ($UnderwaterMagmaConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UnderwaterMagmaConfiguration$$Original = $UnderwaterMagmaConfiguration;}
declare module "net.minecraft.world.level.biome.BiomeGenerationSettings" {
import {$Iterable} from "java.lang.Iterable"
import {$GenerationStep$Carving, $GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Map$$Type} from "java.util.Map"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Set} from "java.util.Set"
import {$ConfiguredWorldCarver, $ConfiguredWorldCarver$$Type} from "net.minecraft.world.level.levelgen.carver.ConfiguredWorldCarver"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Holder} from "net.minecraft.core.Holder"

export class $BiomeGenerationSettings {
static readonly "CODEC": $MapCodec<($BiomeGenerationSettings)>
static readonly "EMPTY": $BiomeGenerationSettings

constructor(arg0: $Map$$Type<($GenerationStep$Carving$$Type), ($HolderSet$$Type<($ConfiguredWorldCarver$$Type<(never)>)>)>, arg1: $List$$Type<($HolderSet$$Type<($PlacedFeature$$Type)>)>)

public "getFlowerFeatures"(): $List<($ConfiguredFeature<(never), (never)>)>
public "getCarvers"(arg0: $GenerationStep$Carving$$Type): $Iterable<($Holder<($ConfiguredWorldCarver<(never)>)>)>
public "getCarvingStages"(): $Set<($GenerationStep$Carving)>
public "features"(): $List<($HolderSet<($PlacedFeature)>)>
public "hasFeature"(arg0: $PlacedFeature$$Type): boolean
get "flowerFeatures"(): $List<($ConfiguredFeature<(never), (never)>)>
get "carvingStages"(): $Set<($GenerationStep$Carving)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeGenerationSettings$$Type = ($BiomeGenerationSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeGenerationSettings$$Original = $BiomeGenerationSettings;}
declare module "net.minecraft.world.level.block.FurnaceBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$AbstractFurnaceBlock} from "net.minecraft.world.level.block.AbstractFurnaceBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FurnaceBlock extends $AbstractFurnaceBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FurnaceBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($FurnaceBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FurnaceBlock$$Type = ($FurnaceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FurnaceBlock$$Original = $FurnaceBlock;}
declare module "net.minecraft.world.level.block.CoralWallFanBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BaseCoralWallFanBlock} from "net.minecraft.world.level.block.BaseCoralWallFanBlock"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CoralWallFanBlock extends $BaseCoralWallFanBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CoralWallFanBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($CoralWallFanBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoralWallFanBlock$$Type = ($CoralWallFanBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CoralWallFanBlock$$Original = $CoralWallFanBlock;}
declare module "net.minecraft.world.level.storage.LevelStorageSource$LevelDirectory" {
import {$LocalDateTime$$Type} from "java.time.LocalDateTime"
import {$LevelResource$$Type} from "net.minecraft.world.level.storage.LevelResource"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$Record} from "java.lang.Record"

export class $LevelStorageSource$LevelDirectory extends $Record {
constructor(path: $Path$$Type)

public "rawDataFile"(arg0: $LocalDateTime$$Type): $Path
public "lockFile"(): $Path
public "corruptedDataFile"(arg0: $LocalDateTime$$Type): $Path
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "path"(): $Path
public "resourcePath"(arg0: $LevelResource$$Type): $Path
public "dataFile"(): $Path
public "directoryName"(): StringJS
public "iconFile"(): $Path
public "oldDataFile"(): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelStorageSource$LevelDirectory$$Type = ({"path"?: $Path$$Type}) | ([path?: $Path$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelStorageSource$LevelDirectory$$Original = $LevelStorageSource$LevelDirectory;}
declare module "net.minecraft.world.level.border.WorldBorder$Settings" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$DynamicLike$$Type} from "com.mojang.serialization.DynamicLike"

export class $WorldBorder$Settings {
public "getWarningTime"(): integer
public "getWarningBlocks"(): integer
public "getSafeZone"(): double
public "getSizeLerpTime"(): long
public "getSizeLerpTarget"(): double
public "write"(arg0: $CompoundTag$$Type): void
public static "read"(arg0: $DynamicLike$$Type<(never)>, arg1: $WorldBorder$Settings$$Type): $WorldBorder$Settings
public "getSize"(): double
public "getDamagePerBlock"(): double
public "getCenterX"(): double
public "getCenterZ"(): double
get "warningTime"(): integer
get "warningBlocks"(): integer
get "safeZone"(): double
get "sizeLerpTime"(): long
get "sizeLerpTarget"(): double
get "size"(): double
get "damagePerBlock"(): double
get "centerX"(): double
get "centerZ"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldBorder$Settings$$Type = ($WorldBorder$Settings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldBorder$Settings$$Original = $WorldBorder$Settings;}
declare module "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$OptionalInt, $OptionalInt$$Type} from "java.util.OptionalInt"

export class $FeatureSize {
static readonly "CODEC": $Codec<($FeatureSize)>

constructor(arg0: $OptionalInt$$Type)

public "minClippedHeight"(): $OptionalInt
public "getSizeAtHeight"(arg0: integer, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeatureSize$$Type = ($FeatureSize);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeatureSize$$Original = $FeatureSize;}
declare module "net.minecraft.world.level.storage.loot.predicates.LootItemCondition" {
import {$LootContextParam} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$LootContext, $LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$LootItemConditionType} from "net.minecraft.world.level.storage.loot.predicates.LootItemConditionType"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$Set} from "java.util.Set"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootContextUser$$Interface} from "net.minecraft.world.level.storage.loot.LootContextUser"
import {$Holder} from "net.minecraft.core.Holder"

export interface $LootItemCondition$$Interface extends $LootContextUser$$Interface, $Predicate$$Interface<($LootContext)> {
get "type"(): $LootItemConditionType
get "referencedContextParams"(): $Set<($LootContextParam<(never)>)>
}

export class $LootItemCondition implements $LootItemCondition$$Interface {
static readonly "CODEC": $Codec<($Holder<($LootItemCondition)>)>
static readonly "DIRECT_CODEC": $Codec<($LootItemCondition)>
static readonly "TYPED_CODEC": $Codec<($LootItemCondition)>

 "getType"(): $LootItemConditionType
 "getReferencedContextParams"(): $Set<($LootContextParam<(never)>)>
 "validate"(arg0: $ValidationContext$$Type): void
 "or"(arg0: $Predicate$$Type<($LootContext)>): $Predicate<($LootContext)>
static "isEqual"<T>(arg0: any): $Predicate<($LootContext)>
 "negate"(): $Predicate<($LootContext)>
 "and"(arg0: $Predicate$$Type<($LootContext)>): $Predicate<($LootContext)>
static "not"<T>(arg0: $Predicate$$Type<($LootContext)>): $Predicate<($LootContext)>
 "test"(arg0: $LootContext$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemCondition$$Type = ($LootItemCondition);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemCondition$$Original = $LootItemCondition;}
declare module "net.minecraft.world.level.levelgen.NoiseSettings" {
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $NoiseSettings extends $Record {
static readonly "CODEC": $Codec<($NoiseSettings)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "clampToHeightAccessor"(arg0: $LevelHeightAccessor$$Type): $NoiseSettings
public "getCellHeight"(): integer
public "getCellWidth"(): integer
public "noiseSizeHorizontal"(): integer
public "noiseSizeVertical"(): integer
public "minY"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "create"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $NoiseSettings
public "height"(): integer
get "cellHeight"(): integer
get "cellWidth"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseSettings$$Type = ({"minY"?: integer, "noiseSizeHorizontal"?: integer, "noiseSizeVertical"?: integer, "height"?: integer}) | ([minY?: integer, noiseSizeHorizontal?: integer, noiseSizeVertical?: integer, height?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseSettings$$Original = $NoiseSettings;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$TwoArgumentSimpleFunction" {
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction, $DensityFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunctions$TwoArgumentSimpleFunction$$Interface extends $DensityFunction$$Interface {
}

export class $DensityFunctions$TwoArgumentSimpleFunction implements $DensityFunctions$TwoArgumentSimpleFunction$$Interface {
 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "cube"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "squeeze"(): $DensityFunction
 "maxValue"(): double
 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "square"(): $DensityFunction
 "minValue"(): double
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$TwoArgumentSimpleFunction$$Type = ($DensityFunctions$TwoArgumentSimpleFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$TwoArgumentSimpleFunction$$Original = $DensityFunctions$TwoArgumentSimpleFunction;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SimpleStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.SimpleStateProvider"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateProvider {
static readonly "CODEC": $Codec<($BlockStateProvider)>

constructor()

public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
public static "simple"(arg0: $BlockState$$Type): $SimpleStateProvider
public static "simple"(arg0: $Block$$Type): $SimpleStateProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateProvider$$Type = ($BlockStateProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateProvider$$Original = $BlockStateProvider;}
declare module "net.minecraft.world.level.biome.Climate$TargetPoint" {
import {$Record} from "java.lang.Record"

export class $Climate$TargetPoint extends $Record {
constructor(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long)

public "temperature"(): long
public "humidity"(): long
public "continentalness"(): long
public "erosion"(): long
public "weirdness"(): long
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "depth"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Climate$TargetPoint$$Type = ({"continentalness"?: long, "depth"?: long, "humidity"?: long, "temperature"?: long, "erosion"?: long, "weirdness"?: long}) | ([continentalness?: long, depth?: long, humidity?: long, temperature?: long, erosion?: long, weirdness?: long]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Climate$TargetPoint$$Original = $Climate$TargetPoint;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.CombiningPredicate" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type, $BlockPredicate$$Interface} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CombiningPredicate implements $BlockPredicate$$Interface {
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
public "type"(): $BlockPredicateType<(never)>
public "or"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "negate"(): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "and"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "test"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CombiningPredicate$$Type = ($CombiningPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CombiningPredicate$$Original = $CombiningPredicate;}
declare module "net.minecraft.world.level.levelgen.feature.VinesFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $VinesFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VinesFeature$$Type = ($VinesFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VinesFeature$$Original = $VinesFeature;}
declare module "net.minecraft.world.level.levelgen.feature.NetherForestVegetationFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig, $NetherForestVegetationConfig$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $NetherForestVegetationFeature extends $Feature<($NetherForestVegetationConfig)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NetherForestVegetationConfig$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NetherForestVegetationConfig$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherForestVegetationFeature$$Type = ($NetherForestVegetationFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherForestVegetationFeature$$Original = $NetherForestVegetationFeature;}
declare module "net.minecraft.world.level.block.ColoredFallingBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ColorRGBA, $ColorRGBA$$Type} from "net.minecraft.util.ColorRGBA"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$FallingBlock} from "net.minecraft.world.level.block.FallingBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ColoredFallingBlock extends $FallingBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ColoredFallingBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
readonly "dustColor": $ColorRGBA
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $ColorRGBA$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getDustColor"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): integer
public "codec"(): $MapCodec<($ColoredFallingBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColoredFallingBlock$$Type = ($ColoredFallingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ColoredFallingBlock$$Original = $ColoredFallingBlock;}
declare module "net.minecraft.world.level.portal.PortalShape" {
import {$Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Optional} from "java.util.Optional"
import {$EntityDimensions$$Type} from "net.minecraft.world.entity.EntityDimensions"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockUtil$FoundRectangle$$Type} from "net.minecraft.BlockUtil$FoundRectangle"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $PortalShape {
static readonly "MAX_WIDTH": integer
static readonly "MAX_HEIGHT": integer

constructor(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Direction$Axis$$Type)

public static "findEmptyPortalShape"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Direction$Axis$$Type): $Optional<($PortalShape)>
public "createPortalBlocks"(): void
public static "findCollisionFreePosition"(arg0: $Vec3$$Type, arg1: $ServerLevel$$Type, arg2: $Entity$$Type, arg3: $EntityDimensions$$Type): $Vec3
public static "findPortalShape"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Predicate$$Type<($PortalShape)>, arg3: $Direction$Axis$$Type): $Optional<($PortalShape)>
public "isValid"(): boolean
public "isComplete"(): boolean
public static "getRelativePosition"(arg0: $BlockUtil$FoundRectangle$$Type, arg1: $Direction$Axis$$Type, arg2: $Vec3$$Type, arg3: $EntityDimensions$$Type): $Vec3
get "valid"(): boolean
get "complete"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PortalShape$$Type = ($PortalShape);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PortalShape$$Original = $PortalShape;}
declare module "net.minecraft.world.level.levelgen.feature.EndGatewayFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration, $EndGatewayConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $EndGatewayFeature extends $Feature<($EndGatewayConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($EndGatewayConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($EndGatewayConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndGatewayFeature$$Type = ($EndGatewayFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndGatewayFeature$$Original = $EndGatewayFeature;}
declare module "net.minecraft.world.level.chunk.LightChunk" {
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$ChunkSkyLightSources} from "net.minecraft.world.level.lighting.ChunkSkyLightSources"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $LightChunk$$Interface extends $BlockGetter$$Interface {
get "skyLightSources"(): $ChunkSkyLightSources
get "maxLightLevel"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $LightChunk implements $LightChunk$$Interface {
 "findBlockLightSources"(arg0: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
 "getSkyLightSources"(): $ChunkSkyLightSources
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getHeight"(): integer
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMinBuildHeight"(): integer
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightChunk$$Type = ($LightChunk);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightChunk$$Original = $LightChunk;}
declare module "net.minecraft.world.level.Explosion" {
import {$Map} from "java.util.Map"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Pair$$Type} from "com.mojang.datafixers.util.Pair"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List, $List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Explosion$BlockInteraction, $Explosion$BlockInteraction$$Type} from "net.minecraft.world.level.Explosion$BlockInteraction"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ExplosionDamageCalculator, $ExplosionDamageCalculator$$Type} from "net.minecraft.world.level.ExplosionDamageCalculator"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ExplosionAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.ExplosionAccess"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export class $Explosion implements $ExplosionAccess$$Interface {
readonly "level": $Level
readonly "blockInteraction": $Explosion$BlockInteraction
readonly "x": double
readonly "y": double
 "damageSource": $DamageSource
readonly "z": double
readonly "damageCalculator": $ExplosionDamageCalculator
 "source": $Entity

constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: $DamageSource$$Type, arg3: $ExplosionDamageCalculator$$Type, arg4: double, arg5: double, arg6: double, arg7: float, arg8: boolean, arg9: $Explosion$BlockInteraction$$Type, arg10: $ParticleOptions$$Type, arg11: $ParticleOptions$$Type, arg12: $Holder$$Type<($SoundEvent)>)
constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: double, arg3: double, arg4: double, arg5: float, arg6: boolean, arg7: $Explosion$BlockInteraction$$Type)
constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: double, arg3: double, arg4: double, arg5: float, arg6: boolean, arg7: $Explosion$BlockInteraction$$Type, arg8: $List$$Type<($BlockPos$$Type)>)
constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: double, arg3: double, arg4: double, arg5: float, arg6: $List$$Type<($BlockPos$$Type)>, arg7: $Explosion$BlockInteraction$$Type, arg8: $ParticleOptions$$Type, arg9: $ParticleOptions$$Type, arg10: $Holder$$Type<($SoundEvent)>)

public "getBlockInteraction"(): $Explosion$BlockInteraction
public "getIndirectSourceEntity"(): $LivingEntity
public "getDirectSourceEntity"(): $Entity
public "interactsWithBlocks"(): boolean
public "clearToBlow"(): void
public "getToBlow"(): $List<($BlockPos)>
public "getHitPlayers"(): $Map<($Player), ($Vec3)>
public "getSmallExplosionParticles"(): $ParticleOptions
public "getLargeExplosionParticles"(): $ParticleOptions
public "getExplosionSound"(): $Holder<($SoundEvent)>
public "canTriggerBlocks"(): boolean
public static "getSeenPercent"(arg0: $Vec3$$Type, arg1: $Entity$$Type): float
public static "getIndirectSourceEntityInternal"(arg0: $Entity$$Type): $LivingEntity
public "handler$bba000$supplementaries$supp$explode"(ci: $CallbackInfo$$Type): void
public static "callAddOrAppendStack$immersiveengineering_$md$a93e73$0"(arg0: $List$$Type, arg1: $ItemStack$$Type, arg2: $BlockPos$$Type): void
public "center"(): $Vec3
public "radius"(): float
public "explode"(): void
public static "getDefaultDamageSource"(arg0: $Level$$Type, arg1: $Entity$$Type): $DamageSource
public "finalizeExplosion"(arg0: boolean): void
public static "callAddOrAppendStack"(arg0: $List$$Type<($Pair$$Type<($ItemStack$$Type), ($BlockPos$$Type)>)>, arg1: $ItemStack$$Type, arg2: $BlockPos$$Type): void
get "indirectSourceEntity"(): $LivingEntity
get "directSourceEntity"(): $Entity
get "toBlow"(): $List<($BlockPos)>
get "hitPlayers"(): $Map<($Player), ($Vec3)>
get "smallExplosionParticles"(): $ParticleOptions
get "largeExplosionParticles"(): $ParticleOptions
get "explosionSound"(): $Holder<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Explosion$$Type = ($Explosion);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Explosion$$Original = $Explosion;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $ColumnFeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($ColumnFeatureConfiguration)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type)

public "height"(): $IntProvider
public "reach"(): $IntProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColumnFeatureConfiguration$$Type = ($ColumnFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ColumnFeatureConfiguration$$Original = $ColumnFeatureConfiguration;}
declare module "net.minecraft.world.level.block.WeatheringCopperStairBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$StairsShape} from "net.minecraft.world.level.block.state.properties.StairsShape"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$StairBlock} from "net.minecraft.world.level.block.StairBlock"
import {$Enum} from "java.lang.Enum"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Half} from "net.minecraft.world.level.block.state.properties.Half"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$WeatheringCopper$$Interface} from "net.minecraft.world.level.block.WeatheringCopper"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$WeatheringCopper$WeatherState$$Type} from "net.minecraft.world.level.block.WeatheringCopper$WeatherState"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WeatheringCopperStairBlock extends $StairBlock implements $WeatheringCopper$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WeatheringCopperStairBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($Half)>
static readonly "SHAPE": $EnumProperty<($StairsShape)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $WeatheringCopper$WeatherState$$Type, arg1: $BlockState$$Type, arg2: $BlockBehaviour$Properties$$Type)

public "getAge"(): $Enum
public "codec"(): $MapCodec<($WeatheringCopperStairBlock)>
public "getChanceModifier"(): float
public "getNext"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getNext"(arg0: $Block$$Type): $Optional<($Block)>
public static "getFirst"(arg0: $BlockState$$Type): $BlockState
public static "getFirst"(arg0: $Block$$Type): $Block
public static "getPrevious"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getPrevious"(arg0: $Block$$Type): $Optional<($Block)>
public "changeOverTime"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getNextState"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($BlockState)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "age"(): $Enum
get "chanceModifier"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatheringCopperStairBlock$$Type = ($WeatheringCopperStairBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeatheringCopperStairBlock$$Original = $WeatheringCopperStairBlock;}
declare module "net.minecraft.world.level.block.BaseCoralPlantTypeBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BaseCoralPlantTypeBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseCoralPlantTypeBlock$$Type = ($BaseCoralPlantTypeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseCoralPlantTypeBlock$$Original = $BaseCoralPlantTypeBlock;}
declare module "net.minecraft.world.level.block.LiquidBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$FlowingFluid, $FlowingFluid$$Type} from "net.minecraft.world.level.material.FlowingFluid"
import {$LiquidBlockAccessor$$Interface as $LiquidBlockAccessor$0$$Interface} from "dev.architectury.mixin.forge.neoforge.LiquidBlockAccessor"
import {$Direction} from "net.minecraft.core.Direction"
import {$ImmutableList} from "com.google.common.collect.ImmutableList"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InjectedLiquidBlockExtension$$Interface} from "dev.architectury.extensions.injected.InjectedLiquidBlockExtension"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$LiquidBlockAccessor$$Interface} from "journeymap.common.mixin.client.LiquidBlockAccessor"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BucketPickup$$Interface} from "net.minecraft.world.level.block.BucketPickup"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $LiquidBlock extends $Block implements $BucketPickup$$Interface, $LiquidBlockAccessor$0$$Interface, $InjectedLiquidBlockExtension$$Interface, $LiquidBlockAccessor$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LiquidBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "LEVEL": $IntegerProperty
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POSSIBLE_FLOW_DIRECTIONS": $ImmutableList<($Direction)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "STABLE_SHAPE": $VoxelShape
readonly "fluid": $FlowingFluid
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $FlowingFluid$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getFluid"(): $FlowingFluid
public "getPickupSound"(): $Optional<($SoundEvent)>
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($LiquidBlock)>
public "arch$getFluid"(): $FlowingFluid
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LiquidBlock$$Type = ($LiquidBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LiquidBlock$$Original = $LiquidBlock;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration" {
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $EndGatewayConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($EndGatewayConfiguration)>

public static "knownExit"(arg0: $BlockPos$$Type, arg1: boolean): $EndGatewayConfiguration
public "getExit"(): $Optional<($BlockPos)>
public "isExitExact"(): boolean
public static "delayedExitSearch"(): $EndGatewayConfiguration
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "exit"(): $Optional<($BlockPos)>
get "exitExact"(): boolean
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndGatewayConfiguration$$Type = ($EndGatewayConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndGatewayConfiguration$$Original = $EndGatewayConfiguration;}
declare module "net.minecraft.world.level.block.NetherPortalBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Portal$Transition} from "net.minecraft.world.level.block.Portal$Transition"
import {$Portal$$Interface} from "net.minecraft.world.level.block.Portal"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$DimensionTransition} from "net.minecraft.world.level.portal.DimensionTransition"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NetherPortalBlock extends $Block implements $Portal$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($NetherPortalBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getPortalTransitionTime"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type): integer
public "getLocalTransition"(): $Portal$Transition
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($NetherPortalBlock)>
public "getPortalDestination"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type, arg2: $BlockPos$$Type): $DimensionTransition
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "localTransition"(): $Portal$Transition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherPortalBlock$$Type = ($NetherPortalBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherPortalBlock$$Original = $NetherPortalBlock;}
declare module "net.minecraft.world.level.block.DoubleBlockCombiner$NeighborCombineResult" {
import {$DoubleBlockCombiner$Combiner, $DoubleBlockCombiner$Combiner$$Type} from "net.minecraft.world.level.block.DoubleBlockCombiner$Combiner"

export interface $DoubleBlockCombiner$NeighborCombineResult$$Interface<S> {

(arg0: $DoubleBlockCombiner$Combiner<(S), (T)>): T
}

export class $DoubleBlockCombiner$NeighborCombineResult<S> implements $DoubleBlockCombiner$NeighborCombineResult$$Interface {
 "apply"<T>(arg0: $DoubleBlockCombiner$Combiner$$Type<(S), (T)>): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBlockCombiner$NeighborCombineResult$$Type<S> = ((arg0: $DoubleBlockCombiner$Combiner<(S), (T)>) => T);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoubleBlockCombiner$NeighborCombineResult$$Original<S> = $DoubleBlockCombiner$NeighborCombineResult<(S)>;}
declare module "net.minecraft.world.level.entity.LevelCallback" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $LevelCallback$$Interface<T> {
}

export class $LevelCallback<T> implements $LevelCallback$$Interface {
 "onDestroyed"(arg0: T): void
 "onTickingStart"(arg0: T): void
 "onTickingEnd"(arg0: T): void
 "onTrackingStart"(arg0: T): void
 "onTrackingEnd"(arg0: T): void
 "onSectionChange"(arg0: T): void
 "onCreated"(arg0: T): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelCallback$$Type<T> = ($LevelCallback<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelCallback$$Original<T> = $LevelCallback<(T)>;}
declare module "net.minecraft.world.level.levelgen.carver.CaveCarverConfiguration" {
import {$VerticalAnchor, $VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$CarverConfiguration, $CarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CarverConfiguration"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"
import {$CarverDebugSettings, $CarverDebugSettings$$Type} from "net.minecraft.world.level.levelgen.carver.CarverDebugSettings"
import {$HeightProvider, $HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $CaveCarverConfiguration extends $CarverConfiguration {
readonly "lavaLevel": $VerticalAnchor
readonly "debugSettings": $CarverDebugSettings
static readonly "CODEC": $Codec<($CaveCarverConfiguration)>
readonly "horizontalRadiusMultiplier": $FloatProvider
readonly "verticalRadiusMultiplier": $FloatProvider
readonly "probability": float
readonly "replaceable": $HolderSet<($Block)>
readonly "y": $HeightProvider
readonly "yScale": $FloatProvider

constructor(arg0: $CarverConfiguration$$Type, arg1: $FloatProvider$$Type, arg2: $FloatProvider$$Type, arg3: $FloatProvider$$Type)
constructor(arg0: float, arg1: $HeightProvider$$Type, arg2: $FloatProvider$$Type, arg3: $VerticalAnchor$$Type, arg4: $HolderSet$$Type<($Block)>, arg5: $FloatProvider$$Type, arg6: $FloatProvider$$Type, arg7: $FloatProvider$$Type)
constructor(arg0: float, arg1: $HeightProvider$$Type, arg2: $FloatProvider$$Type, arg3: $VerticalAnchor$$Type, arg4: $CarverDebugSettings$$Type, arg5: $HolderSet$$Type<($Block)>, arg6: $FloatProvider$$Type, arg7: $FloatProvider$$Type, arg8: $FloatProvider$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaveCarverConfiguration$$Type = ($CaveCarverConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CaveCarverConfiguration$$Original = $CaveCarverConfiguration;}
declare module "net.minecraft.world.level.block.CaveVines" {
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ToIntFunction} from "java.util.function.ToIntFunction"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $CaveVines$$Interface {
}

export class $CaveVines implements $CaveVines$$Interface {
static readonly "SHAPE": $VoxelShape
static readonly "BERRIES": $BooleanProperty

static "emission"(arg0: integer): $ToIntFunction<($BlockState)>
static "hasGlowBerries"(arg0: $BlockState$$Type): boolean
static "use"(arg0: $Entity$$Type, arg1: $BlockState$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): $InteractionResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaveVines$$Type = ($CaveVines);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CaveVines$$Original = $CaveVines;}
declare module "net.minecraft.world.level.levelgen.Heightmap" {
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Predicate} from "java.util.function.Predicate"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Set$$Type} from "java.util.Set"
import {$HeightmapAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.world.combined_heightmap_update.HeightmapAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $Heightmap implements $HeightmapAccessor$$Interface {
constructor(arg0: $ChunkAccess$$Type, arg1: $Heightmap$Types$$Type)

public "setRawData"(arg0: $ChunkAccess$$Type, arg1: $Heightmap$Types$$Type, arg2: (long)[]): void
public static "primeHeightmaps"(arg0: $ChunkAccess$$Type, arg1: $Set$$Type<($Heightmap$Types$$Type)>): void
public "getFirstAvailable"(arg0: integer, arg1: integer): integer
public "getRawData"(): (long)[]
public "getHighestTaken"(arg0: integer, arg1: integer): integer
public "callSet"(arg0: integer, arg1: integer, arg2: integer): void
public "getBlockPredicate"(): $Predicate
public "update"(arg0: integer, arg1: integer, arg2: integer, arg3: $BlockState$$Type): boolean
get "rawData"(): (long)[]
get "blockPredicate"(): $Predicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Heightmap$$Type = ($Heightmap);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Heightmap$$Original = $Heightmap;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.PosRuleTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $PosRuleTest {
static readonly "CODEC": $Codec<($PosRuleTest)>

constructor()

public "test"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PosRuleTest$$Type = ($PosRuleTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PosRuleTest$$Original = $PosRuleTest;}
declare module "net.minecraft.world.level.levelgen.feature.EndPlatformFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$ServerLevelAccessor$$Type} from "net.minecraft.world.level.ServerLevelAccessor"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $EndPlatformFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public static "createEndPlatform"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: boolean): void
public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndPlatformFeature$$Type = ($EndPlatformFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndPlatformFeature$$Original = $EndPlatformFeature;}
declare module "net.minecraft.world.level.levelgen.heightproviders.WeightedListHeight" {
import {$HeightProviderType} from "net.minecraft.world.level.levelgen.heightproviders.HeightProviderType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$SimpleWeightedRandomList$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$HeightProvider, $HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $WeightedListHeight extends $HeightProvider {
static readonly "CODEC": $MapCodec<($WeightedListHeight)>

constructor(arg0: $SimpleWeightedRandomList$$Type<($HeightProvider$$Type)>)

public "getType"(): $HeightProviderType<(never)>
public "sample"(arg0: $RandomSource$$Type, arg1: $WorldGenerationContext$$Type): integer
get "type"(): $HeightProviderType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeightedListHeight$$Type = ($WeightedListHeight);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeightedListHeight$$Original = $WeightedListHeight;}
declare module "net.minecraft.world.level.levelgen.heightproviders.HeightProvider" {
import {$HeightProviderType} from "net.minecraft.world.level.levelgen.heightproviders.HeightProviderType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"

export class $HeightProvider {
static readonly "CODEC": $Codec<($HeightProvider)>

constructor()

public "getType"(): $HeightProviderType<(never)>
public "sample"(arg0: $RandomSource$$Type, arg1: $WorldGenerationContext$$Type): integer
get "type"(): $HeightProviderType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeightProvider$$Type = ($HeightProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HeightProvider$$Original = $HeightProvider;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifierType" {
import {$RuleBlockEntityModifier} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifier"
import {$Passthrough} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.Passthrough"
import {$AppendLoot} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.AppendLoot"
import {$Clear} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.Clear"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$AppendStatic} from "net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.AppendStatic"

export interface $RuleBlockEntityModifierType$$Interface<P extends $RuleBlockEntityModifier> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.RuleBlockEntityModifier
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.RuleBlockEntityModifierTag
}

export class $RuleBlockEntityModifierType<P extends $RuleBlockEntityModifier> implements $RuleBlockEntityModifierType$$Interface {
static readonly "PASSTHROUGH": $RuleBlockEntityModifierType<($Passthrough)>
static readonly "APPEND_STATIC": $RuleBlockEntityModifierType<($AppendStatic)>
static readonly "APPEND_LOOT": $RuleBlockEntityModifierType<($AppendLoot)>
static readonly "CLEAR": $RuleBlockEntityModifierType<($Clear)>

 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleBlockEntityModifierType$$Type<P> = (Special.RuleBlockEntityModifier) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleBlockEntityModifierType$$Original<P> = $RuleBlockEntityModifierType<(P)>;}
declare module "net.minecraft.world.level.block.entity.HangingSignBlockEntity" {
import {$SignBlockEntity} from "net.minecraft.world.level.block.entity.SignBlockEntity"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HangingSignBlockEntity extends $SignBlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getSignInteractionFailedSoundEvent"(): $SoundEvent
public "getTextLineHeight"(): integer
public "getMaxTextLineWidth"(): integer
get "signInteractionFailedSoundEvent"(): $SoundEvent
get "textLineHeight"(): integer
get "maxTextLineWidth"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HangingSignBlockEntity$$Type = ($HangingSignBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HangingSignBlockEntity$$Original = $HangingSignBlockEntity;}
declare module "net.minecraft.world.level.block.HoneyBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$HalfTransparentBlock} from "net.minecraft.world.level.block.HalfTransparentBlock"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HoneyBlock extends $HalfTransparentBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($HoneyBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($HoneyBlock)>
public static "showJumpParticles"(arg0: $Entity$$Type): void
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public static "showSlideParticles"(arg0: $Entity$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoneyBlock$$Type = ($HoneyBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HoneyBlock$$Original = $HoneyBlock;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.WouldSurvivePredicate" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type, $BlockPredicate$$Interface} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WouldSurvivePredicate implements $BlockPredicate$$Interface {
static readonly "CODEC": $MapCodec<($WouldSurvivePredicate)>

public "type"(): $BlockPredicateType<(never)>
public "test"(arg0: any, arg1: any): boolean
public "test"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): boolean
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
public "or"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "negate"(): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "and"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WouldSurvivePredicate$$Type = ($WouldSurvivePredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WouldSurvivePredicate$$Original = $WouldSurvivePredicate;}
declare module "net.minecraft.world.level.block.entity.BrushableBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$AccessorMixinBrushableBlockEntity$$Interface} from "noobanidus.mods.lootr.common.mixin.accessor.AccessorMixinBrushableBlockEntity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Operation$$Type} from "com.llamalad7.mixinextras.injector.wrapoperation.Operation"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BrushableBlockEntity extends $BlockEntity implements $AccessorMixinBrushableBlockEntity$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getUpdatePacket"(): $Packet
public "unpackLootTable"(arg0: $Player$$Type): void
public "checkReset"(): void
public "brush"(arg0: long, arg1: $Player$$Type, arg2: $Direction$$Type): boolean
public "wrapOperation$fai000$lootr$tryLoadLootTable"(arg0: $CompoundTag$$Type, arg1: StringJS, arg2: integer, arg3: $Operation$$Type): boolean
public "setLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
public "getHitDirection"(): $Direction
public "lootr$getLootTable"(): $ResourceKey
public "lootr$getLootTableSeed"(): long
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getItem"(): $ItemStack
get "updatePacket"(): $Packet
get "hitDirection"(): $Direction
get "item"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrushableBlockEntity$$Type = ($BrushableBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BrushableBlockEntity$$Original = $BrushableBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.HugeBrownMushroomFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$AbstractHugeMushroomFeature} from "net.minecraft.world.level.levelgen.feature.AbstractHugeMushroomFeature"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $HugeBrownMushroomFeature extends $AbstractHugeMushroomFeature {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($HugeMushroomFeatureConfiguration$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HugeBrownMushroomFeature$$Type = ($HugeBrownMushroomFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HugeBrownMushroomFeature$$Original = $HugeBrownMushroomFeature;}
declare module "net.minecraft.world.level.chunk.LightChunkGetter" {
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$LightChunk} from "net.minecraft.world.level.chunk.LightChunk"

export interface $LightChunkGetter$$Interface {
get "level"(): $BlockGetter
}

export class $LightChunkGetter implements $LightChunkGetter$$Interface {
 "getLevel"(): $BlockGetter
 "onLightUpdate"(arg0: $LightLayer$$Type, arg1: $SectionPos$$Type): void
 "getChunkForLighting"(arg0: integer, arg1: integer): $LightChunk
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightChunkGetter$$Type = ($LightChunkGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightChunkGetter$$Original = $LightChunkGetter;}
declare module "net.minecraft.world.level.block.BaseTorchBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BaseTorchBlock extends $Block implements $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseTorchBlock$$Type = ($BaseTorchBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseTorchBlock$$Original = $BaseTorchBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.JigsawStructure" {
import {$ISpawnBoxStructure$$Interface} from "net.mehvahdjukaar.moonlight.api.worldgen.ISpawnBoxStructure"
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$List$$Type} from "java.util.List"
import {$WeightedRandomList} from "net.minecraft.util.random.WeightedRandomList"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SpawnBoxSettings, $SpawnBoxSettings$$Type} from "net.mehvahdjukaar.moonlight.api.worldgen.SpawnBoxSettings"
import {$LiquidSettings, $LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$MobSpawnSettings$SpawnerData} from "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData"
import {$DimensionPadding, $DimensionPadding$$Type} from "net.minecraft.world.level.levelgen.structure.pools.DimensionPadding"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$StructureTemplatePool$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool"
import {$PoolAliasBinding$$Type} from "net.minecraft.world.level.levelgen.structure.pools.alias.PoolAliasBinding"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $JigsawStructure extends $Structure implements $ISpawnBoxStructure$$Interface {
static readonly "CODEC": $MapCodec<($JigsawStructure)>
static readonly "DEFAULT_LIQUID_SETTINGS": $LiquidSettings
static readonly "DEFAULT_DIMENSION_PADDING": $DimensionPadding
static readonly "MAX_DEPTH": integer
static readonly "MIN_DEPTH": integer
static readonly "DIRECT_CODEC": $Codec<($Structure)>
static readonly "MAX_TOTAL_STRUCTURE_RANGE": integer

constructor(arg0: $Structure$StructureSettings$$Type, arg1: $Holder$$Type<($StructureTemplatePool)>, arg2: integer, arg3: $HeightProvider$$Type, arg4: boolean, arg5: $Heightmap$Types$$Type)
constructor(arg0: $Structure$StructureSettings$$Type, arg1: $Holder$$Type<($StructureTemplatePool)>, arg2: integer, arg3: $HeightProvider$$Type, arg4: boolean)
constructor(arg0: $Structure$StructureSettings$$Type, arg1: $Holder$$Type<($StructureTemplatePool)>, arg2: ($ResourceLocation$$Type)?, arg3: integer, arg4: $HeightProvider$$Type, arg5: boolean, arg6: ($Heightmap$Types$$Type)?, arg7: integer, arg8: $List$$Type<($PoolAliasBinding$$Type)>, arg9: $DimensionPadding$$Type, arg10: $LiquidSettings$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "ml$getSpawnBoxSettings"(): $SpawnBoxSettings
public "ml$setSpawnBoxSettings"(settings: $SpawnBoxSettings$$Type): void
public "type"(): $StructureType<(never)>
public "ml$getSpecialSpawns"(structureManager: $StructureManager$$Type, structure: $Structure$$Type, pos: $BlockPos$$Type, chunkPosReferences: $LongSet$$Type, category: $MobCategory$$Type): $WeightedRandomList<($MobSpawnSettings$SpawnerData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JigsawStructure$$Type = ($JigsawStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JigsawStructure$$Original = $JigsawStructure;}
declare module "net.minecraft.world.level.Spawner" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export interface $Spawner$$Interface {

(arg0: $EntityType<(never)>, arg1: $RandomSource): void
}

export class $Spawner implements $Spawner$$Interface {
static "appendHoverText"(arg0: $ItemStack$$Type, arg1: $List$$Type<($Component$$Type)>, arg2: StringJS): void
 "setEntityId"(arg0: $EntityType$$Type<(never)>, arg1: $RandomSource$$Type): void
static "getSpawnEntityDisplayName"(arg0: $ItemStack$$Type, arg1: StringJS): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Spawner$$Type = ((arg0: $EntityType<(never)>, arg1: $RandomSource) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Spawner$$Original = $Spawner;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorList" {
import {$StructureProcessor, $StructureProcessor$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$List, $List$$Type} from "java.util.List"

export class $StructureProcessorList {
constructor(arg0: $List$$Type<($StructureProcessor$$Type)>)

public "toString"(): StringJS
public "list"(): $List<($StructureProcessor)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenProcessorList
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenProcessorListTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureProcessorList$$Type = (Special.WorldgenProcessorList);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureProcessorList$$Original = $StructureProcessorList;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.LavaSubmergedBlockProcessor" {
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $LavaSubmergedBlockProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($LavaSubmergedBlockProcessor)>
static readonly "INSTANCE": $LavaSubmergedBlockProcessor

constructor()

public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LavaSubmergedBlockProcessor$$Type = ($LavaSubmergedBlockProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LavaSubmergedBlockProcessor$$Original = $LavaSubmergedBlockProcessor;}
declare module "net.minecraft.world.level.chunk.LevelChunk" {
import {$ProtoChunk$$Type} from "net.minecraft.world.level.chunk.ProtoChunk"
import {$UpgradeData$$Type} from "net.minecraft.world.level.chunk.UpgradeData"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Trackable} from "dev.uncandango.alltheleaks.mixin.Trackable"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ChunkAccess$TicksToSave} from "net.minecraft.world.level.chunk.ChunkAccess$TicksToSave"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$LevelChunk$EntityCreationType$$Type} from "net.minecraft.world.level.chunk.LevelChunk$EntityCreationType"
import {$TickContainerAccess} from "net.minecraft.world.ticks.TickContainerAccess"
import {$BlendingData$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$IAttachmentHolder$$Interface} from "net.neoforged.neoforge.attachment.IAttachmentHolder"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function$$Type} from "java.util.function.Function"
import {$LevelChunkTicks$$Type} from "net.minecraft.world.ticks.LevelChunkTicks"
import {$Class} from "java.lang.Class"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ObjectOpenCustomHashSet} from "it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$AttachmentType$$Type} from "net.neoforged.neoforge.attachment.AttachmentType"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ExtendedChunk$$Interface} from "ca.spottedleaf.starlight.common.chunk.ExtendedChunk"
import {$LevelChunkSection$$Type} from "net.minecraft.world.level.chunk.LevelChunkSection"
import {$ChunkStatus} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$FullChunkStatus, $FullChunkStatus$$Type} from "net.minecraft.server.level.FullChunkStatus"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$SWMRNibbleArray, $SWMRNibbleArray$$Type} from "ca.spottedleaf.starlight.common.light.SWMRNibbleArray"
import {$ClientboundLevelChunkPacketData$BlockEntityTagOutput$$Type} from "net.minecraft.network.protocol.game.ClientboundLevelChunkPacketData$BlockEntityTagOutput"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$LevelChunk$PostLoadProcessor$$Type} from "net.minecraft.world.level.chunk.LevelChunk$PostLoadProcessor"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$GameEventListenerRegistry} from "net.minecraft.world.level.gameevent.GameEventListenerRegistry"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelChunkAuxiliaryLightManager} from "net.neoforged.neoforge.common.world.LevelChunkAuxiliaryLightManager"
import {$Int2ObjectMap$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectMap"

export class $LevelChunk extends $ChunkAccess implements $IAttachmentHolder$$Interface, $ExtendedChunk$$Interface {
readonly "blockEntities": $Map<($BlockPos), ($BlockEntity)>
static readonly "NO_FILLED_SECTION": integer

constructor(arg0: $Level$$Type, arg1: $ChunkPos$$Type, arg2: $UpgradeData$$Type, arg3: $LevelChunkTicks$$Type<($Block$$Type)>, arg4: $LevelChunkTicks$$Type<($Fluid$$Type)>, arg5: long, arg6: ($LevelChunkSection$$Type)[], arg7: $LevelChunk$PostLoadProcessor$$Type, arg8: $BlendingData$$Type)
constructor(arg0: $ServerLevel$$Type, arg1: $ProtoChunk$$Type, arg2: $LevelChunk$PostLoadProcessor$$Type)
constructor(arg0: $Level$$Type, arg1: $ChunkPos$$Type)

public "unregisterTickContainerFromLevel"(arg0: $ServerLevel$$Type): void
public "unpackTicks"(arg0: long): void
public "getListenerRegistry"(arg0: integer): $GameEventListenerRegistry
public "getPersistedStatus"(): $ChunkStatus
public "getBlockEntityNbtForSaving"(arg0: $BlockPos$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "setFullStatus"(arg0: $Supplier$$Type<($FullChunkStatus$$Type)>): void
public "registerAllBlockEntitiesAfterLevelLoad"(): void
public "setGameEventListenerRegistrySections"(arg0: $Int2ObjectMap$$Type): void
public "handler$zoj000$scalablelux$onTransitionToFull"(serverLevel: $ServerLevel$$Type, protoChunk: $ProtoChunk$$Type, postLoadProcessor: $LevelChunk$PostLoadProcessor$$Type, ci: $CallbackInfo$$Type): void
public "runPostLoad"(): void
public "replaceWithPacketData"(arg0: $FriendlyByteBuf$$Type, arg1: $CompoundTag$$Type, arg2: $Consumer$$Type<($ClientboundLevelChunkPacketData$BlockEntityTagOutput)>): void
public "replaceBiomes"(arg0: $FriendlyByteBuf$$Type): void
public "setLoaded"(arg0: boolean): void
public "postProcessGeneration"(): void
public "registerTickContainerInLevel"(arg0: $ServerLevel$$Type): void
public "getTicksForSerialization"(): $ChunkAccess$TicksToSave
public "getBlockEntities"(): $Map<($BlockPos), ($BlockEntity)>
public "getLevel"(): $Level
public "isEmpty"(): boolean
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "getFluidState"(arg0: integer, arg1: integer, arg2: integer): $FluidState
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "getBlockEntity"(arg0: $BlockPos$$Type, arg1: $LevelChunk$EntityCreationType$$Type): $BlockEntity
public "syncData"(arg0: $AttachmentType$$Type<(never)>): void
public "setBlockEntity"(arg0: $BlockEntity$$Type): void
public "addAndRegisterBlockEntity"(arg0: $BlockEntity$$Type): void
public "removeBlockEntity"(arg0: $BlockPos$$Type): void
public "setBlockState"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: boolean): $BlockState
public "getFullStatus"(): $FullChunkStatus
public "getBlockTicks"(): $TickContainerAccess<($Block)>
public "getFluidTicks"(): $TickContainerAccess<($Fluid)>
public "getAuxLightManager"(arg0: $ChunkPos$$Type): $LevelChunkAuxiliaryLightManager
public "clearAllBlockEntities"(): void
/**
 * 
 * @deprecated
 */
public "addEntity"(arg0: $Entity$$Type): void
public "removeData"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "getData"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "setData"<T>(arg0: $AttachmentType$$Type<(T)>, arg1: T): T
public "hasAttachments"(): boolean
public "hasData"(arg0: $AttachmentType$$Type<(never)>): boolean
public "getExistingDataOrNull"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "getBlockNibbles"(): ($SWMRNibbleArray)[]
public "setBlockNibbles"(arg0: ($SWMRNibbleArray$$Type)[]): void
public "getSkyNibbles"(): ($SWMRNibbleArray)[]
public "setSkyNibbles"(arg0: ($SWMRNibbleArray$$Type)[]): void
public "getSkyEmptinessMap"(): (boolean)[]
public "setSkyEmptinessMap"(arg0: (boolean)[]): void
public "getBlockEmptinessMap"(): (boolean)[]
public "setBlockEmptinessMap"(arg0: (boolean)[]): void
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public static "startTracking"(arg0: any): void
public static "createWeakRefBasedSet"(): $ObjectOpenCustomHashSet<($WeakReference<($Trackable)>)>
public static "clearNullReferences"(): void
public static "getSummary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
get "persistedStatus"(): $ChunkStatus
set "fullStatus"(value: $Supplier$$Type<($FullChunkStatus$$Type)>)
set "gameEventListenerRegistrySections"(value: $Int2ObjectMap$$Type)
set "loaded"(value: boolean)
get "ticksForSerialization"(): $ChunkAccess$TicksToSave
get "level"(): $Level
get "empty"(): boolean
set "blockEntity"(value: $BlockEntity$$Type)
get "fullStatus"(): $FullChunkStatus
get "blockTicks"(): $TickContainerAccess<($Block)>
get "fluidTicks"(): $TickContainerAccess<($Fluid)>
get "blockNibbles"(): ($SWMRNibbleArray)[]
set "blockNibbles"(value: ($SWMRNibbleArray$$Type)[])
get "skyNibbles"(): ($SWMRNibbleArray)[]
set "skyNibbles"(value: ($SWMRNibbleArray$$Type)[])
get "skyEmptinessMap"(): (boolean)[]
set "skyEmptinessMap"(value: (boolean)[])
get "blockEmptinessMap"(): (boolean)[]
set "blockEmptinessMap"(value: (boolean)[])
public static get "summary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelChunk$$Type = ($LevelChunk);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelChunk$$Original = $LevelChunk;}
declare module "net.minecraft.world.level.block.GlowLichenBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$MultifaceBlock} from "net.minecraft.world.level.block.MultifaceBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$ToIntFunction} from "java.util.function.ToIntFunction"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$MultifaceSpreader} from "net.minecraft.world.level.block.MultifaceSpreader"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $GlowLichenBlock extends $MultifaceBlock implements $BonemealableBlock$$Interface, $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($GlowLichenBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "emission"(arg0: integer): $ToIntFunction<($BlockState)>
public "getSpreader"(): $MultifaceSpreader
public "codec"(): $MapCodec<($GlowLichenBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "spreader"(): $MultifaceSpreader
get "type"(): $BonemealableBlock$Type
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlowLichenBlock$$Type = ($GlowLichenBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GlowLichenBlock$$Original = $GlowLichenBlock;}
declare module "net.minecraft.world.level.block.DeadBushBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$IShearable$$Interface} from "net.neoforged.neoforge.common.IShearable"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $DeadBushBlock extends $BushBlock implements $IShearable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DeadBushBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($DeadBushBlock)>
public "onSheared"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): $List<($ItemStack)>
public "isShearable"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): boolean
public "handler$cik000$apothic_enchanting$apoth_handleShearFortune"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "handler$cik000$apothic_enchanting$apoth_handleShearEnchantments"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "spawnShearedDrop"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeadBushBlock$$Type = ($DeadBushBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeadBushBlock$$Original = $DeadBushBlock;}
declare module "net.minecraft.world.level.block.SnifferEggBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$PathComputationType$$Type} from "net.minecraft.world.level.pathfinder.PathComputationType"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SnifferEggBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SnifferEggBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "MAX_HATCH_LEVEL": integer
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "HATCH": $IntegerProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "isPathfindable"(arg0: $BlockState$$Type, arg1: $PathComputationType$$Type): boolean
public "getHatchLevel"(arg0: $BlockState$$Type): integer
public static "hatchBoost"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "codec"(): $MapCodec<($SnifferEggBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SnifferEggBlock$$Type = ($SnifferEggBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SnifferEggBlock$$Original = $SnifferEggBlock;}
declare module "net.minecraft.world.level.portal.PortalForcer" {
import {$Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$Optional} from "java.util.Optional"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockUtil$FoundRectangle} from "net.minecraft.BlockUtil$FoundRectangle"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WorldBorder$$Type} from "net.minecraft.world.level.border.WorldBorder"

export class $PortalForcer {
static readonly "TICKET_RADIUS": integer

constructor(arg0: $ServerLevel$$Type)

public "findClosestPortalPosition"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $WorldBorder$$Type): $Optional
public "createPortal"(arg0: $BlockPos$$Type, arg1: $Direction$Axis$$Type): $Optional<($BlockUtil$FoundRectangle)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PortalForcer$$Type = ($PortalForcer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PortalForcer$$Original = $PortalForcer;}
declare module "net.minecraft.world.level.block.LoomBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $LoomBlock extends $HorizontalDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LoomBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($LoomBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoomBlock$$Type = ($LoomBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LoomBlock$$Original = $LoomBlock;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration" {
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockColumnConfiguration$Layer, $BlockColumnConfiguration$Layer$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration$Layer"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record} from "java.lang.Record"

export class $BlockColumnConfiguration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($BlockColumnConfiguration)>

constructor(arg0: $List$$Type<($BlockColumnConfiguration$Layer$$Type)>, arg1: $Direction$$Type, arg2: $BlockPredicate$$Type, arg3: boolean)

public "allowedPlacement"(): $BlockPredicate
public "prioritizeTip"(): boolean
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "layer"(arg0: $IntProvider$$Type, arg1: $BlockStateProvider$$Type): $BlockColumnConfiguration$Layer
public "layers"(): $List<($BlockColumnConfiguration$Layer)>
public "direction"(): $Direction
public static "simple"(arg0: $IntProvider$$Type, arg1: $BlockStateProvider$$Type): $BlockColumnConfiguration
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockColumnConfiguration$$Type = ({"direction"?: $Direction$$Type, "layers"?: $List$$Type<($BlockColumnConfiguration$Layer$$Type)>, "prioritizeTip"?: boolean, "allowedPlacement"?: $BlockPredicate$$Type}) | ([direction?: $Direction$$Type, layers?: $List$$Type<($BlockColumnConfiguration$Layer$$Type)>, prioritizeTip?: boolean, allowedPlacement?: $BlockPredicate$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockColumnConfiguration$$Original = $BlockColumnConfiguration;}
declare module "net.minecraft.world.level.block.WeatheringCopperFullBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Enum} from "java.lang.Enum"
import {$Optional} from "java.util.Optional"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$WeatheringCopper$$Interface} from "net.minecraft.world.level.block.WeatheringCopper"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$WeatheringCopper$WeatherState$$Type} from "net.minecraft.world.level.block.WeatheringCopper$WeatherState"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WeatheringCopperFullBlock extends $Block implements $WeatheringCopper$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WeatheringCopperFullBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $WeatheringCopper$WeatherState$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getAge"(): $Enum
public "codec"(): $MapCodec<($WeatheringCopperFullBlock)>
public "getChanceModifier"(): float
public "getNext"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getNext"(arg0: $Block$$Type): $Optional<($Block)>
public static "getFirst"(arg0: $BlockState$$Type): $BlockState
public static "getFirst"(arg0: $Block$$Type): $Block
public static "getPrevious"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getPrevious"(arg0: $Block$$Type): $Optional<($Block)>
public "changeOverTime"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getNextState"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($BlockState)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "age"(): $Enum
get "chanceModifier"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatheringCopperFullBlock$$Type = ($WeatheringCopperFullBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeatheringCopperFullBlock$$Original = $WeatheringCopperFullBlock;}
declare module "net.minecraft.world.level.block.entity.BannerPatternLayers" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$BannerPatternLayers$Layer, $BannerPatternLayers$Layer$$Type} from "net.minecraft.world.level.block.entity.BannerPatternLayers$Layer"
import {$Record} from "java.lang.Record"

export class $BannerPatternLayers extends $Record {
static readonly "CODEC": $Codec<($BannerPatternLayers)>
static readonly "EMPTY": $BannerPatternLayers
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($BannerPatternLayers)>

constructor(arg0: $List$$Type<($BannerPatternLayers$Layer$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "layers"(): $List<($BannerPatternLayers$Layer)>
public "removeLast"(): $BannerPatternLayers
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BannerPatternLayers$$Type = ({"layers"?: $List$$Type<($BannerPatternLayers$Layer$$Type)>}) | ([layers?: $List$$Type<($BannerPatternLayers$Layer$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BannerPatternLayers$$Original = $BannerPatternLayers;}
declare module "net.minecraft.world.level.levelgen.Aquifer$FluidPicker" {
import {$Aquifer$FluidStatus, $Aquifer$FluidStatus$$Type} from "net.minecraft.world.level.levelgen.Aquifer$FluidStatus"

export interface $Aquifer$FluidPicker$$Interface {

(arg0: integer, arg1: integer, arg2: integer): $Aquifer$FluidStatus$$Type
}

export class $Aquifer$FluidPicker implements $Aquifer$FluidPicker$$Interface {
 "computeFluid"(arg0: integer, arg1: integer, arg2: integer): $Aquifer$FluidStatus
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Aquifer$FluidPicker$$Type = ((arg0: integer, arg1: integer, arg2: integer) => $Aquifer$FluidStatus$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Aquifer$FluidPicker$$Original = $Aquifer$FluidPicker;}
declare module "net.minecraft.world.level.block.SimpleWaterloggedBlock" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$LiquidBlockContainer$$Interface} from "net.minecraft.world.level.block.LiquidBlockContainer"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BucketPickup$$Interface} from "net.minecraft.world.level.block.BucketPickup"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $SimpleWaterloggedBlock$$Interface extends $BucketPickup$$Interface, $LiquidBlockContainer$$Interface {
get "pickupSound"(): $Optional<($SoundEvent)>
}

export class $SimpleWaterloggedBlock implements $SimpleWaterloggedBlock$$Interface {
 "getPickupSound"(): $Optional<($SoundEvent)>
 "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
 "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
 "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
 "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleWaterloggedBlock$$Type = ($SimpleWaterloggedBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleWaterloggedBlock$$Original = $SimpleWaterloggedBlock;}
declare module "net.minecraft.world.level.timers.TimerQueue" {
import {$TimerCallbacks$$Type} from "net.minecraft.world.level.timers.TimerCallbacks"
import {$Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$Set} from "java.util.Set"
import {$ListTag} from "net.minecraft.nbt.ListTag"
import {$Stream$$Type} from "java.util.stream.Stream"
import {$TimerCallback$$Type} from "net.minecraft.world.level.timers.TimerCallback"

export class $TimerQueue<T> {
constructor(arg0: $TimerCallbacks$$Type<(T)>)
constructor(arg0: $TimerCallbacks$$Type<(T)>, arg1: $Stream$$Type<($Dynamic$$Type<(never)>)>)

public "tick"(arg0: T, arg1: long): void
public "remove"(arg0: StringJS): integer
public "store"(): $ListTag
public "schedule"(arg0: StringJS, arg1: long, arg2: $TimerCallback$$Type<(T)>): void
public "getEventsIds"(): $Set<(StringJS)>
get "eventsIds"(): $Set<(StringJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimerQueue$$Type<T> = ($TimerQueue<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TimerQueue$$Original<T> = $TimerQueue<(T)>;}
declare module "net.minecraft.world.level.block.CartographyTableBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CartographyTableBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CartographyTableBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($CartographyTableBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CartographyTableBlock$$Type = ($CartographyTableBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CartographyTableBlock$$Original = $CartographyTableBlock;}
declare module "net.minecraft.world.level.block.BeehiveBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BeehiveBlockEntity$BeeReleaseStatus$$Type} from "net.minecraft.world.level.block.entity.BeehiveBlockEntity$BeeReleaseStatus"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BeehiveBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BeehiveBlock)>
static readonly "MAX_HONEY_LEVELS": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "HONEY_LEVEL": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "playerDestroy"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockEntity$$Type, arg5: $ItemStack$$Type): void
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "releaseBeesAndResetHoneyLevel"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type, arg4: $BeehiveBlockEntity$BeeReleaseStatus$$Type): void
public static "dropHoneycomb"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "resetHoneyLevel"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type): void
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($BeehiveBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeehiveBlock$$Type = ($BeehiveBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeehiveBlock$$Original = $BeehiveBlock;}
declare module "net.minecraft.world.level.levelgen.WorldGenerationContext" {
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"

export class $WorldGenerationContext {
constructor(arg0: $ChunkGenerator$$Type, arg1: $LevelHeightAccessor$$Type)

public "getMinGenY"(): integer
public "getGenDepth"(): integer
get "minGenY"(): integer
get "genDepth"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldGenerationContext$$Type = ($WorldGenerationContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldGenerationContext$$Original = $WorldGenerationContext;}
declare module "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext" {
import {$Blender} from "net.minecraft.world.level.levelgen.blending.Blender"

export interface $DensityFunction$FunctionContext$$Interface {
get "blender"(): $Blender
}

export class $DensityFunction$FunctionContext implements $DensityFunction$FunctionContext$$Interface {
 "blockY"(): integer
 "blockZ"(): integer
 "blockX"(): integer
 "getBlender"(): $Blender
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$FunctionContext$$Type = ($DensityFunction$FunctionContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$FunctionContext$$Original = $DensityFunction$FunctionContext;}
declare module "net.minecraft.world.level.block.MudBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $MudBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($MudBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($MudBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MudBlock$$Type = ($MudBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MudBlock$$Original = $MudBlock;}
declare module "net.minecraft.world.level.block.entity.vault.VaultConfig" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$PlayerDetector, $PlayerDetector$$Type} from "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$PlayerDetector$EntitySelector, $PlayerDetector$EntitySelector$$Type} from "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector$EntitySelector"
import {$Record} from "java.lang.Record"

export class $VaultConfig extends $Record {
constructor(arg0: $ResourceKey$$Type<($LootTable)>, arg1: double, arg2: double, arg3: $ItemStack$$Type, arg4: ($ResourceKey$$Type<($LootTable$$Type)>)?, arg5: $PlayerDetector$$Type, arg6: $PlayerDetector$EntitySelector$$Type)
constructor(arg0: $ResourceKey$$Type<($LootTable)>, arg1: double, arg2: double, arg3: $ItemStack$$Type, arg4: ($ResourceKey$$Type<($LootTable$$Type)>)?)

public "lootTable"(): $ResourceKey<($LootTable)>
public "overrideLootTableToDisplay"(): $Optional<($ResourceKey<($LootTable)>)>
public "playerDetector"(): $PlayerDetector
public "entitySelector"(): $PlayerDetector$EntitySelector
public "keyItem"(): $ItemStack
public "activationRange"(): double
public "deactivationRange"(): double
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultConfig$$Type = ({"keyItem"?: $ItemStack$$Type, "activationRange"?: double, "overrideLootTableToDisplay"?: ($ResourceKey$$Type<($LootTable$$Type)>)?, "deactivationRange"?: double, "entitySelector"?: $PlayerDetector$EntitySelector$$Type, "lootTable"?: $ResourceKey$$Type<($LootTable)>, "playerDetector"?: $PlayerDetector$$Type}) | ([keyItem?: $ItemStack$$Type, activationRange?: double, overrideLootTableToDisplay?: ($ResourceKey$$Type<($LootTable$$Type)>)?, deactivationRange?: double, entitySelector?: $PlayerDetector$EntitySelector$$Type, lootTable?: $ResourceKey$$Type<($LootTable)>, playerDetector?: $PlayerDetector$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultConfig$$Original = $VaultConfig;}
declare module "net.minecraft.world.level.dimension.end.EndDragonFight$Data" {
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"

export class $EndDragonFight$Data extends $Record {
static readonly "CODEC": $Codec<($EndDragonFight$Data)>
static readonly "DEFAULT": $EndDragonFight$Data

constructor(needsStateScanning: boolean, dragonKilled: boolean, previouslyKilled: boolean, isRespawning: boolean, dragonUUID: ($UUID$$Type)?, exitPortalLocation: ($BlockPos$$Type)?, gateways: ($List$$Type<(integer)>)?)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "gateways"(): $Optional<($List<(integer)>)>
public "needsStateScanning"(): boolean
public "dragonKilled"(): boolean
public "previouslyKilled"(): boolean
public "isRespawning"(): boolean
public "dragonUUID"(): $Optional<($UUID)>
public "exitPortalLocation"(): $Optional<($BlockPos)>
get "respawning"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndDragonFight$Data$$Type = ({"dragonUUID"?: ($UUID$$Type)?, "gateways"?: ($List$$Type<(integer)>)?, "exitPortalLocation"?: ($BlockPos$$Type)?, "previouslyKilled"?: boolean, "isRespawning"?: boolean, "needsStateScanning"?: boolean, "dragonKilled"?: boolean}) | ([dragonUUID?: ($UUID$$Type)?, gateways?: ($List$$Type<(integer)>)?, exitPortalLocation?: ($BlockPos$$Type)?, previouslyKilled?: boolean, isRespawning?: boolean, needsStateScanning?: boolean, dragonKilled?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndDragonFight$Data$$Original = $EndDragonFight$Data;}
declare module "net.minecraft.world.level.timers.TimerCallback" {
import {$TimerQueue, $TimerQueue$$Type} from "net.minecraft.world.level.timers.TimerQueue"

export interface $TimerCallback$$Interface<T> {

(arg0: T, arg1: $TimerQueue<(T)>, arg2: long): void
}

export class $TimerCallback<T> implements $TimerCallback$$Interface {
 "handle"(arg0: T, arg1: $TimerQueue$$Type<(T)>, arg2: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimerCallback$$Type<T> = ((arg0: T, arg1: $TimerQueue<(T)>, arg2: long) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TimerCallback$$Original<T> = $TimerCallback<(T)>;}
declare module "net.minecraft.world.level.levelgen.heightproviders.BiasedToBottomHeight" {
import {$HeightProviderType} from "net.minecraft.world.level.levelgen.heightproviders.HeightProviderType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $BiasedToBottomHeight extends $HeightProvider {
static readonly "CODEC": $MapCodec<($BiasedToBottomHeight)>

public "toString"(): StringJS
public static "of"(arg0: $VerticalAnchor$$Type, arg1: $VerticalAnchor$$Type, arg2: integer): $BiasedToBottomHeight
public "getType"(): $HeightProviderType<(never)>
public "sample"(arg0: $RandomSource$$Type, arg1: $WorldGenerationContext$$Type): integer
get "type"(): $HeightProviderType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiasedToBottomHeight$$Type = ($BiasedToBottomHeight);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiasedToBottomHeight$$Original = $BiasedToBottomHeight;}
declare module "net.minecraft.world.level.block.RootsBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $RootsBlock extends $BushBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RootsBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($RootsBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RootsBlock$$Type = ($RootsBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RootsBlock$$Original = $RootsBlock;}
declare module "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSizeType" {
import {$ThreeLayersFeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.ThreeLayersFeatureSize"
import {$TwoLayersFeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.TwoLayersFeatureSize"
import {$FeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $FeatureSizeType<P extends $FeatureSize> {
static readonly "THREE_LAYERS_FEATURE_SIZE": $FeatureSizeType<($ThreeLayersFeatureSize)>
static readonly "TWO_LAYERS_FEATURE_SIZE": $FeatureSizeType<($TwoLayersFeatureSize)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenFeatureSizeType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenFeatureSizeTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeatureSizeType$$Type<P> = (Special.WorldgenFeatureSizeType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeatureSizeType$$Original<P> = $FeatureSizeType<(P)>;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$Palette" {
import {$List, $List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$PaletteAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.PaletteAccess"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"

export class $StructureTemplate$Palette implements $PaletteAccess$$Interface {
public static "construct$immersiveengineering_$md$a93e73$0"(arg0: $List$$Type): $StructureTemplate$Palette
public "blocks"(arg0: $Block$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "blocks"(): $List<($StructureTemplate$StructureBlockInfo)>
public static "construct"(arg0: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>): $StructureTemplate$Palette
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplate$Palette$$Type = ($StructureTemplate$Palette);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplate$Palette$$Original = $StructureTemplate$Palette;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$Properties" {
import {$MapColor$$Type} from "net.minecraft.world.level.material.MapColor"
import {$FeatureFlag$$Type} from "net.minecraft.world.flag.FeatureFlag"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NoteBlockInstrument$$Type} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$BlockPropertiesAccessor$$Interface} from "com.supermartijn642.core.mixin.BlockPropertiesAccessor"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$BlockBehaviour$OffsetType$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$OffsetType"
import {$BlockBehaviour$StateArgumentPredicate$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$StateArgumentPredicate"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$PushReaction$$Type} from "net.minecraft.world.level.material.PushReaction"
import {$BlockBehaviour$StatePredicate$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$StatePredicate"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockBehaviour$Properties implements $BlockPropertiesAccessor$$Interface {
 "canOcclude": boolean
 "lightEmission": $ToIntFunction<($BlockState)>
 "drops": $ResourceKey<($LootTable)>
 "soundType": $SoundType
static readonly "CODEC": $Codec<($BlockBehaviour$Properties)>
 "isRandomlyTicking": boolean
 "spawnTerrainParticles": boolean
 "isAir": boolean
 "hasCollision": boolean

constructor()

public "lightLevel"(arg0: $ToIntFunction$$Type<($BlockState)>): $BlockBehaviour$Properties
public static "ofFullCopy"(arg0: $BlockBehaviour$$Type): $BlockBehaviour$Properties
public "noLootTable"(): $BlockBehaviour$Properties
public "explosionResistance"(arg0: float): $BlockBehaviour$Properties
public "friction"(arg0: float): $BlockBehaviour$Properties
public "speedFactor"(arg0: float): $BlockBehaviour$Properties
public "jumpFactor"(arg0: float): $BlockBehaviour$Properties
public "dynamicShape"(): $BlockBehaviour$Properties
public "ignitedByLava"(): $BlockBehaviour$Properties
public "mapColor"(arg0: $MapColor$$Type): $BlockBehaviour$Properties
public "mapColor"(arg0: $Function$$Type<($BlockState), ($MapColor$$Type)>): $BlockBehaviour$Properties
public "mapColor"(arg0: $DyeColor$$Type): $BlockBehaviour$Properties
public "destroyTime"(arg0: float): $BlockBehaviour$Properties
public "pushReaction"(arg0: $PushReaction$$Type): $BlockBehaviour$Properties
public "isViewBlocking"(arg0: $BlockBehaviour$StatePredicate$$Type): $BlockBehaviour$Properties
public "hasPostProcess"(arg0: $BlockBehaviour$StatePredicate$$Type): $BlockBehaviour$Properties
public "emissiveRendering"(arg0: $BlockBehaviour$StatePredicate$$Type): $BlockBehaviour$Properties
public "replaceable"(): $BlockBehaviour$Properties
public "forceSolidOn"(): $BlockBehaviour$Properties
/**
 * 
 * @deprecated
 */
public "forceSolidOff"(): $BlockBehaviour$Properties
public "isValidSpawn"(arg0: $BlockBehaviour$StateArgumentPredicate$$Type<($EntityType$$Type<(never)>)>): $BlockBehaviour$Properties
/**
 * 
 * @deprecated
 */
public static "ofLegacyCopy"(arg0: $BlockBehaviour$$Type): $BlockBehaviour$Properties
public "noCollission"(): $BlockBehaviour$Properties
public "noOcclusion"(): $BlockBehaviour$Properties
public "instabreak"(): $BlockBehaviour$Properties
public "randomTicks"(): $BlockBehaviour$Properties
/**
 * 
 * @deprecated
 */
public "dropsLike"(arg0: $Block$$Type): $BlockBehaviour$Properties
public "lootFrom"(arg0: $Supplier$$Type<($Block$$Type)>): $BlockBehaviour$Properties
public "offsetType"(arg0: $BlockBehaviour$OffsetType$$Type): $BlockBehaviour$Properties
public "noTerrainParticles"(): $BlockBehaviour$Properties
public "getLootTableSupplier"(): $Supplier
public "setLootTableSupplier"(arg0: $Supplier$$Type): void
public static "of"(): $BlockBehaviour$Properties
public "requiredFeatures"(...arg0: ($FeatureFlag$$Type)[]): $BlockBehaviour$Properties
public "sound"(arg0: $SoundType$$Type): $BlockBehaviour$Properties
public "air"(): $BlockBehaviour$Properties
public "instrument"(arg0: $NoteBlockInstrument$$Type): $BlockBehaviour$Properties
public "strength"(arg0: float, arg1: float): $BlockBehaviour$Properties
public "strength"(arg0: float): $BlockBehaviour$Properties
public "requiresCorrectToolForDrops"(): $BlockBehaviour$Properties
public "isSuffocating"(arg0: $BlockBehaviour$StatePredicate$$Type): $BlockBehaviour$Properties
public "liquid"(): $BlockBehaviour$Properties
public "isRedstoneConductor"(arg0: $BlockBehaviour$StatePredicate$$Type): $BlockBehaviour$Properties
get "lootTableSupplier"(): $Supplier
set "lootTableSupplier"(value: $Supplier$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$Properties$$Type = ($BlockBehaviour$Properties);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$Properties$$Original = $BlockBehaviour$Properties;}
declare module "net.minecraft.world.level.levelgen.DensityFunction$NoiseHolder" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$NormalNoise, $NormalNoise$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise"
import {$NormalNoise$NoiseParameters, $NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $DensityFunction$NoiseHolder extends $Record {
static readonly "CODEC": $Codec<($DensityFunction$NoiseHolder)>

constructor(arg0: $Holder$$Type<($NormalNoise$NoiseParameters)>)
constructor(arg0: $Holder$$Type<($NormalNoise$NoiseParameters)>, arg1: $NormalNoise$$Type)

public "noiseData"(): $Holder<($NormalNoise$NoiseParameters)>
public "maxValue"(): double
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getValue"(arg0: double, arg1: double, arg2: double): double
public "noise"(): $NormalNoise
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$NoiseHolder$$Type = ({"noiseData"?: $Holder$$Type<($NormalNoise$NoiseParameters)>, "noise"?: $NormalNoise$$Type}) | ([noiseData?: $Holder$$Type<($NormalNoise$NoiseParameters)>, noise?: $NormalNoise$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$NoiseHolder$$Original = $DensityFunction$NoiseHolder;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.ForkingTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $ForkingTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($ForkingTrunkPlacer)>
static readonly "MAX_HEIGHT": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForkingTrunkPlacer$$Type = ($ForkingTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ForkingTrunkPlacer$$Original = $ForkingTrunkPlacer;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$Constant" {
import {$DensityFunction$SimpleFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction$SimpleFunction"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$Record} from "java.lang.Record"
import {$DensityFunction} from "net.minecraft.world.level.levelgen.DensityFunction"

export class $DensityFunctions$Constant extends $Record implements $DensityFunction$SimpleFunction$$Interface {
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
public "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
public "cube"(): $DensityFunction
public "halfNegative"(): $DensityFunction
public "quarterNegative"(): $DensityFunction
public "squeeze"(): $DensityFunction
public "maxValue"(): double
public "abs"(): $DensityFunction
public "clamp"(arg0: double, arg1: double): $DensityFunction
public "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
public "square"(): $DensityFunction
public "minValue"(): double
public "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$Constant$$Type = ({"value"?: double}) | ([value?: double]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$Constant$$Original = $DensityFunctions$Constant;}
declare module "net.minecraft.world.level.block.state.properties.RedstoneSide" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $RedstoneSide extends $Enum<($RedstoneSide)> implements $StringRepresentable$$Interface {
static readonly "SIDE": $RedstoneSide
static readonly "UP": $RedstoneSide
static readonly "NONE": $RedstoneSide

public "isConnected"(): boolean
public "toString"(): StringJS
public static "values"(): ($RedstoneSide)[]
public static "valueOf"(arg0: StringJS): $RedstoneSide
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "connected"(): boolean
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneSide$$Type = (("up") | ("side") | ("none"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneSide$$Original = $RedstoneSide;}
declare module "net.minecraft.world.level.block.Portal$Transition" {
import {$Enum} from "java.lang.Enum"

export class $Portal$Transition extends $Enum<($Portal$Transition)> {
static readonly "CONFUSION": $Portal$Transition
static readonly "NONE": $Portal$Transition

public static "values"(): ($Portal$Transition)[]
public static "valueOf"(arg0: StringJS): $Portal$Transition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Portal$Transition$$Type = (("confusion") | ("none"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Portal$Transition$$Original = $Portal$Transition;}
declare module "net.minecraft.world.level.block.DoubleBlockCombiner$Combiner" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $DoubleBlockCombiner$Combiner$$Interface<S, T> {
}

export class $DoubleBlockCombiner$Combiner<S, T> implements $DoubleBlockCombiner$Combiner$$Interface {
 "acceptNone"(): T
 "acceptDouble"(arg0: S, arg1: S): T
 "acceptSingle"(arg0: S): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBlockCombiner$Combiner$$Type<S, T> = ($DoubleBlockCombiner$Combiner<(S), (T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoubleBlockCombiner$Combiner$$Original<S, T> = $DoubleBlockCombiner$Combiner<(S), (T)>;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.PosAlwaysTrueTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PosRuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.PosRuleTest"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $PosAlwaysTrueTest extends $PosRuleTest {
static readonly "CODEC": $MapCodec<($PosAlwaysTrueTest)>
static readonly "INSTANCE": $PosAlwaysTrueTest

public "test"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PosAlwaysTrueTest$$Type = ($PosAlwaysTrueTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PosAlwaysTrueTest$$Original = $PosAlwaysTrueTest;}
declare module "net.minecraft.world.level.pathfinder.Path" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$Set$$Type} from "java.util.Set"
import {$Path$DebugData} from "net.minecraft.world.level.pathfinder.Path$DebugData"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Node, $Node$$Type} from "net.minecraft.world.level.pathfinder.Node"
import {$Target$$Type} from "net.minecraft.world.level.pathfinder.Target"

export class $Path {
readonly "nodes": $List<($Node)>

constructor(arg0: $List$$Type<($Node$$Type)>, arg1: $BlockPos$$Type, arg2: boolean)

public "canReach"(): boolean
public "sameAs"(arg0: $Path$$Type): boolean
public "getNodeCount"(): integer
public "getNextEntityPos"(arg0: $Entity$$Type): $Vec3
public "truncateNodes"(arg0: integer): void
public "getNextNodePos"(): $BlockPos
public "getNextNode"(): $Node
public "getNextNodeIndex"(): integer
public "getNodePos"(arg0: integer): $BlockPos
public "getEndNode"(): $Node
public "writeToStream"(arg0: $FriendlyByteBuf$$Type): void
public static "createFromStream"(arg0: $FriendlyByteBuf$$Type): $Path
public "debugData"(): $Path$DebugData
public "getDistToTarget"(): float
public "notStarted"(): boolean
public "setNextNodeIndex"(arg0: integer): void
public "getEntityPosAtNode"(arg0: $Entity$$Type, arg1: integer): $Vec3
public "getPreviousNode"(): $Node
public "toString"(): StringJS
public "isDone"(): boolean
public "copy"(): $Path
public "getTarget"(): $BlockPos
public "advance"(): void
public "replaceNode"(arg0: integer, arg1: $Node$$Type): void
public "getNode"(arg0: integer): $Node
public "setDebug"(arg0: ($Node$$Type)[], arg1: ($Node$$Type)[], arg2: $Set$$Type<($Target$$Type)>): void
get "nodeCount"(): integer
get "nextNodePos"(): $BlockPos
get "nextNode"(): $Node
get "nextNodeIndex"(): integer
get "endNode"(): $Node
get "distToTarget"(): float
set "nextNodeIndex"(value: integer)
get "previousNode"(): $Node
get "done"(): boolean
get "target"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Path$$Type = ($Path);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Path$$Original = $Path;}
declare module "net.minecraft.world.level.block.LadderBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $LadderBlock extends $Block implements $SimpleWaterloggedBlock$$Interface, $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LadderBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "codec"(): $MapCodec<($LadderBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LadderBlock$$Type = ($LadderBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LadderBlock$$Original = $LadderBlock;}
declare module "net.minecraft.world.level.block.state.properties.PistonType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $PistonType extends $Enum<($PistonType)> implements $StringRepresentable$$Interface {
static readonly "STICKY": $PistonType
static readonly "DEFAULT": $PistonType

public "toString"(): StringJS
public static "values"(): ($PistonType)[]
public static "valueOf"(arg0: StringJS): $PistonType
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonType$$Type = (("normal") | ("sticky"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PistonType$$Original = $PistonType;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $LiquidSettings extends $Enum<($LiquidSettings)> implements $StringRepresentable$$Interface {
static "CODEC": $Codec<($LiquidSettings)>
static readonly "IGNORE_WATERLOGGING": $LiquidSettings
static readonly "APPLY_WATERLOGGING": $LiquidSettings

public static "values"(): ($LiquidSettings)[]
public static "valueOf"(arg0: StringJS): $LiquidSettings
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LiquidSettings$$Type = (("ignore_waterlogging") | ("apply_waterlogging"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LiquidSettings$$Original = $LiquidSettings;}
declare module "net.minecraft.world.level.block.IronBarsBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Map} from "java.util.Map"
import {$Direction} from "net.minecraft.core.Direction"
import {$CrossCollisionBlock} from "net.minecraft.world.level.block.CrossCollisionBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $IronBarsBlock extends $CrossCollisionBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($IronBarsBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($BooleanProperty)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "SOUTH": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "EAST": $BooleanProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "attachsTo"(arg0: $BlockState$$Type, arg1: boolean): boolean
public "codec"(): $MapCodec<($IronBarsBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IronBarsBlock$$Type = ($IronBarsBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IronBarsBlock$$Original = $IronBarsBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List$$Type} from "java.util.List"
import {$RuinedPortalStructure$Setup$$Type} from "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalStructure$Setup"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $RuinedPortalStructure extends $Structure {
static readonly "CODEC": $MapCodec<($RuinedPortalStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type, arg1: $RuinedPortalStructure$Setup$$Type)
constructor(arg0: $Structure$StructureSettings$$Type, arg1: $List$$Type<($RuinedPortalStructure$Setup$$Type)>)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuinedPortalStructure$$Type = ($RuinedPortalStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuinedPortalStructure$$Original = $RuinedPortalStructure;}
declare module "net.minecraft.world.level.block.WallHangingSignBlock" {
import {$SignBlock} from "net.minecraft.world.level.block.SignBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$WoodType$$Type} from "net.minecraft.world.level.block.state.properties.WoodType"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WallHangingSignBlock extends $SignBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WallHangingSignBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "SHAPE_NORTHSOUTH": $VoxelShape
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "PLANK_EASTWEST": $VoxelShape
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "PLANK_NORTHSOUTH": $VoxelShape
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "SHAPE_EASTWEST": $VoxelShape

constructor(arg0: $WoodType$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getYRotationDegrees"(arg0: $BlockState$$Type): float
public "canAttachTo"(arg0: $LevelReader$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "canPlace"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getDescriptionId"(): StringJS
public "codec"(): $MapCodec<($WallHangingSignBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallHangingSignBlock$$Type = ($WallHangingSignBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallHangingSignBlock$$Original = $WallHangingSignBlock;}
declare module "net.minecraft.world.level.block.entity.SignBlockEntity" {
import {$UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$FilteredText$$Type} from "net.minecraft.server.network.FilteredText"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SignText, $SignText$$Type} from "net.minecraft.world.level.block.entity.SignText"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$CommandSourceStack} from "net.minecraft.commands.CommandSourceStack"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SignBlockEntity extends $BlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)
constructor(arg0: $BlockEntityType$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "isWaxed"(): boolean
public "isFacingFrontText"(arg0: $Player$$Type): boolean
public "getSignInteractionFailedSoundEvent"(): $SoundEvent
public "executeClickCommandsIfPresent"(arg0: $Player$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: boolean): boolean
public "canExecuteClickCommands"(arg0: boolean, arg1: $Player$$Type): boolean
public "setAllowedPlayerEditor"(arg0: $UUID$$Type): void
public "getPlayerWhoMayEdit"(): $UUID
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getFrontText"(): $SignText
public "getBackText"(): $SignText
public "getTextLineHeight"(): integer
public "getMaxTextLineWidth"(): integer
public "updateSignText"(arg0: $Player$$Type, arg1: boolean, arg2: $List$$Type<($FilteredText$$Type)>): void
public "setWaxed"(arg0: boolean): boolean
public "playerIsTooFarAwayToEdit"(arg0: $UUID$$Type): boolean
public static "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SignBlockEntity$$Type): void
public "setText"(arg0: $SignText$$Type, arg1: boolean): boolean
public "getText"(arg0: boolean): $SignText
public static "createCommandSourceStack"(arg0: $Player$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): $CommandSourceStack
public "onlyOpCanSetNbt"(): boolean
public "updateText"(arg0: $UnaryOperator$$Type<($SignText)>, arg1: boolean): boolean
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "waxed"(): boolean
get "signInteractionFailedSoundEvent"(): $SoundEvent
set "allowedPlayerEditor"(value: $UUID$$Type)
get "playerWhoMayEdit"(): $UUID
get "frontText"(): $SignText
get "backText"(): $SignText
get "textLineHeight"(): integer
get "maxTextLineWidth"(): integer
set "waxed"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignBlockEntity$$Type = ($SignBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignBlockEntity$$Original = $SignBlockEntity;}
declare module "net.minecraft.world.level.chunk.LevelChunk$EntityCreationType" {
import {$Enum} from "java.lang.Enum"

export class $LevelChunk$EntityCreationType extends $Enum<($LevelChunk$EntityCreationType)> {
static readonly "QUEUED": $LevelChunk$EntityCreationType
static readonly "CHECK": $LevelChunk$EntityCreationType
static readonly "IMMEDIATE": $LevelChunk$EntityCreationType

public static "values"(): ($LevelChunk$EntityCreationType)[]
public static "valueOf"(arg0: StringJS): $LevelChunk$EntityCreationType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelChunk$EntityCreationType$$Type = (("immediate") | ("queued") | ("check"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelChunk$EntityCreationType$$Original = $LevelChunk$EntityCreationType;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.BlockRotProcessor" {
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $BlockRotProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($BlockRotProcessor)>

constructor(arg0: $HolderSet$$Type<($Block)>, arg1: float)
constructor(arg0: float)

public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRotProcessor$$Type = ($BlockRotProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockRotProcessor$$Original = $BlockRotProcessor;}
declare module "net.minecraft.world.level.block.ChainBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$RotatedPillarBlock} from "net.minecraft.world.level.block.RotatedPillarBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ChainBlock extends $RotatedPillarBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ChainBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AXIS": $EnumProperty<($Direction$Axis)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($ChainBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChainBlock$$Type = ($ChainBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChainBlock$$Original = $ChainBlock;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $OreConfiguration$TargetBlockState {
static readonly "CODEC": $Codec<($OreConfiguration$TargetBlockState)>
readonly "state": $BlockState
readonly "target": $RuleTest

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreConfiguration$TargetBlockState$$Type = ($OreConfiguration$TargetBlockState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OreConfiguration$TargetBlockState$$Original = $OreConfiguration$TargetBlockState;}
declare module "net.minecraft.world.level.chunk.ImposterProtoChunk" {
import {$ProtoChunk} from "net.minecraft.world.level.chunk.ProtoChunk"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$Trackable} from "dev.uncandango.alltheleaks.mixin.Trackable"
import {$ChunkAccess$TicksToSave} from "net.minecraft.world.level.chunk.ChunkAccess$TicksToSave"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$Holder} from "net.minecraft.core.Holder"
import {$TickContainerAccess} from "net.minecraft.world.ticks.TickContainerAccess"
import {$Climate$Sampler$$Type} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$BlendingData, $BlendingData$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$CarvingMask} from "net.minecraft.world.level.chunk.CarvingMask"
import {$Function$$Type} from "java.util.function.Function"
import {$Class} from "java.lang.Class"
import {$Heightmap} from "net.minecraft.world.level.levelgen.Heightmap"
import {$AttachmentHolder$AsField} from "net.neoforged.neoforge.attachment.AttachmentHolder$AsField"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ObjectOpenCustomHashSet} from "it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet"
import {$ChunkSkyLightSources} from "net.minecraft.world.level.lighting.ChunkSkyLightSources"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$ExtendedChunk$$Interface} from "ca.spottedleaf.starlight.common.chunk.ExtendedChunk"
import {$LevelChunkSection} from "net.minecraft.world.level.chunk.LevelChunkSection"
import {$ChunkPos} from "net.minecraft.world.level.ChunkPos"
import {$ChunkStatus, $ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$SWMRNibbleArray, $SWMRNibbleArray$$Type} from "ca.spottedleaf.starlight.common.light.SWMRNibbleArray"
import {$BiomeResolver$$Type} from "net.minecraft.world.level.biome.BiomeResolver"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$StructureStart, $StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$LevelChunk, $LevelChunk$$Type} from "net.minecraft.world.level.chunk.LevelChunk"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $ImposterProtoChunk extends $ProtoChunk implements $ExtendedChunk$$Interface {
readonly "blockEntities": $Map<($BlockPos), ($BlockEntity)>
static readonly "NO_FILLED_SECTION": integer

constructor(arg0: $LevelChunk$$Type, arg1: boolean)

public "setPersistedStatus"(arg0: $ChunkStatus$$Type): void
public "getAllStarts"(): $Map<($Structure), ($StructureStart)>
public "markPosForPostprocessing"(arg0: $BlockPos$$Type): void
public "setHeightmap"(arg0: $Heightmap$Types$$Type, arg1: (long)[]): void
public "getStartForStructure"(arg0: $Structure$$Type): $StructureStart
public "setStartForStructure"(arg0: $Structure$$Type, arg1: $StructureStart$$Type): void
public "setAllStarts"(arg0: $Map$$Type<($Structure$$Type), ($StructureStart$$Type)>): void
public "getReferencesForStructure"(arg0: $Structure$$Type): $LongSet
public "addReferenceForStructure"(arg0: $Structure$$Type, arg1: long): void
public "setAllReferences"(arg0: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>): void
public "isUnsaved"(): boolean
public "getPersistedStatus"(): $ChunkStatus
public "setBlockEntityNbt"(arg0: $CompoundTag$$Type): void
public "getBlockEntityNbt"(arg0: $BlockPos$$Type): $CompoundTag
public "getBlockEntityNbtForSaving"(arg0: $BlockPos$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "findBlocks"(arg0: $Predicate$$Type<($BlockState)>, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "findBlocks"(arg0: $Predicate$$Type<($BlockState)>, arg1: $BiPredicate$$Type<($BlockState), ($BlockPos)>, arg2: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "findBlocks"(arg0: $BiPredicate$$Type<($BlockState), ($BlockPos)>, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "getOrCreateHeightmapUnprimed"(arg0: $Heightmap$Types$$Type): $Heightmap
public "isLightCorrect"(): boolean
public "getTicksForSerialization"(): $ChunkAccess$TicksToSave
public "getBlendingData"(): $BlendingData
public "setBlendingData"(arg0: $BlendingData$$Type): void
public "setLightCorrect"(arg0: boolean): void
public "fillBiomesFromNoise"(arg0: $BiomeResolver$$Type, arg1: $Climate$Sampler$$Type): void
public "getAllReferences"(): $Map<($Structure), ($LongSet)>
public "initializeLightSources"(): void
public "getSkyLightSources"(): $ChunkSkyLightSources
public "getAttachmentHolder"(): $AttachmentHolder$AsField
public "getBlockNibbles"(): ($SWMRNibbleArray)[]
public "setBlockNibbles"(nibbles: ($SWMRNibbleArray$$Type)[]): void
public "getSkyNibbles"(): ($SWMRNibbleArray)[]
public "setSkyNibbles"(nibbles: ($SWMRNibbleArray$$Type)[]): void
public "getSkyEmptinessMap"(): (boolean)[]
public "setSkyEmptinessMap"(emptinessMap: (boolean)[]): void
public "getBlockEmptinessMap"(): (boolean)[]
public "setBlockEmptinessMap"(emptinessMap: (boolean)[]): void
public "getCarvingMask"(arg0: $GenerationStep$Carving$$Type): $CarvingMask
public "getOrCreateCarvingMask"(arg0: $GenerationStep$Carving$$Type): $CarvingMask
public "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
public "getSections"(): ($LevelChunkSection)[]
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "getSection"(arg0: integer): $LevelChunkSection
public "getPos"(): $ChunkPos
public "setBlockEntity"(arg0: $BlockEntity$$Type): void
public "removeBlockEntity"(arg0: $BlockPos$$Type): void
public "setUnsaved"(arg0: boolean): void
public "setBlockState"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: boolean): $BlockState
public "getBlockTicks"(): $TickContainerAccess<($Block)>
public "getFluidTicks"(): $TickContainerAccess<($Fluid)>
public "getMaxLightLevel"(): integer
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "getWrapped"(): $LevelChunk
public "addEntity"(arg0: $Entity$$Type): void
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public static "startTracking"(arg0: any): void
public static "createWeakRefBasedSet"(): $ObjectOpenCustomHashSet<($WeakReference<($Trackable)>)>
public static "clearNullReferences"(): void
public static "getSummary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
set "persistedStatus"(value: $ChunkStatus$$Type)
get "allStarts"(): $Map<($Structure), ($StructureStart)>
set "allStarts"(value: $Map$$Type<($Structure$$Type), ($StructureStart$$Type)>)
set "allReferences"(value: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>)
get "unsaved"(): boolean
get "persistedStatus"(): $ChunkStatus
set "blockEntityNbt"(value: $CompoundTag$$Type)
get "lightCorrect"(): boolean
get "ticksForSerialization"(): $ChunkAccess$TicksToSave
get "blendingData"(): $BlendingData
set "blendingData"(value: $BlendingData$$Type)
set "lightCorrect"(value: boolean)
get "allReferences"(): $Map<($Structure), ($LongSet)>
get "skyLightSources"(): $ChunkSkyLightSources
get "attachmentHolder"(): $AttachmentHolder$AsField
get "blockNibbles"(): ($SWMRNibbleArray)[]
set "blockNibbles"(value: ($SWMRNibbleArray$$Type)[])
get "skyNibbles"(): ($SWMRNibbleArray)[]
set "skyNibbles"(value: ($SWMRNibbleArray$$Type)[])
get "skyEmptinessMap"(): (boolean)[]
set "skyEmptinessMap"(value: (boolean)[])
get "blockEmptinessMap"(): (boolean)[]
set "blockEmptinessMap"(value: (boolean)[])
get "sections"(): ($LevelChunkSection)[]
get "pos"(): $ChunkPos
set "blockEntity"(value: $BlockEntity$$Type)
set "unsaved"(value: boolean)
get "blockTicks"(): $TickContainerAccess<($Block)>
get "fluidTicks"(): $TickContainerAccess<($Fluid)>
get "maxLightLevel"(): integer
get "wrapped"(): $LevelChunk
public static get "summary"(): $Map<($Class<(never)>), ($Map<($Class<(never)>), (long)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImposterProtoChunk$$Type = ($ImposterProtoChunk);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ImposterProtoChunk$$Original = $ImposterProtoChunk;}
declare module "net.minecraft.world.level.block.WitherRoseBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$SuspiciousEffectHolder} from "net.minecraft.world.level.block.SuspiciousEffectHolder"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$SuspiciousStewEffects$$Type} from "net.minecraft.world.item.component.SuspiciousStewEffects"
import {$FlowerBlock} from "net.minecraft.world.level.block.FlowerBlock"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WitherRoseBlock extends $FlowerBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WitherRoseBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $SuspiciousStewEffects$$Type, arg1: $BlockBehaviour$Properties$$Type)
constructor(arg0: $Holder$$Type<($MobEffect)>, arg1: float, arg2: $BlockBehaviour$Properties$$Type)

public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($WitherRoseBlock)>
public static "getAllEffectHolders"(): $List<($SuspiciousEffectHolder)>
public static "tryGet"(arg0: $ItemLike$$Type): $SuspiciousEffectHolder
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static get "allEffectHolders"(): $List<($SuspiciousEffectHolder)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WitherRoseBlock$$Type = ($WitherRoseBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WitherRoseBlock$$Original = $WitherRoseBlock;}
declare module "net.minecraft.world.level.chunk.ChunkGeneratorStructureState" {
import {$HolderLookup$$Type} from "net.minecraft.core.HolderLookup"
import {$StructureSet, $StructureSet$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSet"
import {$List} from "java.util.List"
import {$RandomState, $RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$StructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$ChunkPos} from "net.minecraft.world.level.ChunkPos"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$ConcentricRingsStructurePlacement$$Type} from "net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStructurePlacement"
import {$Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$IChunkGenerator$$Interface} from "org.embeddedt.modernfix.duck.IChunkGenerator"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Stream$$Type} from "java.util.stream.Stream"

export class $ChunkGeneratorStructureState implements $IChunkGenerator$$Interface {
public "randomState"(): $RandomState
public "mfix$setAssociatedServerLevel"(arg0: $ServerLevel$$Type): void
public "ensureStructuresGenerated"(): void
public "getLevelSeed"(): long
public "hasStructureChunkInRange"(arg0: $Holder$$Type<($StructureSet)>, arg1: integer, arg2: integer, arg3: integer): boolean
public "getRingPositionsFor"(arg0: $ConcentricRingsStructurePlacement$$Type): $List<($ChunkPos)>
public static "createForFlat"(arg0: $RandomState$$Type, arg1: long, arg2: $BiomeSource$$Type, arg3: $Stream$$Type<($Holder$$Type<($StructureSet$$Type)>)>): $ChunkGeneratorStructureState
public static "createForNormal"(arg0: $RandomState$$Type, arg1: long, arg2: $BiomeSource$$Type, arg3: $HolderLookup$$Type<($StructureSet$$Type)>): $ChunkGeneratorStructureState
public "getPlacementsForStructure"(arg0: $Holder$$Type<($Structure)>): $List<($StructurePlacement)>
public "possibleStructureSets"(): $List<($Holder<($StructureSet)>)>
get "levelSeed"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkGeneratorStructureState$$Type = ($ChunkGeneratorStructureState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkGeneratorStructureState$$Original = $ChunkGeneratorStructureState;}
declare module "net.minecraft.world.level.levelgen.feature.ConfiguredFeature" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Feature, $Feature$$Type} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$HolderSet} from "net.minecraft.core.HolderSet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration, $FeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $ConfiguredFeature<FC extends $FeatureConfiguration, F extends $Feature<(object)>> extends $Record {
static readonly "CODEC": $Codec<($Holder<($ConfiguredFeature<(never), (never)>)>)>
static readonly "DIRECT_CODEC": $Codec<($ConfiguredFeature<(never), (never)>)>
static readonly "LIST_CODEC": $Codec<($HolderSet<($ConfiguredFeature<(never), (never)>)>)>

constructor(arg0: F, arg1: FC)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
public "place"(arg0: $WorldGenLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): boolean
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "feature"(): F
public "config"(): FC
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenConfiguredFeature
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenConfiguredFeatureTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfiguredFeature$$Type<FC, F> = (Special.WorldgenConfiguredFeature) | ({"config"?: FC, "feature"?: F}) | ([config?: FC, feature?: F]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConfiguredFeature$$Original<FC, F> = $ConfiguredFeature<(FC), (F)>;}
declare module "net.minecraft.world.level.block.StructureVoidBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $StructureVoidBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($StructureVoidBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($StructureVoidBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureVoidBlock$$Type = ($StructureVoidBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureVoidBlock$$Original = $StructureVoidBlock;}
declare module "net.minecraft.world.level.levelgen.carver.CaveWorldCarver" {
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$CaveCarverConfiguration, $CaveCarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CaveCarverConfiguration"
import {$CanyonCarverConfiguration} from "net.minecraft.world.level.levelgen.carver.CanyonCarverConfiguration"
import {$Aquifer$$Type} from "net.minecraft.world.level.levelgen.Aquifer"
import {$CarvingContext$$Type} from "net.minecraft.world.level.levelgen.carver.CarvingContext"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$CarvingMask$$Type} from "net.minecraft.world.level.chunk.CarvingMask"
import {$WorldCarver} from "net.minecraft.world.level.levelgen.carver.WorldCarver"
import {$CarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CarverConfiguration"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"

export class $CaveWorldCarver extends $WorldCarver<($CaveCarverConfiguration)> {
static readonly "CAVE": $WorldCarver<($CaveCarverConfiguration)>
static readonly "CANYON": $WorldCarver<($CanyonCarverConfiguration)>
static readonly "NETHER_CAVE": $WorldCarver<($CaveCarverConfiguration)>

constructor(arg0: $Codec$$Type<($CaveCarverConfiguration$$Type)>)

public "carve"(arg0: $CarvingContext$$Type, arg1: $CarverConfiguration$$Type, arg2: $ChunkAccess$$Type, arg3: $Function$$Type, arg4: $RandomSource$$Type, arg5: $Aquifer$$Type, arg6: $ChunkPos$$Type, arg7: $CarvingMask$$Type): boolean
public "carve"(arg0: $CarvingContext$$Type, arg1: $CaveCarverConfiguration$$Type, arg2: $ChunkAccess$$Type, arg3: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg4: $RandomSource$$Type, arg5: $Aquifer$$Type, arg6: $ChunkPos$$Type, arg7: $CarvingMask$$Type): boolean
public "isStartChunk"(arg0: $CarverConfiguration$$Type, arg1: $RandomSource$$Type): boolean
public "isStartChunk"(arg0: $CaveCarverConfiguration$$Type, arg1: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaveWorldCarver$$Type = ($CaveWorldCarver);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CaveWorldCarver$$Original = $CaveWorldCarver;}
declare module "net.minecraft.world.level.block.entity.DecoratedPotBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$RandomizableContainer$$Type, $RandomizableContainer$$Interface} from "net.minecraft.world.RandomizableContainer"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$ContainerSingleItem$BlockContainerSingleItem$$Interface} from "net.minecraft.world.ticks.ContainerSingleItem$BlockContainerSingleItem"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Operation$$Type} from "com.llamalad7.mixinextras.injector.wrapoperation.Operation"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$PotDecorations, $PotDecorations$$Type} from "net.minecraft.world.level.block.entity.PotDecorations"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$DecoratedPotBlockEntity$WobbleStyle, $DecoratedPotBlockEntity$WobbleStyle$$Type} from "net.minecraft.world.level.block.entity.DecoratedPotBlockEntity$WobbleStyle"

export class $DecoratedPotBlockEntity extends $BlockEntity implements $RandomizableContainer$$Interface, $ContainerSingleItem$BlockContainerSingleItem$$Interface {
static readonly "TAG_SHERDS": StringJS
 "lastWobbleStyle": $DecoratedPotBlockEntity$WobbleStyle
static readonly "TAG_ITEM": StringJS
 "wobbleStartedAtTick": long
static readonly "ATTACHMENTS_NBT_KEY": StringJS
static readonly "EVENT_POT_WOBBLES": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "getTheItem"(): $ItemStack
public "setTheItem"(arg0: $ItemStack$$Type): void
public "getPotAsItem"(): $ItemStack
public "setLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "setLootTableSeed"(arg0: long): void
public "splitTheItem"(arg0: integer): $ItemStack
public "getContainerBlockEntity"(): $BlockEntity
public "setFromItem"(arg0: $ItemStack$$Type): void
public static "createDecoratedPotItem"(arg0: $PotDecorations$$Type): $ItemStack
public "getDecorations"(): $PotDecorations
public "getDirection"(): $Direction
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "wobble"(arg0: $DecoratedPotBlockEntity$WobbleStyle$$Type): void
public "getLootTable"(): $ResourceKey<($LootTable)>
public "getLootTableSeed"(): long
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "unpackLootTable"(arg0: $Player$$Type): void
public "tryLoadLootTable"(arg0: $CompoundTag$$Type): boolean
public "trySaveLootTable"(arg0: $CompoundTag$$Type): boolean
public "setLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
public "wrapOperation$fak000$lootr$setLootTable"(arg0: $RandomizableContainer$$Type, arg1: $ResourceKey$$Type, arg2: $Operation$$Type): void
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "wrapOperation$fak000$lootr$tryLoadLootTable"(arg0: $RandomizableContainer$$Type, arg1: long, arg2: $Operation$$Type): void
public "handler$fak000$lootr$unpackLootTable"(arg0: $Player$$Type, arg1: $CallbackInfo$$Type): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public "stillValid"(arg0: $Player$$Type): boolean
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "startOpen"(arg0: $Player$$Type): void
public "stopOpen"(arg0: $Player$$Type): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "countItem"(arg0: $Item$$Type): integer
public "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
public "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "getItem"(arg0: integer): $ItemStack
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "isEmpty"(): boolean
public "getMaxStackSize"(): integer
public "getMaxStackSize"(arg0: $ItemStack$$Type): integer
public "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
public "getContainerSize"(): integer
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "clearContent"(): void
public "removeTheItem"(): $ItemStack
public static "tryClear"(arg0: any): void
public "self"(): $Container
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "getSlotLimit"(slot: integer): integer
public "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
public "clear"(): void
public "getWidth"(): integer
public "getHeight"(): integer
public "getBlock"(level: $Level$$Type): $LevelBlock
public "setChanged"(): void
public "asContainer"(): $Container
public "setTransferCooldown"(arg0: long): void
public "canReceiveTransferCooldown"(): boolean
public "lithium$itemInsertionTestRequiresStackSize1"(): boolean
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "clear"(match: $ItemPredicate$$Type): void
public "find"(match: $ItemPredicate$$Type): integer
public "find"(): integer
public "count"(match: $ItemPredicate$$Type): integer
public "count"(): integer
public "countNonEmpty"(): integer
public "countNonEmpty"(match: $ItemPredicate$$Type): integer
public "getAllItems"(): $List<($ItemStack)>
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "theItem"(): $ItemStack
set "theItem"(value: $ItemStack$$Type)
get "potAsItem"(): $ItemStack
set "lootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "lootTableSeed"(value: long)
get "containerBlockEntity"(): $BlockEntity
set "fromItem"(value: $ItemStack$$Type)
get "decorations"(): $PotDecorations
get "direction"(): $Direction
get "lootTable"(): $ResourceKey<($LootTable)>
get "lootTableSeed"(): long
get "level"(): $Level
get "blockPos"(): $BlockPos
get "empty"(): boolean
get "maxStackSize"(): integer
get "containerSize"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "width"(): integer
get "height"(): integer
get "changed"(): void
set "transferCooldown"(value: long)
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DecoratedPotBlockEntity$$Type = ($DecoratedPotBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DecoratedPotBlockEntity$$Original = $DecoratedPotBlockEntity;}
declare module "net.minecraft.world.level.block.SkullBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SkullBlock$Type$$Type} from "net.minecraft.world.level.block.SkullBlock$Type"
import {$AbstractSkullBlock} from "net.minecraft.world.level.block.AbstractSkullBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SkullBlock extends $AbstractSkullBlock {
static readonly "ROTATION": $IntegerProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SkullBlock)>
static readonly "MAX": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $SkullBlock$Type$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "codec"(): $MapCodec<($SkullBlock)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SkullBlock$$Type = ($SkullBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SkullBlock$$Original = $SkullBlock;}
declare module "net.minecraft.world.level.gameevent.GameEvent" {
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $GameEvent extends $Record {
static readonly "EXPLODE": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_DESTROY": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_OPEN": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_MOUNT": $Holder$Reference<($GameEvent)>
static readonly "FLUID_PLACE": $Holder$Reference<($GameEvent)>
static readonly "DEFAULT_NOTIFICATION_RADIUS": integer
static readonly "BLOCK_ATTACH": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_DETACH": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_DAMAGE": $Holder$Reference<($GameEvent)>
static readonly "PROJECTILE_SHOOT": $Holder$Reference<($GameEvent)>
static readonly "DRINK": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_DIE": $Holder$Reference<($GameEvent)>
static readonly "HIT_GROUND": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_ACTIVATE": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_10": $Holder$Reference<($GameEvent)>
static readonly "CODEC": $Codec<($Holder<($GameEvent)>)>
static readonly "RESONATE_14": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_13": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_12": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_11": $Holder$Reference<($GameEvent)>
static readonly "CONTAINER_CLOSE": $Holder$Reference<($GameEvent)>
static readonly "LIGHTNING_STRIKE": $Holder$Reference<($GameEvent)>
static readonly "CONTAINER_OPEN": $Holder$Reference<($GameEvent)>
static readonly "PRIME_FUSE": $Holder$Reference<($GameEvent)>
static readonly "SWIM": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_CLOSE": $Holder$Reference<($GameEvent)>
static readonly "EAT": $Holder$Reference<($GameEvent)>
static readonly "TELEPORT": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_15": $Holder$Reference<($GameEvent)>
static readonly "INSTRUMENT_PLAY": $Holder$Reference<($GameEvent)>
static readonly "SCULK_SENSOR_TENDRILS_CLICKING": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_PLACE": $Holder$Reference<($GameEvent)>
static readonly "SPLASH": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_DEACTIVATE": $Holder$Reference<($GameEvent)>
static readonly "ITEM_INTERACT_FINISH": $Holder$Reference<($GameEvent)>
static readonly "SHRIEK": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_ACTION": $Holder$Reference<($GameEvent)>
static readonly "JUKEBOX_PLAY": $Holder$Reference<($GameEvent)>
static readonly "NOTE_BLOCK_PLAY": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_CHANGE": $Holder$Reference<($GameEvent)>
static readonly "FLAP": $Holder$Reference<($GameEvent)>
static readonly "PROJECTILE_LAND": $Holder$Reference<($GameEvent)>
static readonly "EQUIP": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_INTERACT": $Holder$Reference<($GameEvent)>
static readonly "UNEQUIP": $Holder$Reference<($GameEvent)>
static readonly "STEP": $Holder$Reference<($GameEvent)>
static readonly "JUKEBOX_STOP_PLAY": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_7": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_6": $Holder$Reference<($GameEvent)>
static readonly "ITEM_INTERACT_START": $Holder$Reference<($GameEvent)>
static readonly "SHEAR": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_5": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_4": $Holder$Reference<($GameEvent)>
static readonly "ELYTRA_GLIDE": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_9": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_DISMOUNT": $Holder$Reference<($GameEvent)>
static readonly "FLUID_PICKUP": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_8": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_3": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_2": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_PLACE": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_1": $Holder$Reference<($GameEvent)>

constructor(arg0: integer)

public "notificationRadius"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "bootstrap"(arg0: $Registry$$Type<($GameEvent$$Type)>): $Holder<($GameEvent)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.GameEvent
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.GameEventTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEvent$$Type = (Special.GameEvent) | ({"notificationRadius"?: integer}) | ([notificationRadius?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEvent$$Original = $GameEvent;}
declare module "net.minecraft.world.level.block.TintedGlassBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$TransparentBlock} from "net.minecraft.world.level.block.TransparentBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $TintedGlassBlock extends $TransparentBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TintedGlassBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($TintedGlassBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TintedGlassBlock$$Type = ($TintedGlassBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TintedGlassBlock$$Original = $TintedGlassBlock;}
declare module "net.minecraft.world.level.block.CandleBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnchantmentStatBlock$$Interface} from "dev.shadowsoffire.apothic_enchanting.api.EnchantmentStatBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$AbstractCandleBlock} from "net.minecraft.world.level.block.AbstractCandleBlock"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$ToIntFunction} from "java.util.function.ToIntFunction"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $CandleBlock extends $AbstractCandleBlock implements $SimpleWaterloggedBlock$$Interface, $EnchantmentStatBlock$$Interface {
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "LIGHT_PER_CANDLE": integer
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CandleBlock)>
static readonly "MIN_CANDLES": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "CANDLES": $IntegerProperty
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIGHT_EMISSION": $ToIntFunction<($BlockState)>
static readonly "MAX_CANDLES": integer
static readonly "LIT": $BooleanProperty
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "canLight"(arg0: $BlockState$$Type): boolean
public "getArcanaBonus"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): float
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "codec"(): $MapCodec<($CandleBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CandleBlock$$Type = ($CandleBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CandleBlock$$Original = $CandleBlock;}
declare module "net.minecraft.world.level.levelgen.feature.BambooFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $BambooFeature extends $Feature<($ProbabilityFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($ProbabilityFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($ProbabilityFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BambooFeature$$Type = ($BambooFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BambooFeature$$Original = $BambooFeature;}
declare module "net.minecraft.world.level.levelgen.placement.PlacementContext" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$WorldGenerationContext} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$CarvingMask} from "net.minecraft.world.level.chunk.CarvingMask"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PlacementContext extends $WorldGenerationContext {
constructor(arg0: $WorldGenLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: ($PlacedFeature$$Type)?)

public "topFeature"(): $Optional<($PlacedFeature)>
public "getCarvingMask"(arg0: $ChunkPos$$Type, arg1: $GenerationStep$Carving$$Type): $CarvingMask
public "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
public "getLevel"(): $WorldGenLevel
public "generator"(): $ChunkGenerator
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getMinBuildHeight"(): integer
get "level"(): $WorldGenLevel
get "minBuildHeight"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacementContext$$Type = ($PlacementContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacementContext$$Original = $PlacementContext;}
declare module "net.minecraft.world.level.storage.PrimaryLevelData$SpecialWorldProperty" {
import {$Enum} from "java.lang.Enum"

/**
 * 
 * @deprecated
 */
export class $PrimaryLevelData$SpecialWorldProperty extends $Enum<($PrimaryLevelData$SpecialWorldProperty)> {
static readonly "FLAT": $PrimaryLevelData$SpecialWorldProperty
static readonly "NONE": $PrimaryLevelData$SpecialWorldProperty
static readonly "DEBUG": $PrimaryLevelData$SpecialWorldProperty

public static "values"(): ($PrimaryLevelData$SpecialWorldProperty)[]
public static "valueOf"(arg0: StringJS): $PrimaryLevelData$SpecialWorldProperty
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PrimaryLevelData$SpecialWorldProperty$$Type = (("none") | ("flat") | ("debug"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PrimaryLevelData$SpecialWorldProperty$$Original = $PrimaryLevelData$SpecialWorldProperty;}
declare module "net.minecraft.world.level.levelgen.feature.SimpleBlockFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration, $SimpleBlockConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $SimpleBlockFeature extends $Feature<($SimpleBlockConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($SimpleBlockConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($SimpleBlockConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleBlockFeature$$Type = ($SimpleBlockFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleBlockFeature$$Original = $SimpleBlockFeature;}
declare module "net.minecraft.world.level.block.BaseCoralWallFanBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BaseCoralFanBlock} from "net.minecraft.world.level.block.BaseCoralFanBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $BaseCoralWallFanBlock extends $BaseCoralFanBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BaseCoralWallFanBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($BaseCoralWallFanBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseCoralWallFanBlock$$Type = ($BaseCoralWallFanBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseCoralWallFanBlock$$Original = $BaseCoralWallFanBlock;}
declare module "net.minecraft.world.level.block.SeaPickleBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SeaPickleBlock extends $BushBlock implements $BonemealableBlock$$Interface, $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "MAX_PICKLES": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SeaPickleBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "PICKLES": $IntegerProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "isDead"(arg0: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($SeaPickleBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeaPickleBlock$$Type = ($SeaPickleBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SeaPickleBlock$$Original = $SeaPickleBlock;}
declare module "net.minecraft.world.level.chunk.storage.ChunkScanAccess" {
import {$CompletableFuture, $CompletableFuture$$Type} from "java.util.concurrent.CompletableFuture"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$StreamTagVisitor, $StreamTagVisitor$$Type} from "net.minecraft.nbt.StreamTagVisitor"

export interface $ChunkScanAccess$$Interface {

(arg0: $ChunkPos, arg1: $StreamTagVisitor): $CompletableFuture$$Type<(void)>
}

export class $ChunkScanAccess implements $ChunkScanAccess$$Interface {
 "scanChunk"(arg0: $ChunkPos$$Type, arg1: $StreamTagVisitor$$Type): $CompletableFuture<(void)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkScanAccess$$Type = ((arg0: $ChunkPos, arg1: $StreamTagVisitor) => $CompletableFuture$$Type<(void)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkScanAccess$$Original = $ChunkScanAccess;}
declare module "net.minecraft.world.level.storage.loot.LootTable" {
import {$LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$UnificationLookup$$Type} from "com.almostreliable.unified.api.unification.UnificationLookup"
import {$List} from "java.util.List"
import {$LootPool, $LootPool$$Type} from "net.minecraft.world.level.storage.loot.LootPool"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootParams$$Type} from "net.minecraft.world.level.storage.loot.LootParams"
import {$LootContextParamSet} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet"
import {$Holder} from "net.minecraft.core.Holder"
import {$ObjectArrayList} from "it.unimi.dsi.fastutil.objects.ObjectArrayList"
import {$LootUnificationHandler, $LootUnificationHandler$$Interface} from "com.almostreliable.unified.unification.loot.LootUnificationHandler"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LootTable$Builder} from "net.minecraft.world.level.storage.loot.LootTable$Builder"
import {$Container$$Type} from "net.minecraft.world.Container"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$AccessorMixinLootTable$$Interface} from "noobanidus.mods.lootr.common.mixin.accessor.AccessorMixinLootTable"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"

export class $LootTable implements $LootUnificationHandler$$Interface, $AccessorMixinLootTable$$Interface {
static readonly "CODEC": $Codec<($Holder<($LootTable)>)>
static readonly "DEFAULT_PARAM_SET": $LootContextParamSet
readonly "pools": $List<($LootPool)>
static readonly "DIRECT_CODEC": $Codec<($LootTable)>
static readonly "RANDOMIZE_SEED": long
static readonly "EMPTY": $LootTable

public static "lootTable"(): $LootTable$Builder
public "getParamSet"(): $LootContextParamSet
public "getRandomSequence"(): $Optional
public static "createStackSplitter"(arg0: $ServerLevel$$Type, arg1: $Consumer$$Type<($ItemStack)>): $Consumer<($ItemStack)>
/**
 * 
 * @deprecated
 */
public "getRandomItemsRaw"(arg0: $LootContext$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
/**
 * 
 * @deprecated
 */
public "getRandomItemsRaw"(arg0: $LootParams$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
public "almostunified$unify"(lookup: $UnificationLookup$$Type): boolean
public "getLootTableId"(): $ResourceLocation
public "setLootTableId"(arg0: $ResourceLocation$$Type): void
public "removePool"(arg0: StringJS): $LootPool
public "addPool"(arg0: $LootPool$$Type): void
public "fill"(arg0: $Container$$Type, arg1: $LootParams$$Type, arg2: long): void
public "validate"(arg0: $ValidationContext$$Type): void
public "getPool"(arg0: StringJS): $LootPool
public "isFrozen"(): boolean
public "freeze"(): void
public "getRandomItems"(arg0: $LootParams$$Type, arg1: long): $ObjectArrayList<($ItemStack)>
public "getRandomItems"(arg0: $LootParams$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
public "getRandomItems"(arg0: $LootParams$$Type, arg1: long, arg2: $Consumer$$Type<($ItemStack)>): void
public "getRandomItems"(arg0: $LootParams$$Type): $ObjectArrayList<($ItemStack)>
public "getRandomItems"(arg0: $LootContext$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
public "getRandomItems"(arg0: $LootParams$$Type, arg1: $RandomSource$$Type): $ObjectArrayList<($ItemStack)>
public static "cast"(table: $LootTable$$Type): $LootUnificationHandler
public static "cast"(pool: $LootPool$$Type): $LootUnificationHandler
get "paramSet"(): $LootContextParamSet
get "randomSequence"(): $Optional
get "lootTableId"(): $ResourceLocation
set "lootTableId"(value: $ResourceLocation$$Type)
get "frozen"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTable$$Type = ($LootTable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootTable$$Original = $LootTable;}
declare module "net.minecraft.world.level.levelgen.feature.PointedDripstoneFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration, $PointedDripstoneConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $PointedDripstoneFeature extends $Feature<($PointedDripstoneConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($PointedDripstoneConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($PointedDripstoneConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PointedDripstoneFeature$$Type = ($PointedDripstoneFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PointedDripstoneFeature$$Original = $PointedDripstoneFeature;}
declare module "net.minecraft.world.level.ClipContext" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ClipContext$Block$$Type} from "net.minecraft.world.level.ClipContext$Block"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClipContext$Fluid, $ClipContext$Fluid$$Type} from "net.minecraft.world.level.ClipContext$Fluid"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$ClipContextAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.world.raycast.ClipContextAccessor"

export class $ClipContext implements $ClipContextAccessor$$Interface {
constructor(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $ClipContext$Block$$Type, arg3: $ClipContext$Fluid$$Type, arg4: $Entity$$Type)
constructor(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $ClipContext$Block$$Type, arg3: $ClipContext$Fluid$$Type, arg4: $CollisionContext$$Type)

public "getFluidHandling"(): $ClipContext$Fluid
public "getFrom"(): $Vec3
public "getTo"(): $Vec3
public "getBlockShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getFluidShape"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
get "fluidHandling"(): $ClipContext$Fluid
get "from"(): $Vec3
get "to"(): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipContext$$Type = ($ClipContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipContext$$Original = $ClipContext;}
declare module "net.minecraft.world.level.block.entity.ConduitBlockEntity" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ConduitBlockEntity extends $BlockEntity {
 "tickCount": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $ConduitBlockEntity$$Type): void
public "getUpdatePacket"(): $Packet
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "isHunting"(): boolean
public "getActiveRotation"(arg0: float): float
public "isActive"(): boolean
public static "clientTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $ConduitBlockEntity$$Type): void
get "updatePacket"(): $Packet
get "hunting"(): boolean
get "active"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConduitBlockEntity$$Type = ($ConduitBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConduitBlockEntity$$Original = $ConduitBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $ProbabilityFeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($ProbabilityFeatureConfiguration)>
readonly "probability": float

constructor(arg0: float)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProbabilityFeatureConfiguration$$Type = ($ProbabilityFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProbabilityFeatureConfiguration$$Original = $ProbabilityFeatureConfiguration;}
declare module "net.minecraft.world.level.levelgen.feature.HugeRedMushroomFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$AbstractHugeMushroomFeature} from "net.minecraft.world.level.levelgen.feature.AbstractHugeMushroomFeature"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $HugeRedMushroomFeature extends $AbstractHugeMushroomFeature {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($HugeMushroomFeatureConfiguration$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HugeRedMushroomFeature$$Type = ($HugeRedMushroomFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HugeRedMushroomFeature$$Original = $HugeRedMushroomFeature;}
declare module "net.minecraft.world.level.block.entity.BarrelBlockEntity" {
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Level} from "net.minecraft.world.level.Level"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type, $InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$Component} from "net.minecraft.network.chat.Component"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BarrelBlockEntity extends $RandomizableContainerBlockEntity implements $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface {
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "recheckOpen"(): void
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "startOpen"(arg0: $Player$$Type): void
public "stopOpen"(arg0: $Player$$Type): void
public "handler$dii000$lithium$setInventoryStackListReplacement"(arg0: $NonNullList$$Type, arg1: $CallbackInfo$$Type): void
public "getContainerSize"(): integer
public "generateLootLithium"(): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public "lithium$emitRemoved"(): void
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitContentModified"(): void
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "tryClear"(arg0: any): void
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "containerSize"(): integer
get "changed"(): void
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BarrelBlockEntity$$Type = ($BarrelBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BarrelBlockEntity$$Original = $BarrelBlockEntity;}
declare module "net.minecraft.world.level.block.state.properties.BambooLeaves" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BambooLeaves extends $Enum<($BambooLeaves)> implements $StringRepresentable$$Interface {
static readonly "SMALL": $BambooLeaves
static readonly "LARGE": $BambooLeaves
static readonly "NONE": $BambooLeaves

public "toString"(): StringJS
public static "values"(): ($BambooLeaves)[]
public static "valueOf"(arg0: StringJS): $BambooLeaves
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BambooLeaves$$Type = (("none") | ("small") | ("large"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BambooLeaves$$Original = $BambooLeaves;}
declare module "net.minecraft.world.level.block.SpawnerBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SpawnerBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SpawnerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "getExpDrop"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): integer
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($SpawnerBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnerBlock$$Type = ($SpawnerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpawnerBlock$$Original = $SpawnerBlock;}
declare module "net.minecraft.world.level.GameType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Abilities$$Type} from "net.minecraft.world.entity.player.Abilities"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Component} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $GameType extends $Enum<($GameType)> implements $StringRepresentable$$Interface {
static readonly "SURVIVAL": $GameType
static readonly "SPECTATOR": $GameType
static readonly "CODEC": $StringRepresentable$EnumCodec<($GameType)>
static readonly "CREATIVE": $GameType
static readonly "ADVENTURE": $GameType
static readonly "DEFAULT_MODE": $GameType

public "getLongDisplayName"(): $Component
public "getShortDisplayName"(): $Component
public "updatePlayerAbilities"(arg0: $Abilities$$Type): void
public "isSurvival"(): boolean
public static "getNullableId"(arg0: $GameType$$Type): integer
public static "byNullableId"(arg0: integer): $GameType
public "getName"(): StringJS
public static "values"(): ($GameType)[]
public static "valueOf"(arg0: StringJS): $GameType
public "getId"(): integer
public static "byName"(arg0: StringJS): $GameType
public static "byName"(arg0: StringJS, arg1: $GameType$$Type): $GameType
public "isCreative"(): boolean
public "getSerializedName"(): StringJS
public static "byId"(arg0: integer): $GameType
public "isBlockPlacingRestricted"(): boolean
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "longDisplayName"(): $Component
get "shortDisplayName"(): $Component
get "survival"(): boolean
get "name"(): StringJS
get "id"(): integer
get "creative"(): boolean
get "serializedName"(): StringJS
get "blockPlacingRestricted"(): boolean
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameType$$Type = (("survival") | ("creative") | ("adventure") | ("spectator"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameType$$Original = $GameType;}
declare module "net.minecraft.world.level.gameevent.DynamicGameEventListener" {
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"

export class $DynamicGameEventListener<T extends $GameEventListener> {
constructor(arg0: T)

public "getListener"(): T
public "move"(arg0: $ServerLevel$$Type): void
public "remove"(arg0: $ServerLevel$$Type): void
public "add"(arg0: $ServerLevel$$Type): void
get "listener"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicGameEventListener$$Type<T> = ($DynamicGameEventListener<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DynamicGameEventListener$$Original<T> = $DynamicGameEventListener<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacerType" {
import {$RootPlacer} from "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$MangroveRootPlacer} from "net.minecraft.world.level.levelgen.feature.rootplacers.MangroveRootPlacer"

export class $RootPlacerType<P extends $RootPlacer> {
static readonly "MANGROVE_ROOT_PLACER": $RootPlacerType<($MangroveRootPlacer)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenRootPlacerType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenRootPlacerTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RootPlacerType$$Type<P> = (Special.WorldgenRootPlacerType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RootPlacerType$$Original<P> = $RootPlacerType<(P)>;}
declare module "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$Function$$Type} from "java.util.function.Function"

export interface $ConditionUserBuilder$$Interface<T extends $ConditionUserBuilder<(object)>> {
}

export class $ConditionUserBuilder<T extends $ConditionUserBuilder<(object)>> implements $ConditionUserBuilder$$Interface {
 "when"(arg0: $LootItemCondition$Builder$$Type): T
 "when"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemCondition$Builder$$Type)>): T
 "unwrap"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionUserBuilder$$Type<T> = ($ConditionUserBuilder<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConditionUserBuilder$$Original<T> = $ConditionUserBuilder<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$CaveSurface, $CaveSurface$$Type} from "net.minecraft.world.level.levelgen.placement.CaveSurface"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $VegetationPatchConfiguration implements $FeatureConfiguration$$Interface {
readonly "vegetationFeature": $Holder<($PlacedFeature)>
readonly "extraEdgeColumnChance": float
static readonly "CODEC": $Codec<($VegetationPatchConfiguration)>
readonly "depth": $IntProvider
readonly "surface": $CaveSurface
readonly "vegetationChance": float
readonly "extraBottomBlockChance": float
readonly "replaceable": $TagKey<($Block)>
readonly "xzRadius": $IntProvider
readonly "groundState": $BlockStateProvider
readonly "verticalRange": integer

constructor(arg0: $TagKey$$Type<($Block)>, arg1: $BlockStateProvider$$Type, arg2: $Holder$$Type<($PlacedFeature)>, arg3: $CaveSurface$$Type, arg4: $IntProvider$$Type, arg5: float, arg6: integer, arg7: float, arg8: $IntProvider$$Type, arg9: float)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VegetationPatchConfiguration$$Type = ($VegetationPatchConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VegetationPatchConfiguration$$Original = $VegetationPatchConfiguration;}
declare module "net.minecraft.world.level.block.FarmBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FarmBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FarmBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "MAX_MOISTURE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "MOISTURE": $IntegerProperty
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "turnToDirt"(arg0: $Entity$$Type, arg1: $BlockState$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): void
public "codec"(): $MapCodec<($FarmBlock)>
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FarmBlock$$Type = ($FarmBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FarmBlock$$Original = $FarmBlock;}
declare module "net.minecraft.world.level.storage.loot.LootDataType" {
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$LootItemFunction} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$LootDataType$Validator, $LootDataType$Validator$$Type} from "net.minecraft.world.level.storage.loot.LootDataType$Validator"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Stream} from "java.util.stream.Stream"
import {$LootItemCondition} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"
import {$Record} from "java.lang.Record"

export class $LootDataType<T> extends $Record {
static readonly "TABLE": $LootDataType<($LootTable)>
static readonly "MODIFIER": $LootDataType<($LootItemFunction)>
static readonly "PREDICATE": $LootDataType<($LootItemCondition)>

constructor(registryKey: $ResourceKey$$Type<($Registry<(T)>)>, codec: $Codec$$Type<(T)>, validator: $LootDataType$Validator$$Type<(T)>, defaultValue: T, conditionalCodec: $Codec$$Type<((T)?)>, idSetter: $BiConsumer$$Type<(T), ($ResourceLocation)>)

public "handler$cjj000$probejs$apply"(resourceLocation: $ResourceLocation$$Type, ops: $DynamicOps$$Type, value: any, cir: $CallbackInfoReturnable$$Type): void
public "conditionalCodec"(): $Codec<($Optional<(T)>)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public static "values"(): $Stream<($LootDataType<(never)>)>
public "hashCode"(): integer
public "defaultValue"(): T
public "deserialize"<V>(arg0: $ResourceLocation$$Type, arg1: $DynamicOps$$Type<(V)>, arg2: V): $Optional<(T)>
public "validator"(): $LootDataType$Validator<(T)>
public "codec"(): $Codec<(T)>
public "registryKey"(): $ResourceKey<($Registry<(T)>)>
public "idSetter"(): $BiConsumer<(T), ($ResourceLocation)>
public "runValidation"(arg0: $ValidationContext$$Type, arg1: $ResourceKey$$Type<(T)>, arg2: T): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootDataType$$Type<T> = ({"registryKey"?: $ResourceKey$$Type<($Registry<(T)>)>, "validator"?: $LootDataType$Validator$$Type<(T)>, "idSetter"?: $BiConsumer$$Type<(T), ($ResourceLocation$$Type)>, "conditionalCodec"?: $Codec$$Type<((T)?)>, "defaultValue"?: T, "codec"?: $Codec$$Type<(T)>}) | ([registryKey?: $ResourceKey$$Type<($Registry<(T)>)>, validator?: $LootDataType$Validator$$Type<(T)>, idSetter?: $BiConsumer$$Type<(T), ($ResourceLocation$$Type)>, conditionalCodec?: $Codec$$Type<((T)?)>, defaultValue?: T, codec?: $Codec$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootDataType$$Original<T> = $LootDataType<(T)>;}
declare module "net.minecraft.world.level.pathfinder.Path$DebugData" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Node, $Node$$Type} from "net.minecraft.world.level.pathfinder.Node"
import {$Record} from "java.lang.Record"
import {$Target, $Target$$Type} from "net.minecraft.world.level.pathfinder.Target"

export class $Path$DebugData extends $Record {
constructor(arg0: ($Node$$Type)[], arg1: ($Node$$Type)[], arg2: $Set$$Type<($Target$$Type)>)

public "openSet"(): ($Node)[]
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "write"(arg0: $FriendlyByteBuf$$Type): void
public static "read"(arg0: $FriendlyByteBuf$$Type): $Path$DebugData
public "targetNodes"(): $Set<($Target)>
public "closedSet"(): ($Node)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Path$DebugData$$Type = ({"targetNodes"?: $Set$$Type<($Target$$Type)>, "closedSet"?: ($Node$$Type)[], "openSet"?: ($Node$$Type)[]}) | ([targetNodes?: $Set$$Type<($Target$$Type)>, closedSet?: ($Node$$Type)[], openSet?: ($Node$$Type)[]]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Path$DebugData$$Original = $Path$DebugData;}
declare module "net.minecraft.world.level.levelgen.blending.Blender" {
import {$Blender$BlendingOutput} from "net.minecraft.world.level.levelgen.blending.Blender$BlendingOutput"
import {$ProtoChunk$$Type} from "net.minecraft.world.level.chunk.ProtoChunk"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$Blender$DistanceGetter} from "net.minecraft.world.level.levelgen.blending.Blender$DistanceGetter"
import {$BlendingData$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData"
import {$BiomeResolver, $BiomeResolver$$Type} from "net.minecraft.world.level.biome.BiomeResolver"
import {$Map$$Type} from "java.util.Map"
import {$WorldGenRegion$$Type} from "net.minecraft.server.level.WorldGenRegion"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Direction8$$Type} from "net.minecraft.core.Direction8"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"

export class $Blender {
public "blendDensity"(arg0: $DensityFunction$FunctionContext$$Type, arg1: double): double
public "getBiomeResolver"(arg0: $BiomeResolver$$Type): $BiomeResolver
public static "makeOldChunkDistanceGetter"(arg0: $BlendingData$$Type, arg1: $Map$$Type<($Direction8$$Type), ($BlendingData$$Type)>): $Blender$DistanceGetter
public "blendOffsetAndFactor"(arg0: integer, arg1: integer): $Blender$BlendingOutput
public static "addAroundOldChunksCarvingMaskFilter"(arg0: $WorldGenLevel$$Type, arg1: $ProtoChunk$$Type): void
public static "generateBorderTicks"(arg0: $WorldGenRegion$$Type, arg1: $ChunkAccess$$Type): void
public static "of"(arg0: $WorldGenRegion$$Type): $Blender
public static "empty"(): $Blender
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Blender$$Type = ($Blender);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Blender$$Original = $Blender;}
declare module "net.minecraft.world.level.block.PotatoBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$CropBlock} from "net.minecraft.world.level.block.CropBlock"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PotatoBlock extends $CropBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PotatoBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($PotatoBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotatoBlock$$Type = ($PotatoBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotatoBlock$$Original = $PotatoBlock;}
declare module "net.minecraft.world.level.block.AmethystBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $AmethystBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($AmethystBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($AmethystBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AmethystBlock$$Type = ($AmethystBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AmethystBlock$$Original = $AmethystBlock;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$BeardifierOrMarker" {
import {$DensityFunction$SimpleFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction$SimpleFunction"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunctions$BeardifierOrMarker$$Interface extends $DensityFunction$SimpleFunction$$Interface {
}

export class $DensityFunctions$BeardifierOrMarker implements $DensityFunctions$BeardifierOrMarker$$Interface {
static readonly "CODEC": $KeyDispatchDataCodec<($DensityFunction)>

 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
 "cube"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "squeeze"(): $DensityFunction
 "maxValue"(): double
 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "square"(): $DensityFunction
 "minValue"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$BeardifierOrMarker$$Type = ($DensityFunctions$BeardifierOrMarker);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$BeardifierOrMarker$$Original = $DensityFunctions$BeardifierOrMarker;}
declare module "net.minecraft.world.level.block.WitherSkullBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$SkullBlock} from "net.minecraft.world.level.block.SkullBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Equipable} from "net.minecraft.world.item.Equipable"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$SkullBlockEntity$$Type} from "net.minecraft.world.level.block.entity.SkullBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WitherSkullBlock extends $SkullBlock {
static readonly "ROTATION": $IntegerProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WitherSkullBlock)>
static readonly "MAX": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public static "canSpawnMob"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type): boolean
public static "checkSpawn"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public static "checkSpawn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $SkullBlockEntity$$Type): void
public "codec"(): $MapCodec<($WitherSkullBlock)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WitherSkullBlock$$Type = ($WitherSkullBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WitherSkullBlock$$Original = $WitherSkullBlock;}
declare module "net.minecraft.world.level.storage.LevelSummary" {
import {$LevelSettings, $LevelSettings$$Type} from "net.minecraft.world.level.LevelSettings"
import {$Comparable$$Interface} from "java.lang.Comparable"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$LevelVersion, $LevelVersion$$Type} from "net.minecraft.world.level.storage.LevelVersion"
import {$Component} from "net.minecraft.network.chat.Component"
import {$GameType} from "net.minecraft.world.level.GameType"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$LevelSummary$BackupStatus} from "net.minecraft.world.level.storage.LevelSummary$BackupStatus"

export class $LevelSummary implements $Comparable$$Interface<($LevelSummary)> {
static readonly "PLAY_WORLD": $Component

constructor(arg0: $LevelSettings$$Type, arg1: $LevelVersion$$Type, arg2: StringJS, arg3: boolean, arg4: boolean, arg5: boolean, arg6: $Path$$Type)

public "isExperimental"(): boolean
public "isDisabled"(): boolean
public "getInfo"(): $Component
public "getSettings"(): $LevelSettings
public "getLevelName"(): StringJS
public "compareTo"(arg0: $LevelSummary$$Type): integer
public "compareTo"(arg0: any): integer
public "isLocked"(): boolean
public "getIcon"(): $Path
public "canDelete"(): boolean
public "isHardcore"(): boolean
public "getLevelId"(): StringJS
public "isCompatible"(): boolean
public "levelVersion"(): $LevelVersion
public "requiresManualConversion"(): boolean
public "getLastPlayed"(): long
public "hasCommands"(): boolean
public "getWorldVersionName"(): $MutableComponent
public "shouldBackup"(): boolean
public "backupStatus"(): $LevelSummary$BackupStatus
public "isDowngrade"(): boolean
public "primaryActionMessage"(): $Component
public "primaryActionActive"(): boolean
public "canUpload"(): boolean
public "canEdit"(): boolean
public "canRecreate"(): boolean
public "getGameMode"(): $GameType
get "experimental"(): boolean
get "disabled"(): boolean
get "info"(): $Component
get "settings"(): $LevelSettings
get "levelName"(): StringJS
get "locked"(): boolean
get "icon"(): $Path
get "hardcore"(): boolean
get "levelId"(): StringJS
get "compatible"(): boolean
get "lastPlayed"(): long
get "worldVersionName"(): $MutableComponent
get "downgrade"(): boolean
get "gameMode"(): $GameType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelSummary$$Type = ($LevelSummary);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelSummary$$Original = $LevelSummary;}
declare module "net.minecraft.world.level.GameRules$Value" {
import {$CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"

export class $GameRules$Value<T extends $GameRules$Value<(object)>> {
constructor(arg0: $GameRules$Type$$Type<(T)>)

public "onChanged"(arg0: $MinecraftServer$$Type): void
public "getCommandResult"(): integer
public "setFromArgument"(arg0: $CommandContext$$Type<($CommandSourceStack$$Type)>, arg1: StringJS): void
public "toString"(): StringJS
public "deserialize"(arg0: StringJS): void
public "serialize"(): StringJS
public "setFrom"(arg0: T, arg1: $MinecraftServer$$Type): void
get "commandResult"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$Value$$Type<T> = ($GameRules$Value<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$Value$$Original<T> = $GameRules$Value<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.CoralMushroomFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$CoralFeature} from "net.minecraft.world.level.levelgen.feature.CoralFeature"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $CoralMushroomFeature extends $CoralFeature {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoralMushroomFeature$$Type = ($CoralMushroomFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CoralMushroomFeature$$Original = $CoralMushroomFeature;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($BlockStateConfiguration)>
readonly "state": $BlockState

constructor(arg0: $BlockState$$Type)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateConfiguration$$Type = ($BlockStateConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateConfiguration$$Original = $BlockStateConfiguration;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$OffsetType" {
import {$Enum} from "java.lang.Enum"

export class $BlockBehaviour$OffsetType extends $Enum<($BlockBehaviour$OffsetType)> {
static readonly "XZ": $BlockBehaviour$OffsetType
static readonly "XYZ": $BlockBehaviour$OffsetType
static readonly "NONE": $BlockBehaviour$OffsetType

public static "values"(): ($BlockBehaviour$OffsetType)[]
public static "valueOf"(arg0: StringJS): $BlockBehaviour$OffsetType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$OffsetType$$Type = (("none") | ("xz") | ("xyz"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$OffsetType$$Original = $BlockBehaviour$OffsetType;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration" {
import {$Optional} from "java.util.Optional"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List} from "java.util.List"
import {$RootPlacer} from "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacer"
import {$FeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$Codec} from "com.mojang.serialization.Codec"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$BlockStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$Stream} from "java.util.stream.Stream"

export class $TreeConfiguration implements $FeatureConfiguration$$Interface {
readonly "foliagePlacer": $FoliagePlacer
readonly "trunkProvider": $BlockStateProvider
static readonly "CODEC": $Codec<($TreeConfiguration)>
readonly "trunkPlacer": $TrunkPlacer
readonly "rootPlacer": $Optional<($RootPlacer)>
readonly "decorators": $List<($TreeDecorator)>
readonly "foliageProvider": $BlockStateProvider
readonly "ignoreVines": boolean
readonly "minimumSize": $FeatureSize
readonly "forceDirt": boolean
readonly "dirtProvider": $BlockStateProvider

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeConfiguration$$Type = ($TreeConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeConfiguration$$Original = $TreeConfiguration;}
declare module "net.minecraft.world.level.block.PitcherCropBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DoubleBlockHalf} from "net.minecraft.world.level.block.state.properties.DoubleBlockHalf"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$DoublePlantBlock} from "net.minecraft.world.level.block.DoublePlantBlock"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $PitcherCropBlock extends $DoublePlantBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PitcherCropBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($DoubleBlockHalf)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "canBeReplaced"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): boolean
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "isRandomlyTicking"(arg0: $BlockState$$Type): boolean
public "randomTick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "codec"(): $MapCodec<($PitcherCropBlock)>
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "entityInside"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): void
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PitcherCropBlock$$Type = ($PitcherCropBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PitcherCropBlock$$Original = $PitcherCropBlock;}
declare module "net.minecraft.world.level.levelgen.feature.VegetationPatchFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration, $VegetationPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $VegetationPatchFeature extends $Feature<($VegetationPatchConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($VegetationPatchConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($VegetationPatchConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VegetationPatchFeature$$Type = ($VegetationPatchFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VegetationPatchFeature$$Original = $VegetationPatchFeature;}
declare module "net.minecraft.world.level.chunk.status.ChunkStep" {
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$ChunkDependencies, $ChunkDependencies$$Type} from "net.minecraft.world.level.chunk.status.ChunkDependencies"
import {$WorldGenContext$$Type} from "net.minecraft.world.level.chunk.status.WorldGenContext"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$StaticCache2D$$Type} from "net.minecraft.util.StaticCache2D"
import {$ChunkStatus, $ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$GenerationChunkHolder$$Type} from "net.minecraft.server.level.GenerationChunkHolder"
import {$Record} from "java.lang.Record"
import {$ChunkStatusTask, $ChunkStatusTask$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatusTask"

export class $ChunkStep extends $Record {
constructor(arg0: $ChunkStatus$$Type, arg1: $ChunkDependencies$$Type, arg2: $ChunkDependencies$$Type, arg3: integer, arg4: $ChunkStatusTask$$Type)

public "targetStatus"(): $ChunkStatus
public "accumulatedDependencies"(): $ChunkDependencies
public "getAccumulatedRadiusOf"(arg0: $ChunkStatus$$Type): integer
public "directDependencies"(): $ChunkDependencies
public "blockStateWriteRadius"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "apply"(arg0: $WorldGenContext$$Type, arg1: $StaticCache2D$$Type<($GenerationChunkHolder$$Type)>, arg2: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
public "task"(): $ChunkStatusTask
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkStep$$Type = ({"directDependencies"?: $ChunkDependencies$$Type, "accumulatedDependencies"?: $ChunkDependencies$$Type, "blockStateWriteRadius"?: integer, "task"?: $ChunkStatusTask$$Type, "targetStatus"?: $ChunkStatus$$Type}) | ([directDependencies?: $ChunkDependencies$$Type, accumulatedDependencies?: $ChunkDependencies$$Type, blockStateWriteRadius?: integer, task?: $ChunkStatusTask$$Type, targetStatus?: $ChunkStatus$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkStep$$Original = $ChunkStep;}
declare module "net.minecraft.world.level.block.RespawnAnchorBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$CollisionGetter$$Type} from "net.minecraft.world.level.CollisionGetter"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $RespawnAnchorBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RespawnAnchorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "MIN_CHARGES": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "MAX_CHARGES": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "CHARGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "canSetSpawn"(arg0: $Level$$Type): boolean
public static "getScaledChargeLevel"(arg0: $BlockState$$Type, arg1: integer): integer
public static "charge"(arg0: $Entity$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($RespawnAnchorBlock)>
public static "findStandUpPosition"(arg0: $EntityType$$Type<(never)>, arg1: $CollisionGetter$$Type, arg2: $BlockPos$$Type): $Optional<($Vec3)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RespawnAnchorBlock$$Type = ($RespawnAnchorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RespawnAnchorBlock$$Original = $RespawnAnchorBlock;}
declare module "net.minecraft.world.level.block.entity.BellBlockEntity" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BellBlockEntity extends $BlockEntity {
 "ticks": integer
 "clickDirection": $Direction
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "shaking": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BellBlockEntity$$Type): void
public "onHit"(arg0: $Direction$$Type): void
public static "clientTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BellBlockEntity$$Type): void
public "triggerEvent"(arg0: integer, arg1: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BellBlockEntity$$Type = ($BellBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BellBlockEntity$$Original = $BellBlockEntity;}
declare module "net.minecraft.world.level.levelgen.GenerationStep$Carving" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $GenerationStep$Carving extends $Enum<($GenerationStep$Carving)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($GenerationStep$Carving)>
static readonly "LIQUID": $GenerationStep$Carving
static readonly "AIR": $GenerationStep$Carving

public "getName"(): StringJS
public static "values"(): ($GenerationStep$Carving)[]
public static "valueOf"(arg0: StringJS): $GenerationStep$Carving
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "name"(): StringJS
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenerationStep$Carving$$Type = (("air") | ("liquid"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GenerationStep$Carving$$Original = $GenerationStep$Carving;}
declare module "net.minecraft.world.level.biome.Biome$ClimateSettings" {
import {$Biome$TemperatureModifier, $Biome$TemperatureModifier$$Type} from "net.minecraft.world.level.biome.Biome$TemperatureModifier"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $Biome$ClimateSettings extends $Record {
static readonly "CODEC": $MapCodec<($Biome$ClimateSettings)>

constructor(hasPrecipitation: boolean, temperature: float, temperatureModifier: $Biome$TemperatureModifier$$Type, downfall: float)

public "temperature"(): float
public "hasPrecipitation"(): boolean
public "temperatureModifier"(): $Biome$TemperatureModifier
public "downfall"(): float
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Biome$ClimateSettings$$Type = ({"hasPrecipitation"?: boolean, "temperatureModifier"?: $Biome$TemperatureModifier$$Type, "temperature"?: float, "downfall"?: float}) | ([hasPrecipitation?: boolean, temperatureModifier?: $Biome$TemperatureModifier$$Type, temperature?: float, downfall?: float]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Biome$ClimateSettings$$Original = $Biome$ClimateSettings;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.PineFoliagePlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $PineFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($PineFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type)

public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
public "foliageRadius"(arg0: $RandomSource$$Type, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PineFoliagePlacer$$Type = ($PineFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PineFoliagePlacer$$Original = $PineFoliagePlacer;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.UpwardsBranchingTrunkPlacer" {
import {$List} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $UpwardsBranchingTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($UpwardsBranchingTrunkPlacer)>
static readonly "MAX_HEIGHT": integer

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $IntProvider$$Type, arg4: float, arg5: $IntProvider$$Type, arg6: $HolderSet$$Type<($Block)>)

public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpwardsBranchingTrunkPlacer$$Type = ($UpwardsBranchingTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UpwardsBranchingTrunkPlacer$$Original = $UpwardsBranchingTrunkPlacer;}
declare module "net.minecraft.world.level.block.state.properties.BellAttachType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BellAttachType extends $Enum<($BellAttachType)> implements $StringRepresentable$$Interface {
static readonly "FLOOR": $BellAttachType
static readonly "DOUBLE_WALL": $BellAttachType
static readonly "CEILING": $BellAttachType
static readonly "SINGLE_WALL": $BellAttachType

public static "values"(): ($BellAttachType)[]
public static "valueOf"(arg0: StringJS): $BellAttachType
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BellAttachType$$Type = (("floor") | ("ceiling") | ("single_wall") | ("double_wall"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BellAttachType$$Original = $BellAttachType;}
declare module "net.minecraft.world.level.levelgen.carver.CanyonWorldCarver" {
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$CaveCarverConfiguration} from "net.minecraft.world.level.levelgen.carver.CaveCarverConfiguration"
import {$Aquifer$$Type} from "net.minecraft.world.level.levelgen.Aquifer"
import {$CanyonCarverConfiguration, $CanyonCarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CanyonCarverConfiguration"
import {$CarvingContext$$Type} from "net.minecraft.world.level.levelgen.carver.CarvingContext"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$CarvingMask$$Type} from "net.minecraft.world.level.chunk.CarvingMask"
import {$WorldCarver} from "net.minecraft.world.level.levelgen.carver.WorldCarver"
import {$CarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CarverConfiguration"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"

export class $CanyonWorldCarver extends $WorldCarver<($CanyonCarverConfiguration)> {
static readonly "CAVE": $WorldCarver<($CaveCarverConfiguration)>
static readonly "CANYON": $WorldCarver<($CanyonCarverConfiguration)>
static readonly "NETHER_CAVE": $WorldCarver<($CaveCarverConfiguration)>

constructor(arg0: $Codec$$Type<($CanyonCarverConfiguration$$Type)>)

public "carve"(arg0: $CarvingContext$$Type, arg1: $CarverConfiguration$$Type, arg2: $ChunkAccess$$Type, arg3: $Function$$Type, arg4: $RandomSource$$Type, arg5: $Aquifer$$Type, arg6: $ChunkPos$$Type, arg7: $CarvingMask$$Type): boolean
public "carve"(arg0: $CarvingContext$$Type, arg1: $CanyonCarverConfiguration$$Type, arg2: $ChunkAccess$$Type, arg3: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg4: $RandomSource$$Type, arg5: $Aquifer$$Type, arg6: $ChunkPos$$Type, arg7: $CarvingMask$$Type): boolean
public "isStartChunk"(arg0: $CarverConfiguration$$Type, arg1: $RandomSource$$Type): boolean
public "isStartChunk"(arg0: $CanyonCarverConfiguration$$Type, arg1: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanyonWorldCarver$$Type = ($CanyonWorldCarver);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CanyonWorldCarver$$Original = $CanyonWorldCarver;}
declare module "net.minecraft.world.level.levelgen.feature.KelpFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $KelpFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KelpFeature$$Type = ($KelpFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KelpFeature$$Original = $KelpFeature;}
declare module "net.minecraft.world.level.levelgen.feature.SnowAndFreezeFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $SnowAndFreezeFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SnowAndFreezeFeature$$Type = ($SnowAndFreezeFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SnowAndFreezeFeature$$Original = $SnowAndFreezeFeature;}
declare module "net.minecraft.world.level.biome.BiomeResolver" {
import {$Climate$Sampler, $Climate$Sampler$$Type} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export interface $BiomeResolver$$Interface {

(arg0: integer, arg1: integer, arg2: integer, arg3: $Climate$Sampler): $Holder$$Type<($Biome$$Type)>
}

export class $BiomeResolver implements $BiomeResolver$$Interface {
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer, arg3: $Climate$Sampler$$Type): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeResolver$$Type = ((arg0: integer, arg1: integer, arg2: integer, arg3: $Climate$Sampler) => $Holder$$Type<($Biome$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeResolver$$Original = $BiomeResolver;}
declare module "net.minecraft.world.level.chunk.ChunkAccess$TicksToSave" {
import {$SerializableTickContainer, $SerializableTickContainer$$Type} from "net.minecraft.world.ticks.SerializableTickContainer"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Record} from "java.lang.Record"

export class $ChunkAccess$TicksToSave extends $Record {
constructor(blocks: $SerializableTickContainer$$Type<($Block$$Type)>, fluids: $SerializableTickContainer$$Type<($Fluid$$Type)>)

public "blocks"(): $SerializableTickContainer<($Block)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "fluids"(): $SerializableTickContainer<($Fluid)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkAccess$TicksToSave$$Type = ({"fluids"?: $SerializableTickContainer$$Type<($Fluid$$Type)>, "blocks"?: $SerializableTickContainer$$Type<($Block$$Type)>}) | ([fluids?: $SerializableTickContainer$$Type<($Fluid$$Type)>, blocks?: $SerializableTickContainer$$Type<($Block$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkAccess$TicksToSave$$Original = $ChunkAccess$TicksToSave;}
declare module "net.minecraft.world.level.block.AmethystClusterBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$AmethystBlock} from "net.minecraft.world.level.block.AmethystBlock"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AmethystClusterBlock extends $AmethystBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($AmethystClusterBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: float, arg1: float, arg2: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($AmethystClusterBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AmethystClusterBlock$$Type = ($AmethystClusterBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AmethystClusterBlock$$Original = $AmethystClusterBlock;}
declare module "net.minecraft.world.level.chunk.UpgradeData" {
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$LevelChunk$$Type} from "net.minecraft.world.level.chunk.LevelChunk"

export class $UpgradeData {
static readonly "EMPTY": $UpgradeData

constructor(arg0: $CompoundTag$$Type, arg1: $LevelHeightAccessor$$Type)

public "isEmpty"(): boolean
public "write"(): $CompoundTag
public "upgrade"(arg0: $LevelChunk$$Type): void
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeData$$Type = ($UpgradeData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UpgradeData$$Original = $UpgradeData;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.CocoaDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $CocoaDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($CocoaDecorator)>

constructor(arg0: float)

public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CocoaDecorator$$Type = ($CocoaDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CocoaDecorator$$Original = $CocoaDecorator;}
declare module "net.minecraft.world.level.GameRules$BooleanValue" {
import {$GameRules$Value, $GameRules$Value$$Type} from "net.minecraft.world.level.GameRules$Value"
import {$GameRules$Type, $GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $GameRules$BooleanValue extends $GameRules$Value<($GameRules$BooleanValue)> {
constructor(arg0: $GameRules$Type$$Type<($GameRules$BooleanValue$$Type)>, arg1: boolean)

public "getCommandResult"(): integer
public "get"(): boolean
public "set"(arg0: boolean, arg1: $MinecraftServer$$Type): void
public static "create"(arg0: boolean, arg1: $BiConsumer$$Type<($MinecraftServer), ($GameRules$BooleanValue)>): $GameRules$Type<($GameRules$BooleanValue)>
public static "create"(arg0: boolean): $GameRules$Type<($GameRules$BooleanValue)>
public "deserialize"(arg0: StringJS): void
public "serialize"(): StringJS
public "setFrom"(arg0: $GameRules$BooleanValue$$Type, arg1: $MinecraftServer$$Type): void
public "setFrom"(arg0: $GameRules$Value$$Type, arg1: $MinecraftServer$$Type): void
get "commandResult"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$BooleanValue$$Type = ($GameRules$BooleanValue);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$BooleanValue$$Original = $GameRules$BooleanValue;}
declare module "net.minecraft.world.level.chunk.LevelChunk$PostLoadProcessor" {
import {$LevelChunk, $LevelChunk$$Type} from "net.minecraft.world.level.chunk.LevelChunk"

export interface $LevelChunk$PostLoadProcessor$$Interface {

(arg0: $LevelChunk): void
}

export class $LevelChunk$PostLoadProcessor implements $LevelChunk$PostLoadProcessor$$Interface {
 "run"(arg0: $LevelChunk$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelChunk$PostLoadProcessor$$Type = ((arg0: $LevelChunk) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelChunk$PostLoadProcessor$$Original = $LevelChunk$PostLoadProcessor;}
declare module "net.minecraft.world.level.ExplosionDamageCalculator" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$Optional} from "java.util.Optional"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ExplosionDamageCalculator {
constructor()

public "getKnockbackMultiplier"(arg0: $Entity$$Type): float
public "shouldDamageEntity"(arg0: $Explosion$$Type, arg1: $Entity$$Type): boolean
public "getEntityDamageAmount"(arg0: $Explosion$$Type, arg1: $Entity$$Type): float
public "getBlockExplosionResistance"(arg0: $Explosion$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $FluidState$$Type): $Optional<(float)>
public "shouldBlockExplode"(arg0: $Explosion$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: float): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionDamageCalculator$$Type = ($ExplosionDamageCalculator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionDamageCalculator$$Original = $ExplosionDamageCalculator;}
declare module "net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStructurePlacement" {
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Optional$$Type} from "java.util.Optional"
import {$StructurePlacement$ExclusionZone$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$ExclusionZone"
import {$StructurePlacementType} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacementType"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$StructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlacement$FrequencyReductionMethod$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$FrequencyReductionMethod"

export class $ConcentricRingsStructurePlacement extends $StructurePlacement {
static readonly "CODEC": $MapCodec<($ConcentricRingsStructurePlacement)>

constructor(arg0: $Vec3i$$Type, arg1: $StructurePlacement$FrequencyReductionMethod$$Type, arg2: float, arg3: integer, arg4: ($StructurePlacement$ExclusionZone$$Type)?, arg5: integer, arg6: integer, arg7: integer, arg8: $HolderSet$$Type<($Biome)>)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $HolderSet$$Type<($Biome)>)

public "preferredBiomes"(): $HolderSet<($Biome)>
public "type"(): $StructurePlacementType<(never)>
public "count"(): integer
public "spread"(): integer
public "distance"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConcentricRingsStructurePlacement$$Type = ($ConcentricRingsStructurePlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConcentricRingsStructurePlacement$$Original = $ConcentricRingsStructurePlacement;}
declare module "net.minecraft.world.level.levelgen.Aquifer$FluidStatus" {
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $Aquifer$FluidStatus {
constructor(arg0: integer, arg1: $BlockState$$Type)

public "at"(arg0: integer): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Aquifer$FluidStatus$$Type = ($Aquifer$FluidStatus);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Aquifer$FluidStatus$$Original = $Aquifer$FluidStatus;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$StateArgumentPredicate" {
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockBehaviour$StateArgumentPredicate$$Interface<A> {

(arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos, arg3: A): boolean
}

export class $BlockBehaviour$StateArgumentPredicate<A> implements $BlockBehaviour$StateArgumentPredicate$$Interface {
 "test"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: A): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$StateArgumentPredicate$$Type<A> = ((arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos, arg3: A) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$StateArgumentPredicate$$Original<A> = $BlockBehaviour$StateArgumentPredicate<(A)>;}
declare module "net.minecraft.world.level.levelgen.flat.FlatLevelGeneratorPreset" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$FlatLevelGeneratorSettings, $FlatLevelGeneratorSettings$$Type} from "net.minecraft.world.level.levelgen.flat.FlatLevelGeneratorSettings"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $FlatLevelGeneratorPreset extends $Record {
static readonly "CODEC": $Codec<($Holder<($FlatLevelGeneratorPreset)>)>
static readonly "DIRECT_CODEC": $Codec<($FlatLevelGeneratorPreset)>

constructor(arg0: $Holder$$Type<($Item)>, arg1: $FlatLevelGeneratorSettings$$Type)

public "displayItem"(): $Holder<($Item)>
public "settings"(): $FlatLevelGeneratorSettings
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
get "tings"(): $FlatLevelGeneratorSettings
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenFlatLevelGeneratorPreset
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenFlatLevelGeneratorPresetTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlatLevelGeneratorPreset$$Type = (Special.WorldgenFlatLevelGeneratorPreset) | ({"settings"?: $FlatLevelGeneratorSettings$$Type, "displayItem"?: $Holder$$Type<($Item)>}) | ([settings?: $FlatLevelGeneratorSettings$$Type, displayItem?: $Holder$$Type<($Item)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlatLevelGeneratorPreset$$Original = $FlatLevelGeneratorPreset;}
declare module "net.minecraft.world.level.levelgen.feature.WaterloggedVegetationPatchFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration, $VegetationPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$VegetationPatchFeature} from "net.minecraft.world.level.levelgen.feature.VegetationPatchFeature"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $WaterloggedVegetationPatchFeature extends $VegetationPatchFeature {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($VegetationPatchConfiguration$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterloggedVegetationPatchFeature$$Type = ($WaterloggedVegetationPatchFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WaterloggedVegetationPatchFeature$$Original = $WaterloggedVegetationPatchFeature;}
declare module "net.minecraft.world.level.levelgen.DensityFunction$Visitor" {
import {$DensityFunction$NoiseHolder, $DensityFunction$NoiseHolder$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$NoiseHolder"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunction$Visitor$$Interface {

(arg0: $DensityFunction): $DensityFunction$$Type
}

export class $DensityFunction$Visitor implements $DensityFunction$Visitor$$Interface {
 "visitNoise"(arg0: $DensityFunction$NoiseHolder$$Type): $DensityFunction$NoiseHolder
 "apply"(arg0: $DensityFunction$$Type): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$Visitor$$Type = ((arg0: $DensityFunction) => $DensityFunction$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$Visitor$$Original = $DensityFunction$Visitor;}
declare module "net.minecraft.world.level.block.entity.TrialSpawnerBlockEntity" {
import {$TrialSpawnerState, $TrialSpawnerState$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$TrialSpawner$StateAccessor$$Interface} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner$StateAccessor"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$TrialSpawner} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Spawner$$Interface} from "net.minecraft.world.level.Spawner"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $TrialSpawnerBlockEntity extends $BlockEntity implements $Spawner$$Interface, $TrialSpawner$StateAccessor$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "markUpdated"(): void
public "getTrialSpawner"(): $TrialSpawner
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "setEntityId"(arg0: $EntityType$$Type<(never)>, arg1: $RandomSource$$Type): void
public "getState"(): $TrialSpawnerState
public "setState"(arg0: $Level$$Type, arg1: $TrialSpawnerState$$Type): void
public "onlyOpCanSetNbt"(): boolean
public static "appendHoverText"(arg0: $ItemStack$$Type, arg1: $List$$Type<($Component$$Type)>, arg2: StringJS): void
public static "getSpawnEntityDisplayName"(arg0: $ItemStack$$Type, arg1: StringJS): $Component
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "trialSpawner"(): $TrialSpawner
get "state"(): $TrialSpawnerState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawnerBlockEntity$$Type = ($TrialSpawnerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawnerBlockEntity$$Original = $TrialSpawnerBlockEntity;}
declare module "net.minecraft.world.level.levelgen.Aquifer" {
import {$Aquifer$FluidPicker$$Type} from "net.minecraft.world.level.levelgen.Aquifer$FluidPicker"
import {$NoiseChunk$$Type} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$PositionalRandomFactory$$Type} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$NoiseRouter$$Type} from "net.minecraft.world.level.levelgen.NoiseRouter"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export interface $Aquifer$$Interface {
}

export class $Aquifer implements $Aquifer$$Interface {
 "shouldScheduleFluidUpdate"(): boolean
 "computeSubstance"(arg0: $DensityFunction$FunctionContext$$Type, arg1: double): $BlockState
static "createDisabled"(arg0: $Aquifer$FluidPicker$$Type): $Aquifer
static "create"(arg0: $NoiseChunk$$Type, arg1: $ChunkPos$$Type, arg2: $NoiseRouter$$Type, arg3: $PositionalRandomFactory$$Type, arg4: integer, arg5: integer, arg6: $Aquifer$FluidPicker$$Type): $Aquifer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Aquifer$$Type = ($Aquifer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Aquifer$$Original = $Aquifer;}
declare module "net.minecraft.world.level.storage.loot.LootContext" {
import {$LootContextParam$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$HolderGetter$Provider} from "net.minecraft.core.HolderGetter$Provider"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$LootItemFunction, $LootItemFunction$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$LootContext$VisitedEntry, $LootContext$VisitedEntry$$Type} from "net.minecraft.world.level.storage.loot.LootContext$VisitedEntry"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $LootContext {
public "setQueriedLootTableId"(arg0: $ResourceLocation$$Type): void
public "getResolver"(): $HolderGetter$Provider
public static "createVisitedEntry"(arg0: $LootItemCondition$$Type): $LootContext$VisitedEntry<($LootItemCondition)>
public static "createVisitedEntry"(arg0: $LootItemFunction$$Type): $LootContext$VisitedEntry<($LootItemFunction)>
public static "createVisitedEntry"(arg0: $LootTable$$Type): $LootContext$VisitedEntry<($LootTable)>
public "pushVisitedElement"(arg0: $LootContext$VisitedEntry$$Type<(never)>): boolean
public "popVisitedElement"(arg0: $LootContext$VisitedEntry$$Type<(never)>): void
public "hasParam"(arg0: $LootContextParam$$Type<(never)>): boolean
public "addDynamicDrops"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
public "getQueriedLootTableId"(): $ResourceLocation
public "getParam"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "hasVisitedElement"(arg0: $LootContext$VisitedEntry$$Type<(never)>): boolean
public "getLevel"(): $ServerLevel
public "getParamOrNull"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "getRandom"(): $RandomSource
public "getLuck"(): float
set "queriedLootTableId"(value: $ResourceLocation$$Type)
get "resolver"(): $HolderGetter$Provider
get "queriedLootTableId"(): $ResourceLocation
get "level"(): $ServerLevel
get "random"(): $RandomSource
get "luck"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContext$$Type = ($LootContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContext$$Original = $LootContext;}
declare module "net.minecraft.world.level.block.state.properties.AttachFace" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $AttachFace extends $Enum<($AttachFace)> implements $StringRepresentable$$Interface {
static readonly "FLOOR": $AttachFace
static readonly "WALL": $AttachFace
static readonly "CEILING": $AttachFace

public static "values"(): ($AttachFace)[]
public static "valueOf"(arg0: StringJS): $AttachFace
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachFace$$Type = (("floor") | ("wall") | ("ceiling"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttachFace$$Original = $AttachFace;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$WeightedPlacedFeature, $WeightedPlacedFeature$$Type} from "net.minecraft.world.level.levelgen.feature.WeightedPlacedFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $RandomFeatureConfiguration implements $FeatureConfiguration$$Interface {
readonly "features": $List<($WeightedPlacedFeature)>
static readonly "CODEC": $Codec<($RandomFeatureConfiguration)>
readonly "defaultFeature": $Holder<($PlacedFeature)>

constructor(arg0: $List$$Type<($WeightedPlacedFeature$$Type)>, arg1: $Holder$$Type<($PlacedFeature)>)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomFeatureConfiguration$$Type = ($RandomFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomFeatureConfiguration$$Original = $RandomFeatureConfiguration;}
declare module "net.minecraft.world.level.levelgen.flat.FlatLayerInfo" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $FlatLayerInfo {
static readonly "CODEC": $Codec<($FlatLayerInfo)>

constructor(arg0: integer, arg1: $Block$$Type)

public "getHeight"(): integer
public "toString"(): StringJS
public "getBlockState"(): $BlockState
get "height"(): integer
get "blockState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlatLayerInfo$$Type = ($FlatLayerInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlatLayerInfo$$Original = $FlatLayerInfo;}
declare module "net.minecraft.world.level.block.CropBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$CropBlockAccessor$$Interface} from "com.simibubi.create.foundation.mixin.accessor.CropBlockAccessor"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$CropBlockAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.CropBlockAccess"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CropBlock extends $BushBlock implements $BonemealableBlock$$Interface, $CropBlockAccess$$Interface, $CropBlockAccessor$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CropBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isMaxAge"(arg0: $BlockState$$Type): boolean
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getAgeProperty"(): $IntegerProperty
public "getStateForAge"(arg0: integer): $BlockState
public "growCrops"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public static "hasSufficientLight"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
public "invokeGetAgeProperty"(): $IntegerProperty
public "create$callGetAgeProperty"(): $IntegerProperty
public "getMaxAge"(): integer
public "getAge"(arg0: $BlockState$$Type): integer
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($CropBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "ageProperty"(): $IntegerProperty
get "maxAge"(): integer
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlock$$Type = ($CropBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CropBlock$$Original = $CropBlock;}
declare module "net.minecraft.world.level.block.WeatheringCopper$WeatherState" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $WeatheringCopper$WeatherState extends $Enum<($WeatheringCopper$WeatherState)> implements $StringRepresentable$$Interface {
static readonly "UNAFFECTED": $WeatheringCopper$WeatherState
static readonly "CODEC": $Codec<($WeatheringCopper$WeatherState)>
static readonly "EXPOSED": $WeatheringCopper$WeatherState
static readonly "WEATHERED": $WeatheringCopper$WeatherState
static readonly "OXIDIZED": $WeatheringCopper$WeatherState

public static "values"(): ($WeatheringCopper$WeatherState)[]
public static "valueOf"(arg0: StringJS): $WeatheringCopper$WeatherState
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatheringCopper$WeatherState$$Type = (("unaffected") | ("exposed") | ("weathered") | ("oxidized"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeatheringCopper$WeatherState$$Original = $WeatheringCopper$WeatherState;}
declare module "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData" {
import {$WeightedEntry$Wrapper} from "net.minecraft.util.random.WeightedEntry$Wrapper"
import {$Codec} from "com.mojang.serialization.Codec"
import {$WeightedEntry$IntrusiveBase} from "net.minecraft.util.random.WeightedEntry$IntrusiveBase"
import {$Weight$$Type} from "net.minecraft.util.random.Weight"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $MobSpawnSettings$SpawnerData extends $WeightedEntry$IntrusiveBase {
static readonly "CODEC": $Codec<($MobSpawnSettings$SpawnerData)>
readonly "minCount": integer
readonly "type": $EntityType<(never)>
readonly "maxCount": integer

constructor(arg0: $EntityType$$Type<(never)>, arg1: integer, arg2: integer, arg3: integer)
constructor(arg0: $EntityType$$Type<(never)>, arg1: $Weight$$Type, arg2: integer, arg3: integer)

public "toString"(): StringJS
public static "wrap"<T>(arg0: T, arg1: integer): $WeightedEntry$Wrapper<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnSettings$SpawnerData$$Type = ($MobSpawnSettings$SpawnerData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobSpawnSettings$SpawnerData$$Original = $MobSpawnSettings$SpawnerData;}
declare module "net.minecraft.world.level.storage.loot.LootParams" {
import {$LootContextParam$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map$$Type} from "java.util.Map"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LootParams$DynamicDrop$$Type} from "net.minecraft.world.level.storage.loot.LootParams$DynamicDrop"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $LootParams {
constructor(arg0: $ServerLevel$$Type, arg1: $Map$$Type<($LootContextParam$$Type<(never)>), (any)>, arg2: $Map$$Type<($ResourceLocation$$Type), ($LootParams$DynamicDrop$$Type)>, arg3: float)

public "getOptionalParameter"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "hasParam"(arg0: $LootContextParam$$Type<(never)>): boolean
public "addDynamicDrops"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
public "getLevel"(): $ServerLevel
public "getParameter"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "getParamOrNull"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "getLuck"(): float
get "level"(): $ServerLevel
get "luck"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootParams$$Type = ($LootParams);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootParams$$Original = $LootParams;}
declare module "net.minecraft.world.level.gameevent.GameEventListener$Provider" {
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"

export interface $GameEventListener$Provider$$Interface<T extends $GameEventListener> {

(): T
get "listener"(): T
}

export class $GameEventListener$Provider<T extends $GameEventListener> implements $GameEventListener$Provider$$Interface {
 "getListener"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEventListener$Provider$$Type<T> = (() => T);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEventListener$Provider$$Original<T> = $GameEventListener$Provider<(T)>;}
declare module "net.minecraft.world.level.levelgen.structure.pools.EmptyPoolElement" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$List} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructurePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplate$StructureBlockInfo} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $EmptyPoolElement extends $StructurePoolElement {
static readonly "CODEC": $MapCodec<($EmptyPoolElement)>
static readonly "INSTANCE": $EmptyPoolElement

public "getShuffledJigsawBlocks"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: $RandomSource$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "place"(arg0: $StructureTemplateManager$$Type, arg1: $WorldGenLevel$$Type, arg2: $StructureManager$$Type, arg3: $ChunkGenerator$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type, arg6: $Rotation$$Type, arg7: $BoundingBox$$Type, arg8: $RandomSource$$Type, arg9: $LiquidSettings$$Type, arg10: boolean): boolean
public "toString"(): StringJS
public "getType"(): $StructurePoolElementType<(never)>
public "getSize"(arg0: $StructureTemplateManager$$Type, arg1: $Rotation$$Type): $Vec3i
public "getBoundingBox"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BoundingBox
get "type"(): $StructurePoolElementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyPoolElement$$Type = ($EmptyPoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EmptyPoolElement$$Original = $EmptyPoolElement;}
declare module "net.minecraft.world.level.block.state.properties.SlabType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $SlabType extends $Enum<($SlabType)> implements $StringRepresentable$$Interface {
static readonly "TOP": $SlabType
static readonly "BOTTOM": $SlabType
static readonly "DOUBLE": $SlabType

public "toString"(): StringJS
public static "values"(): ($SlabType)[]
public static "valueOf"(arg0: StringJS): $SlabType
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlabType$$Type = (("top") | ("bottom") | ("double"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlabType$$Original = $SlabType;}
declare module "net.minecraft.world.level.levelgen.feature.ChorusPlantFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $ChorusPlantFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChorusPlantFeature$$Type = ($ChorusPlantFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChorusPlantFeature$$Original = $ChorusPlantFeature;}
declare module "net.minecraft.world.level.block.CarvedPumpkinBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockPattern$BlockPatternMatch$$Type} from "net.minecraft.world.level.block.state.pattern.BlockPattern$BlockPatternMatch"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CarvedPumpkinBlock extends $HorizontalDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CarvedPumpkinBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "canSpawnGolem"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
public static "clearPatternBlocks"(arg0: $Level$$Type, arg1: $BlockPattern$BlockPatternMatch$$Type): void
public static "updatePatternBlocks"(arg0: $Level$$Type, arg1: $BlockPattern$BlockPatternMatch$$Type): void
public "codec"(): $MapCodec<($CarvedPumpkinBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarvedPumpkinBlock$$Type = ($CarvedPumpkinBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarvedPumpkinBlock$$Original = $CarvedPumpkinBlock;}
declare module "net.minecraft.world.level.storage.loot.entries.SequentialEntry$Builder" {
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$LootPoolEntryContainer} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$LootPoolEntryContainer$Builder, $LootPoolEntryContainer$Builder$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer$Builder"
import {$ConditionUserBuilder} from "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder"

export class $SequentialEntry$Builder extends $LootPoolEntryContainer$Builder<($SequentialEntry$Builder)> {
constructor(...arg0: ($LootPoolEntryContainer$Builder$$Type<(never)>)[])

public "then"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $SequentialEntry$Builder
public "build"(): $LootPoolEntryContainer
public "when"(arg0: $LootItemCondition$Builder$$Type): $ConditionUserBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequentialEntry$Builder$$Type = ($SequentialEntry$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SequentialEntry$Builder$$Original = $SequentialEntry$Builder;}
declare module "net.minecraft.world.level.block.RepeaterBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$DiodeBlock} from "net.minecraft.world.level.block.DiodeBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RepeaterBlock extends $DiodeBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($RepeaterBlock)>
static readonly "LOCKED": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "DELAY": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "isLocked"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($RepeaterBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RepeaterBlock$$Type = ($RepeaterBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RepeaterBlock$$Original = $RepeaterBlock;}
declare module "net.minecraft.world.level.chunk.status.ChunkDependencies" {
import {$ImmutableList, $ImmutableList$$Type} from "com.google.common.collect.ImmutableList"
import {$ChunkStatus, $ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"

export class $ChunkDependencies {
constructor(arg0: $ImmutableList$$Type<($ChunkStatus$$Type)>)

public "getRadius"(): integer
public "getRadiusOf"(arg0: $ChunkStatus$$Type): integer
public "size"(): integer
public "get"(arg0: integer): $ChunkStatus
public "toString"(): StringJS
public "asList"(): $ImmutableList<($ChunkStatus)>
get "radius"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkDependencies$$Type = ($ChunkDependencies);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkDependencies$$Original = $ChunkDependencies;}
declare module "net.minecraft.world.level.block.DoubleBlockCombiner$BlockType" {
import {$Enum} from "java.lang.Enum"

export class $DoubleBlockCombiner$BlockType extends $Enum<($DoubleBlockCombiner$BlockType)> {
static readonly "SINGLE": $DoubleBlockCombiner$BlockType
static readonly "SECOND": $DoubleBlockCombiner$BlockType
static readonly "FIRST": $DoubleBlockCombiner$BlockType

public static "values"(): ($DoubleBlockCombiner$BlockType)[]
public static "valueOf"(arg0: StringJS): $DoubleBlockCombiner$BlockType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBlockCombiner$BlockType$$Type = (("single") | ("first") | ("second"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoubleBlockCombiner$BlockType$$Original = $DoubleBlockCombiner$BlockType;}
declare module "net.minecraft.world.level.material.MapColor" {
import {$MapColor$Brightness$$Type} from "net.minecraft.world.level.material.MapColor$Brightness"

export class $MapColor {
readonly "col": integer
static readonly "WOOD": $MapColor
static readonly "CRIMSON_STEM": $MapColor
static readonly "TERRACOTTA_LIGHT_BLUE": $MapColor
static readonly "PODZOL": $MapColor
static readonly "WARPED_WART_BLOCK": $MapColor
static readonly "COLOR_LIGHT_GREEN": $MapColor
static readonly "COLOR_BLACK": $MapColor
static readonly "TERRACOTTA_GREEN": $MapColor
static readonly "WARPED_NYLIUM": $MapColor
static readonly "FIRE": $MapColor
static readonly "GRASS": $MapColor
static readonly "TERRACOTTA_ORANGE": $MapColor
static readonly "GLOW_LICHEN": $MapColor
static readonly "COLOR_CYAN": $MapColor
readonly "id": integer
static readonly "NONE": $MapColor
static readonly "WOOL": $MapColor
static readonly "QUARTZ": $MapColor
static readonly "WATER": $MapColor
static readonly "TERRACOTTA_YELLOW": $MapColor
static readonly "SAND": $MapColor
static readonly "SNOW": $MapColor
static readonly "DIRT": $MapColor
static readonly "LAPIS": $MapColor
static readonly "DEEPSLATE": $MapColor
static readonly "COLOR_YELLOW": $MapColor
static readonly "COLOR_LIGHT_GRAY": $MapColor
static readonly "TERRACOTTA_LIGHT_GRAY": $MapColor
static readonly "CRIMSON_NYLIUM": $MapColor
static readonly "TERRACOTTA_BLUE": $MapColor
static readonly "WARPED_HYPHAE": $MapColor
static readonly "METAL": $MapColor
static readonly "TERRACOTTA_GRAY": $MapColor
static readonly "WARPED_STEM": $MapColor
static readonly "PLANT": $MapColor
static readonly "GOLD": $MapColor
static readonly "DIAMOND": $MapColor
static readonly "COLOR_RED": $MapColor
static readonly "COLOR_ORANGE": $MapColor
static readonly "COLOR_BLUE": $MapColor
static readonly "NETHER": $MapColor
static readonly "TERRACOTTA_BLACK": $MapColor
static readonly "TERRACOTTA_PINK": $MapColor
static readonly "COLOR_MAGENTA": $MapColor
static readonly "TERRACOTTA_WHITE": $MapColor
static readonly "COLOR_GRAY": $MapColor
static readonly "COLOR_LIGHT_BLUE": $MapColor
static readonly "TERRACOTTA_LIGHT_GREEN": $MapColor
static readonly "COLOR_GREEN": $MapColor
static readonly "COLOR_PURPLE": $MapColor
static readonly "EMERALD": $MapColor
static readonly "ICE": $MapColor
static readonly "COLOR_BROWN": $MapColor
static readonly "TERRACOTTA_PURPLE": $MapColor
static readonly "TERRACOTTA_BROWN": $MapColor
static readonly "TERRACOTTA_MAGENTA": $MapColor
static readonly "RAW_IRON": $MapColor
static readonly "COLOR_PINK": $MapColor
static readonly "TERRACOTTA_RED": $MapColor
static readonly "CRIMSON_HYPHAE": $MapColor
static readonly "STONE": $MapColor
static readonly "TERRACOTTA_CYAN": $MapColor
static readonly "CLAY": $MapColor

public static "getColorFromPackedId"(arg0: integer): integer
public "getPackedId"(arg0: $MapColor$Brightness$$Type): byte
public "calculateRGBColor"(arg0: $MapColor$Brightness$$Type): integer
public static "byId"(arg0: integer): $MapColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapColor$$Type = ($MapColor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapColor$$Original = $MapColor;}
declare module "net.minecraft.world.level.levelgen.SurfaceRules$SurfaceRule" {
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $SurfaceRules$SurfaceRule$$Interface {

(arg0: integer, arg1: integer, arg2: integer): $BlockState$$Type
}

export class $SurfaceRules$SurfaceRule implements $SurfaceRules$SurfaceRule$$Interface {
 "tryApply"(arg0: integer, arg1: integer, arg2: integer): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceRules$SurfaceRule$$Type = ((arg0: integer, arg1: integer, arg2: integer) => $BlockState$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SurfaceRules$SurfaceRule$$Original = $SurfaceRules$SurfaceRule;}
declare module "net.minecraft.world.level.block.CeilingHangingSignBlock" {
import {$SignBlock} from "net.minecraft.world.level.block.SignBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$WoodType$$Type} from "net.minecraft.world.level.block.state.properties.WoodType"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CeilingHangingSignBlock extends $SignBlock {
static readonly "ROTATION": $IntegerProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CeilingHangingSignBlock)>
static readonly "ATTACHED": $BooleanProperty
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $WoodType$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getYRotationDegrees"(arg0: $BlockState$$Type): float
public "codec"(): $MapCodec<($CeilingHangingSignBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CeilingHangingSignBlock$$Type = ($CeilingHangingSignBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CeilingHangingSignBlock$$Original = $CeilingHangingSignBlock;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.SimpleStateProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BlockStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $SimpleStateProvider extends $BlockStateProvider {
static readonly "CODEC": $MapCodec<($SimpleStateProvider)>

public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleStateProvider$$Type = ($SimpleStateProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleStateProvider$$Original = $SimpleStateProvider;}
declare module "net.minecraft.world.level.storage.loot.predicates.AnyOfCondition$Builder" {
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$CompositeLootItemCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.CompositeLootItemCondition$Builder"

export class $AnyOfCondition$Builder extends $CompositeLootItemCondition$Builder {
constructor(...arg0: ($LootItemCondition$Builder$$Type)[])

public "or"(arg0: $LootItemCondition$Builder$$Type): $AnyOfCondition$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnyOfCondition$Builder$$Type = ($AnyOfCondition$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AnyOfCondition$Builder$$Original = $AnyOfCondition$Builder;}
declare module "net.minecraft.world.level.block.StainedGlassPaneBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Map} from "java.util.Map"
import {$Direction} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BeaconBeamBlock$$Interface} from "net.minecraft.world.level.block.BeaconBeamBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$IronBarsBlock} from "net.minecraft.world.level.block.IronBarsBlock"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $StainedGlassPaneBlock extends $IronBarsBlock implements $BeaconBeamBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($StainedGlassPaneBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($BooleanProperty)>
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "SOUTH": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer
static readonly "EAST": $BooleanProperty

constructor(arg0: $DyeColor$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getColor"(): $DyeColor
public "codec"(): $MapCodec<($StainedGlassPaneBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StainedGlassPaneBlock$$Type = ($StainedGlassPaneBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StainedGlassPaneBlock$$Original = $StainedGlassPaneBlock;}
declare module "net.minecraft.world.level.block.MushroomBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ConfiguredFeature$$Type} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MushroomBlock extends $BushBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($MushroomBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $ResourceKey$$Type<($ConfiguredFeature<(never), (never)>)>, arg1: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "growMushroom"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $RandomSource$$Type): boolean
public "codec"(): $MapCodec<($MushroomBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MushroomBlock$$Type = ($MushroomBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MushroomBlock$$Original = $MushroomBlock;}
declare module "net.minecraft.world.level.block.GlazedTerracottaBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $GlazedTerracottaBlock extends $HorizontalDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($GlazedTerracottaBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "codec"(): $MapCodec<($GlazedTerracottaBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlazedTerracottaBlock$$Type = ($GlazedTerracottaBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GlazedTerracottaBlock$$Original = $GlazedTerracottaBlock;}
declare module "net.minecraft.world.level.levelgen.feature.VoidStartPlatformFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $VoidStartPlatformFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VoidStartPlatformFeature$$Type = ($VoidStartPlatformFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VoidStartPlatformFeature$$Original = $VoidStartPlatformFeature;}
declare module "net.minecraft.world.level.material.LavaFluid$Source" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LavaFluid} from "net.minecraft.world.level.material.LavaFluid"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$Holder} from "net.minecraft.core.Holder"

export class $LavaFluid$Source extends $LavaFluid {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
static readonly "MIN_LEVEL_CUTOFF": float
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty

constructor()

public "isSource"(arg0: $FluidState$$Type): boolean
public "getAmount"(arg0: $FluidState$$Type): integer
public "asHolder"(): $Holder
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LavaFluid$Source$$Type = ($LavaFluid$Source);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LavaFluid$Source$$Original = $LavaFluid$Source;}
declare module "net.minecraft.world.level.gameevent.EntityPositionSource$Type" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PositionSource} from "net.minecraft.world.level.gameevent.PositionSource"
import {$EntityPositionSource} from "net.minecraft.world.level.gameevent.EntityPositionSource"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PositionSourceType, $PositionSourceType$$Type, $PositionSourceType$$Interface} from "net.minecraft.world.level.gameevent.PositionSourceType"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $EntityPositionSource$Type implements $PositionSourceType$$Interface<($EntityPositionSource)> {
constructor()

public "streamCodec"(): $StreamCodec<($ByteBuf), ($EntityPositionSource)>
public "codec"(): $MapCodec<($EntityPositionSource)>
public static "register"<S extends $PositionSourceType<(object)>, T extends $PositionSource>(arg0: StringJS, arg1: S): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityPositionSource$Type$$Type = ($EntityPositionSource$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityPositionSource$Type$$Original = $EntityPositionSource$Type;}
declare module "net.minecraft.world.level.block.DiodeBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DiodeBlock extends $HorizontalDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getOutputSignal"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): integer
public "shouldPrioritize"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isLocked"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public static "isDiode"(arg0: $BlockState$$Type): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiodeBlock$$Type = ($DiodeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiodeBlock$$Original = $DiodeBlock;}
declare module "net.minecraft.world.level.block.ConduitBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $ConduitBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ConduitBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($ConduitBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConduitBlock$$Type = ($ConduitBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConduitBlock$$Original = $ConduitBlock;}
declare module "net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$StructurePiece, $StructurePiece$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePiece"
import {$PiecesContainer} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"
import {$StructurePieceAccessor$$Interface} from "net.minecraft.world.level.levelgen.structure.StructurePieceAccessor"

export class $StructurePiecesBuilder implements $StructurePieceAccessor$$Interface {
constructor()

public "addPiece"(arg0: $StructurePiece$$Type): void
public "findCollisionPiece"(arg0: $BoundingBox$$Type): $StructurePiece
public "moveInsideHeights"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer): void
/**
 * 
 * @deprecated
 */
public "offsetPiecesVertically"(arg0: integer): void
/**
 * 
 * @deprecated
 */
public "moveBelowSeaLevel"(arg0: integer, arg1: integer, arg2: $RandomSource$$Type, arg3: integer): integer
public "clear"(): void
public "isEmpty"(): boolean
public "build"(): $PiecesContainer
public "getBoundingBox"(): $BoundingBox
get "empty"(): boolean
get "boundingBox"(): $BoundingBox
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePiecesBuilder$$Type = ($StructurePiecesBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePiecesBuilder$$Original = $StructurePiecesBuilder;}
declare module "net.minecraft.world.level.gameevent.PositionSource" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$PositionSourceType} from "net.minecraft.world.level.gameevent.PositionSourceType"

export interface $PositionSource$$Interface {
get "type"(): $PositionSourceType<($PositionSource)>
}

export class $PositionSource implements $PositionSource$$Interface {
static readonly "CODEC": $Codec<($PositionSource)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($PositionSource)>

 "getPosition"(arg0: $Level$$Type): $Optional<($Vec3)>
 "getType"(): $PositionSourceType<($PositionSource)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PositionSource$$Type = ($PositionSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PositionSource$$Original = $PositionSource;}
declare module "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet" {
import {$LootContextParamSet$Builder} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet$Builder"
import {$LootContextParam, $LootContextParam$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$ProblemReporter$$Type} from "net.minecraft.util.ProblemReporter"
import {$Set} from "java.util.Set"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootContextUser$$Type} from "net.minecraft.world.level.storage.loot.LootContextUser"

export class $LootContextParamSet {
public "isAllowed"(arg0: $LootContextParam$$Type<(never)>): boolean
public "getRequired"(): $Set<($LootContextParam<(never)>)>
public "getAllowed"(): $Set<($LootContextParam<(never)>)>
public "validateUser"(arg0: $ProblemReporter$$Type, arg1: $LootContextUser$$Type): void
public "validateUser"(arg0: $ValidationContext$$Type, arg1: $LootContextUser$$Type): void
public "toString"(): StringJS
public static "builder"(): $LootContextParamSet$Builder
get "required"(): $Set<($LootContextParam<(never)>)>
get "allowed"(): $Set<($LootContextParam<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContextParamSet$$Type = ($LootContextParamSet);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContextParamSet$$Original = $LootContextParamSet;}
declare module "net.minecraft.world.level.storage.loot.LootTable$Builder" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$LootPool$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootPool$Builder"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function$$Type} from "java.util.function.Function"
import {$LootItemFunction$Builder$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction$Builder"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$LootContextParamSet$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet"
import {$FunctionUserBuilder, $FunctionUserBuilder$$Interface} from "net.minecraft.world.level.storage.loot.functions.FunctionUserBuilder"

export class $LootTable$Builder implements $FunctionUserBuilder$$Interface<($LootTable$Builder)> {
constructor()

public "setRandomSequence"(arg0: $ResourceLocation$$Type): $LootTable$Builder
public "setParamSet"(arg0: $LootContextParamSet$$Type): $LootTable$Builder
public "withPool"(arg0: $LootPool$Builder$$Type): $LootTable$Builder
public "apply"(arg0: $LootItemFunction$Builder$$Type): $FunctionUserBuilder
public "unwrap"(): $LootTable$Builder
public "build"(): $LootTable
public "apply"<E>(arg0: (E)[], arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): $LootTable$Builder
public "apply"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): $LootTable$Builder
set "randomSequence"(value: $ResourceLocation$$Type)
set "paramSet"(value: $LootContextParamSet$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTable$Builder$$Type = ($LootTable$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootTable$Builder$$Original = $LootTable$Builder;}
declare module "net.minecraft.world.level.block.BrewingStandBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BrewingStandBlock extends $BaseEntityBlock implements $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BrewingStandBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "HAS_BOTTLE": ($BooleanProperty)[]
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($BrewingStandBlock)>
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrewingStandBlock$$Type = ($BrewingStandBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BrewingStandBlock$$Original = $BrewingStandBlock;}
declare module "net.minecraft.world.level.levelgen.feature.SculkPatchFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$SculkPatchConfiguration, $SculkPatchConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $SculkPatchFeature extends $Feature<($SculkPatchConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($SculkPatchConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($SculkPatchConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkPatchFeature$$Type = ($SculkPatchFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkPatchFeature$$Original = $SculkPatchFeature;}
declare module "net.minecraft.world.level.levelgen.structure.structures.OceanRuinStructure$Type" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $OceanRuinStructure$Type extends $Enum<($OceanRuinStructure$Type)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($OceanRuinStructure$Type)>
static readonly "COLD": $OceanRuinStructure$Type
static readonly "WARM": $OceanRuinStructure$Type

public "getName"(): StringJS
public static "values"(): ($OceanRuinStructure$Type)[]
public static "valueOf"(arg0: StringJS): $OceanRuinStructure$Type
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "name"(): StringJS
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OceanRuinStructure$Type$$Type = (("warm") | ("cold"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OceanRuinStructure$Type$$Original = $OceanRuinStructure$Type;}
declare module "net.minecraft.world.level.levelgen.feature.OreFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration, $OreConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$OreConfiguration$TargetBlockState$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$Function$$Type} from "java.util.function.Function"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$BlockPos$MutableBlockPos$$Type} from "net.minecraft.core.BlockPos$MutableBlockPos"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $OreFeature extends $Feature<($OreConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($OreConfiguration$$Type)>)

public static "canPlaceOre"(arg0: $BlockState$$Type, arg1: $Function$$Type<($BlockPos), ($BlockState$$Type)>, arg2: $RandomSource$$Type, arg3: $OreConfiguration$$Type, arg4: $OreConfiguration$TargetBlockState$$Type, arg5: $BlockPos$MutableBlockPos$$Type): boolean
public "place"(arg0: $FeaturePlaceContext$$Type<($OreConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreFeature$$Type = ($OreFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OreFeature$$Original = $OreFeature;}
declare module "net.minecraft.world.level.levelgen.feature.featuresize.TwoLayersFeatureSize" {
import {$OptionalInt$$Type} from "java.util.OptionalInt"
import {$FeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $TwoLayersFeatureSize extends $FeatureSize {
static readonly "CODEC": $MapCodec<($TwoLayersFeatureSize)>

constructor(arg0: integer, arg1: integer, arg2: integer)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $OptionalInt$$Type)

public "getSizeAtHeight"(arg0: integer, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TwoLayersFeatureSize$$Type = ($TwoLayersFeatureSize);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TwoLayersFeatureSize$$Original = $TwoLayersFeatureSize;}
declare module "net.minecraft.world.level.block.DecoratedPotBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $DecoratedPotBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DecoratedPotBlock)>
static readonly "SHERDS_DYNAMIC_DROP_ID": $ResourceLocation
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "CRACKED": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($DecoratedPotBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DecoratedPotBlock$$Type = ($DecoratedPotBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DecoratedPotBlock$$Original = $DecoratedPotBlock;}
declare module "net.minecraft.world.level.block.TallGrassBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$IShearable$$Interface} from "net.neoforged.neoforge.common.IShearable"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TallGrassBlock extends $BushBlock implements $BonemealableBlock$$Interface, $IShearable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TallGrassBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "codec"(): $MapCodec<($TallGrassBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public "onSheared"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): $List<($ItemStack)>
public "isShearable"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type): boolean
public "handler$cik000$apothic_enchanting$apoth_handleShearFortune"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "handler$cik000$apothic_enchanting$apoth_handleShearEnchantments"(arg0: $Player$$Type, arg1: $ItemStack$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "spawnShearedDrop"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TallGrassBlock$$Type = ($TallGrassBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TallGrassBlock$$Original = $TallGrassBlock;}
declare module "net.minecraft.world.level.block.state.properties.BooleanProperty" {
import {$Collection} from "java.util.Collection"
import {$Optional} from "java.util.Optional"
import {$Comparable$$Type} from "java.lang.Comparable"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $BooleanProperty extends $Property<(boolean)> {
public "getPossibleValues"(): $Collection<(boolean)>
public "generateHashCode"(): integer
public "getName"(arg0: boolean): StringJS
public "getName"(arg0: $Comparable$$Type): StringJS
public "equals"(arg0: any): boolean
public "getValue"(arg0: StringJS): $Optional<(boolean)>
public static "create"(arg0: StringJS): $BooleanProperty
get "possibleValues"(): $Collection<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanProperty$$Type = ($BooleanProperty);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BooleanProperty$$Original = $BooleanProperty;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$SpikeFeature$EndSpike, $SpikeFeature$EndSpike$$Type} from "net.minecraft.world.level.levelgen.feature.SpikeFeature$EndSpike"

export class $SpikeConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($SpikeConfiguration)>

constructor(arg0: boolean, arg1: $List$$Type<($SpikeFeature$EndSpike$$Type)>, arg2: $BlockPos$$Type)

public "getSpikes"(): $List<($SpikeFeature$EndSpike)>
public "getCrystalBeamTarget"(): $BlockPos
public "isCrystalInvulnerable"(): boolean
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "spikes"(): $List<($SpikeFeature$EndSpike)>
get "crystalBeamTarget"(): $BlockPos
get "crystalInvulnerable"(): boolean
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpikeConfiguration$$Type = ($SpikeConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpikeConfiguration$$Original = $SpikeConfiguration;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.AllOfPredicate" {
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$CombiningPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.CombiningPredicate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AllOfPredicate extends $CombiningPredicate {
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllOfPredicate$$Type = ($AllOfPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllOfPredicate$$Original = $AllOfPredicate;}
declare module "net.minecraft.world.level.levelgen.structure.Structure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$StructureSpawnOverride} from "net.minecraft.world.level.levelgen.structure.StructureSpawnOverride"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$GenerationStep$Decoration} from "net.minecraft.world.level.levelgen.GenerationStep$Decoration"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$HolderSet} from "net.minecraft.core.HolderSet"
import {$TerrainAdjustment} from "net.minecraft.world.level.levelgen.structure.TerrainAdjustment"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$Map} from "java.util.Map"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$RecordCodecBuilder$Instance$$Type} from "com.mojang.serialization.codecs.RecordCodecBuilder$Instance"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StructureStart} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$RecordCodecBuilder} from "com.mojang.serialization.codecs.RecordCodecBuilder"
import {$MobCategory} from "net.minecraft.world.entity.MobCategory"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$PiecesContainer$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings, $Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$ModifiableStructureInfo} from "net.neoforged.neoforge.common.world.ModifiableStructureInfo"

export class $Structure {
static readonly "CODEC": $Codec<($Holder<($Structure)>)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

public static "simpleCodec"<S extends $Structure>(arg0: $Function$$Type<($Structure$StructureSettings), (S)>): $MapCodec<(S)>
public "modifiableStructureInfo"(): $ModifiableStructureInfo
public static "settingsCodec"<S extends $Structure>(arg0: $RecordCodecBuilder$Instance$$Type<(S)>): $RecordCodecBuilder<(S), ($Structure$StructureSettings)>
public "spawnOverrides"(): $Map<($MobCategory), ($StructureSpawnOverride)>
public "terrainAdaptation"(): $TerrainAdjustment
public "adjustBoundingBox"(arg0: $BoundingBox$$Type): $BoundingBox
public "findValidGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "afterPlace"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BoundingBox$$Type, arg5: $ChunkPos$$Type, arg6: $PiecesContainer$$Type): void
public static "getMeanFirstOccupiedHeight"(arg0: $Structure$GenerationContext$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer): integer
public "type"(): $StructureType<(never)>
public "step"(): $GenerationStep$Decoration
public "generate"(arg0: $RegistryAccess$$Type, arg1: $ChunkGenerator$$Type, arg2: $BiomeSource$$Type, arg3: $RandomState$$Type, arg4: $StructureTemplateManager$$Type, arg5: long, arg6: $ChunkPos$$Type, arg7: integer, arg8: $LevelHeightAccessor$$Type, arg9: $Predicate$$Type<($Holder<($Biome)>)>): $StructureStart
public "getModifiedStructureSettings"(): $Structure$StructureSettings
public "biomes"(): $HolderSet<($Biome)>
public static set "tingsCodec"(value: $RecordCodecBuilder$Instance$$Type<(S)>)
get "modifiedStructureSettings"(): $Structure$StructureSettings
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructure
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructureTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$$Type = (Special.WorldgenStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Structure$$Original = $Structure;}
declare module "net.minecraft.world.level.material.WaterFluid$Flowing" {
import {$WaterFluid} from "net.minecraft.world.level.material.WaterFluid"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$Holder} from "net.minecraft.core.Holder"

export class $WaterFluid$Flowing extends $WaterFluid {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty

constructor()

public "isSource"(arg0: $FluidState$$Type): boolean
public "getAmount"(arg0: $FluidState$$Type): integer
public "asHolder"(): $Holder
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WaterFluid$Flowing$$Type = ($WaterFluid$Flowing);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WaterFluid$Flowing$$Original = $WaterFluid$Flowing;}
declare module "net.minecraft.world.level.block.PipeBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Map} from "java.util.Map"
import {$Direction} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PipeBlock extends $Block {
static readonly "DOWN": $BooleanProperty
static readonly "WEST": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
static readonly "NORTH": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "SOUTH": $BooleanProperty
static readonly "UP": $BooleanProperty
static readonly "EAST": $BooleanProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "PROPERTY_BY_DIRECTION": $Map<($Direction), ($BooleanProperty)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: float, arg1: $BlockBehaviour$Properties$$Type)

public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PipeBlock$$Type = ($PipeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PipeBlock$$Original = $PipeBlock;}
declare module "net.minecraft.world.level.block.state.properties.WallSide" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $WallSide extends $Enum<($WallSide)> implements $StringRepresentable$$Interface {
static readonly "LOW": $WallSide
static readonly "TALL": $WallSide
static readonly "NONE": $WallSide

public "toString"(): StringJS
public static "values"(): ($WallSide)[]
public static "valueOf"(arg0: StringJS): $WallSide
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallSide$$Type = (("none") | ("low") | ("tall"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallSide$$Original = $WallSide;}
declare module "net.minecraft.world.level.block.BigDripleafBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $BigDripleafBlock extends $HorizontalDirectionalBlock implements $BonemealableBlock$$Interface, $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BigDripleafBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public static "placeWithRandomHeight"(arg0: $LevelAccessor$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): void
public "codec"(): $MapCodec<($BigDripleafBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BigDripleafBlock$$Type = ($BigDripleafBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BigDripleafBlock$$Original = $BigDripleafBlock;}
declare module "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalStructure$Setup" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$RuinedPortalPiece$VerticalPlacement, $RuinedPortalPiece$VerticalPlacement$$Type} from "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalPiece$VerticalPlacement"
import {$Record} from "java.lang.Record"

export class $RuinedPortalStructure$Setup extends $Record {
static readonly "CODEC": $Codec<($RuinedPortalStructure$Setup)>

constructor(arg0: $RuinedPortalPiece$VerticalPlacement$$Type, arg1: float, arg2: float, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: float)

public "vines"(): boolean
public "placement"(): $RuinedPortalPiece$VerticalPlacement
public "mossiness"(): float
public "replaceWithBlackstone"(): boolean
public "overgrown"(): boolean
public "airPocketProbability"(): float
public "canBeCold"(): boolean
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "weight"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuinedPortalStructure$Setup$$Type = ({"mossiness"?: float, "replaceWithBlackstone"?: boolean, "placement"?: $RuinedPortalPiece$VerticalPlacement$$Type, "airPocketProbability"?: float, "overgrown"?: boolean, "canBeCold"?: boolean, "vines"?: boolean, "weight"?: float}) | ([mossiness?: float, replaceWithBlackstone?: boolean, placement?: $RuinedPortalPiece$VerticalPlacement$$Type, airPocketProbability?: float, overgrown?: boolean, canBeCold?: boolean, vines?: boolean, weight?: float]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuinedPortalStructure$Setup$$Original = $RuinedPortalStructure$Setup;}
declare module "net.minecraft.world.level.block.PressurePlateBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BasePressurePlateBlock} from "net.minecraft.world.level.block.BasePressurePlateBlock"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PressurePlateBlock extends $BasePressurePlateBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PressurePlateBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockSetType$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($PressurePlateBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressurePlateBlock$$Type = ($PressurePlateBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PressurePlateBlock$$Original = $PressurePlateBlock;}
declare module "net.minecraft.world.level.block.state.properties.ChestType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $ChestType extends $Enum<($ChestType)> implements $StringRepresentable$$Interface {
static readonly "SINGLE": $ChestType
static readonly "LEFT": $ChestType
static readonly "RIGHT": $ChestType

public static "values"(): ($ChestType)[]
public static "valueOf"(arg0: StringJS): $ChestType
public "getSerializedName"(): StringJS
public "getOpposite"(): $ChestType
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "opposite"(): $ChestType
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestType$$Type = (("single") | ("left") | ("right"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestType$$Original = $ChestType;}
declare module "net.minecraft.world.level.levelgen.structure.StructureSpawnOverride" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureSpawnOverride$BoundingBoxType, $StructureSpawnOverride$BoundingBoxType$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSpawnOverride$BoundingBoxType"
import {$WeightedRandomList, $WeightedRandomList$$Type} from "net.minecraft.util.random.WeightedRandomList"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$$Type} from "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData"
import {$Record} from "java.lang.Record"

export class $StructureSpawnOverride extends $Record {
static readonly "CODEC": $Codec<($StructureSpawnOverride)>

constructor(arg0: $StructureSpawnOverride$BoundingBoxType$$Type, arg1: $WeightedRandomList$$Type<($MobSpawnSettings$SpawnerData$$Type)>)

public "boundingBox"(): $StructureSpawnOverride$BoundingBoxType
public "spawns"(): $WeightedRandomList<($MobSpawnSettings$SpawnerData)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureSpawnOverride$$Type = ({"boundingBox"?: $StructureSpawnOverride$BoundingBoxType$$Type, "spawns"?: $WeightedRandomList$$Type<($MobSpawnSettings$SpawnerData$$Type)>}) | ([boundingBox?: $StructureSpawnOverride$BoundingBoxType$$Type, spawns?: $WeightedRandomList$$Type<($MobSpawnSettings$SpawnerData$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureSpawnOverride$$Original = $StructureSpawnOverride;}
declare module "net.minecraft.world.level.levelgen.feature.BasaltColumnsFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration, $ColumnFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $BasaltColumnsFeature extends $Feature<($ColumnFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($ColumnFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($ColumnFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasaltColumnsFeature$$Type = ($BasaltColumnsFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasaltColumnsFeature$$Original = $BasaltColumnsFeature;}
declare module "net.minecraft.world.level.block.CakeBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CakeBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
static readonly "FULL_CAKE_SIGNAL": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CakeBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "MAX_BITES": integer
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "BITES": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public static "getOutputSignal"(arg0: integer): integer
public "codec"(): $MapCodec<($CakeBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CakeBlock$$Type = ($CakeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CakeBlock$$Original = $CakeBlock;}
declare module "net.minecraft.world.level.block.entity.CampfireBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$RecipeHolder} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CampfireCookingRecipe} from "net.minecraft.world.item.crafting.CampfireCookingRecipe"

export class $CampfireBlockEntity extends $BlockEntity implements $Clearable$$Interface, $SleepingBlockEntity$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS
readonly "cookingTime": (integer)[]
readonly "cookingProgress": (integer)[]

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "dowse"(): void
public "getUpdatePacket"(): $Packet
public "clearContent"(): void
public static "cookTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CampfireBlockEntity$$Type): void
public static "cooldownTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CampfireBlockEntity$$Type): void
public "getCookableRecipe"(arg0: $ItemStack$$Type): $Optional<($RecipeHolder<($CampfireCookingRecipe)>)>
public "placeFood"(arg0: $LivingEntity$$Type, arg1: $ItemStack$$Type, arg2: integer): boolean
public "getItems"(): $NonNullList<($ItemStack)>
public static "particleTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CampfireBlockEntity$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public static "tryClear"(arg0: any): void
public "lithium$startSleeping"(): boolean
public "wakeUpNow"(): void
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "sleepOnlyCurrentTick"(): void
public "isSleeping"(): boolean
get "updatePacket"(): $Packet
get "items"(): $NonNullList<($ItemStack)>
set "ticker"(value: $TickingBlockEntity$$Type)
get "sleeping"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CampfireBlockEntity$$Type = ($CampfireBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CampfireBlockEntity$$Original = $CampfireBlockEntity;}
declare module "net.minecraft.world.level.BlockGetter" {
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor, $LevelHeightAccessor$$Interface} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$IBlockGetterExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBlockGetterExtension"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockGetter$$Interface extends $LevelHeightAccessor$$Interface, $IBlockGetterExtension$$Interface {
get "maxLightLevel"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $BlockGetter implements $BlockGetter$$Interface {
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getHeight"(): integer
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMinBuildHeight"(): integer
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockGetter$$Type = ($BlockGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockGetter$$Original = $BlockGetter;}
declare module "net.minecraft.world.level.levelgen.feature.AbstractHugeMushroomFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration, $HugeMushroomFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $AbstractHugeMushroomFeature extends $Feature<($HugeMushroomFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($HugeMushroomFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($HugeMushroomFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractHugeMushroomFeature$$Type = ($AbstractHugeMushroomFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractHugeMushroomFeature$$Original = $AbstractHugeMushroomFeature;}
declare module "net.minecraft.world.level.block.TallFlowerBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$DoubleBlockHalf} from "net.minecraft.world.level.block.state.properties.DoubleBlockHalf"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$DoublePlantBlock} from "net.minecraft.world.level.block.DoublePlantBlock"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TallFlowerBlock extends $DoublePlantBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TallFlowerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($DoubleBlockHalf)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "codec"(): $MapCodec<($TallFlowerBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TallFlowerBlock$$Type = ($TallFlowerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TallFlowerBlock$$Original = $TallFlowerBlock;}
declare module "net.minecraft.world.level.storage.LevelVersion" {
import {$Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$DataVersion} from "net.minecraft.world.level.storage.DataVersion"

export class $LevelVersion {
public "snapshot"(): boolean
public static "parse"(arg0: $Dynamic$$Type<(never)>): $LevelVersion
public "levelDataVersion"(): integer
public "lastPlayed"(): long
public "minecraftVersionName"(): StringJS
public "minecraftVersion"(): $DataVersion
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelVersion$$Type = ($LevelVersion);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelVersion$$Original = $LevelVersion;}
declare module "net.minecraft.world.level.block.CopperBulbBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CopperBulbBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CopperBulbBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "checkAndFlip"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CopperBulbBlock$$Type = ($CopperBulbBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CopperBulbBlock$$Original = $CopperBulbBlock;}
declare module "net.minecraft.world.level.biome.Biome$TemperatureModifier" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $Biome$TemperatureModifier extends $Enum<($Biome$TemperatureModifier)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($Biome$TemperatureModifier)>
static readonly "NONE": $Biome$TemperatureModifier
static readonly "FROZEN": $Biome$TemperatureModifier

public "modifyTemperature"(arg0: $BlockPos$$Type, arg1: float): float
public "getName"(): StringJS
public static "values"(): ($Biome$TemperatureModifier)[]
public static "valueOf"(arg0: StringJS): $Biome$TemperatureModifier
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "name"(): StringJS
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Biome$TemperatureModifier$$Type = (("none") | ("frozen"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Biome$TemperatureModifier$$Original = $Biome$TemperatureModifier;}
declare module "net.minecraft.world.level.levelgen.flat.FlatLevelGeneratorSettings" {
import {$StructureSet, $StructureSet$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSet"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List, $List$$Type} from "java.util.List"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$HolderGetter$$Type} from "net.minecraft.core.HolderGetter"
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$FlatLayerInfo, $FlatLayerInfo$$Type} from "net.minecraft.world.level.levelgen.flat.FlatLayerInfo"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BiomeGenerationSettings} from "net.minecraft.world.level.biome.BiomeGenerationSettings"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $FlatLevelGeneratorSettings {
static readonly "CODEC": $Codec<($FlatLevelGeneratorSettings)>

constructor(arg0: ($HolderSet$$Type<($StructureSet$$Type)>)?, arg1: $Holder$$Type<($Biome)>, arg2: $List$$Type<($Holder$$Type<($PlacedFeature$$Type)>)>)

public "adjustGenerationSettings"(arg0: $Holder$$Type<($Biome)>): $BiomeGenerationSettings
public "structureOverrides"(): $Optional<($HolderSet<($StructureSet)>)>
public "setAddLakes"(): void
public "setDecoration"(): void
public "withBiomeAndLayers"(arg0: $List$$Type<($FlatLayerInfo$$Type)>, arg1: ($HolderSet$$Type<($StructureSet$$Type)>)?, arg2: $Holder$$Type<($Biome)>): $FlatLevelGeneratorSettings
public "getLayersInfo"(): $List<($FlatLayerInfo)>
public static "getDefaultBiome"(arg0: $HolderGetter$$Type<($Biome$$Type)>): $Holder<($Biome)>
public static "createLakesList"(arg0: $HolderGetter$$Type<($PlacedFeature$$Type)>): $List<($Holder<($PlacedFeature)>)>
public static "getDefault"(arg0: $HolderGetter$$Type<($Biome$$Type)>, arg1: $HolderGetter$$Type<($StructureSet$$Type)>, arg2: $HolderGetter$$Type<($PlacedFeature$$Type)>): $FlatLevelGeneratorSettings
public "getBiome"(): $Holder<($Biome)>
public "updateLayers"(): void
public "getLayers"(): $List<($BlockState)>
get "addLakes"(): void
get "decoration"(): void
get "layersInfo"(): $List<($FlatLayerInfo)>
get "biome"(): $Holder<($Biome)>
get "layers"(): $List<($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlatLevelGeneratorSettings$$Type = ($FlatLevelGeneratorSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlatLevelGeneratorSettings$$Original = $FlatLevelGeneratorSettings;}
declare module "net.minecraft.world.level.block.EnchantingTableBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EnchantingTableBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($EnchantingTableBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "BOOKSHELF_OFFSETS": $List<($BlockPos)>
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public static "isValidBookShelf"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type): boolean
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($EnchantingTableBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantingTableBlock$$Type = ($EnchantingTableBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnchantingTableBlock$$Original = $EnchantingTableBlock;}
declare module "net.minecraft.world.level.block.NetherrackBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NetherrackBlock extends $Block implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($NetherrackBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getType"(): $BonemealableBlock$Type
public "codec"(): $MapCodec<($NetherrackBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherrackBlock$$Type = ($NetherrackBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherrackBlock$$Original = $NetherrackBlock;}
declare module "net.minecraft.world.level.block.SuspiciousEffectHolder" {
import {$SuspiciousStewEffects, $SuspiciousStewEffects$$Type} from "net.minecraft.world.item.component.SuspiciousStewEffects"
import {$List} from "java.util.List"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"

export interface $SuspiciousEffectHolder$$Interface {

(): $SuspiciousStewEffects$$Type
public static get "allEffectHolders"(): $List<($SuspiciousEffectHolder)>
get "suspiciousEffects"(): $SuspiciousStewEffects
}

export class $SuspiciousEffectHolder implements $SuspiciousEffectHolder$$Interface {
static "getAllEffectHolders"(): $List<($SuspiciousEffectHolder)>
 "getSuspiciousEffects"(): $SuspiciousStewEffects
static "tryGet"(arg0: $ItemLike$$Type): $SuspiciousEffectHolder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SuspiciousEffectHolder$$Type = (() => $SuspiciousStewEffects$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SuspiciousEffectHolder$$Original = $SuspiciousEffectHolder;}
declare module "net.minecraft.world.level.levelgen.carver.CarverConfiguration" {
import {$VerticalAnchor, $VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"
import {$CarverDebugSettings, $CarverDebugSettings$$Type} from "net.minecraft.world.level.levelgen.carver.CarverDebugSettings"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider, $HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $CarverConfiguration extends $ProbabilityFeatureConfiguration {
readonly "lavaLevel": $VerticalAnchor
readonly "debugSettings": $CarverDebugSettings
static readonly "CODEC": $MapCodec<($CarverConfiguration)>
readonly "probability": float
readonly "replaceable": $HolderSet<($Block)>
readonly "y": $HeightProvider
readonly "yScale": $FloatProvider

constructor(arg0: float, arg1: $HeightProvider$$Type, arg2: $FloatProvider$$Type, arg3: $VerticalAnchor$$Type, arg4: $CarverDebugSettings$$Type, arg5: $HolderSet$$Type<($Block)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarverConfiguration$$Type = ($CarverConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarverConfiguration$$Original = $CarverConfiguration;}
declare module "net.minecraft.world.level.levelgen.feature.SeagrassFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $SeagrassFeature extends $Feature<($ProbabilityFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($ProbabilityFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($ProbabilityFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeagrassFeature$$Type = ($SeagrassFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SeagrassFeature$$Original = $SeagrassFeature;}
declare module "net.minecraft.world.level.GameRules" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"
import {$GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$GameRulesKJS$$Interface} from "dev.latvian.mods.kubejs.core.GameRulesKJS"
import {$GameRules$Category$$Type} from "net.minecraft.world.level.GameRules$Category"
import {$GameRules$GameRuleTypeVisitor$$Type} from "net.minecraft.world.level.GameRules$GameRuleTypeVisitor"
import {$GameRules$BooleanValue, $GameRules$BooleanValue$$Type} from "net.minecraft.world.level.GameRules$BooleanValue"
import {$DynamicLike$$Type} from "com.mojang.serialization.DynamicLike"
import {$GameRules$Key, $GameRules$Key$$Type} from "net.minecraft.world.level.GameRules$Key"
import {$GameRules$IntegerValue, $GameRules$IntegerValue$$Type} from "net.minecraft.world.level.GameRules$IntegerValue"
import {$MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $GameRules implements $GameRulesKJS$$Interface {
static readonly "RULE_MAX_COMMAND_CHAIN_LENGTH": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_DROWNING_DAMAGE": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_LOGADMINCOMMANDS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_REDUCEDDEBUGINFO": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_WEATHER_CYCLE": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_FORGIVE_DEAD_PLAYERS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "DEFAULT_RANDOM_TICK_SPEED": integer
static readonly "RULE_TNT_EXPLOSION_DROP_DECAY": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_NATURAL_REGENERATION": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DISABLE_ELYTRA_MOVEMENT_CHECK": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_COMMAND_MODIFICATION_BLOCK_LIMIT": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_SPAWN_CHUNK_RADIUS": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_ANNOUNCE_ADVANCEMENTS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_COMMANDBLOCKOUTPUT": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOMOBSPAWNING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_PROJECTILESCANBREAKBLOCKS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DAYLIGHT": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DISABLE_RAIDS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_FIRE_DAMAGE": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_PLAYERS_SLEEPING_PERCENTAGE": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_WATER_SOURCE_CONVERSION": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOBLOCKDROPS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_BLOCK_EXPLOSION_DROP_DECAY": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_SPECTATORSGENERATECHUNKS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DO_VINES_SPREAD": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DO_IMMEDIATE_RESPAWN": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOENTITYDROPS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_KEEPINVENTORY": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_RANDOMTICKING": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_DO_TRADER_SPAWNING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOMOBLOOT": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_GLOBAL_SOUND_EVENTS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DO_PATROL_SPAWNING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_PLAYERS_NETHER_PORTAL_DEFAULT_DELAY": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_FALL_DAMAGE": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOINSOMNIA": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_MOB_EXPLOSION_DROP_DECAY": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_LIMITED_CRAFTING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DO_WARDEN_SPAWNING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOFIRETICK": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_MOBGRIEFING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_PLAYERS_NETHER_PORTAL_CREATIVE_DELAY": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_SHOWDEATHMESSAGES": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_MAX_ENTITY_CRAMMING": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_SPAWN_RADIUS": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_UNIVERSAL_ANGER": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_FREEZE_DAMAGE": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_SNOW_ACCUMULATION_HEIGHT": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_LAVA_SOURCE_CONVERSION": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_SENDCOMMANDFEEDBACK": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_MAX_COMMAND_FORK_COUNT": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_ENDER_PEARLS_VANISH_ON_DEATH": $GameRules$Key<($GameRules$BooleanValue)>

constructor()
constructor(arg0: $DynamicLike$$Type<(never)>)

public static "visitGameRuleTypes"(arg0: $GameRules$GameRuleTypeVisitor$$Type): void
public "set"(rule: StringJS, value: StringJS): void
public "get"(rule: StringJS): $GameRules$Value
public "createTag"(): $CompoundTag
public "getBoolean"(arg0: $GameRules$Key$$Type<($GameRules$BooleanValue$$Type)>): boolean
public "getInt"(arg0: $GameRules$Key$$Type<($GameRules$IntegerValue$$Type)>): integer
public static "register"<T extends $GameRules$Value<(object)>>(arg0: StringJS, arg1: $GameRules$Category$$Type, arg2: $GameRules$Type$$Type<(T)>): $GameRules$Key<(T)>
public "copy"(): $GameRules
public "getRule"<T extends $GameRules$Value<(object)>>(arg0: $GameRules$Key$$Type<(T)>): T
public "assignFrom"(arg0: $GameRules$$Type, arg1: $MinecraftServer$$Type): void
public "kjs$getString"(rule: StringJS): StringJS
public "kjs$getBoolean"(rule: StringJS): boolean
public "kjs$getInt"(rule: StringJS): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$$Type = ($GameRules);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$$Original = $GameRules;}
declare module "net.minecraft.world.level.biome.BiomeSpecialEffects" {
import {$AmbientMoodSettings} from "net.minecraft.world.level.biome.AmbientMoodSettings"
import {$BiomeSpecialEffects$GrassColorModifier} from "net.minecraft.world.level.biome.BiomeSpecialEffects$GrassColorModifier"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$AmbientParticleSettings} from "net.minecraft.world.level.biome.AmbientParticleSettings"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$AmbientAdditionsSettings} from "net.minecraft.world.level.biome.AmbientAdditionsSettings"
import {$Holder} from "net.minecraft.core.Holder"
import {$Music} from "net.minecraft.sounds.Music"

export class $BiomeSpecialEffects {
 "skyColor": integer
static readonly "CODEC": $Codec<($BiomeSpecialEffects)>
 "waterFogColor": integer
 "ambientLoopSoundEvent": $Optional<($Holder<($SoundEvent)>)>
 "foliageColorOverride": $Optional<(integer)>
 "grassColorOverride": $Optional<(integer)>
 "ambientAdditionsSettings": $Optional<($AmbientAdditionsSettings)>
 "ambientParticleSettings": $Optional<($AmbientParticleSettings)>
 "waterColor": integer
 "backgroundMusic": $Optional<($Music)>
 "grassColorModifier": $BiomeSpecialEffects$GrassColorModifier
 "fogColor": integer
 "ambientMoodSettings": $Optional<($AmbientMoodSettings)>

public "getGrassColorOverride"(): $Optional<(integer)>
public "getGrassColorModifier"(): $BiomeSpecialEffects$GrassColorModifier
public "getFoliageColorOverride"(): $Optional<(integer)>
public "getFogColor"(): integer
public "getWaterColor"(): integer
public "getWaterFogColor"(): integer
public "getAmbientParticleSettings"(): $Optional<($AmbientParticleSettings)>
public "getAmbientLoopSoundEvent"(): $Optional<($Holder<($SoundEvent)>)>
public "getAmbientMoodSettings"(): $Optional<($AmbientMoodSettings)>
public "getAmbientAdditionsSettings"(): $Optional<($AmbientAdditionsSettings)>
public "getBackgroundMusic"(): $Optional<($Music)>
public "getSkyColor"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeSpecialEffects$$Type = ($BiomeSpecialEffects);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeSpecialEffects$$Original = $BiomeSpecialEffects;}
declare module "net.minecraft.world.level.levelgen.SurfaceRules$Context" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $SurfaceRules$Context {
public "updateY"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceRules$Context$$Type = ($SurfaceRules$Context);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SurfaceRules$Context$$Original = $SurfaceRules$Context;}
declare module "net.minecraft.world.level.levelgen.feature.SpringFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration, $SpringConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $SpringFeature extends $Feature<($SpringConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($SpringConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($SpringConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpringFeature$$Type = ($SpringFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpringFeature$$Original = $SpringFeature;}
declare module "net.minecraft.world.level.storage.LevelStorageSource$LevelStorageAccess" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$PlayerDataStorage} from "net.minecraft.world.level.storage.PlayerDataStorage"
import {$Optional} from "java.util.Optional"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$Dynamic, $Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$LevelStorageSource$LevelDirectory} from "net.minecraft.world.level.storage.LevelStorageSource$LevelDirectory"
import {$LevelResource$$Type} from "net.minecraft.world.level.storage.LevelResource"
import {$LevelStorageSource} from "net.minecraft.world.level.storage.LevelStorageSource"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$WorldData$$Type} from "net.minecraft.world.level.storage.WorldData"
import {$Path} from "java.nio.file.Path"
import {$LevelSummary} from "net.minecraft.world.level.storage.LevelSummary"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$Instant} from "java.time.Instant"

export class $LevelStorageSource$LevelStorageAccess implements $AutoCloseable$$Interface {
public "getWorldDir"(): $Path
public "checkForLowDiskSpace"(): boolean
public "estimateDiskSpace"(): long
public "getDataTagFallback"(): $Dynamic<(never)>
public "renameLevel"(arg0: StringJS): void
public "renameAndDropPlayer"(arg0: StringJS): void
public "makeWorldBackup"(): long
public "restoreLevelDataFromOld"(): boolean
public "getDataTag"(): $Dynamic<(never)>
public "safeClose"(): void
public "getDimensionPath"(arg0: $ResourceKey$$Type<($Level)>): $Path
public "getLevelDirectory"(): $LevelStorageSource$LevelDirectory
public "readAdditionalLevelSaveData"(arg0: boolean): void
public "createPlayerStorage"(): $PlayerDataStorage
public "parent"(): $LevelStorageSource
public "close"(): void
public "saveDataTag"(arg0: $RegistryAccess$$Type, arg1: $WorldData$$Type): void
public "saveDataTag"(arg0: $RegistryAccess$$Type, arg1: $WorldData$$Type, arg2: $CompoundTag$$Type): void
public "getLevelId"(): StringJS
public "getLevelPath"(arg0: $LevelResource$$Type): $Path
public "getIconFile"(): $Optional<($Path)>
public "getFileModificationTime"(arg0: boolean): $Instant
public "getSummary"(arg0: $Dynamic$$Type<(never)>): $LevelSummary
public "hasWorldData"(): boolean
public "deleteLevel"(): void
get "worldDir"(): $Path
get "dataTagFallback"(): $Dynamic<(never)>
get "dataTag"(): $Dynamic<(never)>
get "levelDirectory"(): $LevelStorageSource$LevelDirectory
get "levelId"(): StringJS
get "iconFile"(): $Optional<($Path)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelStorageSource$LevelStorageAccess$$Type = ($LevelStorageSource$LevelStorageAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelStorageSource$LevelStorageAccess$$Original = $LevelStorageSource$LevelStorageAccess;}
declare module "net.minecraft.world.level.block.AbstractCandleBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractCandleBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "LIGHT_PER_CANDLE": integer

public static "isLit"(arg0: $BlockState$$Type): boolean
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "extinguish"(arg0: $Player$$Type, arg1: $BlockState$$Type, arg2: $LevelAccessor$$Type, arg3: $BlockPos$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractCandleBlock$$Type = ($AbstractCandleBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractCandleBlock$$Original = $AbstractCandleBlock;}
declare module "net.minecraft.world.level.levelgen.carver.ConfiguredWorldCarver" {
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Aquifer$$Type} from "net.minecraft.world.level.levelgen.Aquifer"
import {$CarvingContext$$Type} from "net.minecraft.world.level.levelgen.carver.CarvingContext"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$CarvingMask$$Type} from "net.minecraft.world.level.chunk.CarvingMask"
import {$WorldCarver, $WorldCarver$$Type} from "net.minecraft.world.level.levelgen.carver.WorldCarver"
import {$HolderSet} from "net.minecraft.core.HolderSet"
import {$CarverConfiguration, $CarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CarverConfiguration"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$Record} from "java.lang.Record"

export class $ConfiguredWorldCarver<WC extends $CarverConfiguration> extends $Record {
static readonly "CODEC": $Codec<($Holder<($ConfiguredWorldCarver<(never)>)>)>
static readonly "DIRECT_CODEC": $Codec<($ConfiguredWorldCarver<(never)>)>
static readonly "LIST_CODEC": $Codec<($HolderSet<($ConfiguredWorldCarver<(never)>)>)>

constructor(arg0: $WorldCarver$$Type<(WC)>, arg1: WC)

public "carve"(arg0: $CarvingContext$$Type, arg1: $ChunkAccess$$Type, arg2: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg3: $RandomSource$$Type, arg4: $Aquifer$$Type, arg5: $ChunkPos$$Type, arg6: $CarvingMask$$Type): boolean
public "isStartChunk"(arg0: $RandomSource$$Type): boolean
public "worldCarver"(): $WorldCarver<(WC)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "config"(): WC
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenConfiguredCarver
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenConfiguredCarverTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfiguredWorldCarver$$Type<WC> = (Special.WorldgenConfiguredCarver) | ({"worldCarver"?: $WorldCarver$$Type<(WC)>, "config"?: WC}) | ([worldCarver?: $WorldCarver$$Type<(WC)>, config?: WC]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConfiguredWorldCarver$$Original<WC> = $ConfiguredWorldCarver<(WC)>;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType" {
import {$BushFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.BushFoliagePlacer"
import {$DarkOakFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.DarkOakFoliagePlacer"
import {$FancyFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FancyFoliagePlacer"
import {$BlobFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.BlobFoliagePlacer"
import {$SpruceFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.SpruceFoliagePlacer"
import {$AcaciaFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.AcaciaFoliagePlacer"
import {$PineFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.PineFoliagePlacer"
import {$MegaPineFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.MegaPineFoliagePlacer"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$RandomSpreadFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.RandomSpreadFoliagePlacer"
import {$MegaJungleFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.MegaJungleFoliagePlacer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$CherryFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.CherryFoliagePlacer"

export class $FoliagePlacerType<P extends $FoliagePlacer> {
static readonly "MEGA_PINE_FOLIAGE_PLACER": $FoliagePlacerType<($MegaPineFoliagePlacer)>
static readonly "PINE_FOLIAGE_PLACER": $FoliagePlacerType<($PineFoliagePlacer)>
static readonly "RANDOM_SPREAD_FOLIAGE_PLACER": $FoliagePlacerType<($RandomSpreadFoliagePlacer)>
static readonly "MEGA_JUNGLE_FOLIAGE_PLACER": $FoliagePlacerType<($MegaJungleFoliagePlacer)>
static readonly "SPRUCE_FOLIAGE_PLACER": $FoliagePlacerType<($SpruceFoliagePlacer)>
static readonly "BUSH_FOLIAGE_PLACER": $FoliagePlacerType<($BushFoliagePlacer)>
static readonly "ACACIA_FOLIAGE_PLACER": $FoliagePlacerType<($AcaciaFoliagePlacer)>
static readonly "BLOB_FOLIAGE_PLACER": $FoliagePlacerType<($BlobFoliagePlacer)>
static readonly "DARK_OAK_FOLIAGE_PLACER": $FoliagePlacerType<($DarkOakFoliagePlacer)>
static readonly "CHERRY_FOLIAGE_PLACER": $FoliagePlacerType<($CherryFoliagePlacer)>
static readonly "FANCY_FOLIAGE_PLACER": $FoliagePlacerType<($FancyFoliagePlacer)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenFoliagePlacerType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenFoliagePlacerTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoliagePlacerType$$Type<P> = (Special.WorldgenFoliagePlacerType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoliagePlacerType$$Original<P> = $FoliagePlacerType<(P)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $PointedDripstoneConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($PointedDripstoneConfiguration)>
readonly "chanceOfTallerDripstone": float
readonly "chanceOfSpreadRadius3": float
readonly "chanceOfSpreadRadius2": float
readonly "chanceOfDirectionalSpread": float

constructor(arg0: float, arg1: float, arg2: float, arg3: float)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PointedDripstoneConfiguration$$Type = ($PointedDripstoneConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PointedDripstoneConfiguration$$Original = $PointedDripstoneConfiguration;}
declare module "net.minecraft.world.level.block.state.properties.BlockStateProperties" {
import {$WallSide} from "net.minecraft.world.level.block.state.properties.WallSide"
import {$TrialSpawnerState} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$ChestType} from "net.minecraft.world.level.block.state.properties.ChestType"
import {$Tilt} from "net.minecraft.world.level.block.state.properties.Tilt"
import {$DoubleBlockHalf} from "net.minecraft.world.level.block.state.properties.DoubleBlockHalf"
import {$Half} from "net.minecraft.world.level.block.state.properties.Half"
import {$DoorHingeSide} from "net.minecraft.world.level.block.state.properties.DoorHingeSide"
import {$SlabType} from "net.minecraft.world.level.block.state.properties.SlabType"
import {$StructureMode} from "net.minecraft.world.level.block.state.properties.StructureMode"
import {$NoteBlockInstrument} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$DripstoneThickness} from "net.minecraft.world.level.block.state.properties.DripstoneThickness"
import {$VaultState} from "net.minecraft.world.level.block.entity.vault.VaultState"
import {$BedPart} from "net.minecraft.world.level.block.state.properties.BedPart"
import {$StairsShape} from "net.minecraft.world.level.block.state.properties.StairsShape"
import {$RailShape} from "net.minecraft.world.level.block.state.properties.RailShape"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$SculkSensorPhase} from "net.minecraft.world.level.block.state.properties.SculkSensorPhase"
import {$PistonType} from "net.minecraft.world.level.block.state.properties.PistonType"
import {$BellAttachType} from "net.minecraft.world.level.block.state.properties.BellAttachType"
import {$ComparatorMode} from "net.minecraft.world.level.block.state.properties.ComparatorMode"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$FrontAndTop} from "net.minecraft.core.FrontAndTop"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BambooLeaves} from "net.minecraft.world.level.block.state.properties.BambooLeaves"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$RedstoneSide} from "net.minecraft.world.level.block.state.properties.RedstoneSide"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $BlockStateProperties {
static readonly "MAX_RESPAWN_ANCHOR_CHARGES": integer
static readonly "BAMBOO_LEAVES": $EnumProperty<($BambooLeaves)>
static readonly "HANGING": $BooleanProperty
static readonly "WEST_WALL": $EnumProperty<($WallSide)>
static readonly "CHISELED_BOOKSHELF_SLOT_5_OCCUPIED": $BooleanProperty
static readonly "BOTTOM": $BooleanProperty
static readonly "DUSTED": $IntegerProperty
static readonly "EYE": $BooleanProperty
static readonly "HALF": $EnumProperty<($Half)>
static readonly "DRAG": $BooleanProperty
static readonly "SOUTH": $BooleanProperty
static readonly "MIN_RESPAWN_ANCHOR_CHARGES": integer
static readonly "DISTANCE": $IntegerProperty
static readonly "LOCKED": $BooleanProperty
static readonly "EXTENDED": $BooleanProperty
static readonly "BLOOM": $BooleanProperty
static readonly "SCULK_SENSOR_PHASE": $EnumProperty<($SculkSensorPhase)>
static readonly "LEVEL": $IntegerProperty
static readonly "DOOR_HINGE": $EnumProperty<($DoorHingeSide)>
static readonly "STAIRS_SHAPE": $EnumProperty<($StairsShape)>
static readonly "EGGS": $IntegerProperty
static readonly "LAYERS": $IntegerProperty
static readonly "CONDITIONAL": $BooleanProperty
static readonly "EAST_WALL": $EnumProperty<($WallSide)>
static readonly "HATCH": $IntegerProperty
static readonly "ORIENTATION": $EnumProperty<($FrontAndTop)>
static readonly "LEVEL_CAULDRON": $IntegerProperty
static readonly "RAIL_SHAPE_STRAIGHT": $EnumProperty<($RailShape)>
static readonly "CHISELED_BOOKSHELF_SLOT_0_OCCUPIED": $BooleanProperty
static readonly "SIGNAL_FIRE": $BooleanProperty
static readonly "STRUCTUREBLOCK_MODE": $EnumProperty<($StructureMode)>
static readonly "PISTON_TYPE": $EnumProperty<($PistonType)>
static readonly "CAN_SUMMON": $BooleanProperty
static readonly "MIN_LEVEL": integer
static readonly "HAS_BOOK": $BooleanProperty
static readonly "OMINOUS": $BooleanProperty
static readonly "ATTACH_FACE": $EnumProperty<($AttachFace)>
static readonly "WATERLOGGED": $BooleanProperty
static readonly "SHRIEKING": $BooleanProperty
static readonly "FALLING": $BooleanProperty
static readonly "AGE_25": $IntegerProperty
static readonly "CRAFTING": $BooleanProperty
static readonly "TRIGGERED": $BooleanProperty
static readonly "MAX_LEVEL_8": integer
static readonly "CRACKED": $BooleanProperty
static readonly "CHISELED_BOOKSHELF_SLOT_4_OCCUPIED": $BooleanProperty
static readonly "UNSTABLE": $BooleanProperty
static readonly "CHEST_TYPE": $EnumProperty<($ChestType)>
static readonly "AGE_5": $IntegerProperty
static readonly "SOUTH_WALL": $EnumProperty<($WallSide)>
static readonly "AGE_4": $IntegerProperty
static readonly "AGE_7": $IntegerProperty
static readonly "STABILITY_MAX_DISTANCE": integer
static readonly "BELL_ATTACHMENT": $EnumProperty<($BellAttachType)>
static readonly "AGE_1": $IntegerProperty
static readonly "MAX_LEVEL_3": integer
static readonly "ATTACHED": $BooleanProperty
static readonly "AGE_3": $IntegerProperty
static readonly "STAGE": $IntegerProperty
static readonly "AGE_2": $IntegerProperty
static readonly "VAULT_STATE": $EnumProperty<($VaultState)>
static readonly "POWER": $IntegerProperty
static readonly "MAX_DISTANCE": integer
static readonly "HAS_BOTTLE_1": $BooleanProperty
static readonly "HAS_BOTTLE_0": $BooleanProperty
static readonly "PICKLES": $IntegerProperty
static readonly "HAS_BOTTLE_2": $BooleanProperty
static readonly "OPEN": $BooleanProperty
static readonly "DRIPSTONE_THICKNESS": $EnumProperty<($DripstoneThickness)>
static readonly "AGE_15": $IntegerProperty
static readonly "LEVEL_HONEY": $IntegerProperty
static readonly "CANDLES": $IntegerProperty
static readonly "LEVEL_COMPOSTER": $IntegerProperty
static readonly "LIT": $BooleanProperty
static readonly "EAST_REDSTONE": $EnumProperty<($RedstoneSide)>
static readonly "OCCUPIED": $BooleanProperty
static readonly "MODE_COMPARATOR": $EnumProperty<($ComparatorMode)>
static readonly "NORTH_REDSTONE": $EnumProperty<($RedstoneSide)>
static readonly "IN_WALL": $BooleanProperty
static readonly "SNOWY": $BooleanProperty
static readonly "DOWN": $BooleanProperty
static readonly "TRIAL_SPAWNER_STATE": $EnumProperty<($TrialSpawnerState)>
static readonly "WEST": $BooleanProperty
static readonly "CHISELED_BOOKSHELF_SLOT_2_OCCUPIED": $BooleanProperty
static readonly "NORTH_WALL": $EnumProperty<($WallSide)>
static readonly "MIN_LEVEL_CAULDRON": integer
static readonly "BED_PART": $EnumProperty<($BedPart)>
static readonly "NORTH": $BooleanProperty
static readonly "LEVEL_FLOWING": $IntegerProperty
static readonly "TILT": $EnumProperty<($Tilt)>
static readonly "UP": $BooleanProperty
static readonly "SOUTH_REDSTONE": $EnumProperty<($RedstoneSide)>
static readonly "MAX_AGE_15": integer
static readonly "HORIZONTAL_FACING": $DirectionProperty
static readonly "BITES": $IntegerProperty
static readonly "SLAB_TYPE": $EnumProperty<($SlabType)>
static readonly "MAX_AGE_2": integer
static readonly "MAX_AGE_1": integer
static readonly "ROTATION_16": $IntegerProperty
static readonly "CHISELED_BOOKSHELF_SLOT_1_OCCUPIED": $BooleanProperty
static readonly "MAX_AGE_7": integer
static readonly "STABILITY_DISTANCE": $IntegerProperty
static readonly "MAX_AGE_5": integer
static readonly "MAX_AGE_4": integer
static readonly "MAX_AGE_3": integer
static readonly "MAX_AGE_25": integer
static readonly "DELAY": $IntegerProperty
static readonly "AXIS": $EnumProperty<($Direction$Axis)>
static readonly "MAX_LEVEL_15": integer
static readonly "HORIZONTAL_AXIS": $EnumProperty<($Direction$Axis)>
static readonly "RAIL_SHAPE": $EnumProperty<($RailShape)>
static readonly "MOISTURE": $IntegerProperty
static readonly "VERTICAL_DIRECTION": $DirectionProperty
static readonly "FLOWER_AMOUNT": $IntegerProperty
static readonly "DOUBLE_BLOCK_HALF": $EnumProperty<($DoubleBlockHalf)>
static readonly "NOTE": $IntegerProperty
static readonly "BERRIES": $BooleanProperty
static readonly "RESPAWN_ANCHOR_CHARGES": $IntegerProperty
static readonly "EAST": $BooleanProperty
static readonly "PERSISTENT": $BooleanProperty
static readonly "HAS_RECORD": $BooleanProperty
static readonly "FACING_HOPPER": $DirectionProperty
static readonly "NOTEBLOCK_INSTRUMENT": $EnumProperty<($NoteBlockInstrument)>
static readonly "POWERED": $BooleanProperty
static readonly "SHORT": $BooleanProperty
static readonly "CHISELED_BOOKSHELF_SLOT_3_OCCUPIED": $BooleanProperty
static readonly "WEST_REDSTONE": $EnumProperty<($RedstoneSide)>
static readonly "ENABLED": $BooleanProperty
static readonly "INVERTED": $BooleanProperty
static readonly "FACING": $DirectionProperty
static readonly "DISARMED": $BooleanProperty

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateProperties$$Type = ($BlockStateProperties);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateProperties$$Original = $BlockStateProperties;}
declare module "net.minecraft.world.level.block.InfestedBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Map} from "java.util.Map"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $InfestedBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($InfestedBlock)>
static readonly "BLOCK_BY_HOST_BLOCK": $Map<($Block), ($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getHostBlock"(): $Block
public static "isCompatibleHostBlock"(arg0: $BlockState$$Type): boolean
public static "infestedStateByHost"(arg0: $BlockState$$Type): $BlockState
public "hostStateByInfested"(arg0: $BlockState$$Type): $BlockState
public "codec"(): $MapCodec<($InfestedBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "hostBlock"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InfestedBlock$$Type = ($InfestedBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InfestedBlock$$Original = $InfestedBlock;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.AcaciaFoliagePlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $AcaciaFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($AcaciaFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type)

public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AcaciaFoliagePlacer$$Type = ($AcaciaFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AcaciaFoliagePlacer$$Original = $AcaciaFoliagePlacer;}
declare module "net.minecraft.world.level.chunk.status.ChunkType" {
import {$Enum} from "java.lang.Enum"

export class $ChunkType extends $Enum<($ChunkType)> {
static readonly "LEVELCHUNK": $ChunkType
static readonly "PROTOCHUNK": $ChunkType

public static "values"(): ($ChunkType)[]
public static "valueOf"(arg0: StringJS): $ChunkType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkType$$Type = (("protochunk") | ("levelchunk"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkType$$Original = $ChunkType;}
declare module "net.minecraft.world.level.storage.loot.entries.AlternativesEntry$Builder" {
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$LootPoolEntryContainer} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$LootPoolEntryContainer$Builder, $LootPoolEntryContainer$Builder$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer$Builder"
import {$ConditionUserBuilder} from "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder"

export class $AlternativesEntry$Builder extends $LootPoolEntryContainer$Builder<($AlternativesEntry$Builder)> {
constructor(...arg0: ($LootPoolEntryContainer$Builder$$Type<(never)>)[])

public "otherwise"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $AlternativesEntry$Builder
public "build"(): $LootPoolEntryContainer
public "when"(arg0: $LootItemCondition$Builder$$Type): $ConditionUserBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlternativesEntry$Builder$$Type = ($AlternativesEntry$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AlternativesEntry$Builder$$Original = $AlternativesEntry$Builder;}
declare module "net.minecraft.world.level.entity.ChunkEntities" {
import {$List$$Type} from "java.util.List"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Stream} from "java.util.stream.Stream"

export class $ChunkEntities<T> {
constructor(arg0: $ChunkPos$$Type, arg1: $List$$Type<(T)>)

public "getEntities"(): $Stream<(T)>
public "isEmpty"(): boolean
public "getPos"(): $ChunkPos
get "entities"(): $Stream<(T)>
get "empty"(): boolean
get "pos"(): $ChunkPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkEntities$$Type<T> = ($ChunkEntities<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkEntities$$Original<T> = $ChunkEntities<(T)>;}
declare module "net.minecraft.world.level.entity.EntityInLevelCallback" {
import {$Entity$RemovalReason$$Type} from "net.minecraft.world.entity.Entity$RemovalReason"

export interface $EntityInLevelCallback$$Interface {
}

export class $EntityInLevelCallback implements $EntityInLevelCallback$$Interface {
static readonly "NULL": $EntityInLevelCallback

 "onMove"(): void
 "onRemove"(arg0: $Entity$RemovalReason$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityInLevelCallback$$Type = ($EntityInLevelCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityInLevelCallback$$Original = $EntityInLevelCallback;}
declare module "net.minecraft.world.level.block.MultifaceSpreader" {
import {$MultifaceSpreader$SpreadPredicate$$Type} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadPredicate"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$MultifaceBlock$$Type} from "net.minecraft.world.level.block.MultifaceBlock"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$MultifaceSpreader$SpreadType} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadType"
import {$MultifaceSpreader$SpreadPos, $MultifaceSpreader$SpreadPos$$Type} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadPos"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MultifaceSpreader$SpreadConfig$$Type} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadConfig"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MultifaceSpreader {
static readonly "DEFAULT_SPREAD_ORDER": ($MultifaceSpreader$SpreadType)[]

constructor(arg0: $MultifaceBlock$$Type)
constructor(arg0: $MultifaceSpreader$SpreadConfig$$Type)

public "spreadFromRandomFaceTowardRandomDirection"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($MultifaceSpreader$SpreadPos)>
public "canSpreadInAnyDirection"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "spreadAll"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: boolean): long
public "spreadFromFaceTowardRandomDirection"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $RandomSource$$Type, arg5: boolean): $Optional<($MultifaceSpreader$SpreadPos)>
public "spreadFromFaceTowardDirection"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $Direction$$Type, arg5: boolean): $Optional<($MultifaceSpreader$SpreadPos)>
public "getSpreadFromFaceTowardDirection"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $Direction$$Type, arg5: $MultifaceSpreader$SpreadPredicate$$Type): $Optional<($MultifaceSpreader$SpreadPos)>
public "spreadToFace"(arg0: $LevelAccessor$$Type, arg1: $MultifaceSpreader$SpreadPos$$Type, arg2: boolean): $Optional<($MultifaceSpreader$SpreadPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceSpreader$$Type = ($MultifaceSpreader);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceSpreader$$Original = $MultifaceSpreader;}
declare module "net.minecraft.world.level.dimension.DimensionType" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$OptionalLong, $OptionalLong$$Type} from "java.util.OptionalLong"
import {$Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IntProvider} from "net.minecraft.util.valueproviders.IntProvider"
import {$DimensionTypeAccessor$$Interface} from "net.irisshaders.iris.mixin.DimensionTypeAccessor"
import {$Holder} from "net.minecraft.core.Holder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$DimensionType$MonsterSettings, $DimensionType$MonsterSettings$$Type} from "net.minecraft.world.level.dimension.DimensionType$MonsterSettings"
import {$Record} from "java.lang.Record"

export class $DimensionType extends $Record implements $DimensionTypeAccessor$$Interface {
static readonly "MIN_Y": integer
static readonly "CODEC": $Codec<($Holder<($DimensionType)>)>
static readonly "MIN_HEIGHT": integer
static readonly "MAX_Y": integer
static readonly "Y_SIZE": integer
static readonly "WAY_ABOVE_MAX_Y": integer
static readonly "WAY_BELOW_MIN_Y": integer
static readonly "DIRECT_CODEC": $Codec<($DimensionType)>
static readonly "BITS_FOR_Y": integer
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Holder<($DimensionType)>)>
static readonly "MOON_BRIGHTNESS_PER_PHASE": (float)[]

constructor(arg0: $OptionalLong$$Type, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: double, arg6: boolean, arg7: boolean, arg8: integer, arg9: integer, arg10: integer, arg11: $TagKey$$Type<($Block)>, arg12: $ResourceLocation$$Type, arg13: float, arg14: $DimensionType$MonsterSettings$$Type)

public "ultraWarm"(): boolean
public "infiniburn"(): $TagKey<($Block)>
public "logicalHeight"(): integer
public "bedWorks"(): boolean
public static "getTeleportationScale"(arg0: $DimensionType$$Type, arg1: $DimensionType$$Type): double
public "respawnAnchorWorks"(): boolean
public "monsterSpawnBlockLightLimit"(): integer
public "monsterSpawnLightTest"(): $IntProvider
public "piglinSafe"(): boolean
public "fixedTime"(): $OptionalLong
public "effectsLocation"(): $ResourceLocation
public "monsterSettings"(): $DimensionType$MonsterSettings
public static "getStorageFolder"(arg0: $ResourceKey$$Type<($Level)>, arg1: $Path$$Type): $Path
public "hasRaids"(): boolean
public "getFixedTime"(): $OptionalLong
public "getAmbientLight"(): float
/**
 * 
 * @deprecated
 */
public static "parseLegacy"(arg0: $Dynamic$$Type<(never)>): $DataResult<($ResourceKey<($Level)>)>
public "timeOfDay"(arg0: long): float
public "minY"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "height"(): integer
public "natural"(): boolean
public "hasFixedTime"(): boolean
public "hasSkyLight"(): boolean
public "hasCeiling"(): boolean
public "coordinateScale"(): double
public "ambientLight"(): float
public "moonPhase"(arg0: long): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.DimensionType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.DimensionTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionType$$Type = (Special.DimensionType) | ({"minY"?: integer, "respawnAnchorWorks"?: boolean, "infiniburn"?: $TagKey$$Type<($Block)>, "coordinateScale"?: double, "fixedTime"?: $OptionalLong$$Type, "natural"?: boolean, "monsterSettings"?: $DimensionType$MonsterSettings$$Type, "effectsLocation"?: $ResourceLocation$$Type, "ambientLight"?: float, "hasSkyLight"?: boolean, "logicalHeight"?: integer, "hasCeiling"?: boolean, "height"?: integer, "bedWorks"?: boolean, "ultraWarm"?: boolean}) | ([minY?: integer, respawnAnchorWorks?: boolean, infiniburn?: $TagKey$$Type<($Block)>, coordinateScale?: double, fixedTime?: $OptionalLong$$Type, natural?: boolean, monsterSettings?: $DimensionType$MonsterSettings$$Type, effectsLocation?: $ResourceLocation$$Type, ambientLight?: float, hasSkyLight?: boolean, logicalHeight?: integer, hasCeiling?: boolean, height?: integer, bedWorks?: boolean, ultraWarm?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionType$$Original = $DimensionType;}
declare module "net.minecraft.world.level.entity.EntityPersistentStorage" {
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$ChunkEntities, $ChunkEntities$$Type} from "net.minecraft.world.level.entity.ChunkEntities"

export interface $EntityPersistentStorage$$Interface<T> extends $AutoCloseable$$Interface {
}

export class $EntityPersistentStorage<T> implements $EntityPersistentStorage$$Interface {
 "loadEntities"(arg0: $ChunkPos$$Type): $CompletableFuture<($ChunkEntities<(T)>)>
 "storeEntities"(arg0: $ChunkEntities$$Type<(T)>): void
 "flush"(arg0: boolean): void
 "close"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityPersistentStorage$$Type<T> = ($EntityPersistentStorage<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityPersistentStorage$$Original<T> = $EntityPersistentStorage<(T)>;}
declare module "net.minecraft.world.level.block.entity.BeehiveBlockEntity$Occupant" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$CustomData, $CustomData$$Type} from "net.minecraft.world.item.component.CustomData"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Record} from "java.lang.Record"

export class $BeehiveBlockEntity$Occupant extends $Record {
static readonly "CODEC": $Codec<($BeehiveBlockEntity$Occupant)>
static readonly "LIST_CODEC": $Codec<($List<($BeehiveBlockEntity$Occupant)>)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($BeehiveBlockEntity$Occupant)>

constructor(arg0: $CustomData$$Type, arg1: integer, arg2: integer)

public "ticksInHive"(): integer
public "minTicksInHive"(): integer
public "createEntity"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $Entity
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"(arg0: $Entity$$Type): $BeehiveBlockEntity$Occupant
public static "create"(arg0: integer): $BeehiveBlockEntity$Occupant
public "entityData"(): $CustomData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeehiveBlockEntity$Occupant$$Type = ({"minTicksInHive"?: integer, "ticksInHive"?: integer, "entityData"?: $CustomData$$Type}) | ([minTicksInHive?: integer, ticksInHive?: integer, entityData?: $CustomData$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeehiveBlockEntity$Occupant$$Original = $BeehiveBlockEntity$Occupant;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.StateTestingPredicate" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BiPredicate, $BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$BlockPredicate, $BlockPredicate$$Type, $BlockPredicate$$Interface} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StateTestingPredicate implements $BlockPredicate$$Interface {
public "test"(arg0: any, arg1: any): boolean
public "test"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): boolean
public static "solid"(): $BlockPredicate
public static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
public static "replaceable"(): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
public static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
public static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
public static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
public static "unobstructed"(): $BlockPredicate
public static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
public static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
public static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
public static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
public static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
public static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
public static "noFluid"(): $BlockPredicate
public static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
public static "alwaysTrue"(): $BlockPredicate
public static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
public static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
public static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
public static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
public "type"(): $BlockPredicateType<(never)>
public "or"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "negate"(): $BiPredicate<($WorldGenLevel), ($BlockPos)>
public "and"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StateTestingPredicate$$Type = ($StateTestingPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StateTestingPredicate$$Original = $StateTestingPredicate;}
declare module "net.minecraft.world.level.pathfinder.Target" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$Node, $Node$$Type} from "net.minecraft.world.level.pathfinder.Node"

export class $Target extends $Node {
 "cameFrom": $Node
 "f": float
 "g": float
readonly "x": integer
 "h": float
readonly "y": integer
 "closed": boolean
readonly "z": integer
 "walkedDistance": float
 "costMalus": float
 "type": $PathType
 "heapIdx": integer

constructor(arg0: integer, arg1: integer, arg2: integer)
constructor(arg0: $Node$$Type)

public static "createFromStream"(arg0: $FriendlyByteBuf$$Type): $Target
public "isReached"(): boolean
public "setReached"(): void
public "updateBest"(arg0: float, arg1: $Node$$Type): void
public "getBestNode"(): $Node
get "reached"(): boolean
get "reached"(): void
get "bestNode"(): $Node
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Target$$Type = ($Target);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Target$$Original = $Target;}
declare module "net.minecraft.world.level.block.DoorBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DoubleBlockHalf} from "net.minecraft.world.level.block.state.properties.DoubleBlockHalf"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$DoorHingeSide} from "net.minecraft.world.level.block.state.properties.DoorHingeSide"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $DoorBlock extends $Block implements $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DoorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($DoubleBlockHalf)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "HINGE": $EnumProperty<($DoorHingeSide)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockSetType$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "setOpen"(arg0: $Entity$$Type, arg1: $Level$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: boolean): void
public static "isWoodenDoor"(arg0: $BlockState$$Type): boolean
public static "isWoodenDoor"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public "type"(): $BlockSetType
public "isOpen"(arg0: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($DoorBlock)>
public "playSound"(arg0: $Entity$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: boolean): void
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoorBlock$$Type = ($DoorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoorBlock$$Original = $DoorBlock;}
declare module "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer" {
import {$LootPoolEntryType} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryType"
import {$List} from "java.util.List"
import {$ComposableEntryContainer$$Interface} from "net.minecraft.world.level.storage.loot.entries.ComposableEntryContainer"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootItemCondition} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export class $LootPoolEntryContainer implements $ComposableEntryContainer$$Interface {
readonly "conditions": $List<($LootItemCondition)>

public "validate"(arg0: $ValidationContext$$Type): void
public "getType"(): $LootPoolEntryType
get "type"(): $LootPoolEntryType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPoolEntryContainer$$Type = ($LootPoolEntryContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootPoolEntryContainer$$Original = $LootPoolEntryContainer;}
declare module "net.minecraft.world.level.entity.EntityAccess" {
import {$UUID} from "java.util.UUID"
import {$EntityInLevelCallback$$Type} from "net.minecraft.world.level.entity.EntityInLevelCallback"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$Entity$RemovalReason$$Type} from "net.minecraft.world.entity.Entity$RemovalReason"
import {$AABB} from "net.minecraft.world.phys.AABB"

export interface $EntityAccess$$Interface {
get "id"(): integer
get "UUID"(): $UUID
get "boundingBox"(): $AABB
set "removed"(value: $Entity$RemovalReason$$Type)
get "selfAndPassengers"(): $Stream<($EntityAccess)>
set "levelCallback"(value: $EntityInLevelCallback$$Type)
get "alwaysTicking"(): boolean
get "passengersAndSelf"(): $Stream<($EntityAccess)>
}

export class $EntityAccess implements $EntityAccess$$Interface {
 "getId"(): integer
 "blockPosition"(): $BlockPos
 "getUUID"(): $UUID
 "getBoundingBox"(): $AABB
 "setRemoved"(arg0: $Entity$RemovalReason$$Type): void
 "getSelfAndPassengers"(): $Stream<($EntityAccess)>
 "setLevelCallback"(arg0: $EntityInLevelCallback$$Type): void
 "shouldBeSaved"(): boolean
 "isAlwaysTicking"(): boolean
 "getPassengersAndSelf"(): $Stream<($EntityAccess)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityAccess$$Type = ($EntityAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityAccess$$Original = $EntityAccess;}
declare module "net.minecraft.world.level.block.BannerBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$AbstractBannerBlock} from "net.minecraft.world.level.block.AbstractBannerBlock"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $BannerBlock extends $AbstractBannerBlock {
static readonly "ROTATION": $IntegerProperty
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BannerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $DyeColor$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "byColor"(arg0: $DyeColor$$Type): $Block
public "codec"(): $MapCodec<($BannerBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BannerBlock$$Type = ($BannerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BannerBlock$$Original = $BannerBlock;}
declare module "net.minecraft.world.level.block.entity.LidBlockEntity" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $LidBlockEntity$$Interface {

(arg0: float): float
}

export class $LidBlockEntity implements $LidBlockEntity$$Interface {
 "getOpenNess"(arg0: float): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LidBlockEntity$$Type = ((arg0: float) => float);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LidBlockEntity$$Original = $LidBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.GiantTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $GiantTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($GiantTrunkPlacer)>
static readonly "MAX_HEIGHT": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GiantTrunkPlacer$$Type = ($GiantTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GiantTrunkPlacer$$Original = $GiantTrunkPlacer;}
declare module "net.minecraft.world.level.chunk.PalettedContainer" {
import {$PalettedContainer$CountConsumer$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$CountConsumer"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$List$$Type} from "java.util.List"
import {$PalettedContainer$Strategy$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$Strategy"
import {$ReadableContainerExtended, $ReadableContainerExtended$$Interface} from "org.embeddedt.embeddium.impl.world.ReadableContainerExtended"
import {$IdMap$$Type} from "net.minecraft.core.IdMap"
import {$BitStorage$$Type} from "net.minecraft.util.BitStorage"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PalettedContainer$Configuration$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$Configuration"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$PalettedContainerRO$PackedData} from "net.minecraft.world.level.chunk.PalettedContainerRO$PackedData"
import {$PaletteResize$$Interface} from "net.minecraft.world.level.chunk.PaletteResize"
import {$PalettedContainerRO, $PalettedContainerRO$$Type, $PalettedContainerRO$$Interface} from "net.minecraft.world.level.chunk.PalettedContainerRO"

export class $PalettedContainer<T> implements $PaletteResize$$Interface<(T)>, $PalettedContainerRO$$Interface<(T)>, $ReadableContainerExtended$$Interface {
constructor(arg0: $IdMap$$Type<(T)>, arg1: $PalettedContainer$Strategy$$Type, arg2: $PalettedContainer$Configuration$$Type<(T)>, arg3: $BitStorage$$Type, arg4: $List$$Type<(T)>)
constructor(arg0: $IdMap$$Type<(T)>, arg1: T, arg2: $PalettedContainer$Strategy$$Type)

public "maybeHas"(arg0: $Predicate$$Type<(T)>): boolean
public "getSerializedSize"(): integer
public "getAll"(arg0: $Consumer$$Type<(T)>): void
public "pack"(arg0: $IdMap$$Type, arg1: $PalettedContainer$Strategy$$Type): $PalettedContainerRO$PackedData
public static "codecRO"<T>(arg0: $IdMap$$Type<(T)>, arg1: $Codec$$Type<(T)>, arg2: $PalettedContainer$Strategy$$Type, arg3: T): $Codec<($PalettedContainerRO<(T)>)>
public "sodium$unpack"(arg0: (any)[], arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): void
public "sodium$unpack"(arg0: (any)[]): void
public static "codecRW"<T>(arg0: $IdMap$$Type<(T)>, arg1: $Codec$$Type<(T)>, arg2: $PalettedContainer$Strategy$$Type, arg3: T): $Codec<($PalettedContainer<(T)>)>
public "recreate"(): $PalettedContainer<(T)>
public "handler$den000$lithium$removeLockHelper"(arg0: $CallbackInfo$$Type): void
public "getAndSetUnchecked"(arg0: integer, arg1: integer, arg2: integer, arg3: T): T
public "handler$dfa000$lithium$count"(arg0: $PalettedContainer$CountConsumer$$Type, arg1: $CallbackInfo$$Type): void
public "get"(arg0: integer, arg1: integer, arg2: integer): T
public "get"(arg0: integer): T
public "count"(arg0: $PalettedContainer$CountConsumer$$Type<(T)>): void
public "set"(arg0: integer, arg1: integer, arg2: integer, arg3: T): void
public "write"(arg0: $FriendlyByteBuf$$Type): void
public "read"(arg0: $FriendlyByteBuf$$Type): void
public "copy"(): $PalettedContainer<(T)>
public "getAndSet"(arg0: integer, arg1: integer, arg2: integer, arg3: T): T
public "release"(): void
public "acquire"(): void
public "onResize"(arg0: integer, arg1: T): integer
public "sodium$copy"(): $PalettedContainerRO
public static "clone"<T>(arg0: $PalettedContainerRO$$Type<(any)>): $PalettedContainerRO<(any)>
public static "of"<T>(arg0: $PalettedContainerRO$$Type<(any)>): $ReadableContainerExtended<(any)>
get "serializedSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainer$$Type<T> = ($PalettedContainer<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainer$$Original<T> = $PalettedContainer<(T)>;}
declare module "net.minecraft.world.level.levelgen.placement.CarvingMaskPlacement" {
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $CarvingMaskPlacement extends $PlacementModifier {
static readonly "CODEC": $MapCodec<($CarvingMaskPlacement)>

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
public static "forStep"(arg0: $GenerationStep$Carving$$Type): $CarvingMaskPlacement
public "type"(): $PlacementModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarvingMaskPlacement$$Type = ($CarvingMaskPlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarvingMaskPlacement$$Original = $CarvingMaskPlacement;}
declare module "net.minecraft.world.level.storage.loot.functions.LootItemFunctionType" {
import {$LootItemFunction} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $LootItemFunctionType<T extends $LootItemFunction> extends $Record {
constructor(arg0: $MapCodec$$Type<(T)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "codec"(): $MapCodec<(T)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.LootFunctionType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.LootFunctionTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemFunctionType$$Type<T> = (Special.LootFunctionType) | ({"codec"?: $MapCodec$$Type<(T)>}) | ([codec?: $MapCodec$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemFunctionType$$Original<T> = $LootItemFunctionType<(T)>;}
declare module "net.minecraft.world.level.block.ButtonBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$FaceAttachedHorizontalDirectionalBlock} from "net.minecraft.world.level.block.FaceAttachedHorizontalDirectionalBlock"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ButtonBlock extends $FaceAttachedHorizontalDirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($ButtonBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
readonly "type": $BlockSetType
readonly "ticksToStayPressed": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "FACE": $EnumProperty<($AttachFace)>

constructor(arg0: $BlockSetType$$Type, arg1: integer, arg2: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($ButtonBlock)>
public "press"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonBlock$$Type = ($ButtonBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ButtonBlock$$Original = $ButtonBlock;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.SpruceFoliagePlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $SpruceFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($SpruceFoliagePlacer)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type)

public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpruceFoliagePlacer$$Type = ($SpruceFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpruceFoliagePlacer$$Original = $SpruceFoliagePlacer;}
declare module "net.minecraft.world.level.block.BonemealableBlock" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"

export interface $BonemealableBlock$$Interface {
get "type"(): $BonemealableBlock$Type
}

export class $BonemealableBlock implements $BonemealableBlock$$Interface {
 "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
 "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
 "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
 "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
 "getType"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BonemealableBlock$$Type = ($BonemealableBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BonemealableBlock$$Original = $BonemealableBlock;}
declare module "net.minecraft.world.level.chunk.DataLayer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DataLayer {
static readonly "LAYER_COUNT": integer
static readonly "SIZE": integer
static readonly "LAYER_SIZE": integer

constructor()
constructor(arg0: (byte)[])
constructor(arg0: integer)

public "getData"(): (byte)[]
public "layerToString"(arg0: integer): StringJS
public "isDefinitelyHomogenous"(): boolean
public "isDefinitelyFilledWith"(arg0: integer): boolean
public "get"(arg0: integer, arg1: integer, arg2: integer): integer
public "toString"(): StringJS
public "isEmpty"(): boolean
public "fill"(arg0: integer): void
public "set"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "copy"(): $DataLayer
get "data"(): (byte)[]
get "definitelyHomogenous"(): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataLayer$$Type = ($DataLayer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataLayer$$Original = $DataLayer;}
declare module "net.minecraft.world.level.block.WeepingVinesPlantBlock" {
import {$GrowingPlantBodyBlock} from "net.minecraft.world.level.block.GrowingPlantBodyBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $WeepingVinesPlantBlock extends $GrowingPlantBodyBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WeepingVinesPlantBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "SHAPE": $VoxelShape
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($WeepingVinesPlantBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeepingVinesPlantBlock$$Type = ($WeepingVinesPlantBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeepingVinesPlantBlock$$Original = $WeepingVinesPlantBlock;}
declare module "net.minecraft.world.level.timers.TimerCallback$Serializer" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$TimerCallback, $TimerCallback$$Type} from "net.minecraft.world.level.timers.TimerCallback"

export class $TimerCallback$Serializer<T, C extends $TimerCallback<(object)>> {
constructor(arg0: $ResourceLocation$$Type, arg1: $Class$$Type<(never)>)

public "getId"(): $ResourceLocation
public "deserialize"(arg0: $CompoundTag$$Type): C
public "serialize"(arg0: $CompoundTag$$Type, arg1: C): void
public "getCls"(): $Class<(never)>
get "id"(): $ResourceLocation
get "cls"(): $Class<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimerCallback$Serializer$$Type<T, C> = ($TimerCallback$Serializer<(T), (C)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TimerCallback$Serializer$$Original<T, C> = $TimerCallback$Serializer<(T), (C)>;}
declare module "net.minecraft.world.level.lighting.LayerLightSectionStorage$SectionType" {
import {$Enum} from "java.lang.Enum"

export class $LayerLightSectionStorage$SectionType extends $Enum<($LayerLightSectionStorage$SectionType)> {
static readonly "LIGHT_ONLY": $LayerLightSectionStorage$SectionType
static readonly "LIGHT_AND_DATA": $LayerLightSectionStorage$SectionType
static readonly "EMPTY": $LayerLightSectionStorage$SectionType

public static "values"(): ($LayerLightSectionStorage$SectionType)[]
public static "valueOf"(arg0: StringJS): $LayerLightSectionStorage$SectionType
public "display"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LayerLightSectionStorage$SectionType$$Type = (("empty") | ("light_only") | ("light_and_data"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LayerLightSectionStorage$SectionType$$Original = $LayerLightSectionStorage$SectionType;}
declare module "net.minecraft.world.level.chunk.storage.SimpleRegionStorage" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Optional} from "java.util.Optional"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$DataFixTypes$$Type} from "net.minecraft.util.datafix.DataFixTypes"
import {$Dynamic, $Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$RegionStorageInfo, $RegionStorageInfo$$Type} from "net.minecraft.world.level.chunk.storage.RegionStorageInfo"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Path$$Type} from "java.nio.file.Path"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"

export class $SimpleRegionStorage implements $AutoCloseable$$Interface {
constructor(arg0: $RegionStorageInfo$$Type, arg1: $Path$$Type, arg2: $DataFixer$$Type, arg3: boolean, arg4: $DataFixTypes$$Type)

public "storageInfo"(): $RegionStorageInfo
public "upgradeChunkTag"(arg0: $Dynamic$$Type<($Tag$$Type)>, arg1: integer): $Dynamic<($Tag)>
public "upgradeChunkTag"(arg0: $CompoundTag$$Type, arg1: integer): $CompoundTag
public "write"(arg0: $ChunkPos$$Type, arg1: $CompoundTag$$Type): $CompletableFuture<(void)>
public "read"(arg0: $ChunkPos$$Type): $CompletableFuture<($Optional<($CompoundTag)>)>
public "close"(): void
public "synchronize"(arg0: boolean): $CompletableFuture<(void)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleRegionStorage$$Type = ($SimpleRegionStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleRegionStorage$$Original = $SimpleRegionStorage;}
declare module "net.minecraft.world.level.block.WeatheringCopperDoorBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Optional} from "java.util.Optional"
import {$Enum} from "java.lang.Enum"
import {$DoubleBlockHalf} from "net.minecraft.world.level.block.state.properties.DoubleBlockHalf"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$DoorHingeSide} from "net.minecraft.world.level.block.state.properties.DoorHingeSide"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$WeatheringCopper$$Interface} from "net.minecraft.world.level.block.WeatheringCopper"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WeatheringCopper$WeatherState$$Type} from "net.minecraft.world.level.block.WeatheringCopper$WeatherState"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$DoorBlock} from "net.minecraft.world.level.block.DoorBlock"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $WeatheringCopperDoorBlock extends $DoorBlock implements $WeatheringCopper$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WeatheringCopperDoorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($DoubleBlockHalf)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "HINGE": $EnumProperty<($DoorHingeSide)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockSetType$$Type, arg1: $WeatheringCopper$WeatherState$$Type, arg2: $BlockBehaviour$Properties$$Type)

public "getAge"(): $Enum
public "codec"(): $MapCodec<($WeatheringCopperDoorBlock)>
public "getChanceModifier"(): float
public "getNext"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getNext"(arg0: $Block$$Type): $Optional<($Block)>
public static "getFirst"(arg0: $BlockState$$Type): $BlockState
public static "getFirst"(arg0: $Block$$Type): $Block
public static "getPrevious"(arg0: $BlockState$$Type): $Optional<($BlockState)>
public static "getPrevious"(arg0: $Block$$Type): $Optional<($Block)>
public "changeOverTime"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getNextState"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($BlockState)>
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "age"(): $Enum
get "chanceModifier"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatheringCopperDoorBlock$$Type = ($WeatheringCopperDoorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeatheringCopperDoorBlock$$Original = $WeatheringCopperDoorBlock;}
declare module "net.minecraft.world.level.block.SculkBlock" {
import {$SculkSpreader$$Type} from "net.minecraft.world.level.block.SculkSpreader"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Collection$$Type} from "java.util.Collection"
import {$SculkSpreader$ChargeCursor$$Type} from "net.minecraft.world.level.block.SculkSpreader$ChargeCursor"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$SculkBehaviour$$Interface} from "net.minecraft.world.level.block.SculkBehaviour"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$DropExperienceBlock} from "net.minecraft.world.level.block.DropExperienceBlock"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SculkBlock extends $DropExperienceBlock implements $SculkBehaviour$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SculkBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "canChangeBlockStateOnSpread"(): boolean
public "attemptUseCharge"(arg0: $SculkSpreader$ChargeCursor$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type, arg4: $SculkSpreader$$Type, arg5: boolean): integer
public "codec"(): $MapCodec<($SculkBlock)>
public "getSculkSpreadDelay"(): byte
public "onDischarged"(arg0: $LevelAccessor$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "depositCharge"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): boolean
public "attemptSpreadVein"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Collection$$Type<($Direction$$Type)>, arg4: boolean): boolean
public "updateDecayDelay"(arg0: integer): integer
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "sculkSpreadDelay"(): byte
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkBlock$$Type = ($SculkBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkBlock$$Original = $SculkBlock;}
declare module "net.minecraft.world.level.SpawnData$CustomSpawnRules" {
import {$InclusiveRange, $InclusiveRange$$Type} from "net.minecraft.util.InclusiveRange"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"

export class $SpawnData$CustomSpawnRules extends $Record {
static readonly "CODEC": $Codec<($SpawnData$CustomSpawnRules)>

constructor(arg0: $InclusiveRange$$Type<(integer)>, arg1: $InclusiveRange$$Type<(integer)>)

public "isValidPosition"(arg0: $BlockPos$$Type, arg1: $ServerLevel$$Type): boolean
public "skyLightLimit"(): $InclusiveRange<(integer)>
public "blockLightLimit"(): $InclusiveRange<(integer)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnData$CustomSpawnRules$$Type = ({"blockLightLimit"?: $InclusiveRange$$Type<(integer)>, "skyLightLimit"?: $InclusiveRange$$Type<(integer)>}) | ([blockLightLimit?: $InclusiveRange$$Type<(integer)>, skyLightLimit?: $InclusiveRange$$Type<(integer)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpawnData$CustomSpawnRules$$Original = $SpawnData$CustomSpawnRules;}
declare module "net.minecraft.world.level.BlockAndTintGetter" {
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$IBlockAndTintGetterExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBlockAndTintGetterExtension"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export interface $BlockAndTintGetter$$Interface extends $BlockGetter$$Interface, $IBlockAndTintGetterExtension$$Interface {
get "lightEngine"(): $LevelLightEngine
get "maxLightLevel"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
get "maxBuildHeight"(): integer
get "sectionsCount"(): integer
get "maxSection"(): integer
get "minSection"(): integer
}

export class $BlockAndTintGetter implements $BlockAndTintGetter$$Interface {
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "getMaxLightLevel"(): integer
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
 "getHeight"(): integer
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getMinBuildHeight"(): integer
 "getMaxBuildHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getSectionIndex"(arg0: integer): integer
 "getSectionsCount"(): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockAndTintGetter$$Type = ($BlockAndTintGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockAndTintGetter$$Original = $BlockAndTintGetter;}
declare module "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ImmutableList} from "com.google.common.collect.ImmutableList"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $StructureTemplatePool$Projection extends $Enum<($StructureTemplatePool$Projection)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $StringRepresentable$EnumCodec<($StructureTemplatePool$Projection)>
static readonly "TERRAIN_MATCHING": $StructureTemplatePool$Projection
static readonly "RIGID": $StructureTemplatePool$Projection

public "getName"(): StringJS
public static "values"(): ($StructureTemplatePool$Projection)[]
public static "valueOf"(arg0: StringJS): $StructureTemplatePool$Projection
public "getProcessors"(): $ImmutableList<($StructureProcessor)>
public static "byName"(arg0: StringJS): $StructureTemplatePool$Projection
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "name"(): StringJS
get "processors"(): $ImmutableList<($StructureProcessor)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplatePool$Projection$$Type = (("terrain_matching") | ("rigid"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplatePool$Projection$$Original = $StructureTemplatePool$Projection;}
declare module "net.minecraft.world.level.levelgen.structure.placement.RandomSpreadType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $RandomSpreadType extends $Enum<($RandomSpreadType)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($RandomSpreadType)>
static readonly "LINEAR": $RandomSpreadType
static readonly "TRIANGULAR": $RandomSpreadType

public "evaluate"(arg0: $RandomSource$$Type, arg1: integer): integer
public static "values"(): ($RandomSpreadType)[]
public static "valueOf"(arg0: StringJS): $RandomSpreadType
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomSpreadType$$Type = (("linear") | ("triangular"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomSpreadType$$Original = $RandomSpreadType;}
declare module "net.minecraft.world.level.lighting.LevelLightEngine" {
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$LightEngine} from "net.minecraft.world.level.lighting.LightEngine"
import {$LayerLightSectionStorage$SectionType} from "net.minecraft.world.level.lighting.LayerLightSectionStorage$SectionType"
import {$LayerLightEventListener} from "net.minecraft.world.level.lighting.LayerLightEventListener"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$LightChunkGetter$$Type} from "net.minecraft.world.level.chunk.LightChunkGetter"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$StarLightInterface} from "ca.spottedleaf.starlight.common.light.StarLightInterface"
import {$LightEventListener$$Interface} from "net.minecraft.world.level.lighting.LightEventListener"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$LevelChunk$$Type} from "net.minecraft.world.level.chunk.LevelChunk"
import {$StarLightLightingProvider$$Interface} from "ca.spottedleaf.starlight.common.light.StarLightLightingProvider"
import {$DataLayer$$Type} from "net.minecraft.world.level.chunk.DataLayer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $LevelLightEngine implements $LightEventListener$$Interface, $StarLightLightingProvider$$Interface {
static readonly "LIGHT_SECTION_PADDING": integer
 "skyEngine": $LightEngine<(never), (never)>
 "blockEngine": $LightEngine<(never), (never)>

constructor(arg0: $LightChunkGetter$$Type, arg1: boolean, arg2: boolean)

public "hasLightWork"(): boolean
public "handler$zol000$scalablelux$construct"(chunkProvider: $LightChunkGetter$$Type, hasBlockLight: boolean, hasSkyLight: boolean, ci: $CallbackInfo$$Type): void
public "getDebugSectionType"(lightLayer: $LightLayer$$Type, sectionPos: $SectionPos$$Type): $LayerLightSectionStorage$SectionType
public "getLightSectionCount"(): integer
public "getMinLightSection"(): integer
public "getMaxLightSection"(): integer
public "clientUpdateLight"(lightType: $LightLayer$$Type, pos: $SectionPos$$Type, nibble: $DataLayer$$Type, trustEdges: boolean): void
public "clientRemoveLightData"(chunkPos: $ChunkPos$$Type): void
public "clientChunkLoad"(pos: $ChunkPos$$Type, chunk: $LevelChunk$$Type): void
public "updateSectionStatus"(pos: $SectionPos$$Type, notReady: boolean): void
public "checkBlock"(pos: $BlockPos$$Type): void
public "retainData"(pos: $ChunkPos$$Type, retainData: boolean): void
public "queueSectionData"(lightType: $LightLayer$$Type, pos: $SectionPos$$Type, nibble: $DataLayer$$Type): void
public "propagateLightSources"(param0: $ChunkPos$$Type): void
public "getDebugData"(lightType: $LightLayer$$Type, pos: $SectionPos$$Type): StringJS
public "runLightUpdates"(): integer
public "lightOnInSection"(pos: $SectionPos$$Type): boolean
public "getLightEngine"(): $StarLightInterface
public "getLayerListener"(lightType: $LightLayer$$Type): $LayerLightEventListener
public "getRawBrightness"(pos: $BlockPos$$Type, ambientDarkness: integer): integer
public "setLightEnabled"(pos: $ChunkPos$$Type, lightEnabled: boolean): void
public "updateSectionStatus"(arg0: $BlockPos$$Type, arg1: boolean): void
get "lightSectionCount"(): integer
get "minLightSection"(): integer
get "maxLightSection"(): integer
get "lightEngine"(): $StarLightInterface
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelLightEngine$$Type = ($LevelLightEngine);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelLightEngine$$Original = $LevelLightEngine;}
declare module "net.minecraft.world.level.material.EmptyFluid" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Holder} from "net.minecraft.core.Holder"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"

export class $EmptyFluid extends $Fluid {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>

constructor()

public "isSource"(arg0: $FluidState$$Type): boolean
public "canBeReplacedWith"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Fluid$$Type, arg4: $Direction$$Type): boolean
public "getTickDelay"(arg0: $LevelReader$$Type): integer
public "getOwnHeight"(arg0: $FluidState$$Type): float
public "getHeight"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): float
public "getShape"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getBucket"(): $Item
public "getAmount"(arg0: $FluidState$$Type): integer
public "getFlow"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type): $Vec3
public "asHolder"(): $Holder
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
get "bucket"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyFluid$$Type = ($EmptyFluid);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EmptyFluid$$Original = $EmptyFluid;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.CherryTrunkPlacer" {
import {$List} from "java.util.List"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$UniformInt$$Type} from "net.minecraft.util.valueproviders.UniformInt"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $CherryTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($CherryTrunkPlacer)>
static readonly "MAX_HEIGHT": integer

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $IntProvider$$Type, arg4: $IntProvider$$Type, arg5: $UniformInt$$Type, arg6: $IntProvider$$Type)

public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CherryTrunkPlacer$$Type = ($CherryTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CherryTrunkPlacer$$Original = $CherryTrunkPlacer;}
declare module "net.minecraft.world.level.block.FrostedIceBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$IceBlock} from "net.minecraft.world.level.block.IceBlock"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FrostedIceBlock extends $IceBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($FrostedIceBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($FrostedIceBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FrostedIceBlock$$Type = ($FrostedIceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FrostedIceBlock$$Original = $FrostedIceBlock;}
declare module "net.minecraft.world.level.validation.ForbiddenSymlinkInfo" {
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$Record} from "java.lang.Record"

export class $ForbiddenSymlinkInfo extends $Record {
constructor(arg0: $Path$$Type, arg1: $Path$$Type)

public "link"(): $Path
public "equals"(arg0: any): boolean
public "target"(): $Path
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForbiddenSymlinkInfo$$Type = ({"target"?: $Path$$Type, "link"?: $Path$$Type}) | ([target?: $Path$$Type, link?: $Path$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ForbiddenSymlinkInfo$$Original = $ForbiddenSymlinkInfo;}
declare module "net.minecraft.world.level.block.CoralPlantBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BaseCoralPlantTypeBlock} from "net.minecraft.world.level.block.BaseCoralPlantTypeBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CoralPlantBlock extends $BaseCoralPlantTypeBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CoralPlantBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($CoralPlantBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CoralPlantBlock$$Type = ($CoralPlantBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CoralPlantBlock$$Original = $CoralPlantBlock;}
declare module "net.minecraft.world.level.gameevent.GameEventListener" {
import {$PositionSource} from "net.minecraft.world.level.gameevent.PositionSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$GameEventListener$DeliveryMode} from "net.minecraft.world.level.gameevent.GameEventListener$DeliveryMode"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export interface $GameEventListener$$Interface {
get "listenerRadius"(): integer
get "listenerSource"(): $PositionSource
get "deliveryMode"(): $GameEventListener$DeliveryMode
}

export class $GameEventListener implements $GameEventListener$$Interface {
 "getListenerRadius"(): integer
 "getListenerSource"(): $PositionSource
 "handleGameEvent"(arg0: $ServerLevel$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $GameEvent$Context$$Type, arg3: $Vec3$$Type): boolean
 "getDeliveryMode"(): $GameEventListener$DeliveryMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEventListener$$Type = ($GameEventListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEventListener$$Original = $GameEventListener;}
declare module "net.minecraft.world.level.levelgen.feature.MultifaceGrowthFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$MultifaceGrowthConfiguration, $MultifaceGrowthConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $MultifaceGrowthFeature extends $Feature<($MultifaceGrowthConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($MultifaceGrowthConfiguration$$Type)>)

public static "placeGrowthIfPossible"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $MultifaceGrowthConfiguration$$Type, arg4: $RandomSource$$Type, arg5: $List$$Type<($Direction$$Type)>): boolean
public "place"(arg0: $FeaturePlaceContext$$Type<($MultifaceGrowthConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceGrowthFeature$$Type = ($MultifaceGrowthFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceGrowthFeature$$Original = $MultifaceGrowthFeature;}
declare module "net.minecraft.world.level.block.state.properties.BlockSetType$PressurePlateSensitivity" {
import {$Enum} from "java.lang.Enum"

export class $BlockSetType$PressurePlateSensitivity extends $Enum<($BlockSetType$PressurePlateSensitivity)> {
static readonly "MOBS": $BlockSetType$PressurePlateSensitivity
static readonly "EVERYTHING": $BlockSetType$PressurePlateSensitivity

public static "values"(): ($BlockSetType$PressurePlateSensitivity)[]
public static "valueOf"(arg0: StringJS): $BlockSetType$PressurePlateSensitivity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockSetType$PressurePlateSensitivity$$Type = (("everything") | ("mobs"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockSetType$PressurePlateSensitivity$$Original = $BlockSetType$PressurePlateSensitivity;}
declare module "net.minecraft.world.level.block.WoolCarpetBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Holder} from "net.minecraft.core.Holder"
import {$CarpetBlock} from "net.minecraft.world.level.block.CarpetBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Equipable, $Equipable$$Interface} from "net.minecraft.world.item.Equipable"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$EquipmentSlot} from "net.minecraft.world.entity.EquipmentSlot"
import {$InteractionResultHolder} from "net.minecraft.world.InteractionResultHolder"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $WoolCarpetBlock extends $CarpetBlock implements $Equipable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WoolCarpetBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $DyeColor$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getColor"(): $DyeColor
public "codec"(): $MapCodec<($WoolCarpetBlock)>
public "getEquipmentSlot"(): $EquipmentSlot
public "getEquipSound"(): $Holder<($SoundEvent)>
public "swapWithEquipmentSlot"(arg0: $Item$$Type, arg1: $Level$$Type, arg2: $Player$$Type, arg3: $InteractionHand$$Type): $InteractionResultHolder<($ItemStack)>
public static "get"(arg0: $ItemStack$$Type): $Equipable
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "color"(): $DyeColor
get "equipmentSlot"(): $EquipmentSlot
get "equipSound"(): $Holder<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WoolCarpetBlock$$Type = ($WoolCarpetBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WoolCarpetBlock$$Original = $WoolCarpetBlock;}
declare module "net.minecraft.world.level.block.entity.CrafterBlockEntity" {
import {$CraftingInput} from "net.minecraft.world.item.crafting.CraftingInput"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CraftingInput$Positioned} from "net.minecraft.world.item.crafting.CraftingInput$Positioned"
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$SetChangedHandlingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SetChangedHandlingBlockEntity"
import {$Component} from "net.minecraft.network.chat.Component"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$CraftingContainer$$Interface} from "net.minecraft.world.inventory.CraftingContainer"
import {$StackedContents$$Type} from "net.minecraft.world.entity.player.StackedContents"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CrafterBlockEntity extends $RandomizableContainerBlockEntity implements $CraftingContainer$$Interface, $SleepingBlockEntity$$Interface, $SetChangedHandlingBlockEntity$$Interface {
static readonly "CONTAINER_WIDTH": integer
static readonly "CONTAINER_HEIGHT": integer
static readonly "DATA_TRIGGERED": integer
static readonly "SLOT_ENABLED": integer
static readonly "CONTAINER_SIZE": integer
static readonly "SLOT_DISABLED": integer
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode
static readonly "NUM_DATA": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CrafterBlockEntity$$Type): void
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "getRedstoneSignal"(): integer
public "getItems"(): $NonNullList<($ItemStack)>
public "setTriggered"(arg0: boolean): void
public "setCraftingTicksRemaining"(arg0: integer): void
public "lithium$handleSetChanged"(): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "fillStackedContents"(arg0: $StackedContents$$Type): void
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "setSlotState"(arg0: integer, arg1: boolean): void
public "isSlotDisabled"(arg0: integer): boolean
public "isTriggered"(): boolean
public "getWidth"(): integer
public "getHeight"(): integer
public "getItem"(arg0: integer): $ItemStack
public "isEmpty"(): boolean
public "stillValid"(arg0: $Player$$Type): boolean
public "getContainerSize"(): integer
public "asCraftInput"(): $CraftingInput
public "asPositionedCraftInput"(): $CraftingInput$Positioned
public "lithium$startSleeping"(): boolean
public "wakeUpNow"(): void
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "sleepOnlyCurrentTick"(): void
public "isSleeping"(): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "tryClear"(arg0: any): void
get "redstoneSignal"(): integer
get "items"(): $NonNullList<($ItemStack)>
set "triggered"(value: boolean)
set "craftingTicksRemaining"(value: integer)
get "triggered"(): boolean
get "width"(): integer
get "height"(): integer
get "empty"(): boolean
get "containerSize"(): integer
set "ticker"(value: $TickingBlockEntity$$Type)
get "sleeping"(): boolean
get "changed"(): void
get "level"(): $Level
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrafterBlockEntity$$Type = ($CrafterBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CrafterBlockEntity$$Original = $CrafterBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration$Layer" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Record} from "java.lang.Record"

export class $BlockColumnConfiguration$Layer extends $Record {
static readonly "CODEC": $Codec<($BlockColumnConfiguration$Layer)>

constructor(arg0: $IntProvider$$Type, arg1: $BlockStateProvider$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "state"(): $BlockStateProvider
public "height"(): $IntProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockColumnConfiguration$Layer$$Type = ({"height"?: $IntProvider$$Type, "state"?: $BlockStateProvider$$Type}) | ([height?: $IntProvider$$Type, state?: $BlockStateProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockColumnConfiguration$Layer$$Original = $BlockColumnConfiguration$Layer;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.RandomBlockMatchTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RandomBlockMatchTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($RandomBlockMatchTest)>

constructor(arg0: $Block$$Type, arg1: float)

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomBlockMatchTest$$Type = ($RandomBlockMatchTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomBlockMatchTest$$Original = $RandomBlockMatchTest;}
declare module "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$BaseContainerBlockEntity} from "net.minecraft.world.level.block.entity.BaseContainerBlockEntity"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Operation$$Type} from "com.llamalad7.mixinextras.injector.wrapoperation.Operation"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$RandomizableContainer$$Type, $RandomizableContainer$$Interface} from "net.minecraft.world.RandomizableContainer"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $RandomizableContainerBlockEntity extends $BaseContainerBlockEntity implements $RandomizableContainer$$Interface {
 "name": $Component
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "lockKey": $LockCode

public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "canOpen"(arg0: $Player$$Type): boolean
public "setLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
public "setLootTableSeed"(arg0: long): void
public "getItem"(arg0: integer): $ItemStack
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "isEmpty"(): boolean
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "getLootTable"(): $ResourceKey<($LootTable)>
public "getLootTableSeed"(): long
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "unpackLootTable"(arg0: $Player$$Type): void
public "tryLoadLootTable"(arg0: $CompoundTag$$Type): boolean
public "trySaveLootTable"(arg0: $CompoundTag$$Type): boolean
public "setLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
public "wrapOperation$fak000$lootr$setLootTable"(arg0: $RandomizableContainer$$Type, arg1: $ResourceKey$$Type, arg2: $Operation$$Type): void
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "wrapOperation$fak000$lootr$tryLoadLootTable"(arg0: $RandomizableContainer$$Type, arg1: long, arg2: $Operation$$Type): void
public "handler$fak000$lootr$unpackLootTable"(arg0: $Player$$Type, arg1: $CallbackInfo$$Type): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "setChanged"(): void
public static "tryClear"(arg0: any): void
set "lootTable"(value: $ResourceKey$$Type<($LootTable)>)
set "lootTableSeed"(value: long)
get "empty"(): boolean
get "lootTable"(): $ResourceKey<($LootTable)>
get "lootTableSeed"(): long
get "level"(): $Level
get "blockPos"(): $BlockPos
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomizableContainerBlockEntity$$Type = ($RandomizableContainerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomizableContainerBlockEntity$$Original = $RandomizableContainerBlockEntity;}
declare module "net.minecraft.world.level.pathfinder.PathType" {
import {$Enum} from "java.lang.Enum"

export class $PathType extends $Enum<($PathType)> {
static readonly "LAVA": $PathType
static readonly "DANGER_POWDER_SNOW": $PathType
static readonly "LEAVES": $PathType
static readonly "BLOCKED": $PathType
static readonly "WALKABLE": $PathType
static readonly "TRAPDOOR": $PathType
static readonly "BREACH": $PathType
static readonly "POWDER_SNOW": $PathType
static readonly "DOOR_WOOD_CLOSED": $PathType
static readonly "DANGER_TRAPDOOR": $PathType
static readonly "DANGER_FIRE": $PathType
static readonly "DAMAGE_FIRE": $PathType
static readonly "WATER": $PathType
static readonly "WATER_BORDER": $PathType
static readonly "WALKABLE_DOOR": $PathType
static readonly "DOOR_IRON_CLOSED": $PathType
static readonly "FENCE": $PathType
static readonly "OPEN": $PathType
static readonly "RAIL": $PathType
static readonly "DAMAGE_OTHER": $PathType
static readonly "DOOR_OPEN": $PathType
static readonly "UNPASSABLE_RAIL": $PathType
static readonly "COCOA": $PathType
static readonly "DANGER_OTHER": $PathType
static readonly "STICKY_HONEY": $PathType
static readonly "DAMAGE_CAUTIOUS": $PathType

public "getMalus"(): float
public static "values"(): ($PathType)[]
public static "valueOf"(arg0: StringJS): $PathType
get "malus"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathType$$Type = (("blocked") | ("open") | ("walkable") | ("walkable_door") | ("trapdoor") | ("powder_snow") | ("danger_powder_snow") | ("fence") | ("lava") | ("water") | ("water_border") | ("rail") | ("unpassable_rail") | ("danger_fire") | ("damage_fire") | ("danger_other") | ("damage_other") | ("door_open") | ("door_wood_closed") | ("door_iron_closed") | ("breach") | ("leaves") | ("sticky_honey") | ("cocoa") | ("damage_cautious") | ("danger_trapdoor"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathType$$Original = $PathType;}
declare module "net.minecraft.world.level.material.LavaFluid" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Optional} from "java.util.Optional"
import {$FlowingFluid} from "net.minecraft.world.level.material.FlowingFluid"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Holder} from "net.minecraft.core.Holder"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$ParticleOptions} from "net.minecraft.core.particles.ParticleOptions"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $LavaFluid extends $FlowingFluid {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
static readonly "MIN_LEVEL_CUTOFF": float
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty

constructor()

public "canBeReplacedWith"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Fluid$$Type, arg4: $Direction$$Type): boolean
public "getTickDelay"(arg0: $LevelReader$$Type): integer
public "getPickupSound"(): $Optional<($SoundEvent)>
public "isSame"(arg0: $Fluid$$Type): boolean
public "randomTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type, arg3: $RandomSource$$Type): void
public "getDropOff"(arg0: $LevelReader$$Type): integer
public "getSlopeFindDistance"(arg0: $LevelReader$$Type): integer
public "getFlowing"(): $Fluid
public "getSpreadDelay"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type, arg3: $FluidState$$Type): integer
public "getSource"(): $Fluid
public "getBucket"(): $Item
public "animateTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type, arg3: $RandomSource$$Type): void
public "createLegacyBlock"(arg0: $FluidState$$Type): $BlockState
public "getDripParticle"(): $ParticleOptions
public "asHolder"(): $Holder
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
get "pickupSound"(): $Optional<($SoundEvent)>
get "flowing"(): $Fluid
get "source"(): $Fluid
get "bucket"(): $Item
get "dripParticle"(): $ParticleOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LavaFluid$$Type = ($LavaFluid);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LavaFluid$$Original = $LavaFluid;}
declare module "net.minecraft.world.level.chunk.PaletteResize" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $PaletteResize$$Interface<T> {

(arg0: integer, arg1: T): integer
}

export class $PaletteResize<T> implements $PaletteResize$$Interface {
 "onResize"(arg0: integer, arg1: T): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaletteResize$$Type<T> = ((arg0: integer, arg1: T) => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PaletteResize$$Original<T> = $PaletteResize<(T)>;}
declare module "net.minecraft.world.level.levelgen.synth.NormalNoise" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StringBuilder$$Type} from "java.lang.StringBuilder"
import {$NormalNoise$NoiseParameters, $NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"

export class $NormalNoise {
/**
 * 
 * @deprecated
 */
public static "createLegacyNetherBiome"(arg0: $RandomSource$$Type, arg1: $NormalNoise$NoiseParameters$$Type): $NormalNoise
public "maxValue"(): double
public "getValue"(arg0: double, arg1: double, arg2: double): double
public "parameters"(): $NormalNoise$NoiseParameters
public static "create"(arg0: $RandomSource$$Type, arg1: integer, ...arg2: (double)[]): $NormalNoise
public static "create"(arg0: $RandomSource$$Type, arg1: $NormalNoise$NoiseParameters$$Type): $NormalNoise
public "parityConfigString"(arg0: $StringBuilder$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NormalNoise$$Type = ($NormalNoise);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NormalNoise$$Original = $NormalNoise;}
declare module "net.minecraft.world.level.storage.LevelResource" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $LevelResource {
static readonly "PLAYER_ADVANCEMENTS_DIR": $LevelResource
static readonly "PLAYER_OLD_DATA_DIR": $LevelResource
static readonly "GENERATED_DIR": $LevelResource
static readonly "LEVEL_DATA_FILE": $LevelResource
static readonly "MAP_RESOURCE_FILE": $LevelResource
static readonly "ROOT": $LevelResource
static readonly "ICON_FILE": $LevelResource
static readonly "LOCK_FILE": $LevelResource
static readonly "OLD_LEVEL_DATA_FILE": $LevelResource
static readonly "PLAYER_STATS_DIR": $LevelResource
static readonly "PLAYER_DATA_DIR": $LevelResource
static readonly "DATAPACK_DIR": $LevelResource

constructor(arg0: StringJS)

public "toString"(): StringJS
public "getId"(): StringJS
get "id"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelResource$$Type = ($LevelResource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelResource$$Original = $LevelResource;}
declare module "net.minecraft.world.level.block.WallBannerBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$AbstractBannerBlock} from "net.minecraft.world.level.block.AbstractBannerBlock"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $WallBannerBlock extends $AbstractBannerBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($WallBannerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $DyeColor$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getDescriptionId"(): StringJS
public "codec"(): $MapCodec<($WallBannerBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallBannerBlock$$Type = ($WallBannerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallBannerBlock$$Original = $WallBannerBlock;}
declare module "net.minecraft.world.level.block.FallingBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Fallable$$Interface} from "net.minecraft.world.level.block.Fallable"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FallingBlock extends $Block implements $Fallable$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getDustColor"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): integer
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public static "isFree"(arg0: $BlockState$$Type): boolean
public "onLand"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $FallingBlockEntity$$Type): void
public "onBrokenAfterFall"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FallingBlockEntity$$Type): void
public "getFallDamageSource"(arg0: $Entity$$Type): $DamageSource
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FallingBlock$$Type = ($FallingBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FallingBlock$$Original = $FallingBlock;}
declare module "net.minecraft.world.level.block.DaylightDetectorBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DaylightDetectorBlock extends $BaseEntityBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($DaylightDetectorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "POWER": $IntegerProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "INVERTED": $BooleanProperty
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($DaylightDetectorBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DaylightDetectorBlock$$Type = ($DaylightDetectorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DaylightDetectorBlock$$Original = $DaylightDetectorBlock;}
declare module "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext" {
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$StructureTemplateManager, $StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Record} from "java.lang.Record"
import {$ResourceManager, $ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $StructurePieceSerializationContext extends $Record {
constructor(arg0: $ResourceManager$$Type, arg1: $RegistryAccess$$Type, arg2: $StructureTemplateManager$$Type)

public "structureTemplateManager"(): $StructureTemplateManager
public static "fromLevel"(arg0: $ServerLevel$$Type): $StructurePieceSerializationContext
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "resourceManager"(): $ResourceManager
public "registryAccess"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePieceSerializationContext$$Type = ({"registryAccess"?: $RegistryAccess$$Type, "resourceManager"?: $ResourceManager$$Type, "structureTemplateManager"?: $StructureTemplateManager$$Type}) | ([registryAccess?: $RegistryAccess$$Type, resourceManager?: $ResourceManager$$Type, structureTemplateManager?: $StructureTemplateManager$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePieceSerializationContext$$Original = $StructurePieceSerializationContext;}
declare module "net.minecraft.world.level.block.TrapDoorBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Half} from "net.minecraft.world.level.block.state.properties.Half"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$HorizontalDirectionalBlock} from "net.minecraft.world.level.block.HorizontalDirectionalBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $TrapDoorBlock extends $HorizontalDirectionalBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($TrapDoorBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "OPEN": $BooleanProperty
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "HALF": $EnumProperty<($Half)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockSetType$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "isLadder"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $LivingEntity$$Type): boolean
public "codec"(): $MapCodec<($TrapDoorBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrapDoorBlock$$Type = ($TrapDoorBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrapDoorBlock$$Original = $TrapDoorBlock;}
declare module "net.minecraft.world.level.levelgen.WorldDimensions" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Optional} from "java.util.Optional"
import {$ImmutableSet} from "com.google.common.collect.ImmutableSet"
import {$Level} from "net.minecraft.world.level.Level"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$WorldDimensions$Complete} from "net.minecraft.world.level.levelgen.WorldDimensions$Complete"
import {$LevelStem, $LevelStem$$Type} from "net.minecraft.world.level.dimension.LevelStem"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$DimensionType$$Type} from "net.minecraft.world.level.dimension.DimensionType"
import {$Record} from "java.lang.Record"

export class $WorldDimensions extends $Record {
static readonly "CODEC": $MapCodec<($WorldDimensions)>

constructor(dimensions: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>)
constructor(arg0: $Registry$$Type<($LevelStem$$Type)>)

public static "keysInOrder"(arg0: $Stream$$Type<($ResourceKey$$Type<($LevelStem$$Type)>)>): $Stream<($ResourceKey<($LevelStem)>)>
public "levels"(): $ImmutableSet<($ResourceKey<($Level)>)>
public "get"(arg0: $ResourceKey$$Type<($LevelStem)>): $Optional<($LevelStem)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "dimensions"(): $Map<($ResourceKey<($LevelStem)>), ($LevelStem)>
public "isDebug"(): boolean
public "bake"(arg0: $Registry$$Type<($LevelStem$$Type)>): $WorldDimensions$Complete
public "overworld"(): $ChunkGenerator
public static "withOverworld"(arg0: $Registry$$Type<($DimensionType$$Type)>, arg1: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>, arg2: $ChunkGenerator$$Type): $Map<($ResourceKey<($LevelStem)>), ($LevelStem)>
public static "withOverworld"(arg0: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>, arg1: $Holder$$Type<($DimensionType)>, arg2: $ChunkGenerator$$Type): $Map<($ResourceKey<($LevelStem)>), ($LevelStem)>
public "replaceOverworldGenerator"(arg0: $RegistryAccess$$Type, arg1: $ChunkGenerator$$Type): $WorldDimensions
get "debug"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldDimensions$$Type = ({"dimensions"?: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>}) | ([dimensions?: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldDimensions$$Original = $WorldDimensions;}
declare module "net.minecraft.world.level.block.GrowingPlantHeadBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$GrowingPlantBlock} from "net.minecraft.world.level.block.GrowingPlantBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item} from "net.minecraft.world.item.Item"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $GrowingPlantHeadBlock extends $GrowingPlantBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

public "getStateForPlacement"(arg0: $LevelAccessor$$Type): $BlockState
public "isMaxAge"(arg0: $BlockState$$Type): boolean
public "getMaxAgeState"(arg0: $BlockState$$Type): $BlockState
public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GrowingPlantHeadBlock$$Type = ($GrowingPlantHeadBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GrowingPlantHeadBlock$$Original = $GrowingPlantHeadBlock;}
declare module "net.minecraft.world.level.block.entity.BlockEntity" {
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IBlockEntityExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBlockEntityExtension"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityAccessor$$Interface as $BlockEntityAccessor$0$$Interface} from "io.wispforest.owo.mixin.ui.access.BlockEntityAccessor"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntityAccessor$$Interface} from "com.copycatsplus.copycats.mixin.foundation.copycat.BlockEntityAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SupportCache$$Interface} from "net.caffeinemc.mods.lithium.common.world.blockentity.SupportCache"
import {$Cullable$$Interface} from "dev.tr7zw.entityculling.versionless.access.Cullable"
import {$AttachmentType$$Type} from "net.neoforged.neoforge.attachment.AttachmentType"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$SetChangedHandlingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SetChangedHandlingBlockEntity"
import {$AttachmentHolder} from "net.neoforged.neoforge.attachment.AttachmentHolder"
import {$ClientGamePacketListener} from "net.minecraft.network.protocol.game.ClientGamePacketListener"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AccessorBlockEntity$$Interface} from "com.railwayteam.railways.mixin.AccessorBlockEntity"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ComparatorTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_comparator_tracking.ComparatorTracker"
import {$ClientboundBlockEntityDataPacket$$Type} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$Connection$$Type} from "net.minecraft.network.Connection"
import {$CrashReportCategory$$Type} from "net.minecraft.CrashReportCategory"

export class $BlockEntity extends $AttachmentHolder implements $IBlockEntityExtension$$Interface, $AccessorBlockEntity$$Interface, $BlockEntityAccessor$0$$Interface, $BlockEntityAccessor$$Interface, $SupportCache$$Interface, $ComparatorTracker$$Interface, $SetChangedHandlingBlockEntity$$Interface, $Cullable$$Interface {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public static "addEntityType"(arg0: $CompoundTag$$Type, arg1: $BlockEntityType$$Type<(never)>): void
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "saveCustomOnly"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "saveToItem"(arg0: $ItemStack$$Type, arg1: $HolderLookup$Provider$$Type): void
public "isValidBlockState"(arg0: $BlockState$$Type): boolean
public static "getPosFromTag"(arg0: $CompoundTag$$Type): $BlockPos
public "loadWithComponents"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "loadCustomOnly"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "saveWithFullMetadata"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "saveWithoutMetadata"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "saveWithId"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "loadStatic"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $CompoundTag$$Type, arg3: $HolderLookup$Provider$$Type): $BlockEntity
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "clearRemoved"(): void
public "applyComponentsFromItemStack"(arg0: $ItemStack$$Type): void
public "setComponents"(arg0: $DataComponentMap$$Type): void
public static "parseCustomNameSafe"(arg0: StringJS, arg1: $HolderLookup$Provider$$Type): $Component
public "lithium$isSupported"(): boolean
public "lithium$onComparatorAdded"(arg0: $Direction$$Type, arg1: integer): void
public "lithium$hasAnyComparatorNearby"(): boolean
public "setWorldPosition"(arg0: $BlockPos$$Type): void
public "owo$setCachedState"(arg0: $BlockState$$Type): void
public "callSaveMetadata"(arg0: $CompoundTag$$Type): void
public "removeData"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "setData"<T>(arg0: $AttachmentType$$Type<(T)>, arg1: T): T
public "setTimeout"(): void
public "getLevel"(): $Level
public "setLevel"(arg0: $Level$$Type): void
public "getType"(): $BlockEntityType<(never)>
public "components"(): $DataComponentMap
public "isRemoved"(): boolean
public "getBlockPos"(): $BlockPos
public "getBlockState"(): $BlockState
public "saveCustomAndMetadata"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
/**
 * 
 * @deprecated
 */
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "collectComponents"(): $DataComponentMap
public "applyComponents"(arg0: $DataComponentMap$$Type, arg1: $DataComponentPatch$$Type): void
public "setChanged"(): void
public "getPersistentData"(): $CompoundTag
public "setRemoved"(): void
public "fillCrashReportCategory"(arg0: $CrashReportCategory$$Type): void
public "onlyOpCanSetNbt"(): boolean
public "syncData"(arg0: $AttachmentType$$Type<(never)>): void
public "isForcedVisible"(): boolean
public "setCulled"(value: boolean): void
public "isCulled"(): boolean
public "setOutOfCamera"(value: boolean): void
public "isOutOfCamera"(): boolean
public "triggerEvent"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "setBlockState"(arg0: $BlockState$$Type): void
public "hasLevel"(): boolean
public "requestModelDataUpdate"(): void
public "onDataPacket"(arg0: $Connection$$Type, arg1: $ClientboundBlockEntityDataPacket$$Type, arg2: $HolderLookup$Provider$$Type): void
public "handleUpdateTag"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "onChunkUnloaded"(): void
public "onLoad"(): void
public "hasCustomOutlineRendering"(arg0: $Player$$Type): boolean
public "invalidateCapabilities"(): void
public "getModelData"(): $ModelData
public "lithium$handleSetChanged"(): void
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
set "worldPosition"(value: $BlockPos$$Type)
get "timeout"(): void
get "level"(): $Level
set "level"(value: $Level$$Type)
get "type"(): $BlockEntityType<(never)>
get "removed"(): boolean
get "blockPos"(): $BlockPos
get "blockState"(): $BlockState
get "changed"(): void
get "persistentData"(): $CompoundTag
get "removed"(): void
get "forcedVisible"(): boolean
set "culled"(value: boolean)
get "culled"(): boolean
set "outOfCamera"(value: boolean)
get "outOfCamera"(): boolean
set "blockState"(value: $BlockState$$Type)
get "modelData"(): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntity$$Type = ($BlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntity$$Original = $BlockEntity;}
declare module "net.minecraft.world.level.chunk.PalettedContainer$Data" {
import {$PalettedContainer$Configuration, $PalettedContainer$Configuration$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$Configuration"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Palette, $Palette$$Type} from "net.minecraft.world.level.chunk.Palette"
import {$BitStorage, $BitStorage$$Type} from "net.minecraft.util.BitStorage"
import {$Record} from "java.lang.Record"

export class $PalettedContainer$Data<T> extends $Record {
public "getSerializedSize"(): integer
public "copyFrom"(arg0: $Palette$$Type<(T)>, arg1: $BitStorage$$Type): void
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "write"(arg0: $FriendlyByteBuf$$Type): void
public "configuration"(): $PalettedContainer$Configuration<(T)>
public "copy"(): $PalettedContainer$Data<(T)>
public "storage"(): $BitStorage
public "palette"(): $Palette<(T)>
get "serializedSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainer$Data$$Type<T> = ({"configuration"?: $PalettedContainer$Configuration$$Type<(T)>, "palette"?: $Palette$$Type<(T)>, "storage"?: $BitStorage$$Type}) | ([configuration?: $PalettedContainer$Configuration$$Type<(T)>, palette?: $Palette$$Type<(T)>, storage?: $BitStorage$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainer$Data$$Original<T> = $PalettedContainer$Data<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.NoOpFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $NoOpFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoOpFeature$$Type = ($NoOpFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoOpFeature$$Original = $NoOpFeature;}
declare module "net.minecraft.world.level.block.state.properties.StairsShape" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $StairsShape extends $Enum<($StairsShape)> implements $StringRepresentable$$Interface {
static readonly "INNER_LEFT": $StairsShape
static readonly "INNER_RIGHT": $StairsShape
static readonly "OUTER_LEFT": $StairsShape
static readonly "OUTER_RIGHT": $StairsShape
static readonly "STRAIGHT": $StairsShape

public "toString"(): StringJS
public static "values"(): ($StairsShape)[]
public static "valueOf"(arg0: StringJS): $StairsShape
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StairsShape$$Type = (("straight") | ("inner_left") | ("inner_right") | ("outer_left") | ("outer_right"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StairsShape$$Original = $StairsShape;}
declare module "net.minecraft.world.level.block.BlastFurnaceBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$AbstractFurnaceBlock} from "net.minecraft.world.level.block.AbstractFurnaceBlock"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlastFurnaceBlock extends $AbstractFurnaceBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BlastFurnaceBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($BlastFurnaceBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlastFurnaceBlock$$Type = ($BlastFurnaceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlastFurnaceBlock$$Original = $BlastFurnaceBlock;}
declare module "net.minecraft.world.level.LevelWriter" {
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $LevelWriter$$Interface {
}

export class $LevelWriter implements $LevelWriter$$Interface {
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelWriter$$Type = ($LevelWriter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelWriter$$Original = $LevelWriter;}
declare module "net.minecraft.world.level.block.BeaconBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BeaconBeamBlock$$Interface} from "net.minecraft.world.level.block.BeaconBeamBlock"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$DyeColor} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BeaconBlock extends $BaseEntityBlock implements $BeaconBeamBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BeaconBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "getColor"(): $DyeColor
public "codec"(): $MapCodec<($BeaconBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeaconBlock$$Type = ($BeaconBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeaconBlock$$Original = $BeaconBlock;}
declare module "net.minecraft.world.level.levelgen.feature.RandomBooleanSelectorFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration, $RandomBooleanFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $RandomBooleanSelectorFeature extends $Feature<($RandomBooleanFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($RandomBooleanFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($RandomBooleanFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomBooleanSelectorFeature$$Type = ($RandomBooleanSelectorFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomBooleanSelectorFeature$$Original = $RandomBooleanSelectorFeature;}
declare module "net.minecraft.world.level.storage.loot.providers.score.ScoreboardNameProvider" {
import {$LootContextParam} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$LootScoreProviderType} from "net.minecraft.world.level.storage.loot.providers.score.LootScoreProviderType"
import {$ScoreHolder} from "net.minecraft.world.scores.ScoreHolder"
import {$Set} from "java.util.Set"

export interface $ScoreboardNameProvider$$Interface {
get "referencedContextParams"(): $Set<($LootContextParam<(never)>)>
get "type"(): $LootScoreProviderType
}

export class $ScoreboardNameProvider implements $ScoreboardNameProvider$$Interface {
 "getReferencedContextParams"(): $Set<($LootContextParam<(never)>)>
 "getScoreHolder"(arg0: $LootContext$$Type): $ScoreHolder
 "getType"(): $LootScoreProviderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScoreboardNameProvider$$Type = ($ScoreboardNameProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScoreboardNameProvider$$Original = $ScoreboardNameProvider;}
declare module "net.minecraft.world.level.block.CandleCakeBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$AbstractCandleBlock} from "net.minecraft.world.level.block.AbstractCandleBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CandleBlock$$Type} from "net.minecraft.world.level.block.CandleBlock"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CandleCakeBlock extends $AbstractCandleBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CandleCakeBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "LIT": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "LIGHT_PER_CANDLE": integer

constructor(arg0: $Block$$Type, arg1: $BlockBehaviour$Properties$$Type)

public static "canLight"(arg0: $BlockState$$Type): boolean
public static "byCandle"(arg0: $CandleBlock$$Type): $BlockState
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($CandleCakeBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CandleCakeBlock$$Type = ($CandleCakeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CandleCakeBlock$$Original = $CandleCakeBlock;}
declare module "net.minecraft.world.level.BaseCommandBlock" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$CommandSource$$Interface} from "net.minecraft.commands.CommandSource"
import {$CommandSourceStack} from "net.minecraft.commands.CommandSourceStack"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $BaseCommandBlock implements $CommandSource$$Interface {
constructor()

public "usedBy"(arg0: $Player$$Type): $InteractionResult
public "getSuccessCount"(): integer
public "getCommand"(): StringJS
public "setSuccessCount"(arg0: integer): void
public "performCommand"(arg0: $Level$$Type): boolean
public "setTrackOutput"(arg0: boolean): void
public "getLastOutput"(): $Component
public "setLastOutput"(arg0: $Component$$Type): void
public "setCommand"(arg0: StringJS): void
public "onUpdated"(): void
public "isTrackOutput"(): boolean
public "getPosition"(): $Vec3
public "isValid"(): boolean
public "getLevel"(): $ServerLevel
public "getName"(): $Component
public "load"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "save"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "sendSystemMessage"(arg0: $Component$$Type): void
public "createCommandSourceStack"(): $CommandSourceStack
public "getCustomName"(): $Component
public "setCustomName"(arg0: $Component$$Type): void
public "acceptsSuccess"(): boolean
public "acceptsFailure"(): boolean
public "shouldInformAdmins"(): boolean
public "alwaysAccepts"(): boolean
get "successCount"(): integer
get "command"(): StringJS
set "successCount"(value: integer)
set "trackOutput"(value: boolean)
get "lastOutput"(): $Component
set "lastOutput"(value: $Component$$Type)
set "command"(value: StringJS)
get "trackOutput"(): boolean
get "position"(): $Vec3
get "valid"(): boolean
get "level"(): $ServerLevel
get "name"(): $Component
get "customName"(): $Component
set "customName"(value: $Component$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseCommandBlock$$Type = ($BaseCommandBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseCommandBlock$$Original = $BaseCommandBlock;}
declare module "net.minecraft.world.level.block.AbstractCauldronBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$CauldronInteraction$InteractionMap$$Type} from "net.minecraft.core.cauldron.CauldronInteraction$InteractionMap"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AbstractCauldronBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type, arg1: $CauldronInteraction$InteractionMap$$Type)

public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "isFull"(arg0: $BlockState$$Type): boolean
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractCauldronBlock$$Type = ($AbstractCauldronBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractCauldronBlock$$Original = $AbstractCauldronBlock;}
declare module "net.minecraft.world.level.block.WeatheringCopper" {
import {$BiMap} from "com.google.common.collect.BiMap"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ChangeOverTimeBlock$$Interface} from "net.minecraft.world.level.block.ChangeOverTimeBlock"
import {$Optional} from "java.util.Optional"
import {$Supplier} from "java.util.function.Supplier"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WeatheringCopper$WeatherState, $WeatheringCopper$WeatherState$$Type} from "net.minecraft.world.level.block.WeatheringCopper$WeatherState"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $WeatheringCopper$$Interface extends $ChangeOverTimeBlock$$Interface<($WeatheringCopper$WeatherState)> {

(): $WeatheringCopper$WeatherState$$Type
get "chanceModifier"(): float
get "age"(): $WeatheringCopper$WeatherState
}

export class $WeatheringCopper implements $WeatheringCopper$$Interface {
/**
 * 
 * @deprecated
 */
static readonly "NEXT_BY_BLOCK": $Supplier<($BiMap<($Block), ($Block)>)>
/**
 * 
 * @deprecated
 */
static readonly "PREVIOUS_BY_BLOCK": $Supplier<($BiMap<($Block), ($Block)>)>

 "getChanceModifier"(): float
 "getNext"(arg0: $BlockState$$Type): $Optional<($BlockState)>
static "getNext"(arg0: $Block$$Type): $Optional<($Block)>
static "getFirst"(arg0: $BlockState$$Type): $BlockState
static "getFirst"(arg0: $Block$$Type): $Block
static "getPrevious"(arg0: $BlockState$$Type): $Optional<($BlockState)>
static "getPrevious"(arg0: $Block$$Type): $Optional<($Block)>
 "changeOverTime"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
 "getNextState"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($BlockState)>
 "getAge"(): $WeatheringCopper$WeatherState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeatheringCopper$$Type = (() => $WeatheringCopper$WeatherState$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeatheringCopper$$Original = $WeatheringCopper;}
declare module "net.minecraft.world.level.levelgen.placement.RarityFilter" {
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$PlacementFilter} from "net.minecraft.world.level.levelgen.placement.PlacementFilter"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $RarityFilter extends $PlacementFilter {
static readonly "CODEC": $MapCodec<($RarityFilter)>

public static "onAverageOnceEvery"(arg0: integer): $RarityFilter
public "type"(): $PlacementModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RarityFilter$$Type = ($RarityFilter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RarityFilter$$Original = $RarityFilter;}
declare module "net.minecraft.world.level.block.entity.BedBlockEntity" {
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BedBlockEntity extends $BlockEntity {
static readonly "ATTACHMENTS_NBT_KEY": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $DyeColor$$Type)

public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "setColor"(arg0: $DyeColor$$Type): void
public "getColor"(): $DyeColor
get "updatePacket"(): $ClientboundBlockEntityDataPacket
set "color"(value: $DyeColor$$Type)
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BedBlockEntity$$Type = ($BedBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BedBlockEntity$$Original = $BedBlockEntity;}
declare module "net.minecraft.world.level.saveddata.SavedData$Factory" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$DataFixTypes, $DataFixTypes$$Type} from "net.minecraft.util.datafix.DataFixTypes"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$SavedData} from "net.minecraft.world.level.saveddata.SavedData"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Record} from "java.lang.Record"

export class $SavedData$Factory<T extends $SavedData> extends $Record {
constructor(arg0: $Supplier$$Type<(T)>, arg1: $BiFunction$$Type<($CompoundTag), ($HolderLookup$Provider), (T)>)
constructor(arg0: $Supplier$$Type<(T)>, deserializer: $BiFunction$$Type<($CompoundTag), ($HolderLookup$Provider), (T)>, type: $DataFixTypes$$Type)

public "type"(): $DataFixTypes
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "constructor"(): $Supplier<(T)>
public "deserializer"(): $BiFunction<($CompoundTag), ($HolderLookup$Provider), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SavedData$Factory$$Type<T> = ({"type"?: $DataFixTypes$$Type, "deserializer"?: $BiFunction$$Type<($CompoundTag$$Type), ($HolderLookup$Provider$$Type), (T)>, "constructor"?: $Supplier$$Type<(T)>}) | ([type?: $DataFixTypes$$Type, deserializer?: $BiFunction$$Type<($CompoundTag$$Type), ($HolderLookup$Provider$$Type), (T)>, arg?: $Supplier$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SavedData$Factory$$Original<T> = $SavedData$Factory<(T)>;}
declare module "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool" {
import {$Pair, $Pair$$Type} from "com.mojang.datafixers.util.Pair"
import {$TemplatePoolAccess$$Interface} from "blusunrize.immersiveengineering.mixin.accessors.TemplatePoolAccess"
import {$List, $List$$Type} from "java.util.List"
import {$StructurePoolElement, $StructurePoolElement$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$ObjectArrayList} from "it.unimi.dsi.fastutil.objects.ObjectArrayList"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$StructureTemplatePoolAccess$$Interface} from "me.desht.pneumaticcraft.mixin.accessors.StructureTemplatePoolAccess"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureTemplatePool$Projection$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection"
import {$Function$$Type} from "java.util.function.Function"

export class $StructureTemplatePool implements $StructureTemplatePoolAccess$$Interface, $TemplatePoolAccess$$Interface {
static readonly "CODEC": $Codec<($Holder<($StructureTemplatePool)>)>
 "rawTemplates": $List<($Pair<($StructurePoolElement), (integer)>)>
 "templates": $ObjectArrayList<($StructurePoolElement)>
static readonly "DIRECT_CODEC": $Codec<($StructureTemplatePool)>

constructor(arg0: $Holder$$Type<($StructureTemplatePool)>, arg1: $List$$Type<($Pair$$Type<($StructurePoolElement$$Type), (integer)>)>)
constructor(arg0: $Holder$$Type<($StructureTemplatePool)>, arg1: $List$$Type<($Pair$$Type<($Function$$Type<($StructureTemplatePool$Projection$$Type), ($StructurePoolElement$$Type)>), (integer)>)>, arg2: $StructureTemplatePool$Projection$$Type)

public "getRandomTemplate"(arg0: $RandomSource$$Type): $StructurePoolElement
public "getShuffledTemplates"(arg0: $RandomSource$$Type): $List<($StructurePoolElement)>
public "getTemplates"(): $ObjectArrayList
public "getRawTemplates"(): $List
public "setRawTemplates"(arg0: $List$$Type): void
public "getMaxSize"(arg0: $StructureTemplateManager$$Type): integer
public "size"(): integer
public "getFallback"(): $Holder<($StructureTemplatePool)>
get "fallback"(): $Holder<($StructureTemplatePool)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenTemplatePool
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenTemplatePoolTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplatePool$$Type = (Special.WorldgenTemplatePool);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplatePool$$Original = $StructureTemplatePool;}
declare module "net.minecraft.world.level.levelgen.feature.TwistingVinesFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig, $TwistingVinesConfig$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$BlockPos$MutableBlockPos$$Type} from "net.minecraft.core.BlockPos$MutableBlockPos"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $TwistingVinesFeature extends $Feature<($TwistingVinesConfig)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($TwistingVinesConfig$$Type)>)

public static "placeWeepingVinesColumn"(arg0: $LevelAccessor$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$MutableBlockPos$$Type, arg3: integer, arg4: integer, arg5: integer): void
public "place"(arg0: $FeaturePlaceContext$$Type<($TwistingVinesConfig$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TwistingVinesFeature$$Type = ($TwistingVinesFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TwistingVinesFeature$$Original = $TwistingVinesFeature;}
declare module "net.minecraft.world.level.storage.LevelSummary$BackupStatus" {
import {$Enum} from "java.lang.Enum"

export class $LevelSummary$BackupStatus extends $Enum<($LevelSummary$BackupStatus)> {
static readonly "UPGRADE_TO_SNAPSHOT": $LevelSummary$BackupStatus
static readonly "DOWNGRADE": $LevelSummary$BackupStatus
static readonly "NONE": $LevelSummary$BackupStatus

public "isSevere"(): boolean
public "getTranslationKey"(): StringJS
public static "values"(): ($LevelSummary$BackupStatus)[]
public static "valueOf"(arg0: StringJS): $LevelSummary$BackupStatus
public "shouldBackup"(): boolean
get "severe"(): boolean
get "translationKey"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelSummary$BackupStatus$$Type = (("none") | ("downgrade") | ("upgrade_to_snapshot"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelSummary$BackupStatus$$Original = $LevelSummary$BackupStatus;}
declare module "net.minecraft.world.level.levelgen.feature.GlowstoneFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $GlowstoneFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlowstoneFeature$$Type = ($GlowstoneFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GlowstoneFeature$$Original = $GlowstoneFeature;}
declare module "net.minecraft.world.level.levelgen.structure.TerrainAdjustment" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $TerrainAdjustment extends $Enum<($TerrainAdjustment)> implements $StringRepresentable$$Interface {
static readonly "ENCAPSULATE": $TerrainAdjustment
static readonly "CODEC": $Codec<($TerrainAdjustment)>
static readonly "BURY": $TerrainAdjustment
static readonly "NONE": $TerrainAdjustment
static readonly "BEARD_BOX": $TerrainAdjustment
static readonly "BEARD_THIN": $TerrainAdjustment

public static "values"(): ($TerrainAdjustment)[]
public static "valueOf"(arg0: StringJS): $TerrainAdjustment
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TerrainAdjustment$$Type = (("none") | ("bury") | ("beard_thin") | ("beard_box") | ("encapsulate"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TerrainAdjustment$$Original = $TerrainAdjustment;}
declare module "net.minecraft.world.level.block.SpongeBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $SpongeBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SpongeBlock)>
static readonly "MAX_COUNT": integer
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "MAX_DEPTH": integer
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($SpongeBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpongeBlock$$Type = ($SpongeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpongeBlock$$Original = $SpongeBlock;}
declare module "net.minecraft.world.level.block.PowderSnowBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Item} from "net.minecraft.world.item.Item"
import {$BucketPickup$$Interface} from "net.minecraft.world.level.block.BucketPickup"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MoreBlockCulling$$Interface} from "ca.fxco.moreculling.api.block.MoreBlockCulling"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PowderSnowBlock extends $Block implements $BucketPickup$$Interface, $MoreBlockCulling$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PowderSnowBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getPickupSound"(): $Optional<($SoundEvent)>
public "moreculling$customShouldDrawFace"(arg0: $BlockGetter$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: $Direction$$Type): $Optional
public "moreculling$usesCustomShouldDrawFace"(arg0: $BlockState$$Type): boolean
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($PowderSnowBlock)>
public static "canEntityWalkOnPowderSnow"(arg0: $Entity$$Type): boolean
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public "moreculling$cantCullAgainst"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "moreculling$shouldAttemptToCull"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): boolean
public "moreculling$canCull"(): boolean
public "moreculling$setCanCull"(arg0: boolean): void
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PowderSnowBlock$$Type = ($PowderSnowBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PowderSnowBlock$$Original = $PowderSnowBlock;}
declare module "net.minecraft.world.level.block.SlimeBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$HalfTransparentBlock} from "net.minecraft.world.level.block.HalfTransparentBlock"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SlimeBlock extends $HalfTransparentBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SlimeBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($SlimeBlock)>
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "stepOn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type): void
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlimeBlock$$Type = ($SlimeBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlimeBlock$$Original = $SlimeBlock;}
declare module "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner" {
import {$TrialSpawnerState, $TrialSpawnerState$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$Optional} from "java.util.Optional"
import {$UUID} from "java.util.UUID"
import {$TrialSpawnerData, $TrialSpawnerData$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerData"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$TrialSpawner$StateAccessor$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner$StateAccessor"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$IOwnedSpawner$$Interface} from "net.neoforged.neoforge.common.extensions.IOwnedSpawner"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlayerDetector, $PlayerDetector$$Type} from "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Either} from "com.mojang.datafixers.util.Either"
import {$SimpleParticleType$$Type} from "net.minecraft.core.particles.SimpleParticleType"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrialSpawnerConfig, $TrialSpawnerConfig$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerConfig"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$PlayerDetector$EntitySelector, $PlayerDetector$EntitySelector$$Type} from "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector$EntitySelector"

export class $TrialSpawner implements $IOwnedSpawner$$Interface {
static readonly "DETECT_PLAYER_SPAWN_BUFFER": integer
static readonly "NORMAL_CONFIG_TAG_NAME": StringJS
static readonly "OMINOUS_CONFIG_TAG_NAME": StringJS

constructor(arg0: $TrialSpawner$StateAccessor$$Type, arg1: $PlayerDetector$$Type, arg2: $PlayerDetector$EntitySelector$$Type)
constructor(arg0: $TrialSpawnerConfig$$Type, arg1: $TrialSpawnerConfig$$Type, arg2: $TrialSpawnerData$$Type, arg3: integer, arg4: integer, arg5: $TrialSpawner$StateAccessor$$Type, arg6: $PlayerDetector$$Type, arg7: $PlayerDetector$EntitySelector$$Type)

public "tickClient"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: boolean): void
public "tickServer"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: boolean): void
public "canSpawnInLevel"(arg0: $Level$$Type): boolean
public "isOminous"(): boolean
public "getTargetCooldownLength"(): integer
public "spawnMob"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): $Optional<($UUID)>
public "removeOminous"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): void
public "getRequiredPlayerRange"(): integer
public "getOminousConfig"(): $TrialSpawnerConfig
public "ejectReward"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $ResourceKey$$Type<($LootTable)>): void
public "markUpdated"(): void
public "getNormalConfig"(): $TrialSpawnerConfig
/**
 * 
 * @deprecated
 */
public "setPlayerDetector"(arg0: $PlayerDetector$$Type): void
public "applyOminous"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): void
public "getPlayerDetector"(): $PlayerDetector
public "getEntitySelector"(): $PlayerDetector$EntitySelector
/**
 * 
 * @deprecated
 */
public "overridePeacefulAndMobSpawnRule"(): void
public "getData"(): $TrialSpawnerData
public "getState"(): $TrialSpawnerState
public "setState"(arg0: $Level$$Type, arg1: $TrialSpawnerState$$Type): void
public "getOwner"(): $Either<($BlockEntity), ($Entity)>
public "getConfig"(): $TrialSpawnerConfig
public "codec"(): $Codec<($TrialSpawner)>
public static "addSpawnParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type, arg3: $SimpleParticleType$$Type): void
public static "addDetectPlayerParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type, arg3: integer, arg4: $ParticleOptions$$Type): void
public static "addEjectItemParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public static "addBecomeOminousParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
get "ominous"(): boolean
get "targetCooldownLength"(): integer
get "requiredPlayerRange"(): integer
get "ominousConfig"(): $TrialSpawnerConfig
get "normalConfig"(): $TrialSpawnerConfig
set "playerDetector"(value: $PlayerDetector$$Type)
get "playerDetector"(): $PlayerDetector
get "entitySelector"(): $PlayerDetector$EntitySelector
get "data"(): $TrialSpawnerData
get "state"(): $TrialSpawnerState
get "owner"(): $Either<($BlockEntity), ($Entity)>
get "config"(): $TrialSpawnerConfig
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawner$$Type = ($TrialSpawner);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawner$$Original = $TrialSpawner;}
declare module "net.minecraft.world.level.storage.CommandStorage" {
import {$DimensionDataStorage$$Type} from "net.minecraft.world.level.storage.DimensionDataStorage"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Stream} from "java.util.stream.Stream"

export class $CommandStorage {
constructor(arg0: $DimensionDataStorage$$Type)

public "get"(arg0: $ResourceLocation$$Type): $CompoundTag
public "set"(arg0: $ResourceLocation$$Type, arg1: $CompoundTag$$Type): void
public "keys"(): $Stream<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandStorage$$Type = ($CommandStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandStorage$$Original = $CommandStorage;}
declare module "net.minecraft.world.level.block.BaseCoralFanBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BaseCoralPlantTypeBlock} from "net.minecraft.world.level.block.BaseCoralPlantTypeBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $BaseCoralFanBlock extends $BaseCoralPlantTypeBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BaseCoralFanBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($BaseCoralFanBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseCoralFanBlock$$Type = ($BaseCoralFanBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseCoralFanBlock$$Original = $BaseCoralFanBlock;}
declare module "net.minecraft.world.level.block.state.pattern.BlockPattern$BlockPatternMatch" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockInWorld, $BlockInWorld$$Type} from "net.minecraft.world.level.block.state.pattern.BlockInWorld"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LoadingCache$$Type} from "com.google.common.cache.LoadingCache"

export class $BlockPattern$BlockPatternMatch {
constructor(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: $Direction$$Type, arg3: $LoadingCache$$Type<($BlockPos$$Type), ($BlockInWorld$$Type)>, arg4: integer, arg5: integer, arg6: integer)

public "getForwards"(): $Direction
public "getFrontTopLeft"(): $BlockPos
public "getUp"(): $Direction
public "getWidth"(): integer
public "getHeight"(): integer
public "getBlock"(arg0: integer, arg1: integer, arg2: integer): $BlockInWorld
public "toString"(): StringJS
public "getDepth"(): integer
get "forwards"(): $Direction
get "frontTopLeft"(): $BlockPos
get "up"(): $Direction
get "width"(): integer
get "height"(): integer
get "depth"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPattern$BlockPatternMatch$$Type = ($BlockPattern$BlockPatternMatch);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPattern$BlockPatternMatch$$Original = $BlockPattern$BlockPatternMatch;}
declare module "net.minecraft.world.level.entity.LevelEntityGetter" {
import {$Iterable} from "java.lang.Iterable"
import {$EntityAccess} from "net.minecraft.world.level.entity.EntityAccess"
import {$UUID$$Type} from "java.util.UUID"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$AbortableIterationConsumer$$Type} from "net.minecraft.util.AbortableIterationConsumer"
import {$Consumer$$Type} from "java.util.function.Consumer"

export interface $LevelEntityGetter$$Interface<T extends $EntityAccess> {
get "all"(): $Iterable<(T)>
}

export class $LevelEntityGetter<T extends $EntityAccess> implements $LevelEntityGetter$$Interface {
 "getAll"(): $Iterable<(T)>
 "get"<U extends $EntityAccess>(arg0: $EntityTypeTest$$Type<(T), (U)>, arg1: $AbortableIterationConsumer$$Type<(U)>): void
 "get"<U extends $EntityAccess>(arg0: $EntityTypeTest$$Type<(T), (U)>, arg1: $AABB$$Type, arg2: $AbortableIterationConsumer$$Type<(U)>): void
 "get"(arg0: $AABB$$Type, arg1: $Consumer$$Type<(T)>): void
 "get"(arg0: $UUID$$Type): T
 "get"(arg0: integer): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelEntityGetter$$Type<T> = ($LevelEntityGetter<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelEntityGetter$$Original<T> = $LevelEntityGetter<(T)>;}
declare module "net.minecraft.world.level.block.GrowingPlantBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Item} from "net.minecraft.world.item.Item"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $GrowingPlantBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getStateForPlacement"(arg0: $LevelAccessor$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GrowingPlantBlock$$Type = ($GrowingPlantBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GrowingPlantBlock$$Original = $GrowingPlantBlock;}
declare module "net.minecraft.world.level.EntityGetter" {
import {$Iterable} from "java.lang.Iterable"
import {$UUID$$Type} from "java.util.UUID"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$Class$$Type} from "java.lang.Class"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityGetterKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityGetterKJS"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

export interface $EntityGetter$$Interface extends $EntityGetterKJS$$Interface {
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "players"(): $EntityArrayList
get "entities"(): $EntityArrayList
}

export class $EntityGetter implements $EntityGetter$$Interface {
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
 "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
 "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
 "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
 "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
 "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
 "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
 "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
 "getPlayerByUUID"(arg0: $UUID$$Type): $Player
 "self"(): $EntityGetter
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getPlayers"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityGetter$$Type = ($EntityGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityGetter$$Original = $EntityGetter;}
declare module "net.minecraft.world.level.block.CauldronBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$AbstractCauldronBlock} from "net.minecraft.world.level.block.AbstractCauldronBlock"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Biome$Precipitation$$Type} from "net.minecraft.world.level.biome.Biome$Precipitation"

export class $CauldronBlock extends $AbstractCauldronBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CauldronBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "handlePrecipitation"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Biome$Precipitation$$Type): void
public "isFull"(arg0: $BlockState$$Type): boolean
public "codec"(): $MapCodec<($CauldronBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CauldronBlock$$Type = ($CauldronBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CauldronBlock$$Original = $CauldronBlock;}
declare module "net.minecraft.world.level.block.LightningRodBlock" {
import {$RodBlock} from "net.minecraft.world.level.block.RodBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $LightningRodBlock extends $RodBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LightningRodBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "POWERED": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "RANGE": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "onLightningStrike"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): void
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "codec"(): $MapCodec<($LightningRodBlock)>
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightningRodBlock$$Type = ($LightningRodBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightningRodBlock$$Original = $LightningRodBlock;}
declare module "net.minecraft.world.level.block.state.BlockState" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerPlayer$RespawnPosAngle} from "net.minecraft.server.level.ServerPlayer$RespawnPosAngle"
import {$ItemAbility$$Type} from "net.neoforged.neoforge.common.ItemAbility"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$Function} from "java.util.function.Function"
import {$PathType, $PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockBehaviour$BlockStateBase} from "net.minecraft.world.level.block.state.BlockBehaviour$BlockStateBase"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BubbleColumnDirection} from "net.neoforged.neoforge.common.enums.BubbleColumnDirection"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$TriState} from "net.neoforged.neoforge.common.util.TriState"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Reference2ObjectArrayMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockStateFTBC$$Interface} from "dev.ftb.mods.ftbchunks.core.BlockStateFTBC"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$IBlockStateExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBlockStateExtension"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockState extends $BlockBehaviour$BlockStateBase implements $IBlockStateExtension$$Interface, $BlockStateFTBC$$Interface {
static readonly "PROPERTIES_TAG": StringJS
static readonly "CODEC": $Codec<($BlockState)>
static readonly "PROPERTY_ENTRY_TO_STRING_FUNCTION": $Function<($Map$Entry<($Property<(never)>), ($Comparable<(never)>)>), (StringJS)>
static readonly "NAME_TAG": StringJS

constructor(arg0: $Block$$Type, arg1: $Reference2ObjectArrayMap$$Type<($Property$$Type<(never)>), ($Comparable$$Type<(never)>)>, arg2: $MapCodec$$Type<($BlockState$$Type)>)

public "getFTBCIsWater"(): boolean
public "getBlockPathType"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Mob$$Type): $PathType
public "getAdjacentBlockPathType"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Mob$$Type, arg3: $PathType$$Type): $PathType
public "hidesNeighborFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "supportsExternalFaceHiding"(): boolean
public "getExplosionResistance"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): float
public "ignitedByLava"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "isStickyBlock"(): boolean
public "getFlammability"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): integer
public "hasDynamicLightEmission"(): boolean
public "isLadder"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $LivingEntity$$Type): boolean
public "canHarvestBlock"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Player$$Type): boolean
public "onDestroyedByPlayer"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Player$$Type, arg3: boolean, arg4: $FluidState$$Type): boolean
public "onDestroyedByPushReaction"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $FluidState$$Type): void
public "getRespawnPosition"(arg0: $EntityType$$Type<(never)>, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: float): $Optional<($ServerPlayer$RespawnPosAngle)>
public "canSustainPlant"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $BlockState$$Type): $TriState
public "onTreeGrow"(arg0: $LevelReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $TreeConfiguration$$Type): boolean
public "isFertile"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "isConduitFrame"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type): boolean
public "isPortalFrame"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getExpDrop"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockEntity$$Type, arg3: $Entity$$Type, arg4: $ItemStack$$Type): integer
public "getEnchantPowerBonus"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): float
public "getBeaconColorMultiplier"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type): integer
public "getStateAtViewpoint"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Vec3$$Type): $BlockState
public "isSlimeBlock"(): boolean
public "canStickTo"(arg0: $BlockState$$Type): boolean
public "isFlammable"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "onCaughtFire"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $LivingEntity$$Type): void
public "getFireSpreadSpeed"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): integer
public "isFireSource"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "canEntityDestroy"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): boolean
public "canDropFromExplosion"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): boolean
public "onBlockExploded"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): void
public "shouldDisplayFluidOverlay"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type): boolean
public "getToolModifiedState"(arg0: $UseOnContext$$Type, arg1: $ItemAbility$$Type, arg2: boolean): $BlockState
public "canBeHydrated"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type, arg3: $BlockPos$$Type): boolean
public "getAppearance"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $BlockState$$Type, arg4: $BlockPos$$Type): $BlockState
public "getBubbleColumnDirection"(): $BubbleColumnDirection
public "shouldHideAdjacentFluidFace"(arg0: $Direction$$Type, arg1: $FluidState$$Type): boolean
public "canRedstoneConnectTo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "isEmpty"(): boolean
public "rotate"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BlockState
public "getCloneItemStack"(arg0: $HitResult$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): $ItemStack
public "addLandingEffects"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: integer): boolean
public "getSoundType"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): $SoundType
public "isScaffolding"(arg0: $LivingEntity$$Type): boolean
public "isBed"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $LivingEntity$$Type): boolean
public "setBedOccupied"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $LivingEntity$$Type, arg3: boolean): void
public "getBedDirection"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): $Direction
public "getFriction"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): float
public "collisionExtendsVertically"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): boolean
public "addRunningEffects"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): boolean
public "onNeighborChange"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type): void
public "getWeakChanges"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
public "isBurning"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getLightEmission"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): integer
public "onBlockStateChange"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "shouldCheckWeakPower"(arg0: $SignalGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "FTBCIsWater"(): boolean
get "stickyBlock"(): boolean
get "slimeBlock"(): boolean
get "bubbleColumnDirection"(): $BubbleColumnDirection
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockState$$Type = ($Block$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockState$$Original = $BlockState;}
declare module "net.minecraft.world.level.block.SculkShriekerBlock" {
import {$BaseEntityBlock} from "net.minecraft.world.level.block.BaseEntityBlock"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Item} from "net.minecraft.world.item.Item"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SculkShriekerBlock extends $BaseEntityBlock implements $SimpleWaterloggedBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SculkShriekerBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "CAN_SUMMON": $BooleanProperty
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "TOP_Y": double
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "SHRIEKING": $BooleanProperty
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "getExpDrop"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): integer
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "newBlockEntity"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): $BlockEntity
public "codec"(): $MapCodec<($SculkShriekerBlock)>
public "stepOn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type): void
public "getPickupSound"(): $Optional<($SoundEvent)>
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkShriekerBlock$$Type = ($SculkShriekerBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkShriekerBlock$$Original = $SculkShriekerBlock;}
declare module "net.minecraft.world.level.block.BeetrootBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$CropBlock} from "net.minecraft.world.level.block.CropBlock"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $BeetrootBlock extends $CropBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($BeetrootBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getMaxAge"(): integer
public "codec"(): $MapCodec<($BeetrootBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "maxAge"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeetrootBlock$$Type = ($BeetrootBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeetrootBlock$$Original = $BeetrootBlock;}
declare module "net.minecraft.world.level.block.entity.BannerPattern" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $BannerPattern extends $Record {
static readonly "CODEC": $Codec<($Holder<($BannerPattern)>)>
static readonly "DIRECT_CODEC": $Codec<($BannerPattern)>
static readonly "DIRECT_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($BannerPattern)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Holder<($BannerPattern)>)>

constructor(arg0: $ResourceLocation$$Type, arg1: StringJS)

public "assetId"(): $ResourceLocation
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "translationKey"(): StringJS
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.BannerPattern
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.BannerPatternTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BannerPattern$$Type = (Special.BannerPattern) | ({"assetId"?: $ResourceLocation$$Type, "translationKey"?: StringJS}) | ([assetId?: $ResourceLocation$$Type, translationKey?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BannerPattern$$Original = $BannerPattern;}
declare module "net.minecraft.world.level.lighting.ChunkSkyLightSources" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"

export class $ChunkSkyLightSources {
static readonly "NEGATIVE_INFINITY": integer

constructor(arg0: $LevelHeightAccessor$$Type)

public "getLowestSourceY"(arg0: integer, arg1: integer): integer
public "getHighestLowestSourceY"(): integer
public "update"(arg0: $BlockGetter$$Type, arg1: integer, arg2: integer, arg3: integer): boolean
public "fillFrom"(arg0: $ChunkAccess$$Type): void
get "highestLowestSourceY"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkSkyLightSources$$Type = ($ChunkSkyLightSources);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkSkyLightSources$$Original = $ChunkSkyLightSources;}
declare module "net.minecraft.world.level.levelgen.GeodeCrackSettings" {
import {$Codec} from "com.mojang.serialization.Codec"

export class $GeodeCrackSettings {
static readonly "CODEC": $Codec<($GeodeCrackSettings)>
readonly "generateCrackChance": double
readonly "crackPointOffset": integer
readonly "baseCrackSize": double

constructor(arg0: double, arg1: double, arg2: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeCrackSettings$$Type = ($GeodeCrackSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeodeCrackSettings$$Original = $GeodeCrackSettings;}
declare module "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider" {
import {$DensityFunction$FunctionContext} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunction$ContextProvider$$Interface {
}

export class $DensityFunction$ContextProvider implements $DensityFunction$ContextProvider$$Interface {
 "fillAllDirectly"(arg0: (double)[], arg1: $DensityFunction$$Type): void
 "forIndex"(arg0: integer): $DensityFunction$FunctionContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$ContextProvider$$Type = ($DensityFunction$ContextProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$ContextProvider$$Original = $DensityFunction$ContextProvider;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.JigsawReplacementProcessor" {
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $JigsawReplacementProcessor extends $StructureProcessor {
static readonly "CODEC": $MapCodec<($JigsawReplacementProcessor)>
static readonly "INSTANCE": $JigsawReplacementProcessor

public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JigsawReplacementProcessor$$Type = ($JigsawReplacementProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JigsawReplacementProcessor$$Original = $JigsawReplacementProcessor;}
declare module "net.minecraft.world.level.levelgen.feature.FossilFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration, $FossilFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $FossilFeature extends $Feature<($FossilFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($FossilFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($FossilFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FossilFeature$$Type = ($FossilFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FossilFeature$$Original = $FossilFeature;}
declare module "net.minecraft.world.level.lighting.DataLayerStorageMap" {
import {$DataLayer, $DataLayer$$Type} from "net.minecraft.world.level.chunk.DataLayer"

export class $DataLayerStorageMap<M extends $DataLayerStorageMap<(object)>> {
public "disableCache"(): void
public "removeLayer"(arg0: long): $DataLayer
public "setLayer"(arg0: long, arg1: $DataLayer$$Type): void
public "clearCache"(): void
public "hasLayer"(arg0: long): boolean
public "copyDataLayer"(arg0: long): $DataLayer
public "getLayer"(arg0: long): $DataLayer
public "copy"(): M
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataLayerStorageMap$$Type<M> = ($DataLayerStorageMap<(M)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataLayerStorageMap$$Original<M> = $DataLayerStorageMap<(M)>;}
declare module "net.minecraft.world.level.levelgen.structure.StructureSet$StructureSelectionEntry" {
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $StructureSet$StructureSelectionEntry extends $Record {
static readonly "CODEC": $Codec<($StructureSet$StructureSelectionEntry)>

constructor(arg0: $Holder$$Type<($Structure)>, arg1: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "weight"(): integer
public "structure"(): $Holder<($Structure)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureSet$StructureSelectionEntry$$Type = ({"structure"?: $Holder$$Type<($Structure)>, "weight"?: integer}) | ([structure?: $Holder$$Type<($Structure)>, weight?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureSet$StructureSelectionEntry$$Original = $StructureSet$StructureSelectionEntry;}
declare module "net.minecraft.world.level.block.Portal" {
import {$DimensionTransition, $DimensionTransition$$Type} from "net.minecraft.world.level.portal.DimensionTransition"
import {$Portal$Transition} from "net.minecraft.world.level.block.Portal$Transition"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"

export interface $Portal$$Interface {

(arg0: $ServerLevel, arg1: $Entity, arg2: $BlockPos): $DimensionTransition$$Type
get "localTransition"(): $Portal$Transition
}

export class $Portal implements $Portal$$Interface {
 "getPortalTransitionTime"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type): integer
 "getLocalTransition"(): $Portal$Transition
 "getPortalDestination"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type, arg2: $BlockPos$$Type): $DimensionTransition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Portal$$Type = ((arg0: $ServerLevel, arg1: $Entity, arg2: $BlockPos) => $DimensionTransition$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Portal$$Original = $Portal;}
declare module "net.minecraft.world.level.chunk.ChunkSource" {
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$LightChunkGetter$$Interface} from "net.minecraft.world.level.chunk.LightChunkGetter"
import {$BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$LightChunk} from "net.minecraft.world.level.chunk.LightChunk"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$LevelChunk} from "net.minecraft.world.level.chunk.LevelChunk"

export class $ChunkSource implements $LightChunkGetter$$Interface, $AutoCloseable$$Interface {
constructor()

public "updateChunkForced"(arg0: $ChunkPos$$Type, arg1: boolean): void
public "getLoadedChunksCount"(): integer
public "tick"(arg0: $BooleanSupplier$$Type, arg1: boolean): void
public "close"(): void
public "getChunk"(arg0: integer, arg1: integer, arg2: boolean): $LevelChunk
public "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
public "getChunkNow"(arg0: integer, arg1: integer): $LevelChunk
public "hasChunk"(arg0: integer, arg1: integer): boolean
public "getLightEngine"(): $LevelLightEngine
public "setSpawnSettings"(arg0: boolean, arg1: boolean): void
public "gatherStats"(): StringJS
public "getChunkForLighting"(arg0: integer, arg1: integer): $LightChunk
public "getLevel"(): $BlockGetter
public "onLightUpdate"(arg0: $LightLayer$$Type, arg1: $SectionPos$$Type): void
get "loadedChunksCount"(): integer
get "lightEngine"(): $LevelLightEngine
get "level"(): $BlockGetter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkSource$$Type = ($ChunkSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkSource$$Original = $ChunkSource;}
declare module "net.minecraft.world.level.entity.TransientEntitySectionManager" {
import {$EntitySectionStorage} from "net.minecraft.world.level.entity.EntitySectionStorage"
import {$TransientEntitySectionManagerAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.util.accessors.TransientEntitySectionManagerAccessor"
import {$EntityAccess, $EntityAccess$$Type} from "net.minecraft.world.level.entity.EntityAccess"
import {$Class$$Type} from "java.lang.Class"
import {$LevelEntityGetter} from "net.minecraft.world.level.entity.LevelEntityGetter"
import {$LevelCallback$$Type} from "net.minecraft.world.level.entity.LevelCallback"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export class $TransientEntitySectionManager<T extends $EntityAccess> implements $TransientEntitySectionManagerAccessor$$Interface {
constructor(arg0: $Class$$Type<(T)>, arg1: $LevelCallback$$Type<(T)>)

public "getCache"(): $EntitySectionStorage
public "count"(): integer
public "gatherStats"(): StringJS
public "stopTicking"(arg0: $ChunkPos$$Type): void
public "startTicking"(arg0: $ChunkPos$$Type): void
public "addEntity"(arg0: T): void
public "getEntityGetter"(): $LevelEntityGetter<(T)>
get "cache"(): $EntitySectionStorage
get "entityGetter"(): $LevelEntityGetter<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransientEntitySectionManager$$Type<T> = ($TransientEntitySectionManager<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TransientEntitySectionManager$$Original<T> = $TransientEntitySectionManager<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.BasaltPillarFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $BasaltPillarFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasaltPillarFeature$$Type = ($BasaltPillarFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasaltPillarFeature$$Original = $BasaltPillarFeature;}
declare module "net.minecraft.world.level.storage.loot.parameters.LootContextParam" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export class $LootContextParam<T> {
constructor(arg0: $ResourceLocation$$Type)

public "getName"(): $ResourceLocation
public "toString"(): StringJS
get "name"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContextParam$$Type<T> = ($LootContextParam<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContextParam$$Original<T> = $LootContextParam<(T)>;}
declare module "net.minecraft.world.level.block.StemBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$BushBlock} from "net.minecraft.world.level.block.BushBlock"
import {$BonemealableBlock$Type} from "net.minecraft.world.level.block.BonemealableBlock$Type"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BonemealableBlock$$Interface} from "net.minecraft.world.level.block.BonemealableBlock"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StemBlock extends $BushBlock implements $BonemealableBlock$$Interface {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($StemBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $ResourceKey$$Type<($Block)>, arg1: $ResourceKey$$Type<($Block)>, arg2: $ResourceKey$$Type<($Item)>, arg3: $BlockBehaviour$Properties$$Type)

public "isValidBonemealTarget"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): boolean
public "isBonemealSuccess"(arg0: $Level$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "performBonemeal"(arg0: $ServerLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "codec"(): $MapCodec<($StemBlock)>
public "getParticlePos"(arg0: $BlockPos$$Type): $BlockPos
public "getType"(): $BonemealableBlock$Type
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "type"(): $BonemealableBlock$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StemBlock$$Type = ($StemBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StemBlock$$Original = $StemBlock;}
declare module "net.minecraft.world.level.levelgen.carver.CanyonCarverConfiguration$CanyonShapeConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"

export class $CanyonCarverConfiguration$CanyonShapeConfiguration {
static readonly "CODEC": $Codec<($CanyonCarverConfiguration$CanyonShapeConfiguration)>
readonly "thickness": $FloatProvider
readonly "distanceFactor": $FloatProvider
readonly "horizontalRadiusFactor": $FloatProvider
readonly "widthSmoothness": integer
readonly "verticalRadiusDefaultFactor": float
readonly "verticalRadiusCenterFactor": float

constructor(arg0: $FloatProvider$$Type, arg1: $FloatProvider$$Type, arg2: integer, arg3: $FloatProvider$$Type, arg4: float, arg5: float)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanyonCarverConfiguration$CanyonShapeConfiguration$$Type = ($CanyonCarverConfiguration$CanyonShapeConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CanyonCarverConfiguration$CanyonShapeConfiguration$$Original = $CanyonCarverConfiguration$CanyonShapeConfiguration;}
declare module "net.minecraft.world.level.storage.loot.ValidationContext" {
import {$HolderGetter$Provider, $HolderGetter$Provider$$Type} from "net.minecraft.core.HolderGetter$Provider"
import {$ProblemReporter, $ProblemReporter$$Type} from "net.minecraft.util.ProblemReporter"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$LootContextUser$$Type} from "net.minecraft.world.level.storage.loot.LootContextUser"
import {$LootContextParamSet$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet"

export class $ValidationContext {
constructor(arg0: $ProblemReporter$$Type, arg1: $LootContextParamSet$$Type, arg2: $HolderGetter$Provider$$Type)
constructor(arg0: $ProblemReporter$$Type, arg1: $LootContextParamSet$$Type)

public "forChild"(arg0: StringJS): $ValidationContext
public "enterElement"(arg0: StringJS, arg1: $ResourceKey$$Type<(never)>): $ValidationContext
public "validateUser"(arg0: $LootContextUser$$Type): void
public "hasVisitedElement"(arg0: $ResourceKey$$Type<(never)>): boolean
public "allowsReferences"(): boolean
public "reportProblem"(arg0: StringJS): void
public "resolver"(): $HolderGetter$Provider
public "reporter"(): $ProblemReporter
public "setParams"(arg0: $LootContextParamSet$$Type): $ValidationContext
set "params"(value: $LootContextParamSet$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ValidationContext$$Type = ($ValidationContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ValidationContext$$Original = $ValidationContext;}
declare module "net.minecraft.world.level.block.CactusBlock" {
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CactusBlock extends $Block {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($CactusBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "MAX_AGE": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "AGE": $IntegerProperty

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "codec"(): $MapCodec<($CactusBlock)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CactusBlock$$Type = ($CactusBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CactusBlock$$Original = $CactusBlock;}
declare module "net.minecraft.world.level.levelgen.SurfaceSystem" {
import {$BiomeManager$$Type} from "net.minecraft.world.level.biome.BiomeManager"
import {$Optional} from "java.util.Optional"
import {$NoiseChunk$$Type} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$CarvingContext$$Type} from "net.minecraft.world.level.levelgen.carver.CarvingContext"
import {$SurfaceRules$RuleSource$$Type} from "net.minecraft.world.level.levelgen.SurfaceRules$RuleSource"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$Function$$Type} from "java.util.function.Function"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PositionalRandomFactory$$Type} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SurfaceSystem {
constructor(arg0: $RandomState$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: $PositionalRandomFactory$$Type)

/**
 * 
 * @deprecated
 */
public "topMaterial"(arg0: $SurfaceRules$RuleSource$$Type, arg1: $CarvingContext$$Type, arg2: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg3: $ChunkAccess$$Type, arg4: $NoiseChunk$$Type, arg5: $BlockPos$$Type, arg6: boolean): $Optional<($BlockState)>
public "buildSurface"(arg0: $RandomState$$Type, arg1: $BiomeManager$$Type, arg2: $Registry$$Type<($Biome$$Type)>, arg3: boolean, arg4: $WorldGenerationContext$$Type, arg5: $ChunkAccess$$Type, arg6: $NoiseChunk$$Type, arg7: $SurfaceRules$RuleSource$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceSystem$$Type = ($SurfaceSystem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SurfaceSystem$$Original = $SurfaceSystem;}
declare module "net.minecraft.world.level.storage.PlayerDataStorage" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelStorageSource$LevelStorageAccess$$Type} from "net.minecraft.world.level.storage.LevelStorageSource$LevelStorageAccess"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Optional} from "java.util.Optional"
import {$File} from "java.io.File"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"

export class $PlayerDataStorage {
constructor(arg0: $LevelStorageSource$LevelStorageAccess$$Type, arg1: $DataFixer$$Type)

public "getPlayerDir"(): $File
public "load"(arg0: $Player$$Type): $Optional<($CompoundTag)>
public "save"(arg0: $Player$$Type): void
public "handler$cki000$owo$onPlayerDataSaved"(player: $Player$$Type, ci: $CallbackInfo$$Type, tag: $CompoundTag$$Type): void
get "playerDir"(): $File
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerDataStorage$$Type = ($PlayerDataStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerDataStorage$$Original = $PlayerDataStorage;}
declare module "net.minecraft.world.level.levelgen.placement.HeightmapPlacement" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $HeightmapPlacement extends $PlacementModifier {
static readonly "CODEC": $MapCodec<($HeightmapPlacement)>

public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
public static "onHeightmap"(arg0: $Heightmap$Types$$Type): $HeightmapPlacement
public "type"(): $PlacementModifierType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeightmapPlacement$$Type = ($HeightmapPlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HeightmapPlacement$$Original = $HeightmapPlacement;}
declare module "net.minecraft.world.level.levelgen.feature.DeltaFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration, $DeltaFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $DeltaFeature extends $Feature<($DeltaFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($DeltaFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($DeltaFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeltaFeature$$Type = ($DeltaFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeltaFeature$$Original = $DeltaFeature;}
declare module "net.minecraft.world.level.block.piston.PistonHeadBlock" {
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$DirectionalBlock} from "net.minecraft.world.level.block.DirectionalBlock"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$PistonType} from "net.minecraft.world.level.block.state.properties.PistonType"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Item} from "net.minecraft.world.item.Item"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PistonHeadBlock extends $DirectionalBlock {
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($PistonHeadBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "SHORT": $BooleanProperty
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "PLATFORM": float
static readonly "UPDATE_LIMIT": integer
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
static readonly "FACING": $DirectionProperty
static readonly "TYPE": $EnumProperty<($PistonType)>

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonHeadBlock$$Type = ($PistonHeadBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PistonHeadBlock$$Original = $PistonHeadBlock;}
